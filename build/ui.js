(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a3, prop, b3[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name307 in all)
      __defProp(target, name307, { get: all[name307], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/87269e2c-17cd-4d90-af68-9f9856eb15e0/tailwind.js
  var init_tailwind = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/87269e2c-17cd-4d90-af68-9f9856eb15e0/tailwind.js"() {
      if (document.getElementById("daf6ec3404") === null) {
        const element = document.createElement("style");
        element.id = "daf6ec3404";
        element.textContent = `/*
! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
*/

html {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font family by default.
2. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 2rem;
  padding-left: 2rem;
}
@media (min-width: 1400px) {

  .container {
    max-width: 1400px;
  }
}
.pointer-events-none {
  pointer-events: none;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.inset-0 {
  inset: 0px;
}
.left-0 {
  left: 0px;
}
.left-10 {
  left: 2.5rem;
}
.left-8 {
  left: 2rem;
}
.right-0 {
  right: 0px;
}
.right-24 {
  right: 6rem;
}
.right-32 {
  right: 8rem;
}
.top-10 {
  top: 2.5rem;
}
.top-20 {
  top: 5rem;
}
.z-10 {
  z-index: 10;
}
.mb-1 {
  margin-bottom: 0.25rem;
}
.ml-3 {
  margin-left: 0.75rem;
}
.mt-2 {
  margin-top: 0.5rem;
}
.block {
  display: block;
}
.flex {
  display: flex;
}
.inline-flex {
  display: inline-flex;
}
.grid {
  display: grid;
}
.h-1 {
  height: 0.25rem;
}
.h-10 {
  height: 2.5rem;
}
.h-11 {
  height: 2.75rem;
}
.h-20 {
  height: 5rem;
}
.h-24 {
  height: 6rem;
}
.h-5 {
  height: 1.25rem;
}
.h-6 {
  height: 1.5rem;
}
.h-8 {
  height: 2rem;
}
.h-9 {
  height: 2.25rem;
}
.h-full {
  height: 100%;
}
.h-px {
  height: 1px;
}
.w-1 {
  width: 0.25rem;
}
.w-10 {
  width: 2.5rem;
}
.w-24 {
  width: 6rem;
}
.w-32 {
  width: 8rem;
}
.w-5 {
  width: 1.25rem;
}
.w-6 {
  width: 1.5rem;
}
.w-60 {
  width: 15rem;
}
.w-8 {
  width: 2rem;
}
.w-[124px] {
  width: 124px;
}
.w-[1px] {
  width: 1px;
}
.w-[400px] {
  width: 400px;
}
.w-full {
  width: 100%;
}
.w-px {
  width: 1px;
}
.grow {
  flex-grow: 1;
}
.border-spacing-2 {
  --tw-border-spacing-x: 0.5rem;
  --tw-border-spacing-y: 0.5rem;
  border-spacing: var(--tw-border-spacing-x) var(--tw-border-spacing-y);
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.resize {
  resize: both;
}
.flex-row {
  flex-direction: row;
}
.flex-col {
  flex-direction: column;
}
.place-items-center {
  place-items: center;
}
.content-center {
  align-content: center;
}
.items-center {
  align-items: center;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.justify-items-center {
  justify-items: center;
}
.gap-1 {
  gap: 0.25rem;
}
.gap-2 {
  gap: 0.5rem;
}
.place-self-end {
  place-self: end;
}
.overflow-y-auto {
  overflow-y: auto;
}
.overflow-y-scroll {
  overflow-y: scroll;
}
.whitespace-nowrap {
  white-space: nowrap;
}
.rounded {
  border-radius: 0.25rem;
}
.rounded-full {
  border-radius: 9999px;
}
.rounded-lg {
  border-radius: var(--radius);
}
.rounded-md {
  border-radius: calc(var(--radius) - 2px);
}
.border {
  border-width: 1px;
}
.border-2 {
  border-width: 2px;
}
.border-b {
  border-bottom-width: 1px;
}
.border-l {
  border-left-width: 1px;
}
.border-r {
  border-right-width: 1px;
}
.border-t {
  border-top-width: 1px;
}
.border-neutral-600 {
  --tw-border-opacity: 1;
  border-color: rgb(82 82 82 / var(--tw-border-opacity));
}
.border-neutral-700 {
  --tw-border-opacity: 1;
  border-color: rgb(64 64 64 / var(--tw-border-opacity));
}
.border-neutral-800 {
  --tw-border-opacity: 1;
  border-color: rgb(38 38 38 / var(--tw-border-opacity));
}
.border-slate-500 {
  --tw-border-opacity: 1;
  border-color: rgb(100 116 139 / var(--tw-border-opacity));
}
.bg-background {
  background-color: hsl(var(--background));
}
.bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity));
}
.bg-fig-blue {
  --tw-bg-opacity: 1;
  background-color: rgb(24 160 251 / var(--tw-bg-opacity));
}
.bg-muted {
  background-color: hsl(var(--muted));
}
.bg-neutral-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(115 115 115 / var(--tw-bg-opacity));
}
.bg-neutral-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(82 82 82 / var(--tw-bg-opacity));
}
.bg-neutral-700 {
  --tw-bg-opacity: 1;
  background-color: rgb(64 64 64 / var(--tw-bg-opacity));
}
.bg-neutral-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(38 38 38 / var(--tw-bg-opacity));
}
.bg-neutral-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(23 23 23 / var(--tw-bg-opacity));
}
.bg-red-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 202 202 / var(--tw-bg-opacity));
}
.bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity));
}
.bg-red-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 38 38 / var(--tw-bg-opacity));
}
.bg-slate-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(203 213 225 / var(--tw-bg-opacity));
}
.bg-slate-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(148 163 184 / var(--tw-bg-opacity));
}
.bg-slate-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(100 116 139 / var(--tw-bg-opacity));
}
.bg-slate-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(71 85 105 / var(--tw-bg-opacity));
}
.bg-slate-700 {
  --tw-bg-opacity: 1;
  background-color: rgb(51 65 85 / var(--tw-bg-opacity));
}
.bg-slate-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(30 41 59 / var(--tw-bg-opacity));
}
.bg-slate-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(15 23 42 / var(--tw-bg-opacity));
}
.bg-gradient-conic {
  background-image: conic-gradient(from 180deg, white, red, black);
}
.bg-gradient-to-r {
  background-image: linear-gradient(to right, var(--tw-gradient-stops));
}
.from-indigo-500 {
  --tw-gradient-from: #6366f1 var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(99 102 241 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.from-white {
  --tw-gradient-from: #fff var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.via-indigo-500 {
  --tw-gradient-to: rgb(99 102 241 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #6366f1 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-pink-500 {
  --tw-gradient-to: rgb(236 72 153 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #ec4899 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-purple-500 {
  --tw-gradient-to: rgb(168 85 247 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #a855f7 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-10% {
  --tw-gradient-via-position: 10%;
}
.via-30% {
  --tw-gradient-via-position: 30%;
}
.to-black {
  --tw-gradient-to: #000 var(--tw-gradient-to-position);
}
.to-pink-500 {
  --tw-gradient-to: #ec4899 var(--tw-gradient-to-position);
}
.p-1 {
  padding: 0.25rem;
}
.p-4 {
  padding: 1rem;
}
.px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}
.py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.pl-2 {
  padding-left: 0.5rem;
}
.pl-4 {
  padding-left: 1rem;
}
.pr-16 {
  padding-right: 4rem;
}
.pr-20 {
  padding-right: 5rem;
}
.pr-8 {
  padding-right: 2rem;
}
.pt-1 {
  padding-top: 0.25rem;
}
.pt-2 {
  padding-top: 0.5rem;
}
.pt-4 {
  padding-top: 1rem;
}
.text-center {
  text-align: center;
}
.align-middle {
  vertical-align: middle;
}
.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.font-bold {
  font-weight: 700;
}
.font-medium {
  font-weight: 500;
}
.text-foreground {
  color: hsl(var(--foreground));
}
.text-muted-foreground {
  color: hsl(var(--muted-foreground));
}
.underline {
  text-decoration-line: underline;
}
.opacity-20 {
  opacity: 0.2;
}
.opacity-50 {
  opacity: 0.5;
}
.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.outline {
  outline-style: solid;
}
.outline-dashed {
  outline-style: dashed;
}
.outline-2 {
  outline-width: 2px;
}
.outline-offset-1 {
  outline-offset: 1px;
}
.outline-offset-2 {
  outline-offset: 2px;
}
.outline-offset-['-2px'] {
  outline-offset: '-2px';
}
.outline-offset-[-2px] {
  outline-offset: -2px;
}
.outline-offset-[-8px] {
  outline-offset: -8px;
}
.outline-offset-[8px] {
  outline-offset: 8px;
}
.outline-blue-500 {
  outline-color: #3b82f6;
}
.outline-fig-blue {
  outline-color: #18A0FB;
}
.outline-neutral-500 {
  outline-color: #737373;
}
.outline-slate-500 {
  outline-color: #64748b;
}
.ring-offset-background {
  --tw-ring-offset-color: hsl(var(--background));
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
@keyframes enter {

  from {
    opacity: var(--tw-enter-opacity, 1);
    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
  }
}
@keyframes exit {

  to {
    opacity: var(--tw-exit-opacity, 1);
    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
  }
}

._tabs_61qsz_1 {
	border-bottom: none !important;
}

.hover:bg-blue-400:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity));
}

.hover:bg-fig-blue:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(24 160 251 / var(--tw-bg-opacity));
}

.focus-visible:outline-none:focus-visible {
  outline: 2px solid transparent;
  outline-offset: 2px;
}

.focus-visible:ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.focus-visible:ring-ring:focus-visible {
  --tw-ring-color: hsl(var(--ring));
}

.focus-visible:ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}

.disabled:pointer-events-none:disabled {
  pointer-events: none;
}

.disabled:opacity-50:disabled {
  opacity: 0.5;
}

.data-[state=active]:bg-background[data-state=active] {
  background-color: hsl(var(--background));
}

.data-[state=active]:text-foreground[data-state=active] {
  color: hsl(var(--foreground));
}

.data-[state=active]:shadow[data-state=active] {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
`;
        document.head.append(element);
      }
    }
  });

  // node_modules/preact/dist/preact.module.js
  function v(n3, l3) {
    for (var u3 in l3)
      n3[u3] = l3[u3];
    return n3;
  }
  function p(n3) {
    var l3 = n3.parentNode;
    l3 && l3.removeChild(n3);
  }
  function y(l3, u3, t3) {
    var i5, o3, r3, f3 = {};
    for (r3 in u3)
      "key" == r3 ? i5 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f3[r3] = u3[r3];
    if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps)
      for (r3 in l3.defaultProps)
        void 0 === f3[r3] && (f3[r3] = l3.defaultProps[r3]);
    return d(l3, f3, i5, o3, null);
  }
  function d(n3, t3, i5, o3, r3) {
    var f3 = { type: n3, props: t3, key: i5, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r3 ? ++u : r3, __i: -1, __u: 0 };
    return null == r3 && null != l.vnode && l.vnode(f3), f3;
  }
  function _() {
    return { current: null };
  }
  function g(n3) {
    return n3.children;
  }
  function b(n3, l3) {
    this.props = n3, this.context = l3;
  }
  function m(n3, l3) {
    if (null == l3)
      return n3.__ ? m(n3.__, n3.__i + 1) : null;
    for (var u3; l3 < n3.__k.length; l3++)
      if (null != (u3 = n3.__k[l3]) && null != u3.__e)
        return u3.__e;
    return "function" == typeof n3.type ? m(n3) : null;
  }
  function k(n3) {
    var l3, u3;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++)
        if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
          n3.__e = n3.__c.base = u3.__e;
          break;
        }
      return k(n3);
    }
  }
  function w(n3) {
    (!n3.__d && (n3.__d = true) && i.push(n3) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
  }
  function x() {
    var n3, u3, t3, o3, r3, e6, c3, s3, a3;
    for (i.sort(f); n3 = i.shift(); )
      n3.__d && (u3 = i.length, o3 = void 0, e6 = (r3 = (t3 = n3).__v).__e, s3 = [], a3 = [], (c3 = t3.__P) && ((o3 = v({}, r3)).__v = r3.__v + 1, l.vnode && l.vnode(o3), L(c3, o3, r3, t3.__n, void 0 !== c3.ownerSVGElement, 32 & r3.__u ? [e6] : null, s3, null == e6 ? m(r3) : e6, !!(32 & r3.__u), a3), o3.__.__k[o3.__i] = o3, M(s3, o3, a3), o3.__e != e6 && k(o3)), i.length > u3 && i.sort(f));
    x.__r = 0;
  }
  function C(n3, l3, u3, t3, i5, o3, r3, f3, e6, a3, h3) {
    var v3, p3, y3, d3, _3, g4 = t3 && t3.__k || s, b3 = l3.length;
    for (u3.__d = e6, P(u3, l3, g4), e6 = u3.__d, v3 = 0; v3 < b3; v3++)
      null != (y3 = u3.__k[v3]) && "boolean" != typeof y3 && "function" != typeof y3 && (p3 = -1 === y3.__i ? c : g4[y3.__i] || c, y3.__i = v3, L(n3, y3, p3, i5, o3, r3, f3, e6, a3, h3), d3 = y3.__e, y3.ref && p3.ref != y3.ref && (p3.ref && z(p3.ref, null, y3), h3.push(y3.ref, y3.__c || d3, y3)), null == _3 && null != d3 && (_3 = d3), 65536 & y3.__u || p3.__k === y3.__k ? e6 = S(y3, e6, n3) : "function" == typeof y3.type && void 0 !== y3.__d ? e6 = y3.__d : d3 && (e6 = d3.nextSibling), y3.__d = void 0, y3.__u &= -196609);
    u3.__d = e6, u3.__e = _3;
  }
  function P(n3, l3, u3) {
    var t3, i5, o3, r3, f3, e6 = l3.length, c3 = u3.length, s3 = c3, a3 = 0;
    for (n3.__k = [], t3 = 0; t3 < e6; t3++)
      null != (i5 = n3.__k[t3] = null == (i5 = l3[t3]) || "boolean" == typeof i5 || "function" == typeof i5 ? null : "string" == typeof i5 || "number" == typeof i5 || "bigint" == typeof i5 || i5.constructor == String ? d(null, i5, null, null, i5) : h(i5) ? d(g, { children: i5 }, null, null, null) : i5.__b > 0 ? d(i5.type, i5.props, i5.key, i5.ref ? i5.ref : null, i5.__v) : i5) ? (i5.__ = n3, i5.__b = n3.__b + 1, f3 = H(i5, u3, r3 = t3 + a3, s3), i5.__i = f3, o3 = null, -1 !== f3 && (s3--, (o3 = u3[f3]) && (o3.__u |= 131072)), null == o3 || null === o3.__v ? (-1 == f3 && a3--, "function" != typeof i5.type && (i5.__u |= 65536)) : f3 !== r3 && (f3 === r3 + 1 ? a3++ : f3 > r3 ? s3 > e6 - r3 ? a3 += f3 - r3 : a3-- : a3 = f3 < r3 && f3 == r3 - 1 ? f3 - r3 : 0, f3 !== t3 + a3 && (i5.__u |= 65536))) : (o3 = u3[t3]) && null == o3.key && o3.__e && (o3.__e == n3.__d && (n3.__d = m(o3)), N(o3, o3, false), u3[t3] = null, s3--);
    if (s3)
      for (t3 = 0; t3 < c3; t3++)
        null != (o3 = u3[t3]) && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = m(o3)), N(o3, o3));
  }
  function S(n3, l3, u3) {
    var t3, i5;
    if ("function" == typeof n3.type) {
      for (t3 = n3.__k, i5 = 0; t3 && i5 < t3.length; i5++)
        t3[i5] && (t3[i5].__ = n3, l3 = S(t3[i5], l3, u3));
      return l3;
    }
    return n3.__e != l3 && (u3.insertBefore(n3.__e, l3 || null), l3 = n3.__e), l3 && l3.nextSibling;
  }
  function $(n3, l3) {
    return l3 = l3 || [], null == n3 || "boolean" == typeof n3 || (h(n3) ? n3.some(function(n4) {
      $(n4, l3);
    }) : l3.push(n3)), l3;
  }
  function H(n3, l3, u3, t3) {
    var i5 = n3.key, o3 = n3.type, r3 = u3 - 1, f3 = u3 + 1, e6 = l3[u3];
    if (null === e6 || e6 && i5 == e6.key && o3 === e6.type)
      return u3;
    if (t3 > (null != e6 && 0 == (131072 & e6.__u) ? 1 : 0))
      for (; r3 >= 0 || f3 < l3.length; ) {
        if (r3 >= 0) {
          if ((e6 = l3[r3]) && 0 == (131072 & e6.__u) && i5 == e6.key && o3 === e6.type)
            return r3;
          r3--;
        }
        if (f3 < l3.length) {
          if ((e6 = l3[f3]) && 0 == (131072 & e6.__u) && i5 == e6.key && o3 === e6.type)
            return f3;
          f3++;
        }
      }
    return -1;
  }
  function I(n3, l3, u3) {
    "-" === l3[0] ? n3.setProperty(l3, null == u3 ? "" : u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
  }
  function T(n3, l3, u3, t3, i5) {
    var o3;
    n:
      if ("style" === l3)
        if ("string" == typeof u3)
          n3.style.cssText = u3;
        else {
          if ("string" == typeof t3 && (n3.style.cssText = t3 = ""), t3)
            for (l3 in t3)
              u3 && l3 in u3 || I(n3.style, l3, "");
          if (u3)
            for (l3 in u3)
              t3 && u3[l3] === t3[l3] || I(n3.style, l3, u3[l3]);
        }
      else if ("o" === l3[0] && "n" === l3[1])
        o3 = l3 !== (l3 = l3.replace(/(PointerCapture)$|Capture$/, "$1")), l3 = l3.toLowerCase() in n3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + o3] = u3, u3 ? t3 ? u3.u = t3.u : (u3.u = Date.now(), n3.addEventListener(l3, o3 ? D : A, o3)) : n3.removeEventListener(l3, o3 ? D : A, o3);
      else {
        if (i5)
          l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && "rowSpan" !== l3 && "colSpan" !== l3 && "role" !== l3 && l3 in n3)
          try {
            n3[l3] = null == u3 ? "" : u3;
            break n;
          } catch (n4) {
          }
        "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l3[4] ? n3.removeAttribute(l3) : n3.setAttribute(l3, u3));
      }
  }
  function A(n3) {
    var u3 = this.l[n3.type + false];
    if (n3.t) {
      if (n3.t <= u3.u)
        return;
    } else
      n3.t = Date.now();
    return u3(l.event ? l.event(n3) : n3);
  }
  function D(n3) {
    return this.l[n3.type + true](l.event ? l.event(n3) : n3);
  }
  function L(n3, u3, t3, i5, o3, r3, f3, e6, c3, s3) {
    var a3, p3, y3, d3, _3, m3, k4, w4, x4, P6, S2, $3, H3, I3, T4, A4 = u3.type;
    if (void 0 !== u3.constructor)
      return null;
    128 & t3.__u && (c3 = !!(32 & t3.__u), r3 = [e6 = u3.__e = t3.__e]), (a3 = l.__b) && a3(u3);
    n:
      if ("function" == typeof A4)
        try {
          if (w4 = u3.props, x4 = (a3 = A4.contextType) && i5[a3.__c], P6 = a3 ? x4 ? x4.props.value : a3.__ : i5, t3.__c ? k4 = (p3 = u3.__c = t3.__c).__ = p3.__E : ("prototype" in A4 && A4.prototype.render ? u3.__c = p3 = new A4(w4, P6) : (u3.__c = p3 = new b(w4, P6), p3.constructor = A4, p3.render = O), x4 && x4.sub(p3), p3.props = w4, p3.state || (p3.state = {}), p3.context = P6, p3.__n = i5, y3 = p3.__d = true, p3.__h = [], p3._sb = []), null == p3.__s && (p3.__s = p3.state), null != A4.getDerivedStateFromProps && (p3.__s == p3.state && (p3.__s = v({}, p3.__s)), v(p3.__s, A4.getDerivedStateFromProps(w4, p3.__s))), d3 = p3.props, _3 = p3.state, p3.__v = u3, y3)
            null == A4.getDerivedStateFromProps && null != p3.componentWillMount && p3.componentWillMount(), null != p3.componentDidMount && p3.__h.push(p3.componentDidMount);
          else {
            if (null == A4.getDerivedStateFromProps && w4 !== d3 && null != p3.componentWillReceiveProps && p3.componentWillReceiveProps(w4, P6), !p3.__e && (null != p3.shouldComponentUpdate && false === p3.shouldComponentUpdate(w4, p3.__s, P6) || u3.__v === t3.__v)) {
              for (u3.__v !== t3.__v && (p3.props = w4, p3.state = p3.__s, p3.__d = false), u3.__e = t3.__e, u3.__k = t3.__k, u3.__k.forEach(function(n4) {
                n4 && (n4.__ = u3);
              }), S2 = 0; S2 < p3._sb.length; S2++)
                p3.__h.push(p3._sb[S2]);
              p3._sb = [], p3.__h.length && f3.push(p3);
              break n;
            }
            null != p3.componentWillUpdate && p3.componentWillUpdate(w4, p3.__s, P6), null != p3.componentDidUpdate && p3.__h.push(function() {
              p3.componentDidUpdate(d3, _3, m3);
            });
          }
          if (p3.context = P6, p3.props = w4, p3.__P = n3, p3.__e = false, $3 = l.__r, H3 = 0, "prototype" in A4 && A4.prototype.render) {
            for (p3.state = p3.__s, p3.__d = false, $3 && $3(u3), a3 = p3.render(p3.props, p3.state, p3.context), I3 = 0; I3 < p3._sb.length; I3++)
              p3.__h.push(p3._sb[I3]);
            p3._sb = [];
          } else
            do {
              p3.__d = false, $3 && $3(u3), a3 = p3.render(p3.props, p3.state, p3.context), p3.state = p3.__s;
            } while (p3.__d && ++H3 < 25);
          p3.state = p3.__s, null != p3.getChildContext && (i5 = v(v({}, i5), p3.getChildContext())), y3 || null == p3.getSnapshotBeforeUpdate || (m3 = p3.getSnapshotBeforeUpdate(d3, _3)), C(n3, h(T4 = null != a3 && a3.type === g && null == a3.key ? a3.props.children : a3) ? T4 : [T4], u3, t3, i5, o3, r3, f3, e6, c3, s3), p3.base = u3.__e, u3.__u &= -161, p3.__h.length && f3.push(p3), k4 && (p3.__E = p3.__ = null);
        } catch (n4) {
          u3.__v = null, c3 || null != r3 ? (u3.__e = e6, u3.__u |= c3 ? 160 : 32, r3[r3.indexOf(e6)] = null) : (u3.__e = t3.__e, u3.__k = t3.__k), l.__e(n4, u3, t3);
        }
      else
        null == r3 && u3.__v === t3.__v ? (u3.__k = t3.__k, u3.__e = t3.__e) : u3.__e = j(t3.__e, u3, t3, i5, o3, r3, f3, c3, s3);
    (a3 = l.diffed) && a3(u3);
  }
  function M(n3, u3, t3) {
    u3.__d = void 0;
    for (var i5 = 0; i5 < t3.length; i5++)
      z(t3[i5], t3[++i5], t3[++i5]);
    l.__c && l.__c(u3, n3), n3.some(function(u4) {
      try {
        n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
          n4.call(u4);
        });
      } catch (n4) {
        l.__e(n4, u4.__v);
      }
    });
  }
  function j(l3, u3, t3, i5, o3, r3, f3, e6, s3) {
    var a3, v3, y3, d3, _3, g4, b3, k4 = t3.props, w4 = u3.props, x4 = u3.type;
    if ("svg" === x4 && (o3 = true), null != r3) {
      for (a3 = 0; a3 < r3.length; a3++)
        if ((_3 = r3[a3]) && "setAttribute" in _3 == !!x4 && (x4 ? _3.localName === x4 : 3 === _3.nodeType)) {
          l3 = _3, r3[a3] = null;
          break;
        }
    }
    if (null == l3) {
      if (null === x4)
        return document.createTextNode(w4);
      l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", x4) : document.createElement(x4, w4.is && w4), r3 = null, e6 = false;
    }
    if (null === x4)
      k4 === w4 || e6 && l3.data === w4 || (l3.data = w4);
    else {
      if (r3 = r3 && n.call(l3.childNodes), k4 = t3.props || c, !e6 && null != r3)
        for (k4 = {}, a3 = 0; a3 < l3.attributes.length; a3++)
          k4[(_3 = l3.attributes[a3]).name] = _3.value;
      for (a3 in k4)
        _3 = k4[a3], "children" == a3 || ("dangerouslySetInnerHTML" == a3 ? y3 = _3 : "key" === a3 || a3 in w4 || T(l3, a3, null, _3, o3));
      for (a3 in w4)
        _3 = w4[a3], "children" == a3 ? d3 = _3 : "dangerouslySetInnerHTML" == a3 ? v3 = _3 : "value" == a3 ? g4 = _3 : "checked" == a3 ? b3 = _3 : "key" === a3 || e6 && "function" != typeof _3 || k4[a3] === _3 || T(l3, a3, _3, k4[a3], o3);
      if (v3)
        e6 || y3 && (v3.__html === y3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3.__html), u3.__k = [];
      else if (y3 && (l3.innerHTML = ""), C(l3, h(d3) ? d3 : [d3], u3, t3, i5, o3 && "foreignObject" !== x4, r3, f3, r3 ? r3[0] : t3.__k && m(t3, 0), e6, s3), null != r3)
        for (a3 = r3.length; a3--; )
          null != r3[a3] && p(r3[a3]);
      e6 || (a3 = "value", void 0 !== g4 && (g4 !== l3[a3] || "progress" === x4 && !g4 || "option" === x4 && g4 !== k4[a3]) && T(l3, a3, g4, k4[a3], false), a3 = "checked", void 0 !== b3 && b3 !== l3[a3] && T(l3, a3, b3, k4[a3], false));
    }
    return l3;
  }
  function z(n3, u3, t3) {
    try {
      "function" == typeof n3 ? n3(u3) : n3.current = u3;
    } catch (n4) {
      l.__e(n4, t3);
    }
  }
  function N(n3, u3, t3) {
    var i5, o3;
    if (l.unmount && l.unmount(n3), (i5 = n3.ref) && (i5.current && i5.current !== n3.__e || z(i5, null, u3)), null != (i5 = n3.__c)) {
      if (i5.componentWillUnmount)
        try {
          i5.componentWillUnmount();
        } catch (n4) {
          l.__e(n4, u3);
        }
      i5.base = i5.__P = null, n3.__c = void 0;
    }
    if (i5 = n3.__k)
      for (o3 = 0; o3 < i5.length; o3++)
        i5[o3] && N(i5[o3], u3, t3 || "function" != typeof n3.type);
    t3 || null == n3.__e || p(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
  }
  function O(n3, l3, u3) {
    return this.constructor(n3, u3);
  }
  function q(u3, t3, i5) {
    var o3, r3, f3, e6;
    l.__ && l.__(u3, t3), r3 = (o3 = "function" == typeof i5) ? null : i5 && i5.__k || t3.__k, f3 = [], e6 = [], L(t3, u3 = (!o3 && i5 || t3).__k = y(g, null, [u3]), r3 || c, c, void 0 !== t3.ownerSVGElement, !o3 && i5 ? [i5] : r3 ? null : t3.firstChild ? n.call(t3.childNodes) : null, f3, !o3 && i5 ? i5 : r3 ? r3.__e : t3.firstChild, o3, e6), M(f3, u3, e6);
  }
  function B(n3, l3) {
    q(n3, l3, B);
  }
  function E(l3, u3, t3) {
    var i5, o3, r3, f3, e6 = v({}, l3.props);
    for (r3 in l3.type && l3.type.defaultProps && (f3 = l3.type.defaultProps), u3)
      "key" == r3 ? i5 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : e6[r3] = void 0 === u3[r3] && void 0 !== f3 ? f3[r3] : u3[r3];
    return arguments.length > 2 && (e6.children = arguments.length > 3 ? n.call(arguments, 2) : t3), d(l3.type, e6, i5 || l3.key, o3 || l3.ref, null);
  }
  function F(n3, l3) {
    var u3 = { __c: l3 = "__cC" + e++, __: n3, Consumer: function(n4, l4) {
      return n4.children(l4);
    }, Provider: function(n4) {
      var u4, t3;
      return this.getChildContext || (u4 = [], (t3 = {})[l3] = this, this.getChildContext = function() {
        return t3;
      }, this.shouldComponentUpdate = function(n5) {
        this.props.value !== n5.value && u4.some(function(n6) {
          n6.__e = true, w(n6);
        });
      }, this.sub = function(n5) {
        u4.push(n5);
        var l4 = n5.componentWillUnmount;
        n5.componentWillUnmount = function() {
          u4.splice(u4.indexOf(n5), 1), l4 && l4.call(n5);
        };
      }), n4.children;
    } };
    return u3.Provider.__ = u3.Consumer.contextType = u3;
  }
  var n, l, u, t, i, o, r, f, e, c, s, a, h;
  var init_preact_module = __esm({
    "node_modules/preact/dist/preact.module.js"() {
      c = {};
      s = [];
      a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
      h = Array.isArray;
      n = s.slice, l = { __e: function(n3, l3, u3, t3) {
        for (var i5, o3, r3; l3 = l3.__; )
          if ((i5 = l3.__c) && !i5.__)
            try {
              if ((o3 = i5.constructor) && null != o3.getDerivedStateFromError && (i5.setState(o3.getDerivedStateFromError(n3)), r3 = i5.__d), null != i5.componentDidCatch && (i5.componentDidCatch(n3, t3 || {}), r3 = i5.__d), r3)
                return i5.__E = i5;
            } catch (l4) {
              n3 = l4;
            }
        throw n3;
      } }, u = 0, t = function(n3) {
        return null != n3 && null == n3.constructor;
      }, b.prototype.setState = function(n3, l3) {
        var u3;
        u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n3 && (n3 = n3(v({}, u3), this.props)), n3 && v(u3, n3), null != n3 && this.__v && (l3 && this._sb.push(l3), w(this));
      }, b.prototype.forceUpdate = function(n3) {
        this.__v && (this.__e = true, n3 && this.__h.push(n3), w(this));
      }, b.prototype.render = g, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n3, l3) {
        return n3.__v.__b - l3.__v.__b;
      }, x.__r = 0, e = 0;
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/utilities/create-class-name.js
  function createClassName(classNames) {
    return classNames.filter(function(className) {
      return className !== null;
    }).join(" ");
  }
  var init_create_class_name = __esm({
    "node_modules/@create-figma-plugin/ui/lib/utilities/create-class-name.js"() {
    }
  });

  // node_modules/preact/hooks/dist/hooks.module.js
  function d2(t3, u3) {
    l.__h && l.__h(r2, t3, o2 || u3), o2 = 0;
    var i5 = r2.__H || (r2.__H = { __: [], __h: [] });
    return t3 >= i5.__.length && i5.__.push({ __V: c2 }), i5.__[t3];
  }
  function h2(n3) {
    return o2 = 1, s2(B2, n3);
  }
  function s2(n3, u3, i5) {
    var o3 = d2(t2++, 2);
    if (o3.t = n3, !o3.__c && (o3.__ = [i5 ? i5(u3) : B2(void 0, u3), function(n4) {
      var t3 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t3, n4);
      t3 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
    }], o3.__c = r2, !r2.u)) {
      var f3 = function(n4, t3, r3) {
        if (!o3.__c.__H)
          return true;
        var u4 = o3.__c.__H.__.filter(function(n5) {
          return n5.__c;
        });
        if (u4.every(function(n5) {
          return !n5.__N;
        }))
          return !c3 || c3.call(this, n4, t3, r3);
        var i6 = false;
        return u4.forEach(function(n5) {
          if (n5.__N) {
            var t4 = n5.__[0];
            n5.__ = n5.__N, n5.__N = void 0, t4 !== n5.__[0] && (i6 = true);
          }
        }), !(!i6 && o3.__c.props === n4) && (!c3 || c3.call(this, n4, t3, r3));
      };
      r2.u = true;
      var c3 = r2.shouldComponentUpdate, e6 = r2.componentWillUpdate;
      r2.componentWillUpdate = function(n4, t3, r3) {
        if (this.__e) {
          var u4 = c3;
          c3 = void 0, f3(n4, t3, r3), c3 = u4;
        }
        e6 && e6.call(this, n4, t3, r3);
      }, r2.shouldComponentUpdate = f3;
    }
    return o3.__N || o3.__;
  }
  function p2(u3, i5) {
    var o3 = d2(t2++, 3);
    !l.__s && z2(o3.__H, i5) && (o3.__ = u3, o3.i = i5, r2.__H.__h.push(o3));
  }
  function y2(u3, i5) {
    var o3 = d2(t2++, 4);
    !l.__s && z2(o3.__H, i5) && (o3.__ = u3, o3.i = i5, r2.__h.push(o3));
  }
  function _2(n3) {
    return o2 = 5, F2(function() {
      return { current: n3 };
    }, []);
  }
  function A2(n3, t3, r3) {
    o2 = 6, y2(function() {
      return "function" == typeof n3 ? (n3(t3()), function() {
        return n3(null);
      }) : n3 ? (n3.current = t3(), function() {
        return n3.current = null;
      }) : void 0;
    }, null == r3 ? r3 : r3.concat(n3));
  }
  function F2(n3, r3) {
    var u3 = d2(t2++, 7);
    return z2(u3.__H, r3) ? (u3.__V = n3(), u3.i = r3, u3.__h = n3, u3.__V) : u3.__;
  }
  function T2(n3, t3) {
    return o2 = 8, F2(function() {
      return n3;
    }, t3);
  }
  function q2(n3) {
    var u3 = r2.context[n3.__c], i5 = d2(t2++, 9);
    return i5.c = n3, u3 ? (null == i5.__ && (i5.__ = true, u3.sub(r2)), u3.props.value) : n3.__;
  }
  function x2(t3, r3) {
    l.useDebugValue && l.useDebugValue(r3 ? r3(t3) : t3);
  }
  function P2(n3) {
    var u3 = d2(t2++, 10), i5 = h2();
    return u3.__ = n3, r2.componentDidCatch || (r2.componentDidCatch = function(n4, t3) {
      u3.__ && u3.__(n4, t3), i5[1](n4);
    }), [i5[0], function() {
      i5[1](void 0);
    }];
  }
  function V() {
    var n3 = d2(t2++, 11);
    if (!n3.__) {
      for (var u3 = r2.__v; null !== u3 && !u3.__m && null !== u3.__; )
        u3 = u3.__;
      var i5 = u3.__m || (u3.__m = [0, 0]);
      n3.__ = "P" + i5[0] + "-" + i5[1]++;
    }
    return n3.__;
  }
  function b2() {
    for (var t3; t3 = f2.shift(); )
      if (t3.__P && t3.__H)
        try {
          t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
        } catch (r3) {
          t3.__H.__h = [], l.__e(r3, t3.__v);
        }
  }
  function j2(n3) {
    var t3, r3 = function() {
      clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n3);
    }, u3 = setTimeout(r3, 100);
    g2 && (t3 = requestAnimationFrame(r3));
  }
  function k2(n3) {
    var t3 = r2, u3 = n3.__c;
    "function" == typeof u3 && (n3.__c = void 0, u3()), r2 = t3;
  }
  function w2(n3) {
    var t3 = r2;
    n3.__c = n3.__(), r2 = t3;
  }
  function z2(n3, t3) {
    return !n3 || n3.length !== t3.length || t3.some(function(t4, r3) {
      return t4 !== n3[r3];
    });
  }
  function B2(n3, t3) {
    return "function" == typeof t3 ? t3(n3) : t3;
  }
  var t2, r2, u2, i2, o2, f2, c2, e2, a2, v2, l2, m2, g2;
  var init_hooks_module = __esm({
    "node_modules/preact/hooks/dist/hooks.module.js"() {
      init_preact_module();
      o2 = 0;
      f2 = [];
      c2 = [];
      e2 = l.__b;
      a2 = l.__r;
      v2 = l.diffed;
      l2 = l.__c;
      m2 = l.unmount;
      l.__b = function(n3) {
        r2 = null, e2 && e2(n3);
      }, l.__r = function(n3) {
        a2 && a2(n3), t2 = 0;
        var i5 = (r2 = n3.__c).__H;
        i5 && (u2 === r2 ? (i5.__h = [], r2.__h = [], i5.__.forEach(function(n4) {
          n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
        })) : (i5.__h.forEach(k2), i5.__h.forEach(w2), i5.__h = [], t2 = 0)), u2 = r2;
      }, l.diffed = function(t3) {
        v2 && v2(t3);
        var o3 = t3.__c;
        o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n3) {
          n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
        })), u2 = r2 = null;
      }, l.__c = function(t3, r3) {
        r3.some(function(t4) {
          try {
            t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n3) {
              return !n3.__ || w2(n3);
            });
          } catch (u3) {
            r3.some(function(n3) {
              n3.__h && (n3.__h = []);
            }), r3 = [], l.__e(u3, t4.__v);
          }
        }), l2 && l2(t3, r3);
      }, l.unmount = function(t3) {
        m2 && m2(t3);
        var r3, u3 = t3.__c;
        u3 && u3.__H && (u3.__H.__.forEach(function(n3) {
          try {
            k2(n3);
          } catch (n4) {
            r3 = n4;
          }
        }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
      };
      g2 = "function" == typeof requestAnimationFrame;
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/5e5ee985-16dd-435d-80bb-8c396b070932/loading-indicator.module.js
  var loading_indicator_module_default;
  var init_loading_indicator_module = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/5e5ee985-16dd-435d-80bb-8c396b070932/loading-indicator.module.js"() {
      if (document.getElementById("c451e2d48b") === null) {
        const element = document.createElement("style");
        element.id = "c451e2d48b";
        element.textContent = `._loadingIndicator_pl5c3_1 {
  position: relative;
  width: 16px;
  height: 16px;
  margin: 0 auto;
}

._svg_pl5c3_8 {
  position: absolute;
  top: 0;
  left: 0;
  width: 16px;
  height: 16px;
  animation: _rotating_pl5c3_1 0.5s linear infinite;
  fill: currentColor;
}

@keyframes _rotating_pl5c3_1 {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvY29tcG9uZW50cy9sb2FkaW5nLWluZGljYXRvci9sb2FkaW5nLWluZGljYXRvci5tb2R1bGUuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxZQUFZO0VBQ1osY0FBYztBQUNoQjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixNQUFNO0VBQ04sT0FBTztFQUNQLFdBQVc7RUFDWCxZQUFZO0VBQ1osaURBQXdDO0VBQ3hDLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFO0lBQ0UsdUJBQXVCO0VBQ3pCO0VBQ0E7SUFDRSx5QkFBeUI7RUFDM0I7QUFDRiIsImZpbGUiOiJub2RlX21vZHVsZXMvQGNyZWF0ZS1maWdtYS1wbHVnaW4vdWkvbGliL2NvbXBvbmVudHMvbG9hZGluZy1pbmRpY2F0b3IvbG9hZGluZy1pbmRpY2F0b3IubW9kdWxlLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5sb2FkaW5nSW5kaWNhdG9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTZweDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBtYXJnaW46IDAgYXV0bztcbn1cblxuLnN2ZyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTZweDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBhbmltYXRpb246IHJvdGF0aW5nIDAuNXMgbGluZWFyIGluZmluaXRlO1xuICBmaWxsOiBjdXJyZW50Q29sb3I7XG59XG5cbkBrZXlmcmFtZXMgcm90YXRpbmcge1xuICBmcm9tIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuICB0byB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxufVxuIl19 */`;
        document.head.append(element);
      }
      loading_indicator_module_default = { "loadingIndicator": "_loadingIndicator_pl5c3_1", "svg": "_svg_pl5c3_8", "rotating": "_rotating_pl5c3_1" };
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/loading-indicator/loading-indicator.js
  function LoadingIndicator(_a) {
    var _b = _a, { color: color2 } = _b, rest = __objRest(_b, ["color"]);
    return y(
      "div",
      __spreadProps(__spreadValues({}, rest), { class: loading_indicator_module_default.loadingIndicator }),
      y(
        "svg",
        { class: loading_indicator_module_default.svg, style: typeof color2 === "undefined" ? void 0 : {
          fill: `var(--figma-color-icon-${color2})`
        } },
        y("path", { d: "M8 15C11.866 15 15 11.866 15 8C15 6.7865 14.6912 5.64511 14.1479 4.65013L15.0263 4.17174C15.6471 5.30882 16 6.6132 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 5.54138 1.10909 3.34181 2.85426 1.8743L3.47761 2.65678C1.96204 3.94081 1 5.85806 1 8C1 11.866 4.13401 15 8 15Z" })
      )
    );
  }
  var init_loading_indicator = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/loading-indicator/loading-indicator.js"() {
      init_preact_module();
      init_loading_indicator_module();
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/caa87ee0-7af4-4b91-ac7a-4ecbec8551d4/button.module.js
  var button_module_default;
  var init_button_module = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/caa87ee0-7af4-4b91-ac7a-4ecbec8551d4/button.module.js"() {
      if (document.getElementById("13442769ce") === null) {
        const element = document.createElement("style");
        element.id = "13442769ce";
        element.textContent = `._button_5fxgc_1 {
  position: relative;
  z-index: var(--z-index-1);
  display: inline-block;
}

._fullWidth_5fxgc_7 {
  display: block;
}

._button_5fxgc_1 button {
  display: inline-block;
  height: 32px;
  border-radius: var(--border-radius-6);
}

._disabled_5fxgc_17 button {
  cursor: not-allowed;
}

._fullWidth_5fxgc_7 button {
  display: block;
  overflow: hidden;
  width: 100%;
  text-overflow: ellipsis;
  white-space: nowrap;
}

._default_5fxgc_29 button {
  padding: 0 14px;
  border: 2px solid transparent;
  background-color: var(--figma-color-bg-brand);
  color: var(--figma-color-text-onbrand);
  line-height: 28px;
}
._default_5fxgc_29:not(._disabled_5fxgc_17) button:focus {
  border-color: var(--figma-color-border-brand-strong);
}
._default_5fxgc_29._disabled_5fxgc_17 button {
  background-color: var(--figma-color-bg-disabled);
  color: var(--figma-color-text-ondisabled);
}

._default_5fxgc_29._danger_5fxgc_44 button {
  background-color: var(--figma-color-bg-danger);
  color: var(--figma-color-text-ondanger);
}
._default_5fxgc_29._danger_5fxgc_44:not(._disabled_5fxgc_17) button:focus {
  border-color: var(--figma-color-border-danger-strong);
}
._default_5fxgc_29._danger_5fxgc_44._disabled_5fxgc_17 button {
  background-color: var(--figma-color-bg-disabled);
  color: var(--figma-color-text-ondisabled);
}

._secondary_5fxgc_56 button {
  padding: 0 15px;
  border: 1px solid var(--figma-color-border-strong);
  background-color: transparent;
  color: var(--figma-color-text);
  line-height: 30px;
}
._secondary_5fxgc_56:not(._disabled_5fxgc_17) button:focus {
  padding: 0 14px;
  border-width: 2px;
  border-color: var(--figma-color-border-brand-strong);
  line-height: 28px;
}
._secondary_5fxgc_56._disabled_5fxgc_17 button {
  border-color: var(--figma-color-border-disabled-strong);
  color: var(--figma-color-text-disabled);
}

._secondary_5fxgc_56._danger_5fxgc_44 button {
  border-color: var(--figma-color-border-danger-strong);
  color: var(--figma-color-text-danger);
}
._secondary_5fxgc_56._danger_5fxgc_44:not(._disabled_5fxgc_17) button:focus {
  border-color: var(--figma-color-border-danger-strong);
}
._secondary_5fxgc_56._danger_5fxgc_44._disabled_5fxgc_17 button {
  border-color: var(--figma-color-border-disabled-strong);
  color: var(--figma-color-text-disabled);
}

._loadingIndicator_5fxgc_86 {
  position: absolute;
  top: 50%;
  left: 50%;
  pointer-events: none;
  transform: translate(-50%, -50%);
}

._default_5fxgc_29 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-icon-onbrand);
}
._default_5fxgc_29._disabled_5fxgc_17 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-icon-ondisabled);
}

._default_5fxgc_29._danger_5fxgc_44 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-icon-ondanger);
}
._default_5fxgc_29._danger_5fxgc_44._disabled_5fxgc_17 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-icon-ondisabled);
}

._secondary_5fxgc_56 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-text);
}
._secondary_5fxgc_56._disabled_5fxgc_17 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-text-disabled);
}

._secondary_5fxgc_56._danger_5fxgc_44 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-text-danger);
}
._secondary_5fxgc_56._danger_5fxgc_44._disabled_5fxgc_17 ._loadingIndicator_5fxgc_86 {
  color: var(--figma-color-text-disabled);
}

._children_5fxgc_122 {
  display: inline;
}
._loading_5fxgc_86 ._children_5fxgc_122 {
  visibility: hidden;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvY29tcG9uZW50cy9idXR0b24vYnV0dG9uLm1vZHVsZS5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxrQkFBa0I7RUFDbEIseUJBQXlCO0VBQ3pCLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxxQkFBcUI7RUFDckIsWUFBWTtFQUNaLHFDQUFxQztBQUN2Qzs7QUFFQTtFQUNFLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLGNBQWM7RUFDZCxnQkFBZ0I7RUFDaEIsV0FBVztFQUNYLHVCQUF1QjtFQUN2QixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsNkJBQTZCO0VBQzdCLDZDQUE2QztFQUM3QyxzQ0FBc0M7RUFDdEMsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxvREFBb0Q7QUFDdEQ7QUFDQTtFQUNFLGdEQUFnRDtFQUNoRCx5Q0FBeUM7QUFDM0M7O0FBRUE7RUFDRSw4Q0FBOEM7RUFDOUMsdUNBQXVDO0FBQ3pDO0FBQ0E7RUFDRSxxREFBcUQ7QUFDdkQ7QUFDQTtFQUNFLGdEQUFnRDtFQUNoRCx5Q0FBeUM7QUFDM0M7O0FBRUE7RUFDRSxlQUFlO0VBQ2Ysa0RBQWtEO0VBQ2xELDZCQUE2QjtFQUM3Qiw4QkFBOEI7RUFDOUIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLG9EQUFvRDtFQUNwRCxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLHVEQUF1RDtFQUN2RCx1Q0FBdUM7QUFDekM7O0FBRUE7RUFDRSxxREFBcUQ7RUFDckQscUNBQXFDO0FBQ3ZDO0FBQ0E7RUFDRSxxREFBcUQ7QUFDdkQ7QUFDQTtFQUNFLHVEQUF1RDtFQUN2RCx1Q0FBdUM7QUFDekM7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsUUFBUTtFQUNSLFNBQVM7RUFDVCxvQkFBb0I7RUFDcEIsZ0NBQWdDO0FBQ2xDOztBQUVBO0VBQ0Usc0NBQXNDO0FBQ3hDO0FBQ0E7RUFDRSx5Q0FBeUM7QUFDM0M7O0FBRUE7RUFDRSx1Q0FBdUM7QUFDekM7QUFDQTtFQUNFLHlDQUF5QztBQUMzQzs7QUFFQTtFQUNFLDhCQUE4QjtBQUNoQztBQUNBO0VBQ0UsdUNBQXVDO0FBQ3pDOztBQUVBO0VBQ0UscUNBQXFDO0FBQ3ZDO0FBQ0E7RUFDRSx1Q0FBdUM7QUFDekM7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxrQkFBa0I7QUFDcEIiLCJmaWxlIjoibm9kZV9tb2R1bGVzL0BjcmVhdGUtZmlnbWEtcGx1Z2luL3VpL2xpYi9jb21wb25lbnRzL2J1dHRvbi9idXR0b24ubW9kdWxlLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5idXR0b24ge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHotaW5kZXg6IHZhcigtLXotaW5kZXgtMSk7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbn1cblxuLmZ1bGxXaWR0aCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uYnV0dG9uIGJ1dHRvbiB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgaGVpZ2h0OiAzMnB4O1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLTYpO1xufVxuXG4uZGlzYWJsZWQgYnV0dG9uIHtcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbn1cblxuLmZ1bGxXaWR0aCBidXR0b24ge1xuICBkaXNwbGF5OiBibG9jaztcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgd2lkdGg6IDEwMCU7XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xufVxuXG4uZGVmYXVsdCBidXR0b24ge1xuICBwYWRkaW5nOiAwIDE0cHg7XG4gIGJvcmRlcjogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci1iZy1icmFuZCk7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0LW9uYnJhbmQpO1xuICBsaW5lLWhlaWdodDogMjhweDtcbn1cbi5kZWZhdWx0Om5vdCguZGlzYWJsZWQpIGJ1dHRvbjpmb2N1cyB7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyLWJyYW5kLXN0cm9uZyk7XG59XG4uZGVmYXVsdC5kaXNhYmxlZCBidXR0b24ge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci1iZy1kaXNhYmxlZCk7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0LW9uZGlzYWJsZWQpO1xufVxuXG4uZGVmYXVsdC5kYW5nZXIgYnV0dG9uIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYmctZGFuZ2VyKTtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtb25kYW5nZXIpO1xufVxuLmRlZmF1bHQuZGFuZ2VyOm5vdCguZGlzYWJsZWQpIGJ1dHRvbjpmb2N1cyB7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyLWRhbmdlci1zdHJvbmcpO1xufVxuLmRlZmF1bHQuZGFuZ2VyLmRpc2FibGVkIGJ1dHRvbiB7XG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWJnLWRpc2FibGVkKTtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtb25kaXNhYmxlZCk7XG59XG5cbi5zZWNvbmRhcnkgYnV0dG9uIHtcbiAgcGFkZGluZzogMCAxNXB4O1xuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1maWdtYS1jb2xvci1ib3JkZXItc3Ryb25nKTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcbiAgbGluZS1oZWlnaHQ6IDMwcHg7XG59XG4uc2Vjb25kYXJ5Om5vdCguZGlzYWJsZWQpIGJ1dHRvbjpmb2N1cyB7XG4gIHBhZGRpbmc6IDAgMTRweDtcbiAgYm9yZGVyLXdpZHRoOiAycHg7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyLWJyYW5kLXN0cm9uZyk7XG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xufVxuLnNlY29uZGFyeS5kaXNhYmxlZCBidXR0b24ge1xuICBib3JkZXItY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWJvcmRlci1kaXNhYmxlZC1zdHJvbmcpO1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC1kaXNhYmxlZCk7XG59XG5cbi5zZWNvbmRhcnkuZGFuZ2VyIGJ1dHRvbiB7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyLWRhbmdlci1zdHJvbmcpO1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC1kYW5nZXIpO1xufVxuLnNlY29uZGFyeS5kYW5nZXI6bm90KC5kaXNhYmxlZCkgYnV0dG9uOmZvY3VzIHtcbiAgYm9yZGVyLWNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci1ib3JkZXItZGFuZ2VyLXN0cm9uZyk7XG59XG4uc2Vjb25kYXJ5LmRhbmdlci5kaXNhYmxlZCBidXR0b24ge1xuICBib3JkZXItY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWJvcmRlci1kaXNhYmxlZC1zdHJvbmcpO1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC1kaXNhYmxlZCk7XG59XG5cbi5sb2FkaW5nSW5kaWNhdG9yIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDUwJTtcbiAgbGVmdDogNTAlO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG59XG5cbi5kZWZhdWx0IC5sb2FkaW5nSW5kaWNhdG9yIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWljb24tb25icmFuZCk7XG59XG4uZGVmYXVsdC5kaXNhYmxlZCAubG9hZGluZ0luZGljYXRvciB7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci1pY29uLW9uZGlzYWJsZWQpO1xufVxuXG4uZGVmYXVsdC5kYW5nZXIgLmxvYWRpbmdJbmRpY2F0b3Ige1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItaWNvbi1vbmRhbmdlcik7XG59XG4uZGVmYXVsdC5kYW5nZXIuZGlzYWJsZWQgLmxvYWRpbmdJbmRpY2F0b3Ige1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItaWNvbi1vbmRpc2FibGVkKTtcbn1cblxuLnNlY29uZGFyeSAubG9hZGluZ0luZGljYXRvciB7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcbn1cbi5zZWNvbmRhcnkuZGlzYWJsZWQgLmxvYWRpbmdJbmRpY2F0b3Ige1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC1kaXNhYmxlZCk7XG59XG5cbi5zZWNvbmRhcnkuZGFuZ2VyIC5sb2FkaW5nSW5kaWNhdG9yIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtZGFuZ2VyKTtcbn1cbi5zZWNvbmRhcnkuZGFuZ2VyLmRpc2FibGVkIC5sb2FkaW5nSW5kaWNhdG9yIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtZGlzYWJsZWQpO1xufVxuXG4uY2hpbGRyZW4ge1xuICBkaXNwbGF5OiBpbmxpbmU7XG59XG4ubG9hZGluZyAuY2hpbGRyZW4ge1xuICB2aXNpYmlsaXR5OiBoaWRkZW47XG59XG4iXX0= */`;
        document.head.append(element);
      }
      button_module_default = { "button": "_button_5fxgc_1", "fullWidth": "_fullWidth_5fxgc_7", "disabled": "_disabled_5fxgc_17", "default": "_default_5fxgc_29", "danger": "_danger_5fxgc_44", "secondary": "_secondary_5fxgc_56", "loadingIndicator": "_loadingIndicator_5fxgc_86", "children": "_children_5fxgc_122", "loading": "_loading_5fxgc_86" };
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/button/button.js
  function Button(_a) {
    var _b = _a, { children, danger = false, disabled = false, fullWidth = false, loading = false, onClick, propagateEscapeKeyDown = true, secondary = false } = _b, rest = __objRest(_b, ["children", "danger", "disabled", "fullWidth", "loading", "onClick", "propagateEscapeKeyDown", "secondary"]);
    const handleKeyDown = T2(function(event) {
      if (event.key !== "Escape") {
        return;
      }
      if (propagateEscapeKeyDown === false) {
        event.stopPropagation();
      }
      event.currentTarget.blur();
    }, [propagateEscapeKeyDown]);
    return y(
      "div",
      { class: createClassName([
        button_module_default.button,
        secondary === true ? button_module_default.secondary : button_module_default.default,
        danger === true ? button_module_default.danger : null,
        fullWidth === true ? button_module_default.fullWidth : null,
        disabled === true ? button_module_default.disabled : null,
        loading === true ? button_module_default.loading : null
      ]) },
      loading === true ? y(
        "div",
        { class: button_module_default.loadingIndicator },
        y(LoadingIndicator, null)
      ) : null,
      y(
        "button",
        __spreadProps(__spreadValues({}, rest), { disabled: disabled === true, onClick: disabled === true || loading === true ? void 0 : onClick, onKeyDown: disabled === true || loading === true ? void 0 : handleKeyDown, tabIndex: disabled === true ? -1 : 0 }),
        y("div", { class: button_module_default.children }, children)
      )
    );
  }
  var init_button = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/button/button.js"() {
      init_preact_module();
      init_hooks_module();
      init_create_class_name();
      init_loading_indicator();
      init_button_module();
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/0d29d943-485e-40ac-b002-52ab76ecedd2/icon.module.js
  var icon_module_default;
  var init_icon_module = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/0d29d943-485e-40ac-b002-52ab76ecedd2/icon.module.js"() {
      if (document.getElementById("4445490750") === null) {
        const element = document.createElement("style");
        element.id = "4445490750";
        element.textContent = `._icon_13804_1 {
  fill: currentColor;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvaWNvbnMvaWNvbi5tb2R1bGUuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0Usa0JBQWtCO0FBQ3BCIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvaWNvbnMvaWNvbi5tb2R1bGUuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmljb24ge1xuICBmaWxsOiBjdXJyZW50Q29sb3I7XG59XG4iXX0= */`;
        document.head.append(element);
      }
      icon_module_default = { "icon": "_icon_13804_1" };
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/icons/create-icon.js
  function createIcon(path, options) {
    const { width, height } = options;
    return function Icon(_a) {
      var _b = _a, { color: color2 } = _b, rest = __objRest(_b, ["color"]);
      return y(
        "svg",
        __spreadProps(__spreadValues({}, rest), { class: icon_module_default.icon, height, style: typeof color2 === "undefined" ? void 0 : {
          fill: `var(--figma-color-icon-${color2})`
        }, width, xmlns: "http://www.w3.org/2000/svg" }),
        y("path", { "clip-rule": "evenodd", d: path, "fill-rule": "evenodd" })
      );
    };
  }
  var init_create_icon = __esm({
    "node_modules/@create-figma-plugin/ui/lib/icons/create-icon.js"() {
      init_preact_module();
      init_icon_module();
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/utilities/get-current-from-ref.js
  function getCurrentFromRef(ref) {
    if (ref.current === null) {
      throw new Error("`ref.current` is `undefined`");
    }
    return ref.current;
  }
  var init_get_current_from_ref = __esm({
    "node_modules/@create-figma-plugin/ui/lib/utilities/get-current-from-ref.js"() {
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/d820d390-10e5-4aef-bffe-623365bf5a29/tabs.module.js
  var tabs_module_default;
  var init_tabs_module = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/d820d390-10e5-4aef-bffe-623365bf5a29/tabs.module.js"() {
      if (document.getElementById("9057b706f3") === null) {
        const element = document.createElement("style");
        element.id = "9057b706f3";
        element.textContent = `._tabs_61qsz_1 {
  position: relative;
  z-index: var(--z-index-1);
  display: flex;
  padding-left: var(--space-extra-small);
  border-bottom: 1px solid var(--figma-color-border);
}

._label_61qsz_9 {
  padding: var(--space-small) var(--space-extra-small);
  color: var(--figma-color-text-secondary);
}
._label_61qsz_9:hover {
  color: var(--figma-color-text);
}

._input_61qsz_17 {
  display: block;
  width: 0;
  height: 0;
}

._input_61qsz_17:checked ~ ._value_61qsz_23 {
  color: var(--figma-color-text);
  font-weight: var(--font-weight-bold);
}

._children_61qsz_28 {
  color: var(--figma-color-text);
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvY29tcG9uZW50cy90YWJzL3RhYnMubW9kdWxlLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGtCQUFrQjtFQUNsQix5QkFBeUI7RUFDekIsYUFBYTtFQUNiLHNDQUFzQztFQUN0QyxrREFBa0Q7QUFDcEQ7O0FBRUE7RUFDRSxvREFBb0Q7RUFDcEQsd0NBQXdDO0FBQzFDO0FBQ0E7RUFDRSw4QkFBOEI7QUFDaEM7O0FBRUE7RUFDRSxjQUFjO0VBQ2QsUUFBUTtFQUNSLFNBQVM7QUFDWDs7QUFFQTtFQUNFLDhCQUE4QjtFQUM5QixvQ0FBb0M7QUFDdEM7O0FBRUE7RUFDRSw4QkFBOEI7QUFDaEMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL0BjcmVhdGUtZmlnbWEtcGx1Z2luL3VpL2xpYi9jb21wb25lbnRzL3RhYnMvdGFicy5tb2R1bGUuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnRhYnMge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHotaW5kZXg6IHZhcigtLXotaW5kZXgtMSk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBhZGRpbmctbGVmdDogdmFyKC0tc3BhY2UtZXh0cmEtc21hbGwpO1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyKTtcbn1cblxuLmxhYmVsIHtcbiAgcGFkZGluZzogdmFyKC0tc3BhY2Utc21hbGwpIHZhcigtLXNwYWNlLWV4dHJhLXNtYWxsKTtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTtcbn1cbi5sYWJlbDpob3ZlciB7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcbn1cblxuLmlucHV0IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHdpZHRoOiAwO1xuICBoZWlnaHQ6IDA7XG59XG5cbi5pbnB1dDpjaGVja2VkIH4gLnZhbHVlIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQpO1xuICBmb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtYm9sZCk7XG59XG5cbi5jaGlsZHJlbiB7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcbn1cbiJdfQ== */`;
        document.head.append(element);
      }
      tabs_module_default = { "tabs": "_tabs_61qsz_1", "label": "_label_61qsz_9", "input": "_input_61qsz_17", "value": "_value_61qsz_23", "children": "_children_61qsz_28" };
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/tabs/tabs.js
  function Tabs(_a) {
    var _b = _a, { name: name307, onChange = function() {
    }, onValueChange = function() {
    }, options, propagateEscapeKeyDown = true, value } = _b, rest = __objRest(_b, ["name", "onChange", "onValueChange", "options", "propagateEscapeKeyDown", "value"]);
    const handleChange = T2(function(event) {
      const id = event.currentTarget.getAttribute(ITEM_ID_DATA_ATTRIBUTE_NAME);
      const newValue = options[parseInt(id, 10)].value;
      onValueChange(newValue, name307);
      onChange(event);
    }, [name307, onChange, onValueChange, options]);
    const handleKeyDown = T2(function(event) {
      if (event.key !== "Escape") {
        return;
      }
      if (propagateEscapeKeyDown === false) {
        event.stopPropagation();
      }
      event.currentTarget.blur();
    }, [propagateEscapeKeyDown]);
    const activeOption = options.find(function(option) {
      return option.value === value;
    });
    return y(
      g,
      null,
      y("div", { class: tabs_module_default.tabs }, options.map(function(option, index2) {
        return y(
          "label",
          { key: index2, class: tabs_module_default.label },
          y("input", __spreadProps(__spreadValues({}, rest), { checked: value === option.value, class: tabs_module_default.input, name: name307, onChange: handleChange, onKeyDown: handleKeyDown, tabIndex: 0, type: "radio", value: option.value, [ITEM_ID_DATA_ATTRIBUTE_NAME]: `${index2}` })),
          y("div", { class: tabs_module_default.value }, option.value)
        );
      })),
      typeof activeOption === "undefined" ? null : y("div", { class: tabs_module_default.children }, activeOption.children)
    );
  }
  var ITEM_ID_DATA_ATTRIBUTE_NAME;
  var init_tabs = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/tabs/tabs.js"() {
      init_preact_module();
      init_hooks_module();
      init_tabs_module();
      ITEM_ID_DATA_ATTRIBUTE_NAME = "data-tabs-item-id";
    }
  });

  // node_modules/hex-rgb/index.js
  function hexRgb(hex2, options = {}) {
    if (typeof hex2 !== "string" || nonHexChars.test(hex2) || !validHexSize.test(hex2)) {
      throw new TypeError("Expected a valid hex string");
    }
    hex2 = hex2.replace(/^#/, "");
    let alphaFromHex = 1;
    if (hex2.length === 8) {
      alphaFromHex = Number.parseInt(hex2.slice(6, 8), 16) / 255;
      hex2 = hex2.slice(0, 6);
    }
    if (hex2.length === 4) {
      alphaFromHex = Number.parseInt(hex2.slice(3, 4).repeat(2), 16) / 255;
      hex2 = hex2.slice(0, 3);
    }
    if (hex2.length === 3) {
      hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
    }
    const number2 = Number.parseInt(hex2, 16);
    const red = number2 >> 16;
    const green = number2 >> 8 & 255;
    const blue = number2 & 255;
    const alpha = typeof options.alpha === "number" ? options.alpha : alphaFromHex;
    if (options.format === "array") {
      return [red, green, blue, alpha];
    }
    if (options.format === "css") {
      const alphaString = alpha === 1 ? "" : ` / ${Number((alpha * 100).toFixed(2))}%`;
      return `rgb(${red} ${green} ${blue}${alphaString})`;
    }
    return { red, green, blue, alpha };
  }
  var hexCharacters, match3or4Hex, match6or8Hex, nonHexChars, validHexSize;
  var init_hex_rgb = __esm({
    "node_modules/hex-rgb/index.js"() {
      hexCharacters = "a-f\\d";
      match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
      match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
      nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
      validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
    }
  });

  // node_modules/@create-figma-plugin/utilities/lib/color/convert-hex-color-to-rgb-color.js
  function convertHexColorToRgbColor(hexColor) {
    if (hexColor.length !== 3 && hexColor.length !== 6) {
      return null;
    }
    try {
      const { red, green, blue } = hexRgb(hexColor);
      return {
        b: blue / 255,
        g: green / 255,
        r: red / 255
      };
    } catch (e6) {
      return null;
    }
  }
  var init_convert_hex_color_to_rgb_color = __esm({
    "node_modules/@create-figma-plugin/utilities/lib/color/convert-hex-color-to-rgb-color.js"() {
      init_hex_rgb();
    }
  });

  // node_modules/@create-figma-plugin/utilities/lib/mixed-values.js
  var MIXED_STRING;
  var init_mixed_values = __esm({
    "node_modules/@create-figma-plugin/utilities/lib/mixed-values.js"() {
      MIXED_STRING = "999999999999999";
    }
  });

  // node_modules/@create-figma-plugin/utilities/lib/index.js
  var init_lib = __esm({
    "node_modules/@create-figma-plugin/utilities/lib/index.js"() {
      init_convert_hex_color_to_rgb_color();
      init_mixed_values();
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/textbox/private/is-keycode-character-generating.js
  function isKeyCodeCharacterGenerating(keyCode) {
    return keyCode === 32 || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 105 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222;
  }
  var init_is_keycode_character_generating = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/textbox/private/is-keycode-character-generating.js"() {
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/textbox/textbox/private/raw-textbox.js
  function RawTextbox(_a) {
    var _b = _a, { disabled = false, name: name307, onInput = function() {
    }, onValueInput = function() {
    }, password = false, placeholder, propagateEscapeKeyDown = true, revertOnEscapeKeyDown = false, spellCheck = false, validateOnBlur, value } = _b, rest = __objRest(_b, ["disabled", "name", "onInput", "onValueInput", "password", "placeholder", "propagateEscapeKeyDown", "revertOnEscapeKeyDown", "spellCheck", "validateOnBlur", "value"]);
    const inputElementRef = _2(null);
    const revertOnEscapeKeyDownRef = _2(false);
    const [originalValue, setOriginalValue] = h2(EMPTY_STRING);
    const setInputElementValue = T2(function(value2) {
      const inputElement = getCurrentFromRef(inputElementRef);
      inputElement.value = value2;
      const inputEvent = document.createEvent("Event");
      inputEvent.initEvent("input", true, true);
      inputElement.dispatchEvent(inputEvent);
    }, []);
    const handleBlur = T2(function() {
      if (revertOnEscapeKeyDownRef.current === true) {
        revertOnEscapeKeyDownRef.current = false;
        return;
      }
      if (typeof validateOnBlur !== "undefined") {
        const result = validateOnBlur(value);
        if (typeof result === "string") {
          setInputElementValue(result);
          setOriginalValue(EMPTY_STRING);
          return;
        }
        if (result === false) {
          if (value !== originalValue) {
            setInputElementValue(originalValue);
          }
          setOriginalValue(EMPTY_STRING);
          return;
        }
      }
      setOriginalValue(EMPTY_STRING);
    }, [originalValue, setInputElementValue, validateOnBlur, value]);
    const handleFocus = T2(function(event) {
      setOriginalValue(value);
      event.currentTarget.select();
    }, [value]);
    const handleInput = T2(function(event) {
      onValueInput(event.currentTarget.value, name307);
      onInput(event);
    }, [name307, onInput, onValueInput]);
    const handleKeyDown = T2(function(event) {
      const key = event.key;
      if (key === "Escape") {
        if (propagateEscapeKeyDown === false) {
          event.stopPropagation();
        }
        if (revertOnEscapeKeyDown === true) {
          revertOnEscapeKeyDownRef.current = true;
          setInputElementValue(originalValue);
          setOriginalValue(EMPTY_STRING);
        }
        event.currentTarget.blur();
        return;
      }
      if (key === "Enter") {
        event.currentTarget.blur();
        return;
      }
      if (value === MIXED_STRING && isKeyCodeCharacterGenerating(event.keyCode) === false) {
        event.preventDefault();
        event.currentTarget.select();
      }
    }, [
      originalValue,
      propagateEscapeKeyDown,
      revertOnEscapeKeyDown,
      setInputElementValue,
      value
    ]);
    const handleMouseUp = T2(function(event) {
      if (value === MIXED_STRING) {
        event.preventDefault();
      }
    }, [value]);
    return y("input", __spreadProps(__spreadValues({}, rest), { ref: inputElementRef, disabled: disabled === true, name: name307, onBlur: handleBlur, onFocus: handleFocus, onInput: handleInput, onKeyDown: handleKeyDown, onMouseUp: handleMouseUp, placeholder, spellcheck: spellCheck, tabIndex: disabled === true ? -1 : 0, type: password === true ? "password" : "text", value: value === MIXED_STRING ? "Mixed" : value }));
  }
  var EMPTY_STRING;
  var init_raw_textbox = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/textbox/textbox/private/raw-textbox.js"() {
      init_lib();
      init_preact_module();
      init_hooks_module();
      init_get_current_from_ref();
      init_is_keycode_character_generating();
      EMPTY_STRING = "";
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/20cd7c8d-05e5-4a38-b9e9-fa5666b23587/textbox.module.js
  var textbox_module_default;
  var init_textbox_module = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/20cd7c8d-05e5-4a38-b9e9-fa5666b23587/textbox.module.js"() {
      if (document.getElementById("d6f1162d61") === null) {
        const element = document.createElement("style");
        element.id = "d6f1162d61";
        element.textContent = `._textbox_sir3b_1 {
  position: relative;
  z-index: var(--z-index-1);
}
._textbox_sir3b_1:focus-within {
  z-index: var(--z-index-2); /* Stack \`.textbox\` over its sibling elements */
}

._input_sir3b_9 {
  display: block;
  width: 100%;
  height: 28px;
  padding: 0 var(--space-extra-small);
  background-color: transparent;
  color: var(--figma-color-text);
}
._disabled_sir3b_17 ._input_sir3b_9 {
  color: var(--figma-color-text-disabled);
  cursor: not-allowed;
}
._hasIcon_sir3b_21 ._input_sir3b_9 {
  padding-left: 32px;
}

._input_sir3b_9::placeholder {
  color: var(--figma-color-text-tertiary);
}

._icon_sir3b_29 {
  position: absolute;
  top: 14px;
  left: 16px;
  color: var(--figma-color-icon-secondary);
  pointer-events: none; /* so that clicking the icon focuses the textbox */
  text-align: center;
  transform: translate(-50%, -50%);
}
._textbox_sir3b_1:not(._disabled_sir3b_17) ._input_sir3b_9:focus ~ ._icon_sir3b_29 {
  color: var(--figma-color-icon-brand);
}
._disabled_sir3b_17 ._icon_sir3b_29 {
  color: var(--figma-color-icon-disabled);
}

._icon_sir3b_29 svg {
  fill: currentColor;
}

._border_sir3b_49 {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border: 1px solid transparent;
  border-radius: var(--border-radius-2);
  pointer-events: none;
}
._hasBorder_sir3b_59 ._border_sir3b_49,
._textbox_sir3b_1:not(._disabled_sir3b_17):hover ._border_sir3b_49 {
  border-color: var(--figma-color-border);
}
._textbox_sir3b_1:not(._disabled_sir3b_17) ._input_sir3b_9:focus ~ ._border_sir3b_49 {
  top: -1px;
  bottom: -1px;
  border-width: 2px;
  border-color: var(--figma-color-border-brand-strong);
}

._underline_sir3b_70 {
  position: absolute;
  right: var(--space-extra-small);
  bottom: 0;
  left: var(--space-extra-small);
  height: 1px;
  background-color: var(--figma-color-border);
}
._textbox_sir3b_1:not(._disabled_sir3b_17) ._input_sir3b_9:focus ~ ._underline_sir3b_70,
._textbox_sir3b_1:not(._disabled_sir3b_17):hover ._underline_sir3b_70 {
  background-color: transparent;
}

/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AY3JlYXRlLWZpZ21hLXBsdWdpbi91aS9saWIvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3gvdGV4dGJveC5tb2R1bGUuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0Usa0JBQWtCO0VBQ2xCLHlCQUF5QjtBQUMzQjtBQUNBO0VBQ0UseUJBQXlCLEVBQUUsK0NBQStDO0FBQzVFOztBQUVBO0VBQ0UsY0FBYztFQUNkLFdBQVc7RUFDWCxZQUFZO0VBQ1osbUNBQW1DO0VBQ25DLDZCQUE2QjtFQUM3Qiw4QkFBOEI7QUFDaEM7QUFDQTtFQUNFLHVDQUF1QztFQUN2QyxtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLHVDQUF1QztBQUN6Qzs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixTQUFTO0VBQ1QsVUFBVTtFQUNWLHdDQUF3QztFQUN4QyxvQkFBb0IsRUFBRSxrREFBa0Q7RUFDeEUsa0JBQWtCO0VBQ2xCLGdDQUFnQztBQUNsQztBQUNBO0VBQ0Usb0NBQW9DO0FBQ3RDO0FBQ0E7RUFDRSx1Q0FBdUM7QUFDekM7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsTUFBTTtFQUNOLFFBQVE7RUFDUixTQUFTO0VBQ1QsT0FBTztFQUNQLDZCQUE2QjtFQUM3QixxQ0FBcUM7RUFDckMsb0JBQW9CO0FBQ3RCO0FBQ0E7O0VBRUUsdUNBQXVDO0FBQ3pDO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixvREFBb0Q7QUFDdEQ7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsK0JBQStCO0VBQy9CLFNBQVM7RUFDVCw4QkFBOEI7RUFDOUIsV0FBVztFQUNYLDJDQUEyQztBQUM3QztBQUNBOztFQUVFLDZCQUE2QjtBQUMvQiIsImZpbGUiOiJub2RlX21vZHVsZXMvQGNyZWF0ZS1maWdtYS1wbHVnaW4vdWkvbGliL2NvbXBvbmVudHMvdGV4dGJveC90ZXh0Ym94L3RleHRib3gubW9kdWxlLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi50ZXh0Ym94IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiB2YXIoLS16LWluZGV4LTEpO1xufVxuLnRleHRib3g6Zm9jdXMtd2l0aGluIHtcbiAgei1pbmRleDogdmFyKC0tei1pbmRleC0yKTsgLyogU3RhY2sgYC50ZXh0Ym94YCBvdmVyIGl0cyBzaWJsaW5nIGVsZW1lbnRzICovXG59XG5cbi5pbnB1dCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAyOHB4O1xuICBwYWRkaW5nOiAwIHZhcigtLXNwYWNlLWV4dHJhLXNtYWxsKTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcbn1cbi5kaXNhYmxlZCAuaW5wdXQge1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC1kaXNhYmxlZCk7XG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XG59XG4uaGFzSWNvbiAuaW5wdXQge1xuICBwYWRkaW5nLWxlZnQ6IDMycHg7XG59XG5cbi5pbnB1dDo6cGxhY2Vob2xkZXIge1xuICBjb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItdGV4dC10ZXJ0aWFyeSk7XG59XG5cbi5pY29uIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDE0cHg7XG4gIGxlZnQ6IDE2cHg7XG4gIGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci1pY29uLXNlY29uZGFyeSk7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lOyAvKiBzbyB0aGF0IGNsaWNraW5nIHRoZSBpY29uIGZvY3VzZXMgdGhlIHRleHRib3ggKi9cbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbn1cbi50ZXh0Ym94Om5vdCguZGlzYWJsZWQpIC5pbnB1dDpmb2N1cyB+IC5pY29uIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWljb24tYnJhbmQpO1xufVxuLmRpc2FibGVkIC5pY29uIHtcbiAgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWljb24tZGlzYWJsZWQpO1xufVxuXG4uaWNvbiBzdmcge1xuICBmaWxsOiBjdXJyZW50Q29sb3I7XG59XG5cbi5ib3JkZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgcmlnaHQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgbGVmdDogMDtcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtMik7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuLmhhc0JvcmRlciAuYm9yZGVyLFxuLnRleHRib3g6bm90KC5kaXNhYmxlZCk6aG92ZXIgLmJvcmRlciB7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyKTtcbn1cbi50ZXh0Ym94Om5vdCguZGlzYWJsZWQpIC5pbnB1dDpmb2N1cyB+IC5ib3JkZXIge1xuICB0b3A6IC0xcHg7XG4gIGJvdHRvbTogLTFweDtcbiAgYm9yZGVyLXdpZHRoOiAycHg7XG4gIGJvcmRlci1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyLWJyYW5kLXN0cm9uZyk7XG59XG5cbi51bmRlcmxpbmUge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiB2YXIoLS1zcGFjZS1leHRyYS1zbWFsbCk7XG4gIGJvdHRvbTogMDtcbiAgbGVmdDogdmFyKC0tc3BhY2UtZXh0cmEtc21hbGwpO1xuICBoZWlnaHQ6IDFweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyKTtcbn1cbi50ZXh0Ym94Om5vdCguZGlzYWJsZWQpIC5pbnB1dDpmb2N1cyB+IC51bmRlcmxpbmUsXG4udGV4dGJveDpub3QoLmRpc2FibGVkKTpob3ZlciAudW5kZXJsaW5lIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG4iXX0= */`;
        document.head.append(element);
      }
      textbox_module_default = { "textbox": "_textbox_sir3b_1", "input": "_input_sir3b_9", "disabled": "_disabled_sir3b_17", "hasIcon": "_hasIcon_sir3b_21", "icon": "_icon_sir3b_29", "border": "_border_sir3b_49", "hasBorder": "_hasBorder_sir3b_59", "underline": "_underline_sir3b_70" };
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/components/textbox/textbox/textbox.js
  function Textbox(_a) {
    var _b = _a, { icon, variant } = _b, rest = __objRest(_b, ["icon", "variant"]);
    if (typeof icon === "string" && icon.length !== 1) {
      throw new Error(`String \`icon\` must be a single character: ${icon}`);
    }
    return y(
      "div",
      { class: createClassName([
        textbox_module_default.textbox,
        typeof variant === "undefined" ? null : variant === "border" ? textbox_module_default.hasBorder : null,
        typeof icon === "undefined" ? null : textbox_module_default.hasIcon,
        rest.disabled === true ? textbox_module_default.disabled : null
      ]) },
      y(RawTextbox, __spreadProps(__spreadValues({}, rest), { class: textbox_module_default.input })),
      typeof icon === "undefined" ? null : y("div", { class: textbox_module_default.icon }, icon),
      y("div", { class: textbox_module_default.border }),
      variant === "underline" ? y("div", { class: textbox_module_default.underline }) : null
    );
  }
  var init_textbox = __esm({
    "node_modules/@create-figma-plugin/ui/lib/components/textbox/textbox/textbox.js"() {
      init_preact_module();
      init_create_class_name();
      init_raw_textbox();
      init_textbox_module();
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/icons/icon-16/icon-chevron-down-16.js
  var IconChevronDown16;
  var init_icon_chevron_down_16 = __esm({
    "node_modules/@create-figma-plugin/ui/lib/icons/icon-16/icon-chevron-down-16.js"() {
      init_create_icon();
      IconChevronDown16 = createIcon("m7.646 9.708-3-3L5.354 6 8 8.647 10.646 6l.708.708-3 3-.354.353-.354-.353Z", { height: 16, width: 16 });
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/icons/icon-32/icon-plus-32.js
  var IconPlus32;
  var init_icon_plus_32 = __esm({
    "node_modules/@create-figma-plugin/ui/lib/icons/icon-32/icon-plus-32.js"() {
      init_create_icon();
      IconPlus32 = createIcon("M15.5 15.5v-5h1v5h5v1h-5v5h-1v-5h-5v-1h5Z", { height: 32, width: 32 });
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/733ffbde-01dd-4478-85ca-172eb64d3f93/base.js
  var init_base = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/733ffbde-01dd-4478-85ca-172eb64d3f93/base.js"() {
      if (document.getElementById("a3b0e59720") === null) {
        const element = document.createElement("style");
        element.id = "a3b0e59720";
        element.textContent = `@import url('https://fonts.googleapis.com/css?family=Inter:400,600&display=swap');

:root {
  /* border-radius */
  --border-radius-2: 2px;
  --border-radius-6: 6px;
  /* box-shadow */
  --box-shadow: var(--box-shadow-menu);
  --box-shadow-menu: 0 5px 17px rgba(0, 0, 0, 0.2),
    0 2px 7px rgba(0, 0, 0, 0.15), inset 0 0 0 0.5px #000000,
    0 0 0 0.5px rgba(0, 0, 0, 0.1);
  --box-shadow-modal: 0 2px 14px rgba(0, 0, 0, 0.15),
    0 0 0 0.5px rgba(0, 0, 0, 0.2);
  /* font */
  --font-family: 'Inter', 'Helvetica', sans-serif;
  --font-family-code: SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono',
    'Courier New', monospace;
  --font-size-11: 11px;
  --font-size-12: 12px;
  --font-weight-regular: 400;
  --font-weight-bold: 600;
  --line-height-16: 16px;
  /* opacity */
  --opacity-30: 0.3;
  /* space */
  --space-extra-small: 8px;
  --space-small: 12px;
  --space-medium: 16px;
  --space-large: 20px;
  --space-extra-large: 24px;
  /* z-index */
  --z-index-1: 1;
  --z-index-2: 2;
}

.figma-dark {
  color-scheme: dark;
}

* {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: currentColor;
}

body {
  margin: 0;
  background-color: var(--figma-color-bg);
  color: var(--figma-color-text);
  font-family: var(--font-family);
  font-size: var(--font-size-11);
  font-weight: var(--font-weight-regular);
  line-height: var(--line-height-16);
}

div,
span {
  cursor: default;
  user-select: none;
}

h1,
h2,
h3 {
  margin: 0;
  font-weight: inherit;
}

button {
  padding: 0;
  border: 0;
  -webkit-appearance: none;
  background-color: transparent;
  font: inherit;
  outline: 0;
}

hr {
  border: 0;
  margin: 0;
}

label {
  display: block;
}

input,
textarea {
  padding: 0;
  border: 0;
  margin: 0;
  -webkit-appearance: none;
  cursor: default;
  font: inherit;
  outline: 0;
}

svg {
  display: block;
}

::selection {
  background-color: var(--figma-color-bg-onselected);
}
`;
        document.head.prepend(element);
      }
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/utilities/render.js
  function render(Plugin2) {
    return function(rootNode2, props) {
      q(y(Plugin2, __spreadValues({}, props)), rootNode2);
    };
  }
  var init_render = __esm({
    "node_modules/@create-figma-plugin/ui/lib/utilities/render.js"() {
      init_base();
      init_preact_module();
    }
  });

  // node_modules/@create-figma-plugin/ui/lib/index.js
  var init_lib2 = __esm({
    "node_modules/@create-figma-plugin/ui/lib/index.js"() {
      init_button();
      init_tabs();
      init_textbox();
      init_icon_chevron_down_16();
      init_icon_plus_32();
      init_render();
    }
  });

  // src/components/primitives-tab/color-name-input.tsx
  var TextboxColorName, color_name_input_default;
  var init_color_name_input = __esm({
    "src/components/primitives-tab/color-name-input.tsx"() {
      "use strict";
      init_preact_module();
      init_hooks_module();
      init_lib2();
      TextboxColorName = () => {
        const [value, setValue] = h2("color");
        function handleInput(event) {
          const newValue = event.currentTarget.value;
          console.log(newValue);
          setValue(newValue);
        }
        return /* @__PURE__ */ y(Textbox, { onInput: handleInput, value, variant: "underline" });
      };
      color_name_input_default = TextboxColorName;
    }
  });

  // ../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/b6943c57-af91-4b48-b62c-b616ad2de435/tailwind.js
  var init_tailwind2 = __esm({
    "../../../private/var/folders/9b/7w9djy9j5dlfjn79khk4l92h0000gn/T/b6943c57-af91-4b48-b62c-b616ad2de435/tailwind.js"() {
      if (document.getElementById("daf6ec3404") === null) {
        const element = document.createElement("style");
        element.id = "daf6ec3404";
        element.textContent = `/*
! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
*/

html {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font family by default.
2. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 2rem;
  padding-left: 2rem;
}
@media (min-width: 1400px) {

  .container {
    max-width: 1400px;
  }
}
.pointer-events-none {
  pointer-events: none;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.inset-0 {
  inset: 0px;
}
.left-0 {
  left: 0px;
}
.left-10 {
  left: 2.5rem;
}
.left-8 {
  left: 2rem;
}
.right-0 {
  right: 0px;
}
.right-24 {
  right: 6rem;
}
.right-32 {
  right: 8rem;
}
.top-10 {
  top: 2.5rem;
}
.top-20 {
  top: 5rem;
}
.z-10 {
  z-index: 10;
}
.mb-1 {
  margin-bottom: 0.25rem;
}
.ml-3 {
  margin-left: 0.75rem;
}
.mt-2 {
  margin-top: 0.5rem;
}
.block {
  display: block;
}
.flex {
  display: flex;
}
.inline-flex {
  display: inline-flex;
}
.grid {
  display: grid;
}
.h-1 {
  height: 0.25rem;
}
.h-10 {
  height: 2.5rem;
}
.h-11 {
  height: 2.75rem;
}
.h-20 {
  height: 5rem;
}
.h-24 {
  height: 6rem;
}
.h-5 {
  height: 1.25rem;
}
.h-6 {
  height: 1.5rem;
}
.h-8 {
  height: 2rem;
}
.h-9 {
  height: 2.25rem;
}
.h-full {
  height: 100%;
}
.h-px {
  height: 1px;
}
.w-1 {
  width: 0.25rem;
}
.w-10 {
  width: 2.5rem;
}
.w-24 {
  width: 6rem;
}
.w-32 {
  width: 8rem;
}
.w-5 {
  width: 1.25rem;
}
.w-6 {
  width: 1.5rem;
}
.w-60 {
  width: 15rem;
}
.w-8 {
  width: 2rem;
}
.w-[124px] {
  width: 124px;
}
.w-[1px] {
  width: 1px;
}
.w-[400px] {
  width: 400px;
}
.w-full {
  width: 100%;
}
.w-px {
  width: 1px;
}
.grow {
  flex-grow: 1;
}
.border-spacing-2 {
  --tw-border-spacing-x: 0.5rem;
  --tw-border-spacing-y: 0.5rem;
  border-spacing: var(--tw-border-spacing-x) var(--tw-border-spacing-y);
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.resize {
  resize: both;
}
.flex-row {
  flex-direction: row;
}
.flex-col {
  flex-direction: column;
}
.place-items-center {
  place-items: center;
}
.content-center {
  align-content: center;
}
.items-center {
  align-items: center;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.justify-items-center {
  justify-items: center;
}
.gap-1 {
  gap: 0.25rem;
}
.gap-2 {
  gap: 0.5rem;
}
.place-self-end {
  place-self: end;
}
.overflow-y-auto {
  overflow-y: auto;
}
.overflow-y-scroll {
  overflow-y: scroll;
}
.whitespace-nowrap {
  white-space: nowrap;
}
.rounded {
  border-radius: 0.25rem;
}
.rounded-full {
  border-radius: 9999px;
}
.rounded-lg {
  border-radius: var(--radius);
}
.rounded-md {
  border-radius: calc(var(--radius) - 2px);
}
.border {
  border-width: 1px;
}
.border-2 {
  border-width: 2px;
}
.border-b {
  border-bottom-width: 1px;
}
.border-l {
  border-left-width: 1px;
}
.border-r {
  border-right-width: 1px;
}
.border-t {
  border-top-width: 1px;
}
.border-neutral-600 {
  --tw-border-opacity: 1;
  border-color: rgb(82 82 82 / var(--tw-border-opacity));
}
.border-neutral-700 {
  --tw-border-opacity: 1;
  border-color: rgb(64 64 64 / var(--tw-border-opacity));
}
.border-neutral-800 {
  --tw-border-opacity: 1;
  border-color: rgb(38 38 38 / var(--tw-border-opacity));
}
.border-slate-500 {
  --tw-border-opacity: 1;
  border-color: rgb(100 116 139 / var(--tw-border-opacity));
}
.bg-background {
  background-color: hsl(var(--background));
}
.bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity));
}
.bg-fig-blue {
  --tw-bg-opacity: 1;
  background-color: rgb(24 160 251 / var(--tw-bg-opacity));
}
.bg-muted {
  background-color: hsl(var(--muted));
}
.bg-neutral-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(115 115 115 / var(--tw-bg-opacity));
}
.bg-neutral-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(82 82 82 / var(--tw-bg-opacity));
}
.bg-neutral-700 {
  --tw-bg-opacity: 1;
  background-color: rgb(64 64 64 / var(--tw-bg-opacity));
}
.bg-neutral-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(38 38 38 / var(--tw-bg-opacity));
}
.bg-neutral-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(23 23 23 / var(--tw-bg-opacity));
}
.bg-red-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 202 202 / var(--tw-bg-opacity));
}
.bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity));
}
.bg-red-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 38 38 / var(--tw-bg-opacity));
}
.bg-slate-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(203 213 225 / var(--tw-bg-opacity));
}
.bg-slate-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(148 163 184 / var(--tw-bg-opacity));
}
.bg-slate-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(100 116 139 / var(--tw-bg-opacity));
}
.bg-slate-600 {
  --tw-bg-opacity: 1;
  background-color: rgb(71 85 105 / var(--tw-bg-opacity));
}
.bg-slate-700 {
  --tw-bg-opacity: 1;
  background-color: rgb(51 65 85 / var(--tw-bg-opacity));
}
.bg-slate-800 {
  --tw-bg-opacity: 1;
  background-color: rgb(30 41 59 / var(--tw-bg-opacity));
}
.bg-slate-900 {
  --tw-bg-opacity: 1;
  background-color: rgb(15 23 42 / var(--tw-bg-opacity));
}
.bg-gradient-conic {
  background-image: conic-gradient(from 180deg, white, red, black);
}
.bg-gradient-to-r {
  background-image: linear-gradient(to right, var(--tw-gradient-stops));
}
.from-indigo-500 {
  --tw-gradient-from: #6366f1 var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(99 102 241 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.from-white {
  --tw-gradient-from: #fff var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.via-indigo-500 {
  --tw-gradient-to: rgb(99 102 241 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #6366f1 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-pink-500 {
  --tw-gradient-to: rgb(236 72 153 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #ec4899 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-purple-500 {
  --tw-gradient-to: rgb(168 85 247 / 0)  var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), #a855f7 var(--tw-gradient-via-position), var(--tw-gradient-to);
}
.via-10% {
  --tw-gradient-via-position: 10%;
}
.via-30% {
  --tw-gradient-via-position: 30%;
}
.to-black {
  --tw-gradient-to: #000 var(--tw-gradient-to-position);
}
.to-pink-500 {
  --tw-gradient-to: #ec4899 var(--tw-gradient-to-position);
}
.p-1 {
  padding: 0.25rem;
}
.p-4 {
  padding: 1rem;
}
.px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}
.py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.pl-2 {
  padding-left: 0.5rem;
}
.pl-4 {
  padding-left: 1rem;
}
.pr-16 {
  padding-right: 4rem;
}
.pr-20 {
  padding-right: 5rem;
}
.pr-8 {
  padding-right: 2rem;
}
.pt-1 {
  padding-top: 0.25rem;
}
.pt-2 {
  padding-top: 0.5rem;
}
.pt-4 {
  padding-top: 1rem;
}
.text-center {
  text-align: center;
}
.align-middle {
  vertical-align: middle;
}
.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.font-bold {
  font-weight: 700;
}
.font-medium {
  font-weight: 500;
}
.text-foreground {
  color: hsl(var(--foreground));
}
.text-muted-foreground {
  color: hsl(var(--muted-foreground));
}
.underline {
  text-decoration-line: underline;
}
.opacity-20 {
  opacity: 0.2;
}
.opacity-50 {
  opacity: 0.5;
}
.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.outline {
  outline-style: solid;
}
.outline-dashed {
  outline-style: dashed;
}
.outline-2 {
  outline-width: 2px;
}
.outline-offset-1 {
  outline-offset: 1px;
}
.outline-offset-2 {
  outline-offset: 2px;
}
.outline-offset-['-2px'] {
  outline-offset: '-2px';
}
.outline-offset-[-2px] {
  outline-offset: -2px;
}
.outline-offset-[-8px] {
  outline-offset: -8px;
}
.outline-offset-[8px] {
  outline-offset: 8px;
}
.outline-blue-500 {
  outline-color: #3b82f6;
}
.outline-fig-blue {
  outline-color: #18A0FB;
}
.outline-neutral-500 {
  outline-color: #737373;
}
.outline-slate-500 {
  outline-color: #64748b;
}
.ring-offset-background {
  --tw-ring-offset-color: hsl(var(--background));
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
@keyframes enter {

  from {
    opacity: var(--tw-enter-opacity, 1);
    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));
  }
}
@keyframes exit {

  to {
    opacity: var(--tw-exit-opacity, 1);
    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));
  }
}

._tabs_61qsz_1 {
	border-bottom: none !important;
}

.hover:bg-blue-400:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(96 165 250 / var(--tw-bg-opacity));
}

.hover:bg-fig-blue:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(24 160 251 / var(--tw-bg-opacity));
}

.focus-visible:outline-none:focus-visible {
  outline: 2px solid transparent;
  outline-offset: 2px;
}

.focus-visible:ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.focus-visible:ring-ring:focus-visible {
  --tw-ring-color: hsl(var(--ring));
}

.focus-visible:ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}

.disabled:pointer-events-none:disabled {
  pointer-events: none;
}

.disabled:opacity-50:disabled {
  opacity: 0.5;
}

.data-[state=active]:bg-background[data-state=active] {
  background-color: hsl(var(--background));
}

.data-[state=active]:text-foreground[data-state=active] {
  color: hsl(var(--foreground));
}

.data-[state=active]:shadow[data-state=active] {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
`;
        document.head.append(element);
      }
    }
  });

  // src/components/tabs.tsx
  var TabGroup, tabs_default;
  var init_tabs2 = __esm({
    "src/components/tabs.tsx"() {
      "use strict";
      init_preact_module();
      init_hooks_module();
      init_lib2();
      init_color_name_input();
      init_tailwind2();
      init_lib2();
      TabGroup = () => {
        const [value, setValue] = h2("Primitives");
        const options = [
          {
            children: /* @__PURE__ */ y("div", { className: "absolute top-10 left-0 w-full h-full overflow-y-scroll flex flex-row" }, /* @__PURE__ */ y("div", { className: "w-10 h-full overflow-y-scroll pt-2 flex flex-col items-center gap-2" }, /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 outline-2 outline-neutral-500 outline-dashed rounded-full relative flex items-center justify-center" }, /* @__PURE__ */ y("span", { className: "absolute" }, /* @__PURE__ */ y(IconPlus32, null)))), /* @__PURE__ */ y("div", { className: "h-full grow" }, /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow h-full" }, /* @__PURE__ */ y(color_name_input_default, null)), /* @__PURE__ */ y("div", { className: "grow h-full border-l border-neutral-700" })), /* @__PURE__ */ y("div", { className: "h-full w-32 bg-gradient-to-r from-white via-indigo-500 via-30% to-black" })), /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow h-full border-t border-neutral-700" }), /* @__PURE__ */ y("div", { className: "grow h-full border-t border-l border-neutral-700" })), /* @__PURE__ */ y("div", { className: "h-full w-32 bg-gradient-to-r from-white via-pink-500 via-30% to-black" })), /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row border-t border-neutral-700" }, /* @__PURE__ */ y("div", { className: "grow h-full" })), /* @__PURE__ */ y("div", { className: "h-full w-32 bg-gradient-to-r from-white via-pink-500 via-30% to-black" })), /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row border-t border-neutral-700" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow h-full" })), /* @__PURE__ */ y("div", { className: "h-full w-32" })))),
            value: "Primitives"
          },
          {
            children: /* @__PURE__ */ y("div", { className: "absolute top-10 left-0 w-full h-full overflow-y-scroll" }, /* @__PURE__ */ y("div", { className: "flex flex-row w-full border-t border-neutral-700" }, /* @__PURE__ */ y("div", { className: "w-10 overflow-y-scroll py-2 flex flex-col items-center gap-2" }, /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 outline-2 outline-neutral-500 outline-dashed rounded-full relative flex items-center justify-center" }, /* @__PURE__ */ y("span", { className: "absolute" }, /* @__PURE__ */ y(IconChevronDown16, null)))), /* @__PURE__ */ y("div", { className: "h-full grow" }, /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row" }), /* @__PURE__ */ y("div", { className: "h-full w-32 bg-gradient-to-r from-white via-indigo-500 via-30% to-black" })))), /* @__PURE__ */ y("div", { className: "flex flex-row w-full border-t border-neutral-700" }, /* @__PURE__ */ y("div", { className: "w-10 overflow-y-scroll py-2 flex flex-col items-center gap-2" }, /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full outline outline-2 outline-offset-2 outline-fig-blue" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 bg-gradient-conic rounded-full opacity-20" }), /* @__PURE__ */ y("div", { className: " w-6 h-6 outline-2 outline-neutral-500 outline-dashed rounded-full relative flex items-center justify-center" }, /* @__PURE__ */ y("span", { className: "absolute" }, /* @__PURE__ */ y(IconChevronDown16, null)))), /* @__PURE__ */ y("div", { className: "h-full grow" }, /* @__PURE__ */ y("div", { className: "h-24 grow flex flex-row" }, /* @__PURE__ */ y("div", { className: "grow flex flex-row" }), /* @__PURE__ */ y("div", { className: "h-full w-32 bg-gradient-to-r from-white via-indigo-500 via-30% to-black" }))))),
            value: "Aliases"
          }
        ];
        function handleValueChange(newValue) {
          console.log(newValue);
          setValue(newValue);
        }
        return /* @__PURE__ */ y(Tabs, { onValueChange: handleValueChange, options, value });
      };
      tabs_default = TabGroup;
    }
  });

  // node_modules/@material/material-color-utilities/utils/math_utils.js
  function signum(num) {
    if (num < 0) {
      return -1;
    } else if (num === 0) {
      return 0;
    } else {
      return 1;
    }
  }
  function lerp(start, stop, amount) {
    return (1 - amount) * start + amount * stop;
  }
  function clampInt(min3, max3, input) {
    if (input < min3) {
      return min3;
    } else if (input > max3) {
      return max3;
    }
    return input;
  }
  function clampDouble(min3, max3, input) {
    if (input < min3) {
      return min3;
    } else if (input > max3) {
      return max3;
    }
    return input;
  }
  function sanitizeDegreesInt(degrees) {
    degrees = degrees % 360;
    if (degrees < 0) {
      degrees = degrees + 360;
    }
    return degrees;
  }
  function sanitizeDegreesDouble(degrees) {
    degrees = degrees % 360;
    if (degrees < 0) {
      degrees = degrees + 360;
    }
    return degrees;
  }
  function differenceDegrees(a3, b3) {
    return 180 - Math.abs(Math.abs(a3 - b3) - 180);
  }
  function matrixMultiply(row2, matrix2) {
    const a3 = row2[0] * matrix2[0][0] + row2[1] * matrix2[0][1] + row2[2] * matrix2[0][2];
    const b3 = row2[0] * matrix2[1][0] + row2[1] * matrix2[1][1] + row2[2] * matrix2[1][2];
    const c3 = row2[0] * matrix2[2][0] + row2[1] * matrix2[2][1] + row2[2] * matrix2[2][2];
    return [a3, b3, c3];
  }
  var init_math_utils = __esm({
    "node_modules/@material/material-color-utilities/utils/math_utils.js"() {
    }
  });

  // node_modules/@material/material-color-utilities/utils/color_utils.js
  function argbFromRgb(red, green, blue) {
    return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>> 0;
  }
  function argbFromLinrgb(linrgb) {
    const r3 = delinearized(linrgb[0]);
    const g4 = delinearized(linrgb[1]);
    const b3 = delinearized(linrgb[2]);
    return argbFromRgb(r3, g4, b3);
  }
  function alphaFromArgb(argb) {
    return argb >> 24 & 255;
  }
  function redFromArgb(argb) {
    return argb >> 16 & 255;
  }
  function greenFromArgb(argb) {
    return argb >> 8 & 255;
  }
  function blueFromArgb(argb) {
    return argb & 255;
  }
  function argbFromXyz(x4, y3, z5) {
    const matrix2 = XYZ_TO_SRGB;
    const linearR = matrix2[0][0] * x4 + matrix2[0][1] * y3 + matrix2[0][2] * z5;
    const linearG = matrix2[1][0] * x4 + matrix2[1][1] * y3 + matrix2[1][2] * z5;
    const linearB = matrix2[2][0] * x4 + matrix2[2][1] * y3 + matrix2[2][2] * z5;
    const r3 = delinearized(linearR);
    const g4 = delinearized(linearG);
    const b3 = delinearized(linearB);
    return argbFromRgb(r3, g4, b3);
  }
  function xyzFromArgb(argb) {
    const r3 = linearized(redFromArgb(argb));
    const g4 = linearized(greenFromArgb(argb));
    const b3 = linearized(blueFromArgb(argb));
    return matrixMultiply([r3, g4, b3], SRGB_TO_XYZ);
  }
  function argbFromLstar(lstar) {
    const y3 = yFromLstar(lstar);
    const component = delinearized(y3);
    return argbFromRgb(component, component, component);
  }
  function lstarFromArgb(argb) {
    const y3 = xyzFromArgb(argb)[1];
    return 116 * labF(y3 / 100) - 16;
  }
  function yFromLstar(lstar) {
    return 100 * labInvf((lstar + 16) / 116);
  }
  function lstarFromY(y3) {
    return labF(y3 / 100) * 116 - 16;
  }
  function linearized(rgbComponent) {
    const normalized = rgbComponent / 255;
    if (normalized <= 0.040449936) {
      return normalized / 12.92 * 100;
    } else {
      return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100;
    }
  }
  function delinearized(rgbComponent) {
    const normalized = rgbComponent / 100;
    let delinearized2 = 0;
    if (normalized <= 31308e-7) {
      delinearized2 = normalized * 12.92;
    } else {
      delinearized2 = 1.055 * Math.pow(normalized, 1 / 2.4) - 0.055;
    }
    return clampInt(0, 255, Math.round(delinearized2 * 255));
  }
  function whitePointD65() {
    return WHITE_POINT_D65;
  }
  function rgbaFromArgb(argb) {
    const r3 = redFromArgb(argb);
    const g4 = greenFromArgb(argb);
    const b3 = blueFromArgb(argb);
    const a3 = alphaFromArgb(argb);
    return { r: r3, g: g4, b: b3, a: a3 };
  }
  function labF(t3) {
    const e6 = 216 / 24389;
    const kappa = 24389 / 27;
    if (t3 > e6) {
      return Math.pow(t3, 1 / 3);
    } else {
      return (kappa * t3 + 16) / 116;
    }
  }
  function labInvf(ft) {
    const e6 = 216 / 24389;
    const kappa = 24389 / 27;
    const ft3 = ft * ft * ft;
    if (ft3 > e6) {
      return ft3;
    } else {
      return (116 * ft - 16) / kappa;
    }
  }
  var SRGB_TO_XYZ, XYZ_TO_SRGB, WHITE_POINT_D65;
  var init_color_utils = __esm({
    "node_modules/@material/material-color-utilities/utils/color_utils.js"() {
      init_math_utils();
      SRGB_TO_XYZ = [
        [0.41233895, 0.35762064, 0.18051042],
        [0.2126, 0.7152, 0.0722],
        [0.01932141, 0.11916382, 0.95034478]
      ];
      XYZ_TO_SRGB = [
        [
          3.2413774792388685,
          -1.5376652402851851,
          -0.49885366846268053
        ],
        [
          -0.9691452513005321,
          1.8758853451067872,
          0.04156585616912061
        ],
        [
          0.05562093689691305,
          -0.20395524564742123,
          1.0571799111220335
        ]
      ];
      WHITE_POINT_D65 = [95.047, 100, 108.883];
    }
  });

  // node_modules/@material/material-color-utilities/hct/viewing_conditions.js
  var ViewingConditions;
  var init_viewing_conditions = __esm({
    "node_modules/@material/material-color-utilities/hct/viewing_conditions.js"() {
      init_color_utils();
      init_math_utils();
      ViewingConditions = class {
        /**
         * Create ViewingConditions from a simple, physically relevant, set of
         * parameters.
         *
         * @param whitePoint White point, measured in the XYZ color space.
         *     default = D65, or sunny day afternoon
         * @param adaptingLuminance The luminance of the adapting field. Informally,
         *     how bright it is in the room where the color is viewed. Can be
         *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
         *     or 200 lux.
         * @param backgroundLstar The lightness of the area surrounding the color.
         *     measured by L* in L*a*b*. default = 50.0
         * @param surround A general description of the lighting surrounding the
         *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
         *     dimly light room, like watching TV at home at night. 2.0 means there
         *     is no difference between the lighting on the color and around it.
         *     default = 2.0
         * @param discountingIlluminant Whether the eye accounts for the tint of the
         *     ambient lighting, such as knowing an apple is still red in green light.
         *     default = false, the eye does not perform this process on
         *       self-luminous objects like displays.
         */
        static make(whitePoint = whitePointD65(), adaptingLuminance = 200 / Math.PI * yFromLstar(50) / 100, backgroundLstar = 50, surround = 2, discountingIlluminant = false) {
          const xyz = whitePoint;
          const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
          const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
          const bW = xyz[0] * -2079e-6 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
          const f3 = 0.8 + surround / 10;
          const c3 = f3 >= 0.9 ? lerp(0.59, 0.69, (f3 - 0.9) * 10) : lerp(0.525, 0.59, (f3 - 0.8) * 10);
          let d3 = discountingIlluminant ? 1 : f3 * (1 - 1 / 3.6 * Math.exp((-adaptingLuminance - 42) / 92));
          d3 = d3 > 1 ? 1 : d3 < 0 ? 0 : d3;
          const nc = f3;
          const rgbD = [
            d3 * (100 / rW) + 1 - d3,
            d3 * (100 / gW) + 1 - d3,
            d3 * (100 / bW) + 1 - d3
          ];
          const k4 = 1 / (5 * adaptingLuminance + 1);
          const k42 = k4 * k4 * k4 * k4;
          const k4F = 1 - k42;
          const fl = k42 * adaptingLuminance + 0.1 * k4F * k4F * Math.cbrt(5 * adaptingLuminance);
          const n3 = yFromLstar(backgroundLstar) / whitePoint[1];
          const z5 = 1.48 + Math.sqrt(n3);
          const nbb = 0.725 / Math.pow(n3, 0.2);
          const ncb = nbb;
          const rgbAFactors = [
            Math.pow(fl * rgbD[0] * rW / 100, 0.42),
            Math.pow(fl * rgbD[1] * gW / 100, 0.42),
            Math.pow(fl * rgbD[2] * bW / 100, 0.42)
          ];
          const rgbA = [
            400 * rgbAFactors[0] / (rgbAFactors[0] + 27.13),
            400 * rgbAFactors[1] / (rgbAFactors[1] + 27.13),
            400 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)
          ];
          const aw = (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
          return new ViewingConditions(n3, aw, nbb, ncb, c3, nc, rgbD, fl, Math.pow(fl, 0.25), z5);
        }
        /**
         * Parameters are intermediate values of the CAM16 conversion process. Their
         * names are shorthand for technical color science terminology, this class
         * would not benefit from documenting them individually. A brief overview
         * is available in the CAM16 specification, and a complete overview requires
         * a color science textbook, such as Fairchild's Color Appearance Models.
         */
        constructor(n3, aw, nbb, ncb, c3, nc, rgbD, fl, fLRoot, z5) {
          this.n = n3;
          this.aw = aw;
          this.nbb = nbb;
          this.ncb = ncb;
          this.c = c3;
          this.nc = nc;
          this.rgbD = rgbD;
          this.fl = fl;
          this.fLRoot = fLRoot;
          this.z = z5;
        }
      };
      ViewingConditions.DEFAULT = ViewingConditions.make();
    }
  });

  // node_modules/@material/material-color-utilities/hct/cam16.js
  var Cam16;
  var init_cam16 = __esm({
    "node_modules/@material/material-color-utilities/hct/cam16.js"() {
      init_color_utils();
      init_math_utils();
      init_viewing_conditions();
      Cam16 = class {
        /**
         * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
         * the following combinations:
         *      -  {j or q} and {c, m, or s} and hue
         *      - jstar, astar, bstar
         * Prefer using a static method that constructs from 3 of those dimensions.
         * This constructor is intended for those methods to use to return all
         * possible dimensions.
         *
         * @param hue
         * @param chroma informally, colorfulness / color intensity. like saturation
         *     in HSL, except perceptually accurate.
         * @param j lightness
         * @param q brightness; ratio of lightness to white point's lightness
         * @param m colorfulness
         * @param s saturation; ratio of chroma to white point's chroma
         * @param jstar CAM16-UCS J coordinate
         * @param astar CAM16-UCS a coordinate
         * @param bstar CAM16-UCS b coordinate
         */
        constructor(hue, chroma, j4, q4, m3, s3, jstar, astar, bstar) {
          this.hue = hue;
          this.chroma = chroma;
          this.j = j4;
          this.q = q4;
          this.m = m3;
          this.s = s3;
          this.jstar = jstar;
          this.astar = astar;
          this.bstar = bstar;
        }
        /**
         * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
         * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
         * specification, and is used to measure distances between colors.
         */
        distance(other) {
          const dJ = this.jstar - other.jstar;
          const dA = this.astar - other.astar;
          const dB = this.bstar - other.bstar;
          const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
          const dE = 1.41 * Math.pow(dEPrime, 0.63);
          return dE;
        }
        /**
         * @param argb ARGB representation of a color.
         * @return CAM16 color, assuming the color was viewed in default viewing
         *     conditions.
         */
        static fromInt(argb) {
          return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
        }
        /**
         * @param argb ARGB representation of a color.
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         * @return CAM16 color.
         */
        static fromIntInViewingConditions(argb, viewingConditions) {
          const red = (argb & 16711680) >> 16;
          const green = (argb & 65280) >> 8;
          const blue = argb & 255;
          const redL = linearized(red);
          const greenL = linearized(green);
          const blueL = linearized(blue);
          const x4 = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
          const y3 = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
          const z5 = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
          const rC = 0.401288 * x4 + 0.650173 * y3 - 0.051461 * z5;
          const gC = -0.250268 * x4 + 1.204414 * y3 + 0.045854 * z5;
          const bC = -2079e-6 * x4 + 0.048952 * y3 + 0.953127 * z5;
          const rD = viewingConditions.rgbD[0] * rC;
          const gD = viewingConditions.rgbD[1] * gC;
          const bD = viewingConditions.rgbD[2] * bC;
          const rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100, 0.42);
          const gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100, 0.42);
          const bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100, 0.42);
          const rA = signum(rD) * 400 * rAF / (rAF + 27.13);
          const gA = signum(gD) * 400 * gAF / (gAF + 27.13);
          const bA = signum(bD) * 400 * bAF / (bAF + 27.13);
          const a3 = (11 * rA + -12 * gA + bA) / 11;
          const b3 = (rA + gA - 2 * bA) / 9;
          const u3 = (20 * rA + 20 * gA + 21 * bA) / 20;
          const p22 = (40 * rA + 20 * gA + bA) / 20;
          const atan23 = Math.atan2(b3, a3);
          const atanDegrees = atan23 * 180 / Math.PI;
          const hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees;
          const hueRadians = hue * Math.PI / 180;
          const ac = p22 * viewingConditions.nbb;
          const j4 = 100 * Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
          const q4 = 4 / viewingConditions.c * Math.sqrt(j4 / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
          const huePrime = hue < 20.14 ? hue + 360 : hue;
          const eHue = 0.25 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8);
          const p1 = 5e4 / 13 * eHue * viewingConditions.nc * viewingConditions.ncb;
          const t3 = p1 * Math.sqrt(a3 * a3 + b3 * b3) / (u3 + 0.305);
          const alpha = Math.pow(t3, 0.9) * Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
          const c3 = alpha * Math.sqrt(j4 / 100);
          const m3 = c3 * viewingConditions.fLRoot;
          const s3 = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
          const jstar = (1 + 100 * 7e-3) * j4 / (1 + 7e-3 * j4);
          const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m3);
          const astar = mstar * Math.cos(hueRadians);
          const bstar = mstar * Math.sin(hueRadians);
          return new Cam16(hue, c3, j4, q4, m3, s3, jstar, astar, bstar);
        }
        /**
         * @param j CAM16 lightness
         * @param c CAM16 chroma
         * @param h CAM16 hue
         */
        static fromJch(j4, c3, h3) {
          return Cam16.fromJchInViewingConditions(j4, c3, h3, ViewingConditions.DEFAULT);
        }
        /**
         * @param j CAM16 lightness
         * @param c CAM16 chroma
         * @param h CAM16 hue
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         */
        static fromJchInViewingConditions(j4, c3, h3, viewingConditions) {
          const q4 = 4 / viewingConditions.c * Math.sqrt(j4 / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
          const m3 = c3 * viewingConditions.fLRoot;
          const alpha = c3 / Math.sqrt(j4 / 100);
          const s3 = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
          const hueRadians = h3 * Math.PI / 180;
          const jstar = (1 + 100 * 7e-3) * j4 / (1 + 7e-3 * j4);
          const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m3);
          const astar = mstar * Math.cos(hueRadians);
          const bstar = mstar * Math.sin(hueRadians);
          return new Cam16(h3, c3, j4, q4, m3, s3, jstar, astar, bstar);
        }
        /**
         * @param jstar CAM16-UCS lightness.
         * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the Y axis.
         * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the X axis.
         */
        static fromUcs(jstar, astar, bstar) {
          return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
        }
        /**
         * @param jstar CAM16-UCS lightness.
         * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the Y axis.
         * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
         *     coordinate on the X axis.
         * @param viewingConditions Information about the environment where the color
         *     was observed.
         */
        static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
          const a3 = astar;
          const b3 = bstar;
          const m3 = Math.sqrt(a3 * a3 + b3 * b3);
          const M3 = (Math.exp(m3 * 0.0228) - 1) / 0.0228;
          const c3 = M3 / viewingConditions.fLRoot;
          let h3 = Math.atan2(b3, a3) * (180 / Math.PI);
          if (h3 < 0) {
            h3 += 360;
          }
          const j4 = jstar / (1 - (jstar - 100) * 7e-3);
          return Cam16.fromJchInViewingConditions(j4, c3, h3, viewingConditions);
        }
        /**
         *  @return ARGB representation of color, assuming the color was viewed in
         *     default viewing conditions, which are near-identical to the default
         *     viewing conditions for sRGB.
         */
        toInt() {
          return this.viewed(ViewingConditions.DEFAULT);
        }
        /**
         * @param viewingConditions Information about the environment where the color
         *     will be viewed.
         * @return ARGB representation of color
         */
        viewed(viewingConditions) {
          const alpha = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100);
          const t3 = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1 / 0.9);
          const hRad = this.hue * Math.PI / 180;
          const eHue = 0.25 * (Math.cos(hRad + 2) + 3.8);
          const ac = viewingConditions.aw * Math.pow(this.j / 100, 1 / viewingConditions.c / viewingConditions.z);
          const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
          const p22 = ac / viewingConditions.nbb;
          const hSin = Math.sin(hRad);
          const hCos = Math.cos(hRad);
          const gamma2 = 23 * (p22 + 0.305) * t3 / (23 * p1 + 11 * t3 * hCos + 108 * t3 * hSin);
          const a3 = gamma2 * hCos;
          const b3 = gamma2 * hSin;
          const rA = (460 * p22 + 451 * a3 + 288 * b3) / 1403;
          const gA = (460 * p22 - 891 * a3 - 261 * b3) / 1403;
          const bA = (460 * p22 - 220 * a3 - 6300 * b3) / 1403;
          const rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA)));
          const rC = signum(rA) * (100 / viewingConditions.fl) * Math.pow(rCBase, 1 / 0.42);
          const gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA)));
          const gC = signum(gA) * (100 / viewingConditions.fl) * Math.pow(gCBase, 1 / 0.42);
          const bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA)));
          const bC = signum(bA) * (100 / viewingConditions.fl) * Math.pow(bCBase, 1 / 0.42);
          const rF = rC / viewingConditions.rgbD[0];
          const gF = gC / viewingConditions.rgbD[1];
          const bF = bC / viewingConditions.rgbD[2];
          const x4 = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
          const y3 = 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF;
          const z5 = -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF;
          const argb = argbFromXyz(x4, y3, z5);
          return argb;
        }
        /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
        /// CAM16.
        static fromXyzInViewingConditions(x4, y3, z5, viewingConditions) {
          const rC = 0.401288 * x4 + 0.650173 * y3 - 0.051461 * z5;
          const gC = -0.250268 * x4 + 1.204414 * y3 + 0.045854 * z5;
          const bC = -2079e-6 * x4 + 0.048952 * y3 + 0.953127 * z5;
          const rD = viewingConditions.rgbD[0] * rC;
          const gD = viewingConditions.rgbD[1] * gC;
          const bD = viewingConditions.rgbD[2] * bC;
          const rAF = Math.pow(viewingConditions.fl * Math.abs(rD) / 100, 0.42);
          const gAF = Math.pow(viewingConditions.fl * Math.abs(gD) / 100, 0.42);
          const bAF = Math.pow(viewingConditions.fl * Math.abs(bD) / 100, 0.42);
          const rA = signum(rD) * 400 * rAF / (rAF + 27.13);
          const gA = signum(gD) * 400 * gAF / (gAF + 27.13);
          const bA = signum(bD) * 400 * bAF / (bAF + 27.13);
          const a3 = (11 * rA + -12 * gA + bA) / 11;
          const b3 = (rA + gA - 2 * bA) / 9;
          const u3 = (20 * rA + 20 * gA + 21 * bA) / 20;
          const p22 = (40 * rA + 20 * gA + bA) / 20;
          const atan23 = Math.atan2(b3, a3);
          const atanDegrees = atan23 * 180 / Math.PI;
          const hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees;
          const hueRadians = hue * Math.PI / 180;
          const ac = p22 * viewingConditions.nbb;
          const J2 = 100 * Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
          const Q3 = 4 / viewingConditions.c * Math.sqrt(J2 / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
          const huePrime = hue < 20.14 ? hue + 360 : hue;
          const eHue = 1 / 4 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8);
          const p1 = 5e4 / 13 * eHue * viewingConditions.nc * viewingConditions.ncb;
          const t3 = p1 * Math.sqrt(a3 * a3 + b3 * b3) / (u3 + 0.305);
          const alpha = Math.pow(t3, 0.9) * Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
          const C3 = alpha * Math.sqrt(J2 / 100);
          const M3 = C3 * viewingConditions.fLRoot;
          const s3 = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
          const jstar = (1 + 100 * 7e-3) * J2 / (1 + 7e-3 * J2);
          const mstar = Math.log(1 + 0.0228 * M3) / 0.0228;
          const astar = mstar * Math.cos(hueRadians);
          const bstar = mstar * Math.sin(hueRadians);
          return new Cam16(hue, C3, J2, Q3, M3, s3, jstar, astar, bstar);
        }
        /// XYZ representation of CAM16 seen in [viewingConditions].
        xyzInViewingConditions(viewingConditions) {
          const alpha = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100);
          const t3 = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1 / 0.9);
          const hRad = this.hue * Math.PI / 180;
          const eHue = 0.25 * (Math.cos(hRad + 2) + 3.8);
          const ac = viewingConditions.aw * Math.pow(this.j / 100, 1 / viewingConditions.c / viewingConditions.z);
          const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
          const p22 = ac / viewingConditions.nbb;
          const hSin = Math.sin(hRad);
          const hCos = Math.cos(hRad);
          const gamma2 = 23 * (p22 + 0.305) * t3 / (23 * p1 + 11 * t3 * hCos + 108 * t3 * hSin);
          const a3 = gamma2 * hCos;
          const b3 = gamma2 * hSin;
          const rA = (460 * p22 + 451 * a3 + 288 * b3) / 1403;
          const gA = (460 * p22 - 891 * a3 - 261 * b3) / 1403;
          const bA = (460 * p22 - 220 * a3 - 6300 * b3) / 1403;
          const rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA)));
          const rC = signum(rA) * (100 / viewingConditions.fl) * Math.pow(rCBase, 1 / 0.42);
          const gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA)));
          const gC = signum(gA) * (100 / viewingConditions.fl) * Math.pow(gCBase, 1 / 0.42);
          const bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA)));
          const bC = signum(bA) * (100 / viewingConditions.fl) * Math.pow(bCBase, 1 / 0.42);
          const rF = rC / viewingConditions.rgbD[0];
          const gF = gC / viewingConditions.rgbD[1];
          const bF = bC / viewingConditions.rgbD[2];
          const x4 = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
          const y3 = 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF;
          const z5 = -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF;
          return [x4, y3, z5];
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/hct/hct_solver.js
  var HctSolver;
  var init_hct_solver = __esm({
    "node_modules/@material/material-color-utilities/hct/hct_solver.js"() {
      init_color_utils();
      init_math_utils();
      init_cam16();
      init_viewing_conditions();
      HctSolver = class {
        /**
         * Sanitizes a small enough angle in radians.
         *
         * @param angle An angle in radians; must not deviate too much
         * from 0.
         * @return A coterminal angle between 0 and 2pi.
         */
        static sanitizeRadians(angle) {
          return (angle + Math.PI * 8) % (Math.PI * 2);
        }
        /**
         * Delinearizes an RGB component, returning a floating-point
         * number.
         *
         * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
         * linear R/G/B channel
         * @return 0.0 <= output <= 255.0, color channel converted to
         * regular RGB space
         */
        static trueDelinearized(rgbComponent) {
          const normalized = rgbComponent / 100;
          let delinearized2 = 0;
          if (normalized <= 31308e-7) {
            delinearized2 = normalized * 12.92;
          } else {
            delinearized2 = 1.055 * Math.pow(normalized, 1 / 2.4) - 0.055;
          }
          return delinearized2 * 255;
        }
        static chromaticAdaptation(component) {
          const af = Math.pow(Math.abs(component), 0.42);
          return signum(component) * 400 * af / (af + 27.13);
        }
        /**
         * Returns the hue of a linear RGB color in CAM16.
         *
         * @param linrgb The linear RGB coordinates of a color.
         * @return The hue of the color in CAM16, in radians.
         */
        static hueOf(linrgb) {
          const scaledDiscount = matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB);
          const rA = HctSolver.chromaticAdaptation(scaledDiscount[0]);
          const gA = HctSolver.chromaticAdaptation(scaledDiscount[1]);
          const bA = HctSolver.chromaticAdaptation(scaledDiscount[2]);
          const a3 = (11 * rA + -12 * gA + bA) / 11;
          const b3 = (rA + gA - 2 * bA) / 9;
          return Math.atan2(b3, a3);
        }
        static areInCyclicOrder(a3, b3, c3) {
          const deltaAB = HctSolver.sanitizeRadians(b3 - a3);
          const deltaAC = HctSolver.sanitizeRadians(c3 - a3);
          return deltaAB < deltaAC;
        }
        /**
         * Solves the lerp equation.
         *
         * @param source The starting number.
         * @param mid The number in the middle.
         * @param target The ending number.
         * @return A number t such that lerp(source, target, t) = mid.
         */
        static intercept(source, mid, target) {
          return (mid - source) / (target - source);
        }
        static lerpPoint(source, t3, target) {
          return [
            source[0] + (target[0] - source[0]) * t3,
            source[1] + (target[1] - source[1]) * t3,
            source[2] + (target[2] - source[2]) * t3
          ];
        }
        /**
         * Intersects a segment with a plane.
         *
         * @param source The coordinates of point A.
         * @param coordinate The R-, G-, or B-coordinate of the plane.
         * @param target The coordinates of point B.
         * @param axis The axis the plane is perpendicular with. (0: R, 1:
         * G, 2: B)
         * @return The intersection point of the segment AB with the plane
         * R=coordinate, G=coordinate, or B=coordinate
         */
        static setCoordinate(source, coordinate, target, axis) {
          const t3 = HctSolver.intercept(source[axis], coordinate, target[axis]);
          return HctSolver.lerpPoint(source, t3, target);
        }
        static isBounded(x4) {
          return 0 <= x4 && x4 <= 100;
        }
        /**
         * Returns the nth possible vertex of the polygonal intersection.
         *
         * @param y The Y value of the plane.
         * @param n The zero-based index of the point. 0 <= n <= 11.
         * @return The nth possible vertex of the polygonal intersection
         * of the y plane and the RGB cube, in linear RGB coordinates, if
         * it exists. If this possible vertex lies outside of the cube,
         * [-1.0, -1.0, -1.0] is returned.
         */
        static nthVertex(y3, n3) {
          const kR = HctSolver.Y_FROM_LINRGB[0];
          const kG = HctSolver.Y_FROM_LINRGB[1];
          const kB = HctSolver.Y_FROM_LINRGB[2];
          const coordA = n3 % 4 <= 1 ? 0 : 100;
          const coordB = n3 % 2 === 0 ? 0 : 100;
          if (n3 < 4) {
            const g4 = coordA;
            const b3 = coordB;
            const r3 = (y3 - g4 * kG - b3 * kB) / kR;
            if (HctSolver.isBounded(r3)) {
              return [r3, g4, b3];
            } else {
              return [-1, -1, -1];
            }
          } else if (n3 < 8) {
            const b3 = coordA;
            const r3 = coordB;
            const g4 = (y3 - r3 * kR - b3 * kB) / kG;
            if (HctSolver.isBounded(g4)) {
              return [r3, g4, b3];
            } else {
              return [-1, -1, -1];
            }
          } else {
            const r3 = coordA;
            const g4 = coordB;
            const b3 = (y3 - r3 * kR - g4 * kG) / kB;
            if (HctSolver.isBounded(b3)) {
              return [r3, g4, b3];
            } else {
              return [-1, -1, -1];
            }
          }
        }
        /**
         * Finds the segment containing the desired color.
         *
         * @param y The Y value of the color.
         * @param targetHue The hue of the color.
         * @return A list of two sets of linear RGB coordinates, each
         * corresponding to an endpoint of the segment containing the
         * desired color.
         */
        static bisectToSegment(y3, targetHue) {
          let left = [-1, -1, -1];
          let right = left;
          let leftHue = 0;
          let rightHue = 0;
          let initialized = false;
          let uncut = true;
          for (let n3 = 0; n3 < 12; n3++) {
            const mid = HctSolver.nthVertex(y3, n3);
            if (mid[0] < 0) {
              continue;
            }
            const midHue = HctSolver.hueOf(mid);
            if (!initialized) {
              left = mid;
              right = mid;
              leftHue = midHue;
              rightHue = midHue;
              initialized = true;
              continue;
            }
            if (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) {
              uncut = false;
              if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                right = mid;
                rightHue = midHue;
              } else {
                left = mid;
                leftHue = midHue;
              }
            }
          }
          return [left, right];
        }
        static midpoint(a3, b3) {
          return [
            (a3[0] + b3[0]) / 2,
            (a3[1] + b3[1]) / 2,
            (a3[2] + b3[2]) / 2
          ];
        }
        static criticalPlaneBelow(x4) {
          return Math.floor(x4 - 0.5);
        }
        static criticalPlaneAbove(x4) {
          return Math.ceil(x4 - 0.5);
        }
        /**
         * Finds a color with the given Y and hue on the boundary of the
         * cube.
         *
         * @param y The Y value of the color.
         * @param targetHue The hue of the color.
         * @return The desired color, in linear RGB coordinates.
         */
        static bisectToLimit(y3, targetHue) {
          const segment = HctSolver.bisectToSegment(y3, targetHue);
          let left = segment[0];
          let leftHue = HctSolver.hueOf(left);
          let right = segment[1];
          for (let axis = 0; axis < 3; axis++) {
            if (left[axis] !== right[axis]) {
              let lPlane = -1;
              let rPlane = 255;
              if (left[axis] < right[axis]) {
                lPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(left[axis]));
                rPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(right[axis]));
              } else {
                lPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(left[axis]));
                rPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(right[axis]));
              }
              for (let i5 = 0; i5 < 8; i5++) {
                if (Math.abs(rPlane - lPlane) <= 1) {
                  break;
                } else {
                  const mPlane = Math.floor((lPlane + rPlane) / 2);
                  const midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane];
                  const mid = HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis);
                  const midHue = HctSolver.hueOf(mid);
                  if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                    right = mid;
                    rPlane = mPlane;
                  } else {
                    left = mid;
                    leftHue = midHue;
                    lPlane = mPlane;
                  }
                }
              }
            }
          }
          return HctSolver.midpoint(left, right);
        }
        static inverseChromaticAdaptation(adapted) {
          const adaptedAbs = Math.abs(adapted);
          const base = Math.max(0, 27.13 * adaptedAbs / (400 - adaptedAbs));
          return signum(adapted) * Math.pow(base, 1 / 0.42);
        }
        /**
         * Finds a color with the given hue, chroma, and Y.
         *
         * @param hueRadians The desired hue in radians.
         * @param chroma The desired chroma.
         * @param y The desired Y.
         * @return The desired color as a hexadecimal integer, if found; 0
         * otherwise.
         */
        static findResultByJ(hueRadians, chroma, y3) {
          let j4 = Math.sqrt(y3) * 11;
          const viewingConditions = ViewingConditions.DEFAULT;
          const tInnerCoeff = 1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
          const eHue = 0.25 * (Math.cos(hueRadians + 2) + 3.8);
          const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
          const hSin = Math.sin(hueRadians);
          const hCos = Math.cos(hueRadians);
          for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
            const jNormalized = j4 / 100;
            const alpha = chroma === 0 || j4 === 0 ? 0 : chroma / Math.sqrt(jNormalized);
            const t3 = Math.pow(alpha * tInnerCoeff, 1 / 0.9);
            const ac = viewingConditions.aw * Math.pow(jNormalized, 1 / viewingConditions.c / viewingConditions.z);
            const p22 = ac / viewingConditions.nbb;
            const gamma2 = 23 * (p22 + 0.305) * t3 / (23 * p1 + 11 * t3 * hCos + 108 * t3 * hSin);
            const a3 = gamma2 * hCos;
            const b3 = gamma2 * hSin;
            const rA = (460 * p22 + 451 * a3 + 288 * b3) / 1403;
            const gA = (460 * p22 - 891 * a3 - 261 * b3) / 1403;
            const bA = (460 * p22 - 220 * a3 - 6300 * b3) / 1403;
            const rCScaled = HctSolver.inverseChromaticAdaptation(rA);
            const gCScaled = HctSolver.inverseChromaticAdaptation(gA);
            const bCScaled = HctSolver.inverseChromaticAdaptation(bA);
            const linrgb = matrixMultiply([rCScaled, gCScaled, bCScaled], HctSolver.LINRGB_FROM_SCALED_DISCOUNT);
            if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
              return 0;
            }
            const kR = HctSolver.Y_FROM_LINRGB[0];
            const kG = HctSolver.Y_FROM_LINRGB[1];
            const kB = HctSolver.Y_FROM_LINRGB[2];
            const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
            if (fnj <= 0) {
              return 0;
            }
            if (iterationRound === 4 || Math.abs(fnj - y3) < 2e-3) {
              if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
                return 0;
              }
              return argbFromLinrgb(linrgb);
            }
            j4 = j4 - (fnj - y3) * j4 / (2 * fnj);
          }
          return 0;
        }
        /**
         * Finds an sRGB color with the given hue, chroma, and L*, if
         * possible.
         *
         * @param hueDegrees The desired hue, in degrees.
         * @param chroma The desired chroma.
         * @param lstar The desired L*.
         * @return A hexadecimal representing the sRGB color. The color
         * has sufficiently close hue, chroma, and L* to the desired
         * values, if possible; otherwise, the hue and L* will be
         * sufficiently close, and chroma will be maximized.
         */
        static solveToInt(hueDegrees, chroma, lstar) {
          if (chroma < 1e-4 || lstar < 1e-4 || lstar > 99.9999) {
            return argbFromLstar(lstar);
          }
          hueDegrees = sanitizeDegreesDouble(hueDegrees);
          const hueRadians = hueDegrees / 180 * Math.PI;
          const y3 = yFromLstar(lstar);
          const exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y3);
          if (exactAnswer !== 0) {
            return exactAnswer;
          }
          const linrgb = HctSolver.bisectToLimit(y3, hueRadians);
          return argbFromLinrgb(linrgb);
        }
        /**
         * Finds an sRGB color with the given hue, chroma, and L*, if
         * possible.
         *
         * @param hueDegrees The desired hue, in degrees.
         * @param chroma The desired chroma.
         * @param lstar The desired L*.
         * @return An CAM16 object representing the sRGB color. The color
         * has sufficiently close hue, chroma, and L* to the desired
         * values, if possible; otherwise, the hue and L* will be
         * sufficiently close, and chroma will be maximized.
         */
        static solveToCam(hueDegrees, chroma, lstar) {
          return Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
        }
      };
      HctSolver.SCALED_DISCOUNT_FROM_LINRGB = [
        [
          0.001200833568784504,
          0.002389694492170889,
          2795742885861124e-19
        ],
        [
          5891086651375999e-19,
          0.0029785502573438758,
          3270666104008398e-19
        ],
        [
          10146692491640572e-20,
          5364214359186694e-19,
          0.0032979401770712076
        ]
      ];
      HctSolver.LINRGB_FROM_SCALED_DISCOUNT = [
        [
          1373.2198709594231,
          -1100.4251190754821,
          -7.278681089101213
        ],
        [
          -271.815969077903,
          559.6580465940733,
          -32.46047482791194
        ],
        [
          1.9622899599665666,
          -57.173814538844006,
          308.7233197812385
        ]
      ];
      HctSolver.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
      HctSolver.CRITICAL_PLANES = [
        0.015176349177441876,
        0.045529047532325624,
        0.07588174588720938,
        0.10623444424209313,
        0.13658714259697685,
        0.16693984095186062,
        0.19729253930674434,
        0.2276452376616281,
        0.2579979360165119,
        0.28835063437139563,
        0.3188300904430532,
        0.350925934958123,
        0.3848314933096426,
        0.42057480301049466,
        0.458183274052838,
        0.4976837250274023,
        0.5391024159806381,
        0.5824650784040898,
        0.6277969426914107,
        0.6751227633498623,
        0.7244668422128921,
        0.775853049866786,
        0.829304845476233,
        0.8848452951698498,
        0.942497089126609,
        1.0022825574869039,
        1.0642236851973577,
        1.1283421258858297,
        1.1946592148522128,
        1.2631959812511864,
        1.3339731595349034,
        1.407011200216447,
        1.4823302800086415,
        1.5599503113873272,
        1.6398909516233677,
        1.7221716113234105,
        1.8068114625156377,
        1.8938294463134073,
        1.9832442801866852,
        2.075074464868551,
        2.1693382909216234,
        2.2660538449872063,
        2.36523901573795,
        2.4669114995532007,
        2.5710888059345764,
        2.6777882626779785,
        2.7870270208169257,
        2.898822059350997,
        3.0131901897720907,
        3.1301480604002863,
        3.2497121605402226,
        3.3718988244681087,
        3.4967242352587946,
        3.624204428461639,
        3.754355295633311,
        3.887192587735158,
        4.022731918402185,
        4.160988767090289,
        4.301978482107941,
        4.445716283538092,
        4.592217266055746,
        4.741496401646282,
        4.893568542229298,
        5.048448422192488,
        5.20615066083972,
        5.3666897647573375,
        5.5300801301023865,
        5.696336044816294,
        5.865471690767354,
        6.037501145825082,
        6.212438385869475,
        6.390297286737924,
        6.571091626112461,
        6.7548350853498045,
        6.941541251256611,
        7.131223617812143,
        7.323895587840543,
        7.5195704746346665,
        7.7182615035334345,
        7.919981813454504,
        8.124744458384042,
        8.332562408825165,
        8.543448553206703,
        8.757415699253682,
        8.974476575321063,
        9.194643831691977,
        9.417930041841839,
        9.644347703669503,
        9.873909240696694,
        10.106627003236781,
        10.342513269534024,
        10.58158024687427,
        10.8238400726681,
        11.069304815507364,
        11.317986476196008,
        11.569896988756009,
        11.825048221409341,
        12.083451977536606,
        12.345119996613247,
        12.610063955123938,
        12.878295467455942,
        13.149826086772048,
        13.42466730586372,
        13.702830557985108,
        13.984327217668513,
        14.269168601521828,
        14.55736596900856,
        14.848930523210871,
        15.143873411576273,
        15.44220572664832,
        15.743938506781891,
        16.04908273684337,
        16.35764934889634,
        16.66964922287304,
        16.985093187232053,
        17.30399201960269,
        17.62635644741625,
        17.95219714852476,
        18.281524751807332,
        18.614349837764564,
        18.95068293910138,
        19.290534541298456,
        19.633915083172692,
        19.98083495742689,
        20.331304511189067,
        20.685334046541502,
        21.042933821039977,
        21.404114048223256,
        21.76888489811322,
        22.137256497705877,
        22.50923893145328,
        22.884842241736916,
        23.264076429332462,
        23.6469514538663,
        24.033477234264016,
        24.42366364919083,
        24.817520537484558,
        25.21505769858089,
        25.61628489293138,
        26.021211842414342,
        26.429848230738664,
        26.842203703840827,
        27.258287870275353,
        27.678110301598522,
        28.10168053274597,
        28.529008062403893,
        28.96010235337422,
        29.39497283293396,
        29.83362889318845,
        30.276079891419332,
        30.722335150426627,
        31.172403958865512,
        31.62629557157785,
        32.08401920991837,
        32.54558406207592,
        33.010999283389665,
        33.4802739966603,
        33.953417292456834,
        34.430438229418264,
        34.911345834551085,
        35.39614910352207,
        35.88485700094671,
        36.37747846067349,
        36.87402238606382,
        37.37449765026789,
        37.87891309649659,
        38.38727753828926,
        38.89959975977785,
        39.41588851594697,
        39.93615253289054,
        40.460400508064545,
        40.98864111053629,
        41.520882981230194,
        42.05713473317016,
        42.597404951718396,
        43.141702194811224,
        43.6900349931913,
        44.24241185063697,
        44.798841244188324,
        45.35933162437017,
        45.92389141541209,
        46.49252901546552,
        47.065252796817916,
        47.64207110610409,
        48.22299226451468,
        48.808024568002054,
        49.3971762874833,
        49.9904556690408,
        50.587870934119984,
        51.189430279724725,
        51.79514187861014,
        52.40501387947288,
        53.0190544071392,
        53.637271562750364,
        54.259673423945976,
        54.88626804504493,
        55.517063457223934,
        56.15206766869424,
        56.79128866487574,
        57.43473440856916,
        58.08241284012621,
        58.734331877617365,
        59.39049941699807,
        60.05092333227251,
        60.715611475655585,
        61.38457167773311,
        62.057811747619894,
        62.7353394731159,
        63.417162620860914,
        64.10328893648692,
        64.79372614476921,
        65.48848194977529,
        66.18756403501224,
        66.89098006357258,
        67.59873767827808,
        68.31084450182222,
        69.02730813691093,
        69.74813616640164,
        70.47333615344107,
        71.20291564160104,
        71.93688215501312,
        72.67524319850172,
        73.41800625771542,
        74.16517879925733,
        74.9167682708136,
        75.67278210128072,
        76.43322770089146,
        77.1981124613393,
        77.96744375590167,
        78.74122893956174,
        79.51947534912904,
        80.30219030335869,
        81.08938110306934,
        81.88105503125999,
        82.67721935322541,
        83.4778813166706,
        84.28304815182372,
        85.09272707154808,
        85.90692527145302,
        86.72564993000343,
        87.54890820862819,
        88.3767072518277,
        89.2090541872801,
        90.04595612594655,
        90.88742016217518,
        91.73345337380438,
        92.58406282226491,
        93.43925555268066,
        94.29903859396902,
        95.16341895893969,
        96.03240364439274,
        96.9059996312159,
        97.78421388448044,
        98.6670533535366,
        99.55452497210776
      ];
    }
  });

  // node_modules/@material/material-color-utilities/hct/hct.js
  var Hct;
  var init_hct = __esm({
    "node_modules/@material/material-color-utilities/hct/hct.js"() {
      init_color_utils();
      init_cam16();
      init_hct_solver();
      init_viewing_conditions();
      Hct = class {
        static from(hue, chroma, tone) {
          return new Hct(HctSolver.solveToInt(hue, chroma, tone));
        }
        /**
         * @param argb ARGB representation of a color.
         * @return HCT representation of a color in default viewing conditions
         */
        static fromInt(argb) {
          return new Hct(argb);
        }
        toInt() {
          return this.argb;
        }
        /**
         * A number, in degrees, representing ex. red, orange, yellow, etc.
         * Ranges from 0 <= hue < 360.
         */
        get hue() {
          return this.internalHue;
        }
        /**
         * @param newHue 0 <= newHue < 360; invalid values are corrected.
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set hue(newHue) {
          this.setInternalState(HctSolver.solveToInt(newHue, this.internalChroma, this.internalTone));
        }
        get chroma() {
          return this.internalChroma;
        }
        /**
         * @param newChroma 0 <= newChroma < ?
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set chroma(newChroma) {
          this.setInternalState(HctSolver.solveToInt(this.internalHue, newChroma, this.internalTone));
        }
        /** Lightness. Ranges from 0 to 100. */
        get tone() {
          return this.internalTone;
        }
        /**
         * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
         * Chroma may decrease because chroma has a different maximum for any given
         * hue and tone.
         */
        set tone(newTone) {
          this.setInternalState(HctSolver.solveToInt(this.internalHue, this.internalChroma, newTone));
        }
        constructor(argb) {
          this.argb = argb;
          const cam = Cam16.fromInt(argb);
          this.internalHue = cam.hue;
          this.internalChroma = cam.chroma;
          this.internalTone = lstarFromArgb(argb);
          this.argb = argb;
        }
        setInternalState(argb) {
          const cam = Cam16.fromInt(argb);
          this.internalHue = cam.hue;
          this.internalChroma = cam.chroma;
          this.internalTone = lstarFromArgb(argb);
          this.argb = argb;
        }
        /**
         * Translates a color into different [ViewingConditions].
         *
         * Colors change appearance. They look different with lights on versus off,
         * the same color, as in hex code, on white looks different when on black.
         * This is called color relativity, most famously explicated by Josef Albers
         * in Interaction of Color.
         *
         * In color science, color appearance models can account for this and
         * calculate the appearance of a color in different settings. HCT is based on
         * CAM16, a color appearance model, and uses it to make these calculations.
         *
         * See [ViewingConditions.make] for parameters affecting color appearance.
         */
        inViewingConditions(vc) {
          const cam = Cam16.fromInt(this.toInt());
          const viewedInVc = cam.xyzInViewingConditions(vc);
          const recastInVc = Cam16.fromXyzInViewingConditions(viewedInVc[0], viewedInVc[1], viewedInVc[2], ViewingConditions.make());
          const recastHct = Hct.from(recastInVc.hue, recastInVc.chroma, lstarFromY(viewedInVc[1]));
          return recastHct;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/blend/blend.js
  var init_blend = __esm({
    "node_modules/@material/material-color-utilities/blend/blend.js"() {
      init_cam16();
      init_hct();
      init_color_utils();
      init_math_utils();
    }
  });

  // node_modules/@material/material-color-utilities/contrast/contrast.js
  var Contrast;
  var init_contrast = __esm({
    "node_modules/@material/material-color-utilities/contrast/contrast.js"() {
      init_color_utils();
      init_math_utils();
      Contrast = class {
        /**
         * Returns a contrast ratio, which ranges from 1 to 21.
         *
         * @param toneA Tone between 0 and 100. Values outside will be clamped.
         * @param toneB Tone between 0 and 100. Values outside will be clamped.
         */
        static ratioOfTones(toneA, toneB) {
          toneA = clampDouble(0, 100, toneA);
          toneB = clampDouble(0, 100, toneB);
          return Contrast.ratioOfYs(yFromLstar(toneA), yFromLstar(toneB));
        }
        static ratioOfYs(y1, y22) {
          const lighter = y1 > y22 ? y1 : y22;
          const darker = lighter === y22 ? y1 : y22;
          return (lighter + 5) / (darker + 5);
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns -1 if ratio cannot be achieved with tone parameter.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in -1 being returned.
         * @param ratio Contrast ratio of return value and tone.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static lighter(tone, ratio) {
          if (tone < 0 || tone > 100) {
            return -1;
          }
          const darkY = yFromLstar(tone);
          const lightY = ratio * (darkY + 5) - 5;
          const realContrast = Contrast.ratioOfYs(lightY, darkY);
          const delta = Math.abs(realContrast - ratio);
          if (realContrast < ratio && delta > 0.04) {
            return -1;
          }
          const returnValue = lstarFromY(lightY) + 0.4;
          if (returnValue < 0 || returnValue > 100) {
            return -1;
          }
          return returnValue;
        }
        /**
         * Returns a tone <= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns -1 if ratio cannot be achieved with tone parameter.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in -1 being returned.
         * @param ratio Contrast ratio of return value and tone.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static darker(tone, ratio) {
          if (tone < 0 || tone > 100) {
            return -1;
          }
          const lightY = yFromLstar(tone);
          const darkY = (lightY + 5) / ratio - 5;
          const realContrast = Contrast.ratioOfYs(lightY, darkY);
          const delta = Math.abs(realContrast - ratio);
          if (realContrast < ratio && delta > 0.04) {
            return -1;
          }
          const returnValue = lstarFromY(darkY) - 0.4;
          if (returnValue < 0 || returnValue > 100) {
            return -1;
          }
          return returnValue;
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns 100 if ratio cannot be achieved with tone parameter.
         *
         * This method is unsafe because the returned value is guaranteed to be in
         * bounds for tone, i.e. between 0 and 100. However, that value may not reach
         * the ratio with tone. For example, there is no color lighter than T100.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in 100 being returned.
         * @param ratio Desired contrast ratio of return value and tone parameter.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static lighterUnsafe(tone, ratio) {
          const lighterSafe = Contrast.lighter(tone, ratio);
          return lighterSafe < 0 ? 100 : lighterSafe;
        }
        /**
         * Returns a tone >= tone parameter that ensures ratio parameter.
         * Return value is between 0 and 100.
         * Returns 100 if ratio cannot be achieved with tone parameter.
         *
         * This method is unsafe because the returned value is guaranteed to be in
         * bounds for tone, i.e. between 0 and 100. However, that value may not reach
         * the [ratio with [tone]. For example, there is no color darker than T0.
         *
         * @param tone Tone return value must contrast with.
         * Range is 0 to 100. Invalid values will result in 0 being returned.
         * @param ratio Desired contrast ratio of return value and tone parameter.
         * Range is 1 to 21, invalid values have undefined behavior.
         */
        static darkerUnsafe(tone, ratio) {
          const darkerSafe = Contrast.darker(tone, ratio);
          return darkerSafe < 0 ? 0 : darkerSafe;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/dislike/dislike_analyzer.js
  var DislikeAnalyzer;
  var init_dislike_analyzer = __esm({
    "node_modules/@material/material-color-utilities/dislike/dislike_analyzer.js"() {
      init_hct();
      DislikeAnalyzer = class {
        /**
         * Returns true if a color is disliked.
         *
         * @param hct A color to be judged.
         * @return Whether the color is disliked.
         *
         * Disliked is defined as a dark yellow-green that is not neutral.
         */
        static isDisliked(hct) {
          const huePasses = Math.round(hct.hue) >= 90 && Math.round(hct.hue) <= 111;
          const chromaPasses = Math.round(hct.chroma) > 16;
          const tonePasses = Math.round(hct.tone) < 65;
          return huePasses && chromaPasses && tonePasses;
        }
        /**
         * If a color is disliked, lighten it to make it likable.
         *
         * @param hct A color to be judged.
         * @return A new color if the original color is disliked, or the original
         *   color if it is acceptable.
         */
        static fixIfDisliked(hct) {
          if (DislikeAnalyzer.isDisliked(hct)) {
            return Hct.from(hct.hue, hct.chroma, 70);
          }
          return hct;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/dynamiccolor/dynamic_color.js
  var DynamicColor;
  var init_dynamic_color = __esm({
    "node_modules/@material/material-color-utilities/dynamiccolor/dynamic_color.js"() {
      init_contrast();
      init_math_utils();
      DynamicColor = class {
        /**
         * Create a DynamicColor defined by a TonalPalette and HCT tone.
         *
         * @param args Functions with DynamicScheme as input. Must provide a palette
         * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
         */
        static fromPalette(args) {
          var _a, _b;
          return new DynamicColor((_a = args.name) != null ? _a : "", args.palette, args.tone, (_b = args.isBackground) != null ? _b : false, args.background, args.secondBackground, args.contrastCurve, args.toneDeltaPair);
        }
        /**
         * The base constructor for DynamicColor.
         *
         * _Strongly_ prefer using one of the convenience constructors. This class is
         * arguably too flexible to ensure it can support any scenario. Functional
         * arguments allow  overriding without risks that come with subclasses.
         *
         * For example, the default behavior of adjust tone at max contrast
         * to be at a 7.0 ratio with its background is principled and
         * matches accessibility guidance. That does not mean it's the desired
         * approach for _every_ design system, and every color pairing,
         * always, in every case.
         *
         * @param name The name of the dynamic color. Defaults to empty.
         * @param palette Function that provides a TonalPalette given
         * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
         * replaces the need to specify hue/chroma. By providing a tonal palette, when
         * contrast adjustments are made, intended chroma can be preserved.
         * @param tone Function that provides a tone, given a DynamicScheme.
         * @param isBackground Whether this dynamic color is a background, with
         * some other color as the foreground. Defaults to false.
         * @param background The background of the dynamic color (as a function of a
         *     `DynamicScheme`), if it exists.
         * @param secondBackground A second background of the dynamic color (as a
         *     function of a `DynamicScheme`), if it
         * exists.
         * @param contrastCurve A `ContrastCurve` object specifying how its contrast
         * against its background should behave in various contrast levels options.
         * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
         * constraint between two colors. One of them must be the color being
         * constructed.
         */
        constructor(name307, palette, tone, isBackground, background, secondBackground, contrastCurve, toneDeltaPair) {
          this.name = name307;
          this.palette = palette;
          this.tone = tone;
          this.isBackground = isBackground;
          this.background = background;
          this.secondBackground = secondBackground;
          this.contrastCurve = contrastCurve;
          this.toneDeltaPair = toneDeltaPair;
          this.hctCache = /* @__PURE__ */ new Map();
          if (!background && secondBackground) {
            throw new Error(`Color ${name307} has secondBackgrounddefined, but background is not defined.`);
          }
          if (!background && contrastCurve) {
            throw new Error(`Color ${name307} has contrastCurvedefined, but background is not defined.`);
          }
          if (background && !contrastCurve) {
            throw new Error(`Color ${name307} has backgrounddefined, but contrastCurve is not defined.`);
          }
        }
        /**
         * Return a ARGB integer (i.e. a hex code).
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getArgb(scheme) {
          return this.getHct(scheme).toInt();
        }
        /**
         * Return a color, expressed in the HCT color space, that this
         * DynamicColor is under the conditions in scheme.
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getHct(scheme) {
          const cachedAnswer = this.hctCache.get(scheme);
          if (cachedAnswer != null) {
            return cachedAnswer;
          }
          const tone = this.getTone(scheme);
          const answer = this.palette(scheme).getHct(tone);
          if (this.hctCache.size > 4) {
            this.hctCache.clear();
          }
          this.hctCache.set(scheme, answer);
          return answer;
        }
        /**
         * Return a tone, T in the HCT color space, that this DynamicColor is under
         * the conditions in scheme.
         *
         * @param scheme Defines the conditions of the user interface, for example,
         * whether or not it is dark mode or light mode, and what the desired
         * contrast level is.
         */
        getTone(scheme) {
          const decreasingContrast = scheme.contrastLevel < 0;
          if (this.toneDeltaPair) {
            const toneDeltaPair = this.toneDeltaPair(scheme);
            const roleA = toneDeltaPair.roleA;
            const roleB = toneDeltaPair.roleB;
            const delta = toneDeltaPair.delta;
            const polarity = toneDeltaPair.polarity;
            const stayTogether = toneDeltaPair.stayTogether;
            const bg = this.background(scheme);
            const bgTone = bg.getTone(scheme);
            const aIsNearer = polarity === "nearer" || polarity === "lighter" && !scheme.isDark || polarity === "darker" && scheme.isDark;
            const nearer = aIsNearer ? roleA : roleB;
            const farther = aIsNearer ? roleB : roleA;
            const amNearer = this.name === nearer.name;
            const expansionDir = scheme.isDark ? 1 : -1;
            const nContrast = nearer.contrastCurve.getContrast(scheme.contrastLevel);
            const fContrast = farther.contrastCurve.getContrast(scheme.contrastLevel);
            const nInitialTone = nearer.tone(scheme);
            let nTone = Contrast.ratioOfTones(bgTone, nInitialTone) >= nContrast ? nInitialTone : DynamicColor.foregroundTone(bgTone, nContrast);
            const fInitialTone = farther.tone(scheme);
            let fTone = Contrast.ratioOfTones(bgTone, fInitialTone) >= fContrast ? fInitialTone : DynamicColor.foregroundTone(bgTone, fContrast);
            if (decreasingContrast) {
              nTone = DynamicColor.foregroundTone(bgTone, nContrast);
              fTone = DynamicColor.foregroundTone(bgTone, fContrast);
            }
            if ((fTone - nTone) * expansionDir >= delta) {
            } else {
              fTone = clampDouble(0, 100, nTone + delta * expansionDir);
              if ((fTone - nTone) * expansionDir >= delta) {
              } else {
                nTone = clampDouble(0, 100, fTone - delta * expansionDir);
              }
            }
            if (50 <= nTone && nTone < 60) {
              if (expansionDir > 0) {
                nTone = 60;
                fTone = Math.max(fTone, nTone + delta * expansionDir);
              } else {
                nTone = 49;
                fTone = Math.min(fTone, nTone + delta * expansionDir);
              }
            } else if (50 <= fTone && fTone < 60) {
              if (stayTogether) {
                if (expansionDir > 0) {
                  nTone = 60;
                  fTone = Math.max(fTone, nTone + delta * expansionDir);
                } else {
                  nTone = 49;
                  fTone = Math.min(fTone, nTone + delta * expansionDir);
                }
              } else {
                if (expansionDir > 0) {
                  fTone = 60;
                } else {
                  fTone = 49;
                }
              }
            }
            return amNearer ? nTone : fTone;
          } else {
            let answer = this.tone(scheme);
            if (this.background == null) {
              return answer;
            }
            const bgTone = this.background(scheme).getTone(scheme);
            const desiredRatio = this.contrastCurve.getContrast(scheme.contrastLevel);
            if (Contrast.ratioOfTones(bgTone, answer) >= desiredRatio) {
            } else {
              answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
            }
            if (decreasingContrast) {
              answer = DynamicColor.foregroundTone(bgTone, desiredRatio);
            }
            if (this.isBackground && 50 <= answer && answer < 60) {
              if (Contrast.ratioOfTones(49, bgTone) >= desiredRatio) {
                answer = 49;
              } else {
                answer = 60;
              }
            }
            if (this.secondBackground) {
              const [bg1, bg2] = [this.background, this.secondBackground];
              const [bgTone1, bgTone2] = [bg1(scheme).getTone(scheme), bg2(scheme).getTone(scheme)];
              const [upper, lower] = [Math.max(bgTone1, bgTone2), Math.min(bgTone1, bgTone2)];
              if (Contrast.ratioOfTones(upper, answer) >= desiredRatio && Contrast.ratioOfTones(lower, answer) >= desiredRatio) {
                return answer;
              }
              const lightOption = Contrast.lighter(upper, desiredRatio);
              const darkOption = Contrast.darker(lower, desiredRatio);
              const availables = [];
              if (lightOption !== -1)
                availables.push(lightOption);
              if (darkOption !== -1)
                availables.push(darkOption);
              const prefersLight = DynamicColor.tonePrefersLightForeground(bgTone1) || DynamicColor.tonePrefersLightForeground(bgTone2);
              if (prefersLight) {
                return lightOption < 0 ? 100 : lightOption;
              }
              if (availables.length === 1) {
                return availables[0];
              }
              return darkOption < 0 ? 0 : darkOption;
            }
            return answer;
          }
        }
        /**
         * Given a background tone, find a foreground tone, while ensuring they reach
         * a contrast ratio that is as close to [ratio] as possible.
         *
         * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
         *     falls outside that range.
         * @param ratio The contrast ratio desired between bgTone and the return
         *     value.
         */
        static foregroundTone(bgTone, ratio) {
          const lighterTone = Contrast.lighterUnsafe(bgTone, ratio);
          const darkerTone = Contrast.darkerUnsafe(bgTone, ratio);
          const lighterRatio = Contrast.ratioOfTones(lighterTone, bgTone);
          const darkerRatio = Contrast.ratioOfTones(darkerTone, bgTone);
          const preferLighter = DynamicColor.tonePrefersLightForeground(bgTone);
          if (preferLighter) {
            const negligibleDifference = Math.abs(lighterRatio - darkerRatio) < 0.1 && lighterRatio < ratio && darkerRatio < ratio;
            return lighterRatio >= ratio || lighterRatio >= darkerRatio || negligibleDifference ? lighterTone : darkerTone;
          } else {
            return darkerRatio >= ratio || darkerRatio >= lighterRatio ? darkerTone : lighterTone;
          }
        }
        /**
         * Returns whether [tone] prefers a light foreground.
         *
         * People prefer white foregrounds on ~T60-70. Observed over time, and also
         * by Andrew Somers during research for APCA.
         *
         * T60 used as to create the smallest discontinuity possible when skipping
         * down to T49 in order to ensure light foregrounds.
         * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
         * 60, it should not be adjusted. Therefore, 60 is excluded here.
         */
        static tonePrefersLightForeground(tone) {
          return Math.round(tone) < 60;
        }
        /**
         * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
         * color.
         */
        static toneAllowsLightForeground(tone) {
          return Math.round(tone) <= 49;
        }
        /**
         * Adjust a tone such that white has 4.5 contrast, if the tone is
         * reasonably close to supporting it.
         */
        static enableLightForeground(tone) {
          if (DynamicColor.tonePrefersLightForeground(tone) && !DynamicColor.toneAllowsLightForeground(tone)) {
            return 49;
          }
          return tone;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/scheme/variant.js
  var Variant;
  var init_variant = __esm({
    "node_modules/@material/material-color-utilities/scheme/variant.js"() {
      (function(Variant2) {
        Variant2[Variant2["MONOCHROME"] = 0] = "MONOCHROME";
        Variant2[Variant2["NEUTRAL"] = 1] = "NEUTRAL";
        Variant2[Variant2["TONAL_SPOT"] = 2] = "TONAL_SPOT";
        Variant2[Variant2["VIBRANT"] = 3] = "VIBRANT";
        Variant2[Variant2["EXPRESSIVE"] = 4] = "EXPRESSIVE";
        Variant2[Variant2["FIDELITY"] = 5] = "FIDELITY";
        Variant2[Variant2["CONTENT"] = 6] = "CONTENT";
        Variant2[Variant2["RAINBOW"] = 7] = "RAINBOW";
        Variant2[Variant2["FRUIT_SALAD"] = 8] = "FRUIT_SALAD";
      })(Variant || (Variant = {}));
    }
  });

  // node_modules/@material/material-color-utilities/dynamiccolor/contrast_curve.js
  var ContrastCurve;
  var init_contrast_curve = __esm({
    "node_modules/@material/material-color-utilities/dynamiccolor/contrast_curve.js"() {
      init_math_utils();
      ContrastCurve = class {
        /**
         * Creates a `ContrastCurve` object.
         *
         * @param low Contrast requirement for contrast level -1.0
         * @param normal Contrast requirement for contrast level 0.0
         * @param medium Contrast requirement for contrast level 0.5
         * @param high Contrast requirement for contrast level 1.0
         */
        constructor(low, normal, medium, high) {
          this.low = low;
          this.normal = normal;
          this.medium = medium;
          this.high = high;
        }
        /**
         * Returns the contrast ratio at a given contrast level.
         *
         * @param contrastLevel The contrast level. 0.0 is the default (normal);
         * -1.0 is the lowest; 1.0 is the highest.
         * @return The contrast ratio, a number between 1.0 and 21.0.
         */
        getContrast(contrastLevel) {
          if (contrastLevel <= -1) {
            return this.low;
          } else if (contrastLevel < 0) {
            return lerp(this.low, this.normal, (contrastLevel - -1) / 1);
          } else if (contrastLevel < 0.5) {
            return lerp(this.normal, this.medium, (contrastLevel - 0) / 0.5);
          } else if (contrastLevel < 1) {
            return lerp(this.medium, this.high, (contrastLevel - 0.5) / 0.5);
          } else {
            return this.high;
          }
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/dynamiccolor/tone_delta_pair.js
  var ToneDeltaPair;
  var init_tone_delta_pair = __esm({
    "node_modules/@material/material-color-utilities/dynamiccolor/tone_delta_pair.js"() {
      ToneDeltaPair = class {
        /**
         * Documents a constraint in tone distance between two DynamicColors.
         *
         * The polarity is an adjective that describes "A", compared to "B".
         *
         * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
         * A's tone should be at least 15 darker than B's.
         *
         * 'nearer' and 'farther' describes closeness to the surface roles. For
         * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
         * should be 10 lighter than B in light mode, and 10 darker than B in dark
         * mode.
         *
         * @param roleA The first role in a pair.
         * @param roleB The second role in a pair.
         * @param delta Required difference between tones. Absolute value, negative
         * values have undefined behavior.
         * @param polarity The relative relation between tones of roleA and roleB,
         * as described above.
         * @param stayTogether Whether these two roles should stay on the same side of
         * the "awkward zone" (T50-59). This is necessary for certain cases where
         * one role has two backgrounds.
         */
        constructor(roleA, roleB, delta, polarity, stayTogether) {
          this.roleA = roleA;
          this.roleB = roleB;
          this.delta = delta;
          this.polarity = polarity;
          this.stayTogether = stayTogether;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/dynamiccolor/material_dynamic_colors.js
  function isFidelity(scheme) {
    return scheme.variant === Variant.FIDELITY || scheme.variant === Variant.CONTENT;
  }
  function isMonochrome(scheme) {
    return scheme.variant === Variant.MONOCHROME;
  }
  function findDesiredChromaByTone(hue, chroma, tone, byDecreasingTone) {
    let answer = tone;
    let closestToChroma = Hct.from(hue, chroma, tone);
    if (closestToChroma.chroma < chroma) {
      let chromaPeak = closestToChroma.chroma;
      while (closestToChroma.chroma < chroma) {
        answer += byDecreasingTone ? -1 : 1;
        const potentialSolution = Hct.from(hue, chroma, answer);
        if (chromaPeak > potentialSolution.chroma) {
          break;
        }
        if (Math.abs(potentialSolution.chroma - chroma) < 0.4) {
          break;
        }
        const potentialDelta = Math.abs(potentialSolution.chroma - chroma);
        const currentDelta = Math.abs(closestToChroma.chroma - chroma);
        if (potentialDelta < currentDelta) {
          closestToChroma = potentialSolution;
        }
        chromaPeak = Math.max(chromaPeak, potentialSolution.chroma);
      }
    }
    return answer;
  }
  function viewingConditionsForAlbers(scheme) {
    return ViewingConditions.make(
      /*whitePoint=*/
      void 0,
      /*adaptingLuminance=*/
      void 0,
      /*backgroundLstar=*/
      scheme.isDark ? 30 : 80,
      /*surround=*/
      void 0,
      /*discountingIlluminant=*/
      void 0
    );
  }
  function performAlbers(prealbers, scheme) {
    const albersd = prealbers.inViewingConditions(viewingConditionsForAlbers(scheme));
    if (DynamicColor.tonePrefersLightForeground(prealbers.tone) && !DynamicColor.toneAllowsLightForeground(albersd.tone)) {
      return DynamicColor.enableLightForeground(prealbers.tone);
    } else {
      return DynamicColor.enableLightForeground(albersd.tone);
    }
  }
  var MaterialDynamicColors;
  var init_material_dynamic_colors = __esm({
    "node_modules/@material/material-color-utilities/dynamiccolor/material_dynamic_colors.js"() {
      init_dislike_analyzer();
      init_hct();
      init_viewing_conditions();
      init_variant();
      init_contrast_curve();
      init_dynamic_color();
      init_tone_delta_pair();
      MaterialDynamicColors = class {
        static highestSurface(s3) {
          return s3.isDark ? MaterialDynamicColors.surfaceBright : MaterialDynamicColors.surfaceDim;
        }
      };
      MaterialDynamicColors.contentAccentToneDelta = 15;
      MaterialDynamicColors.primaryPaletteKeyColor = DynamicColor.fromPalette({
        name: "primary_palette_key_color",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => s3.primaryPalette.keyColor.tone
      });
      MaterialDynamicColors.secondaryPaletteKeyColor = DynamicColor.fromPalette({
        name: "secondary_palette_key_color",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => s3.secondaryPalette.keyColor.tone
      });
      MaterialDynamicColors.tertiaryPaletteKeyColor = DynamicColor.fromPalette({
        name: "tertiary_palette_key_color",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => s3.tertiaryPalette.keyColor.tone
      });
      MaterialDynamicColors.neutralPaletteKeyColor = DynamicColor.fromPalette({
        name: "neutral_palette_key_color",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.neutralPalette.keyColor.tone
      });
      MaterialDynamicColors.neutralVariantPaletteKeyColor = DynamicColor.fromPalette({
        name: "neutral_variant_palette_key_color",
        palette: (s3) => s3.neutralVariantPalette,
        tone: (s3) => s3.neutralVariantPalette.keyColor.tone
      });
      MaterialDynamicColors.background = DynamicColor.fromPalette({
        name: "background",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 6 : 98,
        isBackground: true
      });
      MaterialDynamicColors.onBackground = DynamicColor.fromPalette({
        name: "on_background",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 90 : 10,
        background: (s3) => MaterialDynamicColors.background,
        contrastCurve: new ContrastCurve(3, 3, 4.5, 7)
      });
      MaterialDynamicColors.surface = DynamicColor.fromPalette({
        name: "surface",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 6 : 98,
        isBackground: true
      });
      MaterialDynamicColors.surfaceDim = DynamicColor.fromPalette({
        name: "surface_dim",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 6 : 87,
        isBackground: true
      });
      MaterialDynamicColors.surfaceBright = DynamicColor.fromPalette({
        name: "surface_bright",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 24 : 98,
        isBackground: true
      });
      MaterialDynamicColors.surfaceContainerLowest = DynamicColor.fromPalette({
        name: "surface_container_lowest",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 4 : 100,
        isBackground: true
      });
      MaterialDynamicColors.surfaceContainerLow = DynamicColor.fromPalette({
        name: "surface_container_low",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 10 : 96,
        isBackground: true
      });
      MaterialDynamicColors.surfaceContainer = DynamicColor.fromPalette({
        name: "surface_container",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 12 : 94,
        isBackground: true
      });
      MaterialDynamicColors.surfaceContainerHigh = DynamicColor.fromPalette({
        name: "surface_container_high",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 17 : 92,
        isBackground: true
      });
      MaterialDynamicColors.surfaceContainerHighest = DynamicColor.fromPalette({
        name: "surface_container_highest",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 22 : 90,
        isBackground: true
      });
      MaterialDynamicColors.onSurface = DynamicColor.fromPalette({
        name: "on_surface",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 90 : 10,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.surfaceVariant = DynamicColor.fromPalette({
        name: "surface_variant",
        palette: (s3) => s3.neutralVariantPalette,
        tone: (s3) => s3.isDark ? 30 : 90,
        isBackground: true
      });
      MaterialDynamicColors.onSurfaceVariant = DynamicColor.fromPalette({
        name: "on_surface_variant",
        palette: (s3) => s3.neutralVariantPalette,
        tone: (s3) => s3.isDark ? 80 : 30,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
      });
      MaterialDynamicColors.inverseSurface = DynamicColor.fromPalette({
        name: "inverse_surface",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 90 : 20
      });
      MaterialDynamicColors.inverseOnSurface = DynamicColor.fromPalette({
        name: "inverse_on_surface",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => s3.isDark ? 20 : 95,
        background: (s3) => MaterialDynamicColors.inverseSurface,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.outline = DynamicColor.fromPalette({
        name: "outline",
        palette: (s3) => s3.neutralVariantPalette,
        tone: (s3) => s3.isDark ? 60 : 50,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1.5, 3, 4.5, 7)
      });
      MaterialDynamicColors.outlineVariant = DynamicColor.fromPalette({
        name: "outline_variant",
        palette: (s3) => s3.neutralVariantPalette,
        tone: (s3) => s3.isDark ? 30 : 80,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7)
      });
      MaterialDynamicColors.shadow = DynamicColor.fromPalette({
        name: "shadow",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => 0
      });
      MaterialDynamicColors.scrim = DynamicColor.fromPalette({
        name: "scrim",
        palette: (s3) => s3.neutralPalette,
        tone: (s3) => 0
      });
      MaterialDynamicColors.surfaceTint = DynamicColor.fromPalette({
        name: "surface_tint",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => s3.isDark ? 80 : 40,
        isBackground: true
      });
      MaterialDynamicColors.primary = DynamicColor.fromPalette({
        name: "primary",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 100 : 0;
          }
          return s3.isDark ? 80 : 40;
        },
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, "nearer", false)
      });
      MaterialDynamicColors.onPrimary = DynamicColor.fromPalette({
        name: "on_primary",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 10 : 90;
          }
          return s3.isDark ? 20 : 100;
        },
        background: (s3) => MaterialDynamicColors.primary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.primaryContainer = DynamicColor.fromPalette({
        name: "primary_container",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => {
          if (isFidelity(s3)) {
            return performAlbers(s3.sourceColorHct, s3);
          }
          if (isMonochrome(s3)) {
            return s3.isDark ? 85 : 25;
          }
          return s3.isDark ? 30 : 90;
        },
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.primaryContainer, MaterialDynamicColors.primary, 15, "nearer", false)
      });
      MaterialDynamicColors.onPrimaryContainer = DynamicColor.fromPalette({
        name: "on_primary_container",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => {
          if (isFidelity(s3)) {
            return DynamicColor.foregroundTone(MaterialDynamicColors.primaryContainer.tone(s3), 4.5);
          }
          if (isMonochrome(s3)) {
            return s3.isDark ? 0 : 100;
          }
          return s3.isDark ? 90 : 10;
        },
        background: (s3) => MaterialDynamicColors.primaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.inversePrimary = DynamicColor.fromPalette({
        name: "inverse_primary",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => s3.isDark ? 40 : 80,
        background: (s3) => MaterialDynamicColors.inverseSurface,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
      });
      MaterialDynamicColors.secondary = DynamicColor.fromPalette({
        name: "secondary",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => s3.isDark ? 80 : 40,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, "nearer", false)
      });
      MaterialDynamicColors.onSecondary = DynamicColor.fromPalette({
        name: "on_secondary",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 10 : 100;
          } else {
            return s3.isDark ? 20 : 100;
          }
        },
        background: (s3) => MaterialDynamicColors.secondary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.secondaryContainer = DynamicColor.fromPalette({
        name: "secondary_container",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => {
          const initialTone = s3.isDark ? 30 : 90;
          if (isMonochrome(s3)) {
            return s3.isDark ? 30 : 85;
          }
          if (!isFidelity(s3)) {
            return initialTone;
          }
          let answer = findDesiredChromaByTone(s3.secondaryPalette.hue, s3.secondaryPalette.chroma, initialTone, s3.isDark ? false : true);
          answer = performAlbers(s3.secondaryPalette.getHct(answer), s3);
          return answer;
        },
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.secondaryContainer, MaterialDynamicColors.secondary, 15, "nearer", false)
      });
      MaterialDynamicColors.onSecondaryContainer = DynamicColor.fromPalette({
        name: "on_secondary_container",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => {
          if (!isFidelity(s3)) {
            return s3.isDark ? 90 : 10;
          }
          return DynamicColor.foregroundTone(MaterialDynamicColors.secondaryContainer.tone(s3), 4.5);
        },
        background: (s3) => MaterialDynamicColors.secondaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.tertiary = DynamicColor.fromPalette({
        name: "tertiary",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 90 : 25;
          }
          return s3.isDark ? 80 : 40;
        },
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, "nearer", false)
      });
      MaterialDynamicColors.onTertiary = DynamicColor.fromPalette({
        name: "on_tertiary",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 10 : 90;
          }
          return s3.isDark ? 20 : 100;
        },
        background: (s3) => MaterialDynamicColors.tertiary,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.tertiaryContainer = DynamicColor.fromPalette({
        name: "tertiary_container",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 60 : 49;
          }
          if (!isFidelity(s3)) {
            return s3.isDark ? 30 : 90;
          }
          const albersTone = performAlbers(s3.tertiaryPalette.getHct(s3.sourceColorHct.tone), s3);
          const proposedHct = s3.tertiaryPalette.getHct(albersTone);
          return DislikeAnalyzer.fixIfDisliked(proposedHct).tone;
        },
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.tertiaryContainer, MaterialDynamicColors.tertiary, 15, "nearer", false)
      });
      MaterialDynamicColors.onTertiaryContainer = DynamicColor.fromPalette({
        name: "on_tertiary_container",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => {
          if (isMonochrome(s3)) {
            return s3.isDark ? 0 : 100;
          }
          if (!isFidelity(s3)) {
            return s3.isDark ? 90 : 10;
          }
          return DynamicColor.foregroundTone(MaterialDynamicColors.tertiaryContainer.tone(s3), 4.5);
        },
        background: (s3) => MaterialDynamicColors.tertiaryContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.error = DynamicColor.fromPalette({
        name: "error",
        palette: (s3) => s3.errorPalette,
        tone: (s3) => s3.isDark ? 80 : 40,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, "nearer", false)
      });
      MaterialDynamicColors.onError = DynamicColor.fromPalette({
        name: "on_error",
        palette: (s3) => s3.errorPalette,
        tone: (s3) => s3.isDark ? 20 : 100,
        background: (s3) => MaterialDynamicColors.error,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.errorContainer = DynamicColor.fromPalette({
        name: "error_container",
        palette: (s3) => s3.errorPalette,
        tone: (s3) => s3.isDark ? 30 : 90,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.errorContainer, MaterialDynamicColors.error, 15, "nearer", false)
      });
      MaterialDynamicColors.onErrorContainer = DynamicColor.fromPalette({
        name: "on_error_container",
        palette: (s3) => s3.errorPalette,
        tone: (s3) => s3.isDark ? 90 : 10,
        background: (s3) => MaterialDynamicColors.errorContainer,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.primaryFixed = DynamicColor.fromPalette({
        name: "primary_fixed",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => isMonochrome(s3) ? 40 : 90,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.primaryFixedDim = DynamicColor.fromPalette({
        name: "primary_fixed_dim",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => isMonochrome(s3) ? 30 : 80,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.primaryFixed, MaterialDynamicColors.primaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.onPrimaryFixed = DynamicColor.fromPalette({
        name: "on_primary_fixed",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => isMonochrome(s3) ? 100 : 10,
        background: (s3) => MaterialDynamicColors.primaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.primaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.onPrimaryFixedVariant = DynamicColor.fromPalette({
        name: "on_primary_fixed_variant",
        palette: (s3) => s3.primaryPalette,
        tone: (s3) => isMonochrome(s3) ? 90 : 30,
        background: (s3) => MaterialDynamicColors.primaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.primaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
      });
      MaterialDynamicColors.secondaryFixed = DynamicColor.fromPalette({
        name: "secondary_fixed",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => isMonochrome(s3) ? 80 : 90,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.secondaryFixedDim = DynamicColor.fromPalette({
        name: "secondary_fixed_dim",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => isMonochrome(s3) ? 70 : 80,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.secondaryFixed, MaterialDynamicColors.secondaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.onSecondaryFixed = DynamicColor.fromPalette({
        name: "on_secondary_fixed",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => 10,
        background: (s3) => MaterialDynamicColors.secondaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.secondaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.onSecondaryFixedVariant = DynamicColor.fromPalette({
        name: "on_secondary_fixed_variant",
        palette: (s3) => s3.secondaryPalette,
        tone: (s3) => isMonochrome(s3) ? 25 : 30,
        background: (s3) => MaterialDynamicColors.secondaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.secondaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
      });
      MaterialDynamicColors.tertiaryFixed = DynamicColor.fromPalette({
        name: "tertiary_fixed",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => isMonochrome(s3) ? 40 : 90,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.tertiaryFixedDim = DynamicColor.fromPalette({
        name: "tertiary_fixed_dim",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => isMonochrome(s3) ? 30 : 80,
        isBackground: true,
        background: (s3) => MaterialDynamicColors.highestSurface(s3),
        contrastCurve: new ContrastCurve(1, 1, 3, 7),
        toneDeltaPair: (s3) => new ToneDeltaPair(MaterialDynamicColors.tertiaryFixed, MaterialDynamicColors.tertiaryFixedDim, 10, "lighter", true)
      });
      MaterialDynamicColors.onTertiaryFixed = DynamicColor.fromPalette({
        name: "on_tertiary_fixed",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => isMonochrome(s3) ? 100 : 10,
        background: (s3) => MaterialDynamicColors.tertiaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.tertiaryFixed,
        contrastCurve: new ContrastCurve(4.5, 7, 11, 21)
      });
      MaterialDynamicColors.onTertiaryFixedVariant = DynamicColor.fromPalette({
        name: "on_tertiary_fixed_variant",
        palette: (s3) => s3.tertiaryPalette,
        tone: (s3) => isMonochrome(s3) ? 90 : 30,
        background: (s3) => MaterialDynamicColors.tertiaryFixedDim,
        secondBackground: (s3) => MaterialDynamicColors.tertiaryFixed,
        contrastCurve: new ContrastCurve(3, 4.5, 7, 11)
      });
    }
  });

  // node_modules/@material/material-color-utilities/palettes/tonal_palette.js
  var TonalPalette;
  var init_tonal_palette = __esm({
    "node_modules/@material/material-color-utilities/palettes/tonal_palette.js"() {
      init_hct();
      TonalPalette = class {
        /**
         * @param argb ARGB representation of a color
         * @return Tones matching that color's hue and chroma.
         */
        static fromInt(argb) {
          const hct = Hct.fromInt(argb);
          return TonalPalette.fromHct(hct);
        }
        /**
         * @param hct Hct
         * @return Tones matching that color's hue and chroma.
         */
        static fromHct(hct) {
          return new TonalPalette(hct.hue, hct.chroma, hct);
        }
        /**
         * @param hue HCT hue
         * @param chroma HCT chroma
         * @return Tones matching hue and chroma.
         */
        static fromHueAndChroma(hue, chroma) {
          return new TonalPalette(hue, chroma, TonalPalette.createKeyColor(hue, chroma));
        }
        constructor(hue, chroma, keyColor) {
          this.hue = hue;
          this.chroma = chroma;
          this.keyColor = keyColor;
          this.cache = /* @__PURE__ */ new Map();
        }
        static createKeyColor(hue, chroma) {
          const startTone = 50;
          let smallestDeltaHct = Hct.from(hue, chroma, startTone);
          let smallestDelta = Math.abs(smallestDeltaHct.chroma - chroma);
          for (let delta = 1; delta < 50; delta += 1) {
            if (Math.round(chroma) === Math.round(smallestDeltaHct.chroma)) {
              return smallestDeltaHct;
            }
            const hctAdd = Hct.from(hue, chroma, startTone + delta);
            const hctAddDelta = Math.abs(hctAdd.chroma - chroma);
            if (hctAddDelta < smallestDelta) {
              smallestDelta = hctAddDelta;
              smallestDeltaHct = hctAdd;
            }
            const hctSubtract = Hct.from(hue, chroma, startTone - delta);
            const hctSubtractDelta = Math.abs(hctSubtract.chroma - chroma);
            if (hctSubtractDelta < smallestDelta) {
              smallestDelta = hctSubtractDelta;
              smallestDeltaHct = hctSubtract;
            }
          }
          return smallestDeltaHct;
        }
        /**
         * @param tone HCT tone, measured from 0 to 100.
         * @return ARGB representation of a color with that tone.
         */
        tone(tone) {
          let argb = this.cache.get(tone);
          if (argb === void 0) {
            argb = Hct.from(this.hue, this.chroma, tone).toInt();
            this.cache.set(tone, argb);
          }
          return argb;
        }
        /**
         * @param tone HCT tone.
         * @return HCT representation of a color with that tone.
         */
        getHct(tone) {
          return Hct.fromInt(this.tone(tone));
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/palettes/core_palette.js
  var init_core_palette = __esm({
    "node_modules/@material/material-color-utilities/palettes/core_palette.js"() {
      init_hct();
      init_tonal_palette();
    }
  });

  // node_modules/@material/material-color-utilities/quantize/lab_point_provider.js
  var init_lab_point_provider = __esm({
    "node_modules/@material/material-color-utilities/quantize/lab_point_provider.js"() {
      init_color_utils();
    }
  });

  // node_modules/@material/material-color-utilities/quantize/quantizer_wsmeans.js
  var init_quantizer_wsmeans = __esm({
    "node_modules/@material/material-color-utilities/quantize/quantizer_wsmeans.js"() {
      init_lab_point_provider();
    }
  });

  // node_modules/@material/material-color-utilities/quantize/quantizer_map.js
  var init_quantizer_map = __esm({
    "node_modules/@material/material-color-utilities/quantize/quantizer_map.js"() {
      init_color_utils();
    }
  });

  // node_modules/@material/material-color-utilities/quantize/quantizer_wu.js
  var init_quantizer_wu = __esm({
    "node_modules/@material/material-color-utilities/quantize/quantizer_wu.js"() {
      init_color_utils();
      init_quantizer_map();
    }
  });

  // node_modules/@material/material-color-utilities/quantize/quantizer_celebi.js
  var init_quantizer_celebi = __esm({
    "node_modules/@material/material-color-utilities/quantize/quantizer_celebi.js"() {
      init_quantizer_wsmeans();
      init_quantizer_wu();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/dynamic_scheme.js
  var DynamicScheme;
  var init_dynamic_scheme = __esm({
    "node_modules/@material/material-color-utilities/scheme/dynamic_scheme.js"() {
      init_hct();
      init_tonal_palette();
      init_math_utils();
      DynamicScheme = class {
        constructor(args) {
          this.sourceColorArgb = args.sourceColorArgb;
          this.variant = args.variant;
          this.contrastLevel = args.contrastLevel;
          this.isDark = args.isDark;
          this.sourceColorHct = Hct.fromInt(args.sourceColorArgb);
          this.primaryPalette = args.primaryPalette;
          this.secondaryPalette = args.secondaryPalette;
          this.tertiaryPalette = args.tertiaryPalette;
          this.neutralPalette = args.neutralPalette;
          this.neutralVariantPalette = args.neutralVariantPalette;
          this.errorPalette = TonalPalette.fromHueAndChroma(25, 84);
        }
        /**
         * Support design spec'ing Dynamic Color by schemes that specify hue
         * rotations that should be applied at certain breakpoints.
         * @param sourceColor the source color of the theme, in HCT.
         * @param hues The "breakpoints", i.e. the hues at which a rotation should
         * be apply.
         * @param rotations The rotation that should be applied when source color's
         * hue is >= the same index in hues array, and <= the hue at the next index
         * in hues array.
         */
        static getRotatedHue(sourceColor, hues, rotations) {
          const sourceHue = sourceColor.hue;
          if (hues.length !== rotations.length) {
            throw new Error(`mismatch between hue length ${hues.length} & rotations ${rotations.length}`);
          }
          if (rotations.length === 1) {
            return sanitizeDegreesDouble(sourceColor.hue + rotations[0]);
          }
          const size2 = hues.length;
          for (let i5 = 0; i5 <= size2 - 2; i5++) {
            const thisHue = hues[i5];
            const nextHue = hues[i5 + 1];
            if (thisHue < sourceHue && sourceHue < nextHue) {
              return sanitizeDegreesDouble(sourceHue + rotations[i5]);
            }
          }
          return sourceHue;
        }
      };
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme.js
  var init_scheme = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme.js"() {
      init_core_palette();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_android.js
  var init_scheme_android = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_android.js"() {
      init_core_palette();
    }
  });

  // node_modules/@material/material-color-utilities/temperature/temperature_cache.js
  var init_temperature_cache = __esm({
    "node_modules/@material/material-color-utilities/temperature/temperature_cache.js"() {
      init_hct();
      init_color_utils();
      init_math_utils();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_content.js
  var init_scheme_content = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_content.js"() {
      init_dislike_analyzer();
      init_tonal_palette();
      init_temperature_cache();
      init_dynamic_scheme();
      init_variant();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_expressive.js
  var SchemeExpressive;
  var init_scheme_expressive = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_expressive.js"() {
      init_tonal_palette();
      init_math_utils();
      init_dynamic_scheme();
      init_variant();
      SchemeExpressive = class extends DynamicScheme {
        constructor(sourceColorHct, isDark, contrastLevel) {
          super({
            sourceColorArgb: sourceColorHct.toInt(),
            variant: Variant.EXPRESSIVE,
            contrastLevel,
            isDark,
            primaryPalette: TonalPalette.fromHueAndChroma(sanitizeDegreesDouble(sourceColorHct.hue + 240), 40),
            secondaryPalette: TonalPalette.fromHueAndChroma(DynamicScheme.getRotatedHue(sourceColorHct, SchemeExpressive.hues, SchemeExpressive.secondaryRotations), 24),
            tertiaryPalette: TonalPalette.fromHueAndChroma(DynamicScheme.getRotatedHue(sourceColorHct, SchemeExpressive.hues, SchemeExpressive.tertiaryRotations), 32),
            neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue + 15, 8),
            neutralVariantPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue + 15, 12)
          });
        }
      };
      SchemeExpressive.hues = [
        0,
        21,
        51,
        121,
        151,
        191,
        271,
        321,
        360
      ];
      SchemeExpressive.secondaryRotations = [
        45,
        95,
        45,
        20,
        45,
        90,
        45,
        45,
        45
      ];
      SchemeExpressive.tertiaryRotations = [
        120,
        120,
        20,
        45,
        20,
        15,
        20,
        120,
        120
      ];
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_fidelity.js
  var init_scheme_fidelity = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_fidelity.js"() {
      init_dislike_analyzer();
      init_tonal_palette();
      init_temperature_cache();
      init_dynamic_scheme();
      init_variant();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_monochrome.js
  var init_scheme_monochrome = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_monochrome.js"() {
      init_tonal_palette();
      init_dynamic_scheme();
      init_variant();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_neutral.js
  var init_scheme_neutral = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_neutral.js"() {
      init_tonal_palette();
      init_dynamic_scheme();
      init_variant();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_tonal_spot.js
  var init_scheme_tonal_spot = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_tonal_spot.js"() {
      init_tonal_palette();
      init_math_utils();
      init_dynamic_scheme();
      init_variant();
    }
  });

  // node_modules/@material/material-color-utilities/scheme/scheme_vibrant.js
  var SchemeVibrant;
  var init_scheme_vibrant = __esm({
    "node_modules/@material/material-color-utilities/scheme/scheme_vibrant.js"() {
      init_tonal_palette();
      init_dynamic_scheme();
      init_variant();
      SchemeVibrant = class extends DynamicScheme {
        constructor(sourceColorHct, isDark, contrastLevel) {
          super({
            sourceColorArgb: sourceColorHct.toInt(),
            variant: Variant.VIBRANT,
            contrastLevel,
            isDark,
            primaryPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 200),
            secondaryPalette: TonalPalette.fromHueAndChroma(DynamicScheme.getRotatedHue(sourceColorHct, SchemeVibrant.hues, SchemeVibrant.secondaryRotations), 24),
            tertiaryPalette: TonalPalette.fromHueAndChroma(DynamicScheme.getRotatedHue(sourceColorHct, SchemeVibrant.hues, SchemeVibrant.tertiaryRotations), 32),
            neutralPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 10),
            neutralVariantPalette: TonalPalette.fromHueAndChroma(sourceColorHct.hue, 12)
          });
        }
      };
      SchemeVibrant.hues = [
        0,
        41,
        61,
        101,
        131,
        181,
        251,
        301,
        360
      ];
      SchemeVibrant.secondaryRotations = [
        18,
        15,
        10,
        12,
        15,
        18,
        15,
        12,
        12
      ];
      SchemeVibrant.tertiaryRotations = [
        35,
        30,
        20,
        25,
        30,
        35,
        30,
        25,
        25
      ];
    }
  });

  // node_modules/@material/material-color-utilities/score/score.js
  function compare(a3, b3) {
    if (a3.score > b3.score) {
      return -1;
    } else if (a3.score < b3.score) {
      return 1;
    }
    return 0;
  }
  var SCORE_OPTION_DEFAULTS, Score;
  var init_score = __esm({
    "node_modules/@material/material-color-utilities/score/score.js"() {
      init_hct();
      init_math_utils();
      SCORE_OPTION_DEFAULTS = {
        desired: 4,
        fallbackColorARGB: 4282549748,
        filter: true
        // Avoid unsuitable colors.
      };
      Score = class {
        constructor() {
        }
        /**
         * Given a map with keys of colors and values of how often the color appears,
         * rank the colors based on suitability for being used for a UI theme.
         *
         * @param colorsToPopulation map with keys of colors and values of how often
         *     the color appears, usually from a source image.
         * @param {ScoreOptions} options optional parameters.
         * @return Colors sorted by suitability for a UI theme. The most suitable
         *     color is the first item, the least suitable is the last. There will
         *     always be at least one color returned. If all the input colors
         *     were not suitable for a theme, a default fallback color will be
         *     provided, Google Blue.
         */
        static score(colorsToPopulation, options) {
          const { desired, fallbackColorARGB, filter: filter3 } = __spreadValues(__spreadValues({}, SCORE_OPTION_DEFAULTS), options);
          const colorsHct = [];
          const huePopulation = new Array(360).fill(0);
          let populationSum = 0;
          for (const [argb, population] of colorsToPopulation.entries()) {
            const hct = Hct.fromInt(argb);
            colorsHct.push(hct);
            const hue = Math.floor(hct.hue);
            huePopulation[hue] += population;
            populationSum += population;
          }
          const hueExcitedProportions = new Array(360).fill(0);
          for (let hue = 0; hue < 360; hue++) {
            const proportion = huePopulation[hue] / populationSum;
            for (let i5 = hue - 14; i5 < hue + 16; i5++) {
              const neighborHue = sanitizeDegreesInt(i5);
              hueExcitedProportions[neighborHue] += proportion;
            }
          }
          const scoredHct = new Array();
          for (const hct of colorsHct) {
            const hue = sanitizeDegreesInt(Math.round(hct.hue));
            const proportion = hueExcitedProportions[hue];
            if (filter3 && (hct.chroma < Score.CUTOFF_CHROMA || proportion <= Score.CUTOFF_EXCITED_PROPORTION)) {
              continue;
            }
            const proportionScore = proportion * 100 * Score.WEIGHT_PROPORTION;
            const chromaWeight = hct.chroma < Score.TARGET_CHROMA ? Score.WEIGHT_CHROMA_BELOW : Score.WEIGHT_CHROMA_ABOVE;
            const chromaScore = (hct.chroma - Score.TARGET_CHROMA) * chromaWeight;
            const score = proportionScore + chromaScore;
            scoredHct.push({ hct, score });
          }
          scoredHct.sort(compare);
          const chosenColors = [];
          for (let differenceDegrees2 = 90; differenceDegrees2 >= 15; differenceDegrees2--) {
            chosenColors.length = 0;
            for (const { hct } of scoredHct) {
              const duplicateHue = chosenColors.find((chosenHct) => {
                return differenceDegrees(hct.hue, chosenHct.hue) < differenceDegrees2;
              });
              if (!duplicateHue) {
                chosenColors.push(hct);
              }
              if (chosenColors.length >= desired)
                break;
            }
            if (chosenColors.length >= desired)
              break;
          }
          const colors = [];
          if (chosenColors.length === 0) {
            colors.push(fallbackColorARGB);
          }
          for (const chosenHct of chosenColors) {
            colors.push(chosenHct.toInt());
          }
          return colors;
        }
      };
      Score.TARGET_CHROMA = 48;
      Score.WEIGHT_PROPORTION = 0.7;
      Score.WEIGHT_CHROMA_ABOVE = 0.3;
      Score.WEIGHT_CHROMA_BELOW = 0.1;
      Score.CUTOFF_CHROMA = 5;
      Score.CUTOFF_EXCITED_PROPORTION = 0.01;
    }
  });

  // node_modules/@material/material-color-utilities/utils/string_utils.js
  function hexFromArgb(argb) {
    const r3 = redFromArgb(argb);
    const g4 = greenFromArgb(argb);
    const b3 = blueFromArgb(argb);
    const outParts = [r3.toString(16), g4.toString(16), b3.toString(16)];
    for (const [i5, part] of outParts.entries()) {
      if (part.length === 1) {
        outParts[i5] = "0" + part;
      }
    }
    return "#" + outParts.join("");
  }
  function argbFromHex(hex2) {
    hex2 = hex2.replace("#", "");
    const isThree = hex2.length === 3;
    const isSix = hex2.length === 6;
    const isEight = hex2.length === 8;
    if (!isThree && !isSix && !isEight) {
      throw new Error("unexpected hex " + hex2);
    }
    let r3 = 0;
    let g4 = 0;
    let b3 = 0;
    if (isThree) {
      r3 = parseIntHex(hex2.slice(0, 1).repeat(2));
      g4 = parseIntHex(hex2.slice(1, 2).repeat(2));
      b3 = parseIntHex(hex2.slice(2, 3).repeat(2));
    } else if (isSix) {
      r3 = parseIntHex(hex2.slice(0, 2));
      g4 = parseIntHex(hex2.slice(2, 4));
      b3 = parseIntHex(hex2.slice(4, 6));
    } else if (isEight) {
      r3 = parseIntHex(hex2.slice(2, 4));
      g4 = parseIntHex(hex2.slice(4, 6));
      b3 = parseIntHex(hex2.slice(6, 8));
    }
    return (255 << 24 | (r3 & 255) << 16 | (g4 & 255) << 8 | b3 & 255) >>> 0;
  }
  function parseIntHex(value) {
    return parseInt(value, 16);
  }
  var init_string_utils = __esm({
    "node_modules/@material/material-color-utilities/utils/string_utils.js"() {
      init_color_utils();
    }
  });

  // node_modules/@material/material-color-utilities/utils/image_utils.js
  var init_image_utils = __esm({
    "node_modules/@material/material-color-utilities/utils/image_utils.js"() {
      init_quantizer_celebi();
      init_score();
      init_color_utils();
    }
  });

  // node_modules/@material/material-color-utilities/utils/theme_utils.js
  var init_theme_utils = __esm({
    "node_modules/@material/material-color-utilities/utils/theme_utils.js"() {
      init_blend();
      init_core_palette();
      init_scheme();
      init_image_utils();
      init_string_utils();
    }
  });

  // node_modules/@material/material-color-utilities/index.js
  var init_material_color_utilities = __esm({
    "node_modules/@material/material-color-utilities/index.js"() {
      init_blend();
      init_contrast();
      init_dislike_analyzer();
      init_dynamic_color();
      init_material_dynamic_colors();
      init_cam16();
      init_hct();
      init_viewing_conditions();
      init_core_palette();
      init_tonal_palette();
      init_quantizer_celebi();
      init_quantizer_map();
      init_quantizer_wsmeans();
      init_quantizer_wu();
      init_dynamic_scheme();
      init_scheme();
      init_scheme_android();
      init_scheme_content();
      init_scheme_expressive();
      init_scheme_fidelity();
      init_scheme_monochrome();
      init_scheme_neutral();
      init_scheme_tonal_spot();
      init_scheme_vibrant();
      init_score();
      init_temperature_cache();
      init_color_utils();
      init_math_utils();
      init_string_utils();
      init_image_utils();
      init_theme_utils();
    }
  });

  // node_modules/zod/lib/index.mjs
  function setErrorMap(map3) {
    overrideErrorMap = map3;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x4) => !!x4)
    });
    ctx.common.issues.push(issue);
  }
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  function isValidIP(ip, version3) {
    if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
        shape: () => newShape
      }));
    } else if (schema instanceof ZodArray) {
      return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
        type: deepPartialify(schema.element)
      }));
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  function mergeValues(a3, b3) {
    const aType = getParsedType(a3);
    const bType = getParsedType(b3);
    if (a3 === b3) {
      return { valid: true, data: a3 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b3);
      const sharedKeys = util.objectKeys(a3).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = __spreadValues(__spreadValues({}, a3), b3);
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a3[key], b3[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a3.length !== b3.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a3.length; index2++) {
        const itemA = a3[index2];
        const itemB = b3[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b3) {
      return { valid: true, data: a3 };
    } else {
      return { valid: false };
    }
  }
  function createZodEnum(values, params) {
    return new ZodEnum(__spreadValues({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum
    }, processCreateParams(params)));
  }
  var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z3;
  var init_lib3 = __esm({
    "node_modules/zod/lib/index.mjs"() {
      (function(util2) {
        util2.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util2.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util2.assertNever = assertNever;
        util2.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util2.getValidEnumValues = (obj) => {
          const validKeys = util2.objectKeys(obj).filter((k4) => typeof obj[obj[k4]] !== "number");
          const filtered = {};
          for (const k4 of validKeys) {
            filtered[k4] = obj[k4];
          }
          return util2.objectValues(filtered);
        };
        util2.objectValues = (obj) => {
          return util2.objectKeys(obj).map(function(e6) {
            return obj[e6];
          });
        };
        util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util2.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util2.joinValues = joinValues;
        util2.jsonStringifyReplacer = (_3, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util || (util = {}));
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return __spreadValues(__spreadValues({}, first), second);
        };
      })(objectUtil || (objectUtil = {}));
      ZodParsedType = util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      getParsedType = (data) => {
        const t3 = typeof data;
        switch (t3) {
          case "undefined":
            return ZodParsedType.undefined;
          case "string":
            return ZodParsedType.string;
          case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
          case "boolean":
            return ZodParsedType.boolean;
          case "function":
            return ZodParsedType.function;
          case "bigint":
            return ZodParsedType.bigint;
          case "symbol":
            return ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return ZodParsedType.array;
            }
            if (data === null) {
              return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return ZodParsedType.date;
            }
            return ZodParsedType.object;
          default:
            return ZodParsedType.unknown;
        }
      };
      ZodIssueCode = util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
      ]);
      quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
      };
      ZodError = class extends Error {
        constructor(issues) {
          super();
          this.issues = [];
          this.addIssue = (sub2) => {
            this.issues = [...this.issues, sub2];
          };
          this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
          };
          const actualProto = new.target.prototype;
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
          } else {
            this.__proto__ = actualProto;
          }
          this.name = "ZodError";
          this.issues = issues;
        }
        get errors() {
          return this.issues;
        }
        format(_mapper) {
          const mapper = _mapper || function(issue) {
            return issue.message;
          };
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union") {
                issue.unionErrors.map(processError);
              } else if (issue.code === "invalid_return_type") {
                processError(issue.returnTypeError);
              } else if (issue.code === "invalid_arguments") {
                processError(issue.argumentsError);
              } else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              } else {
                let curr = fieldErrors;
                let i5 = 0;
                while (i5 < issue.path.length) {
                  const el = issue.path[i5];
                  const terminal = i5 === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  } else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i5++;
                }
              }
            }
          };
          processError(this);
          return fieldErrors;
        }
        toString() {
          return this.message;
        }
        get message() {
          return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
          return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub2 of this.issues) {
            if (sub2.path.length > 0) {
              fieldErrors[sub2.path[0]] = fieldErrors[sub2.path[0]] || [];
              fieldErrors[sub2.path[0]].push(mapper(sub2));
            } else {
              formErrors.push(mapper(sub2));
            }
          }
          return { formErrors, fieldErrors };
        }
        get formErrors() {
          return this.flatten();
        }
      };
      ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
      };
      errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
          case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
              message = "Required";
            } else {
              message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
          case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
          case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
          case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
          case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
          case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
          case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
          case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
          case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
              if ("includes" in issue.validation) {
                message = `Invalid input: must include "${issue.validation.includes}"`;
                if (typeof issue.validation.position === "number") {
                  message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                }
              } else if ("startsWith" in issue.validation) {
                message = `Invalid input: must start with "${issue.validation.startsWith}"`;
              } else if ("endsWith" in issue.validation) {
                message = `Invalid input: must end with "${issue.validation.endsWith}"`;
              } else {
                util.assertNever(issue.validation);
              }
            } else if (issue.validation !== "regex") {
              message = `Invalid ${issue.validation}`;
            } else {
              message = "Invalid";
            }
            break;
          case ZodIssueCode.too_small:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.too_big:
            if (issue.type === "array")
              message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
              message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
              message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
              message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
              message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
              message = "Invalid input";
            break;
          case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
          case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
          case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
          case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
          default:
            message = _ctx.defaultError;
            util.assertNever(issue);
        }
        return { message };
      };
      overrideErrorMap = errorMap;
      makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = __spreadProps(__spreadValues({}, issueData), {
          path: fullPath
        });
        let errorMessage = "";
        const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
        for (const map3 of maps) {
          errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return __spreadProps(__spreadValues({}, issueData), {
          path: fullPath,
          message: issueData.message || errorMessage
        });
      };
      EMPTY_PATH = [];
      ParseStatus = class {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s3 of results) {
            if (s3.status === "aborted")
              return INVALID;
            if (s3.status === "dirty")
              status.dirty();
            arrayValue.push(s3.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
          const syncPairs = [];
          for (const pair of pairs) {
            syncPairs.push({
              key: await pair.key,
              value: await pair.value
            });
          }
          return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return INVALID;
            if (value.status === "aborted")
              return INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      };
      INVALID = Object.freeze({
        status: "aborted"
      });
      DIRTY = (value) => ({ status: "dirty", value });
      OK = (value) => ({ status: "valid", value });
      isAborted = (x4) => x4.status === "aborted";
      isDirty = (x4) => x4.status === "dirty";
      isValid = (x4) => x4.status === "valid";
      isAsync = (x4) => typeof Promise !== "undefined" && x4 instanceof Promise;
      (function(errorUtil2) {
        errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
      })(errorUtil || (errorUtil = {}));
      ParseInputLazyPath = class {
        constructor(parent, value, path, key) {
          this._cachedPath = [];
          this.parent = parent;
          this.data = value;
          this._path = path;
          this._key = key;
        }
        get path() {
          if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
              this._cachedPath.push(...this._path, ...this._key);
            } else {
              this._cachedPath.push(...this._path, this._key);
            }
          }
          return this._cachedPath;
        }
      };
      handleResult = (ctx, result) => {
        if (isValid(result)) {
          return { success: true, data: result.value };
        } else {
          if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
          }
          return {
            success: false,
            get error() {
              if (this._error)
                return this._error;
              const error = new ZodError(ctx.common.issues);
              this._error = error;
              return this._error;
            }
          };
        }
      };
      ZodType = class {
        constructor(def) {
          this.spa = this.safeParseAsync;
          this._def = def;
          this.parse = this.parse.bind(this);
          this.safeParse = this.safeParse.bind(this);
          this.parseAsync = this.parseAsync.bind(this);
          this.safeParseAsync = this.safeParseAsync.bind(this);
          this.spa = this.spa.bind(this);
          this.refine = this.refine.bind(this);
          this.refinement = this.refinement.bind(this);
          this.superRefine = this.superRefine.bind(this);
          this.optional = this.optional.bind(this);
          this.nullable = this.nullable.bind(this);
          this.nullish = this.nullish.bind(this);
          this.array = this.array.bind(this);
          this.promise = this.promise.bind(this);
          this.or = this.or.bind(this);
          this.and = this.and.bind(this);
          this.transform = this.transform.bind(this);
          this.brand = this.brand.bind(this);
          this.default = this.default.bind(this);
          this.catch = this.catch.bind(this);
          this.describe = this.describe.bind(this);
          this.pipe = this.pipe.bind(this);
          this.readonly = this.readonly.bind(this);
          this.isNullable = this.isNullable.bind(this);
          this.isOptional = this.isOptional.bind(this);
        }
        get description() {
          return this._def.description;
        }
        _getType(input) {
          return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
          return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          };
        }
        _processInputParams(input) {
          return {
            status: new ParseStatus(),
            ctx: {
              common: input.parent.common,
              data: input.data,
              parsedType: getParsedType(input.data),
              schemaErrorMap: this._def.errorMap,
              path: input.path,
              parent: input.parent
            }
          };
        }
        _parseSync(input) {
          const result = this._parse(input);
          if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
          }
          return result;
        }
        _parseAsync(input) {
          const result = this._parse(input);
          return Promise.resolve(result);
        }
        parse(data, params) {
          const result = this.safeParse(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        safeParse(data, params) {
          var _a;
          const ctx = {
            common: {
              issues: [],
              async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
              contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const result = this._parseSync({ data, path: ctx.path, parent: ctx });
          return handleResult(ctx, result);
        }
        async parseAsync(data, params) {
          const result = await this.safeParseAsync(data, params);
          if (result.success)
            return result.data;
          throw result.error;
        }
        async safeParseAsync(data, params) {
          const ctx = {
            common: {
              issues: [],
              contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
              async: true
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
          };
          const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
          const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
          return handleResult(ctx, result);
        }
        refine(check, message) {
          const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
              return { message };
            } else if (typeof message === "function") {
              return message(val);
            } else {
              return message;
            }
          };
          return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue(__spreadValues({
              code: ZodIssueCode.custom
            }, getIssueProperties(val)));
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then((data) => {
                if (!data) {
                  setError();
                  return false;
                } else {
                  return true;
                }
              });
            }
            if (!result) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        refinement(check, refinementData) {
          return this._refinement((val, ctx) => {
            if (!check(val)) {
              ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
              return false;
            } else {
              return true;
            }
          });
        }
        _refinement(refinement) {
          return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement }
          });
        }
        superRefine(refinement) {
          return this._refinement(refinement);
        }
        optional() {
          return ZodOptional.create(this, this._def);
        }
        nullable() {
          return ZodNullable.create(this, this._def);
        }
        nullish() {
          return this.nullable().optional();
        }
        array() {
          return ZodArray.create(this, this._def);
        }
        promise() {
          return ZodPromise.create(this, this._def);
        }
        or(option) {
          return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
          return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
          return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform }
          }));
        }
        default(def) {
          const defaultValueFunc = typeof def === "function" ? def : () => def;
          return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
          }));
        }
        brand() {
          return new ZodBranded(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this
          }, processCreateParams(this._def)));
        }
        catch(def) {
          const catchValueFunc = typeof def === "function" ? def : () => def;
          return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
          }));
        }
        describe(description) {
          const This = this.constructor;
          return new This(__spreadProps(__spreadValues({}, this._def), {
            description
          }));
        }
        pipe(target) {
          return ZodPipeline.create(this, target);
        }
        readonly() {
          return ZodReadonly.create(this);
        }
        isOptional() {
          return this.safeParse(void 0).success;
        }
        isNullable() {
          return this.safeParse(null).success;
        }
      };
      cuidRegex = /^c[^\s-]{8,}$/i;
      cuid2Regex = /^[a-z][a-z0-9]*$/;
      ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
      uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
      emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
      _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
      ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
      ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
      datetimeRegex = (args) => {
        if (args.precision) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
          }
        } else if (args.precision === 0) {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
          }
        } else {
          if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
          } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
          }
        }
      };
      ZodString = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = String(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.string) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(
              ctx2,
              {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx2.parsedType
              }
              //
            );
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.length < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.length > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "length") {
              const tooBig = input.data.length > check.value;
              const tooSmall = input.data.length < check.value;
              if (tooBig || tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                if (tooBig) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                } else if (tooSmall) {
                  addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: check.value,
                    type: "string",
                    inclusive: true,
                    exact: true,
                    message: check.message
                  });
                }
                status.dirty();
              }
            } else if (check.kind === "email") {
              if (!emailRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "email",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "emoji") {
              if (!emojiRegex) {
                emojiRegex = new RegExp(_emojiRegex, "u");
              }
              if (!emojiRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "emoji",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "uuid") {
              if (!uuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "uuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid") {
              if (!cuidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "cuid2") {
              if (!cuid2Regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "cuid2",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ulid") {
              if (!ulidRegex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ulid",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "url") {
              try {
                new URL(input.data);
              } catch (_a) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "url",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "regex") {
              check.regex.lastIndex = 0;
              const testResult = check.regex.test(input.data);
              if (!testResult) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "regex",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "trim") {
              input.data = input.data.trim();
            } else if (check.kind === "includes") {
              if (!input.data.includes(check.value, check.position)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { includes: check.value, position: check.position },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "toLowerCase") {
              input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
              input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
              if (!input.data.startsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { startsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "endsWith") {
              if (!input.data.endsWith(check.value)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: { endsWith: check.value },
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "datetime") {
              const regex = datetimeRegex(check);
              if (!regex.test(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_string,
                  validation: "datetime",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "ip") {
              if (!isValidIP(input.data, check.version)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  validation: "ip",
                  code: ZodIssueCode.invalid_string,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        _regex(regex, validation, message) {
          return this.refinement((data) => regex.test(data), __spreadValues({
            validation,
            code: ZodIssueCode.invalid_string
          }, errorUtil.errToObj(message)));
        }
        _addCheck(check) {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        email(message) {
          return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
        }
        url(message) {
          return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
        }
        emoji(message) {
          return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
        }
        uuid(message) {
          return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
        }
        cuid(message) {
          return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
        }
        cuid2(message) {
          return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
        }
        ulid(message) {
          return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
        }
        ip(options) {
          return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
        }
        datetime(options) {
          var _a;
          if (typeof options === "string") {
            return this._addCheck({
              kind: "datetime",
              precision: null,
              offset: false,
              message: options
            });
          }
          return this._addCheck(__spreadValues({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        regex(regex, message) {
          return this._addCheck(__spreadValues({
            kind: "regex",
            regex
          }, errorUtil.errToObj(message)));
        }
        includes(value, options) {
          return this._addCheck(__spreadValues({
            kind: "includes",
            value,
            position: options === null || options === void 0 ? void 0 : options.position
          }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
        }
        startsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "startsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        endsWith(value, message) {
          return this._addCheck(__spreadValues({
            kind: "endsWith",
            value
          }, errorUtil.errToObj(message)));
        }
        min(minLength, message) {
          return this._addCheck(__spreadValues({
            kind: "min",
            value: minLength
          }, errorUtil.errToObj(message)));
        }
        max(maxLength, message) {
          return this._addCheck(__spreadValues({
            kind: "max",
            value: maxLength
          }, errorUtil.errToObj(message)));
        }
        length(len, message) {
          return this._addCheck(__spreadValues({
            kind: "length",
            value: len
          }, errorUtil.errToObj(message)));
        }
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        nonempty(message) {
          return this.min(1, errorUtil.errToObj(message));
        }
        trim() {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "trim" }]
          }));
        }
        toLowerCase() {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toLowerCase" }]
          }));
        }
        toUpperCase() {
          return new ZodString(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, { kind: "toUpperCase" }]
          }));
        }
        get isDatetime() {
          return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
          return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
          return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
          return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
          return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
          return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
          return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
          return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
          let min3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min3 === null || ch.value > min3)
                min3 = ch.value;
            }
          }
          return min3;
        }
        get maxLength() {
          let max3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max3 === null || ch.value < max3)
                max3 = ch.value;
            }
          }
          return max3;
        }
      };
      ZodString.create = (params) => {
        var _a;
        return new ZodString(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodString,
          coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params)));
      };
      ZodNumber = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
          this.step = this.multipleOf;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = Number(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.number) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.number,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "int") {
              if (!util.isInteger(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "number",
                  inclusive: check.inclusive,
                  exact: false,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (floatSafeRemainder(input.data, check.value) !== 0) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "finite") {
              if (!Number.isFinite(input.data)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_finite,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodNumber(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        int(message) {
          return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
          });
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        finite(message) {
          return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
          });
        }
        safe(message) {
          return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
          })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min3 === null || ch.value > min3)
                min3 = ch.value;
            }
          }
          return min3;
        }
        get maxValue() {
          let max3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max3 === null || ch.value < max3)
                max3 = ch.value;
            }
          }
          return max3;
        }
        get isInt() {
          return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
        }
        get isFinite() {
          let max3 = null, min3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
              return true;
            } else if (ch.kind === "min") {
              if (min3 === null || ch.value > min3)
                min3 = ch.value;
            } else if (ch.kind === "max") {
              if (max3 === null || ch.value < max3)
                max3 = ch.value;
            }
          }
          return Number.isFinite(min3) && Number.isFinite(max3);
        }
      };
      ZodNumber.create = (params) => {
        return new ZodNumber(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodNumber,
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
        }, processCreateParams(params)));
      };
      ZodBigInt = class extends ZodType {
        constructor() {
          super(...arguments);
          this.min = this.gte;
          this.max = this.lte;
        }
        _parse(input) {
          if (this._def.coerce) {
            input.data = BigInt(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.bigint) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.bigint,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          let ctx = void 0;
          const status = new ParseStatus();
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
              if (tooSmall) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  type: "bigint",
                  minimum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
              if (tooBig) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  type: "bigint",
                  maximum: check.value,
                  inclusive: check.inclusive,
                  message: check.message
                });
                status.dirty();
              }
            } else if (check.kind === "multipleOf") {
              if (input.data % check.value !== BigInt(0)) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.not_multiple_of,
                  multipleOf: check.value,
                  message: check.message
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return { status: status.value, value: input.data };
        }
        gte(value, message) {
          return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
          return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
          return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
          return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [
              ...this._def.checks,
              {
                kind,
                value,
                inclusive,
                message: errorUtil.toString(message)
              }
            ]
          }));
        }
        _addCheck(check) {
          return new ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        positive(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        negative(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
          });
        }
        nonpositive(message) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        nonnegative(message) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
          });
        }
        multipleOf(value, message) {
          return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
          });
        }
        get minValue() {
          let min3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min3 === null || ch.value > min3)
                min3 = ch.value;
            }
          }
          return min3;
        }
        get maxValue() {
          let max3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max3 === null || ch.value < max3)
                max3 = ch.value;
            }
          }
          return max3;
        }
      };
      ZodBigInt.create = (params) => {
        var _a;
        return new ZodBigInt(__spreadValues({
          checks: [],
          typeName: ZodFirstPartyTypeKind.ZodBigInt,
          coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false
        }, processCreateParams(params)));
      };
      ZodBoolean = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = Boolean(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.boolean,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodBoolean.create = (params) => {
        return new ZodBoolean(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodBoolean,
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
        }, processCreateParams(params)));
      };
      ZodDate = class extends ZodType {
        _parse(input) {
          if (this._def.coerce) {
            input.data = new Date(input.data);
          }
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.date) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.date,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          if (isNaN(input.data.getTime())) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_date
            });
            return INVALID;
          }
          const status = new ParseStatus();
          let ctx = void 0;
          for (const check of this._def.checks) {
            if (check.kind === "min") {
              if (input.data.getTime() < check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  minimum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else if (check.kind === "max") {
              if (input.data.getTime() > check.value) {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  message: check.message,
                  inclusive: true,
                  exact: false,
                  maximum: check.value,
                  type: "date"
                });
                status.dirty();
              }
            } else {
              util.assertNever(check);
            }
          }
          return {
            status: status.value,
            value: new Date(input.data.getTime())
          };
        }
        _addCheck(check) {
          return new ZodDate(__spreadProps(__spreadValues({}, this._def), {
            checks: [...this._def.checks, check]
          }));
        }
        min(minDate, message) {
          return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        max(maxDate, message) {
          return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
          });
        }
        get minDate() {
          let min3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "min") {
              if (min3 === null || ch.value > min3)
                min3 = ch.value;
            }
          }
          return min3 != null ? new Date(min3) : null;
        }
        get maxDate() {
          let max3 = null;
          for (const ch of this._def.checks) {
            if (ch.kind === "max") {
              if (max3 === null || ch.value < max3)
                max3 = ch.value;
            }
          }
          return max3 != null ? new Date(max3) : null;
        }
      };
      ZodDate.create = (params) => {
        return new ZodDate(__spreadValues({
          checks: [],
          coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
          typeName: ZodFirstPartyTypeKind.ZodDate
        }, processCreateParams(params)));
      };
      ZodSymbol = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.symbol,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodSymbol.create = (params) => {
        return new ZodSymbol(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodSymbol
        }, processCreateParams(params)));
      };
      ZodUndefined = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.undefined,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodUndefined.create = (params) => {
        return new ZodUndefined(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUndefined
        }, processCreateParams(params)));
      };
      ZodNull = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.null,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodNull.create = (params) => {
        return new ZodNull(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNull
        }, processCreateParams(params)));
      };
      ZodAny = class extends ZodType {
        constructor() {
          super(...arguments);
          this._any = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodAny.create = (params) => {
        return new ZodAny(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodAny
        }, processCreateParams(params)));
      };
      ZodUnknown = class extends ZodType {
        constructor() {
          super(...arguments);
          this._unknown = true;
        }
        _parse(input) {
          return OK(input.data);
        }
      };
      ZodUnknown.create = (params) => {
        return new ZodUnknown(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodUnknown
        }, processCreateParams(params)));
      };
      ZodNever = class extends ZodType {
        _parse(input) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
          });
          return INVALID;
        }
      };
      ZodNever.create = (params) => {
        return new ZodNever(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNever
        }, processCreateParams(params)));
      };
      ZodVoid = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.void,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return OK(input.data);
        }
      };
      ZodVoid.create = (params) => {
        return new ZodVoid(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodVoid
        }, processCreateParams(params)));
      };
      ZodArray = class extends ZodType {
        _parse(input) {
          const { ctx, status } = this._processInputParams(input);
          const def = this._def;
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
              addIssueToContext(ctx, {
                code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                minimum: tooSmall ? def.exactLength.value : void 0,
                maximum: tooBig ? def.exactLength.value : void 0,
                type: "array",
                inclusive: true,
                exact: true,
                message: def.exactLength.message
              });
              status.dirty();
            }
          }
          if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.minLength.message
              });
              status.dirty();
            }
          }
          if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxLength.value,
                type: "array",
                inclusive: true,
                exact: false,
                message: def.maxLength.message
              });
              status.dirty();
            }
          }
          if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i5) => {
              return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i5));
            })).then((result2) => {
              return ParseStatus.mergeArray(status, result2);
            });
          }
          const result = [...ctx.data].map((item, i5) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i5));
          });
          return ParseStatus.mergeArray(status, result);
        }
        get element() {
          return this._def.type;
        }
        min(minLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            minLength: { value: minLength, message: errorUtil.toString(message) }
          }));
        }
        max(maxLength, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            maxLength: { value: maxLength, message: errorUtil.toString(message) }
          }));
        }
        length(len, message) {
          return new ZodArray(__spreadProps(__spreadValues({}, this._def), {
            exactLength: { value: len, message: errorUtil.toString(message) }
          }));
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodArray.create = (schema, params) => {
        return new ZodArray(__spreadValues({
          type: schema,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: ZodFirstPartyTypeKind.ZodArray
        }, processCreateParams(params)));
      };
      ZodObject = class extends ZodType {
        constructor() {
          super(...arguments);
          this._cached = null;
          this.nonstrict = this.passthrough;
          this.augment = this.extend;
        }
        _getCached() {
          if (this._cached !== null)
            return this._cached;
          const shape = this._def.shape();
          const keys = util.objectKeys(shape);
          return this._cached = { shape, keys };
        }
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.object) {
            const ctx2 = this._getOrReturnCtx(input);
            addIssueToContext(ctx2, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx2.parsedType
            });
            return INVALID;
          }
          const { status, ctx } = this._processInputParams(input);
          const { shape, keys: shapeKeys } = this._getCached();
          const extraKeys = [];
          if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
              if (!shapeKeys.includes(key)) {
                extraKeys.push(key);
              }
            }
          }
          const pairs = [];
          for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
          if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
              for (const key of extraKeys) {
                pairs.push({
                  key: { status: "valid", value: key },
                  value: { status: "valid", value: ctx.data[key] }
                });
              }
            } else if (unknownKeys === "strict") {
              if (extraKeys.length > 0) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.unrecognized_keys,
                  keys: extraKeys
                });
                status.dirty();
              }
            } else if (unknownKeys === "strip")
              ;
            else {
              throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
          } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
              const value = ctx.data[key];
              pairs.push({
                key: { status: "valid", value: key },
                value: catchall._parse(
                  new ParseInputLazyPath(ctx, value, ctx.path, key)
                  //, ctx.child(key), value, getParsedType(value)
                ),
                alwaysSet: key in ctx.data
              });
            }
          }
          if (ctx.common.async) {
            return Promise.resolve().then(async () => {
              const syncPairs = [];
              for (const pair of pairs) {
                const key = await pair.key;
                syncPairs.push({
                  key,
                  value: await pair.value,
                  alwaysSet: pair.alwaysSet
                });
              }
              return syncPairs;
            }).then((syncPairs) => {
              return ParseStatus.mergeObjectSync(status, syncPairs);
            });
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get shape() {
          return this._def.shape();
        }
        strict(message) {
          errorUtil.errToObj;
          return new ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strict"
          }), message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}));
        }
        strip() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "strip"
          }));
        }
        passthrough() {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            unknownKeys: "passthrough"
          }));
        }
        // const AugmentFactory =
        //   <Def extends ZodObjectDef>(def: Def) =>
        //   <Augmentation extends ZodRawShape>(
        //     augmentation: Augmentation
        //   ): ZodObject<
        //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
        //     Def["unknownKeys"],
        //     Def["catchall"]
        //   > => {
        //     return new ZodObject({
        //       ...def,
        //       shape: () => ({
        //         ...def.shape(),
        //         ...augmentation,
        //       }),
        //     }) as any;
        //   };
        extend(augmentation) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
          }));
        }
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        merge(merging) {
          const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject
          });
          return merged;
        }
        // merge<
        //   Incoming extends AnyZodObject,
        //   Augmentation extends Incoming["shape"],
        //   NewOutput extends {
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   },
        //   NewInput extends {
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }
        // >(
        //   merging: Incoming
        // ): ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"],
        //   NewOutput,
        //   NewInput
        // > {
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        setKey(key, schema) {
          return this.augment({ [key]: schema });
        }
        // merge<Incoming extends AnyZodObject>(
        //   merging: Incoming
        // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
        // ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"]
        // > {
        //   // const mergedShape = objectUtil.mergeShapes(
        //   //   this._def.shape(),
        //   //   merging._def.shape()
        //   // );
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        catchall(index2) {
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            catchall: index2
          }));
        }
        pick(mask) {
          const shape = {};
          util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        omit(mask) {
          const shape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
              shape[key] = this.shape[key];
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => shape
          }));
        }
        /**
         * @deprecated
         */
        deepPartial() {
          return deepPartialify(this);
        }
        partial(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
              newShape[key] = fieldSchema;
            } else {
              newShape[key] = fieldSchema.optional();
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        required(mask) {
          const newShape = {};
          util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
          return new ZodObject(__spreadProps(__spreadValues({}, this._def), {
            shape: () => newShape
          }));
        }
        keyof() {
          return createZodEnum(util.objectKeys(this.shape));
        }
      };
      ZodObject.create = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodObject.strictCreate = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape: () => shape,
          unknownKeys: "strict",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodObject.lazycreate = (shape, params) => {
        return new ZodObject(__spreadValues({
          shape,
          unknownKeys: "strip",
          catchall: ZodNever.create(),
          typeName: ZodFirstPartyTypeKind.ZodObject
        }, processCreateParams(params)));
      };
      ZodUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const options = this._def.options;
          function handleResults(results) {
            for (const result of results) {
              if (result.result.status === "valid") {
                return result.result;
              }
            }
            for (const result of results) {
              if (result.result.status === "dirty") {
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
              }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              return {
                result: await option._parseAsync({
                  data: ctx.data,
                  path: ctx.path,
                  parent: childCtx
                }),
                ctx: childCtx
              };
            })).then(handleResults);
          } else {
            let dirty = void 0;
            const issues = [];
            for (const option of options) {
              const childCtx = __spreadProps(__spreadValues({}, ctx), {
                common: __spreadProps(__spreadValues({}, ctx.common), {
                  issues: []
                }),
                parent: null
              });
              const result = option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              });
              if (result.status === "valid") {
                return result;
              } else if (result.status === "dirty" && !dirty) {
                dirty = { result, ctx: childCtx };
              }
              if (childCtx.common.issues.length) {
                issues.push(childCtx.common.issues);
              }
            }
            if (dirty) {
              ctx.common.issues.push(...dirty.ctx.common.issues);
              return dirty.result;
            }
            const unionErrors = issues.map((issues2) => new ZodError(issues2));
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union,
              unionErrors
            });
            return INVALID;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      ZodUnion.create = (types, params) => {
        return new ZodUnion(__spreadValues({
          options: types,
          typeName: ZodFirstPartyTypeKind.ZodUnion
        }, processCreateParams(params)));
      };
      getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
          return getDiscriminator(type.schema);
        } else if (type instanceof ZodEffects) {
          return getDiscriminator(type.innerType());
        } else if (type instanceof ZodLiteral) {
          return [type.value];
        } else if (type instanceof ZodEnum) {
          return type.options;
        } else if (type instanceof ZodNativeEnum) {
          return Object.keys(type.enum);
        } else if (type instanceof ZodDefault) {
          return getDiscriminator(type._def.innerType);
        } else if (type instanceof ZodUndefined) {
          return [void 0];
        } else if (type instanceof ZodNull) {
          return [null];
        } else {
          return null;
        }
      };
      ZodDiscriminatedUnion = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const discriminator = this.discriminator;
          const discriminatorValue = ctx.data[discriminator];
          const option = this.optionsMap.get(discriminatorValue);
          if (!option) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [discriminator]
            });
            return INVALID;
          }
          if (ctx.common.async) {
            return option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          } else {
            return option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        get discriminator() {
          return this._def.discriminator;
        }
        get options() {
          return this._def.options;
        }
        get optionsMap() {
          return this._def.optionsMap;
        }
        /**
         * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
         * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
         * have a different value for each object in the union.
         * @param discriminator the name of the discriminator property
         * @param types an array of object schemas
         * @param params
         */
        static create(discriminator, options, params) {
          const optionsMap = /* @__PURE__ */ new Map();
          for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
              throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
              if (optionsMap.has(value)) {
                throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
              }
              optionsMap.set(value, type);
            }
          }
          return new ZodDiscriminatedUnion(__spreadValues({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap
          }, processCreateParams(params)));
        }
      };
      ZodIntersection = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
              return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_intersection_types
              });
              return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
              status.dirty();
            }
            return { status: status.value, value: merged.data };
          };
          if (ctx.common.async) {
            return Promise.all([
              this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              }),
              this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              })
            ]).then(([left, right]) => handleParsed(left, right));
          } else {
            return handleParsed(this._def.left._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }), this._def.right._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }));
          }
        }
      };
      ZodIntersection.create = (left, right, params) => {
        return new ZodIntersection(__spreadValues({
          left,
          right,
          typeName: ZodFirstPartyTypeKind.ZodIntersection
        }, processCreateParams(params)));
      };
      ZodTuple = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.array,
              received: ctx.parsedType
            });
            return INVALID;
          }
          if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            return INVALID;
          }
          const rest = this._def.rest;
          if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: this._def.items.length,
              inclusive: true,
              exact: false,
              type: "array"
            });
            status.dirty();
          }
          const items = [...ctx.data].map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
              return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
          }).filter((x4) => !!x4);
          if (ctx.common.async) {
            return Promise.all(items).then((results) => {
              return ParseStatus.mergeArray(status, results);
            });
          } else {
            return ParseStatus.mergeArray(status, items);
          }
        }
        get items() {
          return this._def.items;
        }
        rest(rest) {
          return new ZodTuple(__spreadProps(__spreadValues({}, this._def), {
            rest
          }));
        }
      };
      ZodTuple.create = (schemas, params) => {
        if (!Array.isArray(schemas)) {
          throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple(__spreadValues({
          items: schemas,
          typeName: ZodFirstPartyTypeKind.ZodTuple,
          rest: null
        }, processCreateParams(params)));
      };
      ZodRecord = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.object,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const pairs = [];
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          for (const key in ctx.data) {
            pairs.push({
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
              value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
          }
          if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
          } else {
            return ParseStatus.mergeObjectSync(status, pairs);
          }
        }
        get element() {
          return this._def.valueType;
        }
        static create(first, second, third) {
          if (second instanceof ZodType) {
            return new ZodRecord(__spreadValues({
              keyType: first,
              valueType: second,
              typeName: ZodFirstPartyTypeKind.ZodRecord
            }, processCreateParams(third)));
          }
          return new ZodRecord(__spreadValues({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord
          }, processCreateParams(second)));
        }
      };
      ZodMap = class extends ZodType {
        get keySchema() {
          return this._def.keyType;
        }
        get valueSchema() {
          return this._def.valueType;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.map,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const keyType = this._def.keyType;
          const valueType = this._def.valueType;
          const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
            return {
              key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
              value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
            };
          });
          if (ctx.common.async) {
            const finalMap = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async () => {
              for (const pair of pairs) {
                const key = await pair.key;
                const value = await pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                  return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                  status.dirty();
                }
                finalMap.set(key.value, value.value);
              }
              return { status: status.value, value: finalMap };
            });
          } else {
            const finalMap = /* @__PURE__ */ new Map();
            for (const pair of pairs) {
              const key = pair.key;
              const value = pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          }
        }
      };
      ZodMap.create = (keyType, valueType, params) => {
        return new ZodMap(__spreadValues({
          valueType,
          keyType,
          typeName: ZodFirstPartyTypeKind.ZodMap
        }, processCreateParams(params)));
      };
      ZodSet = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.set,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const def = this._def;
          if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: def.minSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.minSize.message
              });
              status.dirty();
            }
          }
          if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: def.maxSize.value,
                type: "set",
                inclusive: true,
                exact: false,
                message: def.maxSize.message
              });
              status.dirty();
            }
          }
          const valueType = this._def.valueType;
          function finalizeSet(elements2) {
            const parsedSet = /* @__PURE__ */ new Set();
            for (const element of elements2) {
              if (element.status === "aborted")
                return INVALID;
              if (element.status === "dirty")
                status.dirty();
              parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
          }
          const elements = [...ctx.data.values()].map((item, i5) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i5)));
          if (ctx.common.async) {
            return Promise.all(elements).then((elements2) => finalizeSet(elements2));
          } else {
            return finalizeSet(elements);
          }
        }
        min(minSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            minSize: { value: minSize, message: errorUtil.toString(message) }
          }));
        }
        max(maxSize, message) {
          return new ZodSet(__spreadProps(__spreadValues({}, this._def), {
            maxSize: { value: maxSize, message: errorUtil.toString(message) }
          }));
        }
        size(size2, message) {
          return this.min(size2, message).max(size2, message);
        }
        nonempty(message) {
          return this.min(1, message);
        }
      };
      ZodSet.create = (valueType, params) => {
        return new ZodSet(__spreadValues({
          valueType,
          minSize: null,
          maxSize: null,
          typeName: ZodFirstPartyTypeKind.ZodSet
        }, processCreateParams(params)));
      };
      ZodFunction = class extends ZodType {
        constructor() {
          super(...arguments);
          this.validate = this.implement;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.function,
              received: ctx.parsedType
            });
            return INVALID;
          }
          function makeArgsIssue(args, error) {
            return makeIssue({
              data: args,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x4) => !!x4),
              issueData: {
                code: ZodIssueCode.invalid_arguments,
                argumentsError: error
              }
            });
          }
          function makeReturnsIssue(returns, error) {
            return makeIssue({
              data: returns,
              path: ctx.path,
              errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap
              ].filter((x4) => !!x4),
              issueData: {
                code: ZodIssueCode.invalid_return_type,
                returnTypeError: error
              }
            });
          }
          const params = { errorMap: ctx.common.contextualErrorMap };
          const fn2 = ctx.data;
          if (this._def.returns instanceof ZodPromise) {
            const me = this;
            return OK(async function(...args) {
              const error = new ZodError([]);
              const parsedArgs = await me._def.args.parseAsync(args, params).catch((e6) => {
                error.addIssue(makeArgsIssue(args, e6));
                throw error;
              });
              const result = await Reflect.apply(fn2, this, parsedArgs);
              const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e6) => {
                error.addIssue(makeReturnsIssue(result, e6));
                throw error;
              });
              return parsedReturns;
            });
          } else {
            const me = this;
            return OK(function(...args) {
              const parsedArgs = me._def.args.safeParse(args, params);
              if (!parsedArgs.success) {
                throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
              }
              const result = Reflect.apply(fn2, this, parsedArgs.data);
              const parsedReturns = me._def.returns.safeParse(result, params);
              if (!parsedReturns.success) {
                throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
              }
              return parsedReturns.data;
            });
          }
        }
        parameters() {
          return this._def.args;
        }
        returnType() {
          return this._def.returns;
        }
        args(...items) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            args: ZodTuple.create(items).rest(ZodUnknown.create())
          }));
        }
        returns(returnType) {
          return new ZodFunction(__spreadProps(__spreadValues({}, this._def), {
            returns: returnType
          }));
        }
        implement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        strictImplement(func) {
          const validatedFunc = this.parse(func);
          return validatedFunc;
        }
        static create(args, returns, params) {
          return new ZodFunction(__spreadValues({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction
          }, processCreateParams(params)));
        }
      };
      ZodLazy = class extends ZodType {
        get schema() {
          return this._def.getter();
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const lazySchema = this._def.getter();
          return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
      };
      ZodLazy.create = (getter, params) => {
        return new ZodLazy(__spreadValues({
          getter,
          typeName: ZodFirstPartyTypeKind.ZodLazy
        }, processCreateParams(params)));
      };
      ZodLiteral = class extends ZodType {
        _parse(input) {
          if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_literal,
              expected: this._def.value
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
        get value() {
          return this._def.value;
        }
      };
      ZodLiteral.create = (value, params) => {
        return new ZodLiteral(__spreadValues({
          value,
          typeName: ZodFirstPartyTypeKind.ZodLiteral
        }, processCreateParams(params)));
      };
      ZodEnum = class extends ZodType {
        _parse(input) {
          if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Values() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        get Enum() {
          const enumValues = {};
          for (const val of this._def.values) {
            enumValues[val] = val;
          }
          return enumValues;
        }
        extract(values) {
          return ZodEnum.create(values);
        }
        exclude(values) {
          return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
      };
      ZodEnum.create = createZodEnum;
      ZodNativeEnum = class extends ZodType {
        _parse(input) {
          const nativeEnumValues = util.getValidEnumValues(this._def.values);
          const ctx = this._getOrReturnCtx(input);
          if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              expected: util.joinValues(expectedValues),
              received: ctx.parsedType,
              code: ZodIssueCode.invalid_type
            });
            return INVALID;
          }
          if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
              received: ctx.data,
              code: ZodIssueCode.invalid_enum_value,
              options: expectedValues
            });
            return INVALID;
          }
          return OK(input.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      ZodNativeEnum.create = (values, params) => {
        return new ZodNativeEnum(__spreadValues({
          values,
          typeName: ZodFirstPartyTypeKind.ZodNativeEnum
        }, processCreateParams(params)));
      };
      ZodPromise = class extends ZodType {
        unwrap() {
          return this._def.type;
        }
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.promise,
              received: ctx.parsedType
            });
            return INVALID;
          }
          const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
          return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
              path: ctx.path,
              errorMap: ctx.common.contextualErrorMap
            });
          }));
        }
      };
      ZodPromise.create = (schema, params) => {
        return new ZodPromise(__spreadValues({
          type: schema,
          typeName: ZodFirstPartyTypeKind.ZodPromise
        }, processCreateParams(params)));
      };
      ZodEffects = class extends ZodType {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          const effect = this._def.effect || null;
          const checkCtx = {
            addIssue: (arg2) => {
              addIssueToContext(ctx, arg2);
              if (arg2.fatal) {
                status.abort();
              } else {
                status.dirty();
              }
            },
            get path() {
              return ctx.path;
            }
          };
          checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
          if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
              return {
                status: "dirty",
                value: ctx.data
              };
            }
            if (ctx.common.async) {
              return Promise.resolve(processed).then((processed2) => {
                return this._def.schema._parseAsync({
                  data: processed2,
                  path: ctx.path,
                  parent: ctx
                });
              });
            } else {
              return this._def.schema._parseSync({
                data: processed,
                path: ctx.path,
                parent: ctx
              });
            }
          }
          if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
              const result = effect.refinement(acc, checkCtx);
              if (ctx.common.async) {
                return Promise.resolve(result);
              }
              if (result instanceof Promise) {
                throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
              }
              return acc;
            };
            if (ctx.common.async === false) {
              const inner = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              executeRefinement(inner.value);
              return { status: status.value, value: inner.value };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                if (inner.status === "aborted")
                  return INVALID;
                if (inner.status === "dirty")
                  status.dirty();
                return executeRefinement(inner.value).then(() => {
                  return { status: status.value, value: inner.value };
                });
              });
            }
          }
          if (effect.type === "transform") {
            if (ctx.common.async === false) {
              const base = this._def.schema._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (!isValid(base))
                return base;
              const result = effect.transform(base.value, checkCtx);
              if (result instanceof Promise) {
                throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
              }
              return { status: status.value, value: result };
            } else {
              return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                if (!isValid(base))
                  return base;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
              });
            }
          }
          util.assertNever(effect);
        }
      };
      ZodEffects.create = (schema, effect, params) => {
        return new ZodEffects(__spreadValues({
          schema,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect
        }, processCreateParams(params)));
      };
      ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects(__spreadValues({
          schema,
          effect: { type: "preprocess", transform: preprocess },
          typeName: ZodFirstPartyTypeKind.ZodEffects
        }, processCreateParams(params)));
      };
      ZodOptional = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.undefined) {
            return OK(void 0);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodOptional.create = (type, params) => {
        return new ZodOptional(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodOptional
        }, processCreateParams(params)));
      };
      ZodNullable = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType === ZodParsedType.null) {
            return OK(null);
          }
          return this._def.innerType._parse(input);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      ZodNullable.create = (type, params) => {
        return new ZodNullable(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodNullable
        }, processCreateParams(params)));
      };
      ZodDefault = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          let data = ctx.data;
          if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
          }
          return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      ZodDefault.create = (type, params) => {
        return new ZodDefault(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodDefault,
          defaultValue: typeof params.default === "function" ? params.default : () => params.default
        }, processCreateParams(params)));
      };
      ZodCatch = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const newCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            })
          });
          const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: __spreadValues({}, newCtx)
          });
          if (isAsync(result)) {
            return result.then((result2) => {
              return {
                status: "valid",
                value: result2.status === "valid" ? result2.value : this._def.catchValue({
                  get error() {
                    return new ZodError(newCtx.common.issues);
                  },
                  input: newCtx.data
                })
              };
            });
          } else {
            return {
              status: "valid",
              value: result.status === "valid" ? result.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          }
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      ZodCatch.create = (type, params) => {
        return new ZodCatch(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodCatch,
          catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
        }, processCreateParams(params)));
      };
      ZodNaN = class extends ZodType {
        _parse(input) {
          const parsedType = this._getType(input);
          if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.nan,
              received: ctx.parsedType
            });
            return INVALID;
          }
          return { status: "valid", value: input.data };
        }
      };
      ZodNaN.create = (params) => {
        return new ZodNaN(__spreadValues({
          typeName: ZodFirstPartyTypeKind.ZodNaN
        }, processCreateParams(params)));
      };
      BRAND = Symbol("zod_brand");
      ZodBranded = class extends ZodType {
        _parse(input) {
          const { ctx } = this._processInputParams(input);
          const data = ctx.data;
          return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
          });
        }
        unwrap() {
          return this._def.type;
        }
      };
      ZodPipeline = class extends ZodType {
        _parse(input) {
          const { status, ctx } = this._processInputParams(input);
          if (ctx.common.async) {
            const handleAsync = async () => {
              const inResult = await this._def.in._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
              });
              if (inResult.status === "aborted")
                return INVALID;
              if (inResult.status === "dirty") {
                status.dirty();
                return DIRTY(inResult.value);
              } else {
                return this._def.out._parseAsync({
                  data: inResult.value,
                  path: ctx.path,
                  parent: ctx
                });
              }
            };
            return handleAsync();
          } else {
            const inResult = this._def.in._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return {
                status: "dirty",
                value: inResult.value
              };
            } else {
              return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }
        }
        static create(a3, b3) {
          return new ZodPipeline({
            in: a3,
            out: b3,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
          });
        }
      };
      ZodReadonly = class extends ZodType {
        _parse(input) {
          const result = this._def.innerType._parse(input);
          if (isValid(result)) {
            result.value = Object.freeze(result.value);
          }
          return result;
        }
      };
      ZodReadonly.create = (type, params) => {
        return new ZodReadonly(__spreadValues({
          innerType: type,
          typeName: ZodFirstPartyTypeKind.ZodReadonly
        }, processCreateParams(params)));
      };
      custom = (check, params = {}, fatal) => {
        if (check)
          return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
              const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
              const _fatal = (_b = (_a = p3.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
              const p22 = typeof p3 === "string" ? { message: p3 } : p3;
              ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p22), { fatal: _fatal }));
            }
          });
        return ZodAny.create();
      };
      late = {
        object: ZodObject.lazycreate
      };
      (function(ZodFirstPartyTypeKind2) {
        ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
      })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
      instanceOfType = (cls, params = {
        message: `Input not instance of ${cls.name}`
      }) => custom((data) => data instanceof cls, params);
      stringType = ZodString.create;
      numberType = ZodNumber.create;
      nanType = ZodNaN.create;
      bigIntType = ZodBigInt.create;
      booleanType = ZodBoolean.create;
      dateType = ZodDate.create;
      symbolType = ZodSymbol.create;
      undefinedType = ZodUndefined.create;
      nullType = ZodNull.create;
      anyType = ZodAny.create;
      unknownType = ZodUnknown.create;
      neverType = ZodNever.create;
      voidType = ZodVoid.create;
      arrayType = ZodArray.create;
      objectType = ZodObject.create;
      strictObjectType = ZodObject.strictCreate;
      unionType = ZodUnion.create;
      discriminatedUnionType = ZodDiscriminatedUnion.create;
      intersectionType = ZodIntersection.create;
      tupleType = ZodTuple.create;
      recordType = ZodRecord.create;
      mapType = ZodMap.create;
      setType = ZodSet.create;
      functionType = ZodFunction.create;
      lazyType = ZodLazy.create;
      literalType = ZodLiteral.create;
      enumType = ZodEnum.create;
      nativeEnumType = ZodNativeEnum.create;
      promiseType = ZodPromise.create;
      effectsType = ZodEffects.create;
      optionalType = ZodOptional.create;
      nullableType = ZodNullable.create;
      preprocessType = ZodEffects.createWithPreprocess;
      pipelineType = ZodPipeline.create;
      ostring = () => stringType().optional();
      onumber = () => numberType().optional();
      oboolean = () => booleanType().optional();
      coerce = {
        string: (arg2) => ZodString.create(__spreadProps(__spreadValues({}, arg2), { coerce: true })),
        number: (arg2) => ZodNumber.create(__spreadProps(__spreadValues({}, arg2), { coerce: true })),
        boolean: (arg2) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg2), {
          coerce: true
        })),
        bigint: (arg2) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg2), { coerce: true })),
        date: (arg2) => ZodDate.create(__spreadProps(__spreadValues({}, arg2), { coerce: true }))
      };
      NEVER = INVALID;
      z3 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap,
        getErrorMap,
        makeIssue,
        EMPTY_PATH,
        addIssueToContext,
        ParseStatus,
        INVALID,
        DIRTY,
        OK,
        isAborted,
        isDirty,
        isValid,
        isAsync,
        get util() {
          return util;
        },
        get objectUtil() {
          return objectUtil;
        },
        ZodParsedType,
        getParsedType,
        ZodType,
        ZodString,
        ZodNumber,
        ZodBigInt,
        ZodBoolean,
        ZodDate,
        ZodSymbol,
        ZodUndefined,
        ZodNull,
        ZodAny,
        ZodUnknown,
        ZodNever,
        ZodVoid,
        ZodArray,
        ZodObject,
        ZodUnion,
        ZodDiscriminatedUnion,
        ZodIntersection,
        ZodTuple,
        ZodRecord,
        ZodMap,
        ZodSet,
        ZodFunction,
        ZodLazy,
        ZodLiteral,
        ZodEnum,
        ZodNativeEnum,
        ZodPromise,
        ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional,
        ZodNullable,
        ZodDefault,
        ZodCatch,
        ZodNaN,
        BRAND,
        ZodBranded,
        ZodPipeline,
        ZodReadonly,
        custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late,
        get ZodFirstPartyTypeKind() {
          return ZodFirstPartyTypeKind;
        },
        coerce,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        "enum": enumType,
        "function": functionType,
        "instanceof": instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        "null": nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean,
        onumber,
        optional: optionalType,
        ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        "undefined": undefinedType,
        union: unionType,
        unknown: unknownType,
        "void": voidType,
        NEVER,
        ZodIssueCode,
        quotelessJson,
        ZodError
      });
    }
  });

  // node_modules/validator/lib/util/assertString.js
  var require_assertString = __commonJS({
    "node_modules/validator/lib/util/assertString.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = assertString;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function assertString(input) {
        var isString2 = typeof input === "string" || input instanceof String;
        if (!isString2) {
          var invalidType = _typeof2(input);
          if (input === null)
            invalidType = "null";
          else if (invalidType === "object")
            invalidType = input.constructor.name;
          throw new TypeError("Expected a string but received a ".concat(invalidType));
        }
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/toDate.js
  var require_toDate = __commonJS({
    "node_modules/validator/lib/toDate.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toDate;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function toDate(date) {
        (0, _assertString.default)(date);
        date = Date.parse(date);
        return !isNaN(date) ? new Date(date) : null;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/alpha.js
  var require_alpha = __commonJS({
    "node_modules/validator/lib/alpha.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.commaDecimal = exports.dotDecimal = exports.bengaliLocales = exports.farsiLocales = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
      var alpha = {
        "en-US": /^[A-Z]+$/i,
        "az-AZ": /^[A-VXYZ]+$/i,
        "bg-BG": /^[-]+$/i,
        "cs-CZ": /^[A-Z]+$/i,
        "da-DK": /^[A-Z]+$/i,
        "de-DE": /^[A-Z]+$/i,
        "el-GR": /^[-]+$/i,
        "es-ES": /^[A-Z]+$/i,
        "fa-IR": /^[]+$/i,
        "fi-FI": /^[A-Z]+$/i,
        "fr-FR": /^[A-Z]+$/i,
        "it-IT": /^[A-Z]+$/i,
        "ja-JP": /^[----]+$/i,
        "nb-NO": /^[A-Z]+$/i,
        "nl-NL": /^[A-Z]+$/i,
        "nn-NO": /^[A-Z]+$/i,
        "hu-HU": /^[A-Z]+$/i,
        "pl-PL": /^[A-Z]+$/i,
        "pt-PT": /^[A-Z]+$/i,
        "ru-RU": /^[-]+$/i,
        "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
        "sl-SI": /^[A-Z]+$/i,
        "sk-SK": /^[A-Z]+$/i,
        "sr-RS@latin": /^[A-Z]+$/i,
        "sr-RS": /^[-]+$/i,
        "sv-SE": /^[A-Z]+$/i,
        "th-TH": /^[-\s]+$/i,
        "tr-TR": /^[A-Z]+$/i,
        "uk-UA": /^[-I]+$/i,
        "vi-VN": /^[A-Z]+$/i,
        "ko-KR": /^[---]*$/,
        "ku-IQ": /^[]+$/i,
        ar: /^[]+$/,
        he: /^[-]+$/,
        fa: /^['']+$/i,
        bn: /^['']+$/,
        "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
        "si-LK": /^[\u0D80-\u0DFF]+$/
      };
      exports.alpha = alpha;
      var alphanumeric = {
        "en-US": /^[0-9A-Z]+$/i,
        "az-AZ": /^[0-9A-VXYZ]+$/i,
        "bg-BG": /^[0-9-]+$/i,
        "cs-CZ": /^[0-9A-Z]+$/i,
        "da-DK": /^[0-9A-Z]+$/i,
        "de-DE": /^[0-9A-Z]+$/i,
        "el-GR": /^[0-9-]+$/i,
        "es-ES": /^[0-9A-Z]+$/i,
        "fi-FI": /^[0-9A-Z]+$/i,
        "fr-FR": /^[0-9A-Z]+$/i,
        "it-IT": /^[0-9A-Z]+$/i,
        "ja-JP": /^[0-9-----]+$/i,
        "hu-HU": /^[0-9A-Z]+$/i,
        "nb-NO": /^[0-9A-Z]+$/i,
        "nl-NL": /^[0-9A-Z]+$/i,
        "nn-NO": /^[0-9A-Z]+$/i,
        "pl-PL": /^[0-9A-Z]+$/i,
        "pt-PT": /^[0-9A-Z]+$/i,
        "ru-RU": /^[0-9-]+$/i,
        "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
        "sl-SI": /^[0-9A-Z]+$/i,
        "sk-SK": /^[0-9A-Z]+$/i,
        "sr-RS@latin": /^[0-9A-Z]+$/i,
        "sr-RS": /^[0-9-]+$/i,
        "sv-SE": /^[0-9A-Z]+$/i,
        "th-TH": /^[-\s]+$/i,
        "tr-TR": /^[0-9A-Z]+$/i,
        "uk-UA": /^[0-9-I]+$/i,
        "ko-KR": /^[0-9---]*$/,
        "ku-IQ": /^[0-9]+$/i,
        "vi-VN": /^[0-9A-Z]+$/i,
        ar: /^[0-9]+$/,
        he: /^[0-9-]+$/,
        fa: /^['0-9']+$/i,
        bn: /^['']+$/,
        "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
        "si-LK": /^[0-9\u0D80-\u0DFF]+$/
      };
      exports.alphanumeric = alphanumeric;
      var decimal = {
        "en-US": ".",
        ar: "\u066B"
      };
      exports.decimal = decimal;
      var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
      exports.englishLocales = englishLocales;
      for (i5 = 0; i5 < englishLocales.length; i5++) {
        locale = "en-".concat(englishLocales[i5]);
        alpha[locale] = alpha["en-US"];
        alphanumeric[locale] = alphanumeric["en-US"];
        decimal[locale] = decimal["en-US"];
      }
      var locale;
      var i5;
      var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
      exports.arabicLocales = arabicLocales;
      for (_i = 0; _i < arabicLocales.length; _i++) {
        _locale = "ar-".concat(arabicLocales[_i]);
        alpha[_locale] = alpha.ar;
        alphanumeric[_locale] = alphanumeric.ar;
        decimal[_locale] = decimal.ar;
      }
      var _locale;
      var _i;
      var farsiLocales = ["IR", "AF"];
      exports.farsiLocales = farsiLocales;
      for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
        _locale2 = "fa-".concat(farsiLocales[_i2]);
        alphanumeric[_locale2] = alphanumeric.fa;
        decimal[_locale2] = decimal.ar;
      }
      var _locale2;
      var _i2;
      var bengaliLocales = ["BD", "IN"];
      exports.bengaliLocales = bengaliLocales;
      for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
        _locale3 = "bn-".concat(bengaliLocales[_i3]);
        alpha[_locale3] = alpha.bn;
        alphanumeric[_locale3] = alphanumeric.bn;
        decimal[_locale3] = decimal["en-US"];
      }
      var _locale3;
      var _i3;
      var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
      exports.dotDecimal = dotDecimal;
      var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
      exports.commaDecimal = commaDecimal;
      for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
        decimal[dotDecimal[_i4]] = decimal["en-US"];
      }
      var _i4;
      for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
        decimal[commaDecimal[_i5]] = ",";
      }
      var _i5;
      alpha["fr-CA"] = alpha["fr-FR"];
      alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
      alpha["pt-BR"] = alpha["pt-PT"];
      alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
      decimal["pt-BR"] = decimal["pt-PT"];
      alpha["pl-Pl"] = alpha["pl-PL"];
      alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
      decimal["pl-Pl"] = decimal["pl-PL"];
      alpha["fa-AF"] = alpha.fa;
    }
  });

  // node_modules/validator/lib/isFloat.js
  var require_isFloat = __commonJS({
    "node_modules/validator/lib/isFloat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isFloat;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      var _alpha = require_alpha();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isFloat(str, options) {
        (0, _assertString.default)(str);
        options = options || {};
        var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
        if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
          return false;
        }
        var value = parseFloat(str.replace(",", "."));
        return float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
      }
      var locales = Object.keys(_alpha.decimal);
      exports.locales = locales;
    }
  });

  // node_modules/validator/lib/toFloat.js
  var require_toFloat = __commonJS({
    "node_modules/validator/lib/toFloat.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toFloat;
      var _isFloat = _interopRequireDefault(require_isFloat());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function toFloat(str) {
        if (!(0, _isFloat.default)(str))
          return NaN;
        return parseFloat(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/toInt.js
  var require_toInt = __commonJS({
    "node_modules/validator/lib/toInt.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toInt;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function toInt(str, radix) {
        (0, _assertString.default)(str);
        return parseInt(str, radix || 10);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/toBoolean.js
  var require_toBoolean = __commonJS({
    "node_modules/validator/lib/toBoolean.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toBoolean;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function toBoolean(str, strict) {
        (0, _assertString.default)(str);
        if (strict) {
          return str === "1" || /^true$/i.test(str);
        }
        return str !== "0" && !/^false$/i.test(str) && str !== "";
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/equals.js
  var require_equals = __commonJS({
    "node_modules/validator/lib/equals.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = equals;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function equals(str, comparison) {
        (0, _assertString.default)(str);
        return str === comparison;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/util/toString.js
  var require_toString = __commonJS({
    "node_modules/validator/lib/util/toString.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = toString2;
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function toString2(input) {
        if (_typeof2(input) === "object" && input !== null) {
          if (typeof input.toString === "function") {
            input = input.toString();
          } else {
            input = "[object Object]";
          }
        } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
          input = "";
        }
        return String(input);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/util/merge.js
  var require_merge = __commonJS({
    "node_modules/validator/lib/util/merge.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = merge;
      function merge() {
        var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var defaults = arguments.length > 1 ? arguments[1] : void 0;
        for (var key in defaults) {
          if (typeof obj[key] === "undefined") {
            obj[key] = defaults[key];
          }
        }
        return obj;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/contains.js
  var require_contains = __commonJS({
    "node_modules/validator/lib/contains.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = contains;
      var _assertString = _interopRequireDefault(require_assertString());
      var _toString = _interopRequireDefault(require_toString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var defaulContainsOptions = {
        ignoreCase: false,
        minOccurrences: 1
      };
      function contains(str, elem, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, defaulContainsOptions);
        if (options.ignoreCase) {
          return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
        }
        return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/matches.js
  var require_matches = __commonJS({
    "node_modules/validator/lib/matches.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = matches;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function matches(str, pattern, modifiers) {
        (0, _assertString.default)(str);
        if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
          pattern = new RegExp(pattern, modifiers);
        }
        return !!str.match(pattern);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isByteLength.js
  var require_isByteLength = __commonJS({
    "node_modules/validator/lib/isByteLength.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isByteLength;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function isByteLength(str, options) {
        (0, _assertString.default)(str);
        var min3;
        var max3;
        if (_typeof2(options) === "object") {
          min3 = options.min || 0;
          max3 = options.max;
        } else {
          min3 = arguments[1];
          max3 = arguments[2];
        }
        var len = encodeURI(str).split(/%..|./).length - 1;
        return len >= min3 && (typeof max3 === "undefined" || len <= max3);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isFQDN.js
  var require_isFQDN = __commonJS({
    "node_modules/validator/lib/isFQDN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isFQDN;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_fqdn_options = {
        require_tld: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_numeric_tld: false,
        allow_wildcard: false,
        ignore_max_length: false
      };
      function isFQDN(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, default_fqdn_options);
        if (options.allow_trailing_dot && str[str.length - 1] === ".") {
          str = str.substring(0, str.length - 1);
        }
        if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
          str = str.substring(2);
        }
        var parts = str.split(".");
        var tld = parts[parts.length - 1];
        if (options.require_tld) {
          if (parts.length < 2) {
            return false;
          }
          if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
            return false;
          }
          if (/\s/.test(tld)) {
            return false;
          }
        }
        if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
          return false;
        }
        return parts.every(function(part) {
          if (part.length > 63 && !options.ignore_max_length) {
            return false;
          }
          if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
            return false;
          }
          if (/[\uff01-\uff5e]/.test(part)) {
            return false;
          }
          if (/^-|-$/.test(part)) {
            return false;
          }
          if (!options.allow_underscores && /_/.test(part)) {
            return false;
          }
          return true;
        });
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIP.js
  var require_isIP = __commonJS({
    "node_modules/validator/lib/isIP.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIP;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
      var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
      var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
      var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
      var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
      function isIP(str) {
        var version3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        (0, _assertString.default)(str);
        version3 = String(version3);
        if (!version3) {
          return isIP(str, 4) || isIP(str, 6);
        }
        if (version3 === "4") {
          return IPv4AddressRegExp.test(str);
        }
        if (version3 === "6") {
          return IPv6AddressRegExp.test(str);
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isEmail.js
  var require_isEmail = __commonJS({
    "node_modules/validator/lib/isEmail.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isEmail;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isByteLength = _interopRequireDefault(require_isByteLength());
      var _isFQDN = _interopRequireDefault(require_isFQDN());
      var _isIP = _interopRequireDefault(require_isIP());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_email_options = {
        allow_display_name: false,
        allow_underscores: false,
        require_display_name: false,
        allow_utf8_local_part: true,
        require_tld: true,
        blacklisted_chars: "",
        ignore_max_length: false,
        host_blacklist: [],
        host_whitelist: []
      };
      var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
      var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
      var gmailUserPart = /^[a-z\d]+$/;
      var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
      var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
      var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
      var defaultMaxEmailLength = 254;
      function validateDisplayName(display_name) {
        var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
        if (!display_name_without_quotes.trim()) {
          return false;
        }
        var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
        if (contains_illegal) {
          if (display_name_without_quotes === display_name) {
            return false;
          }
          var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
          if (!all_start_with_back_slash) {
            return false;
          }
        }
        return true;
      }
      function isEmail(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, default_email_options);
        if (options.require_display_name || options.allow_display_name) {
          var display_email = str.match(splitNameAddress);
          if (display_email) {
            var display_name = display_email[1];
            str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
            if (display_name.endsWith(" ")) {
              display_name = display_name.slice(0, -1);
            }
            if (!validateDisplayName(display_name)) {
              return false;
            }
          } else if (options.require_display_name) {
            return false;
          }
        }
        if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
          return false;
        }
        var parts = str.split("@");
        var domain = parts.pop();
        var lower_domain = domain.toLowerCase();
        if (options.host_blacklist.includes(lower_domain)) {
          return false;
        }
        if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
          return false;
        }
        var user = parts.join("@");
        if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
          user = user.toLowerCase();
          var username = user.split("+")[0];
          if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
            min: 6,
            max: 30
          })) {
            return false;
          }
          var _user_parts = username.split(".");
          for (var i5 = 0; i5 < _user_parts.length; i5++) {
            if (!gmailUserPart.test(_user_parts[i5])) {
              return false;
            }
          }
        }
        if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
          max: 64
        }) || !(0, _isByteLength.default)(domain, {
          max: 254
        }))) {
          return false;
        }
        if (!(0, _isFQDN.default)(domain, {
          require_tld: options.require_tld,
          ignore_max_length: options.ignore_max_length,
          allow_underscores: options.allow_underscores
        })) {
          if (!options.allow_ip_domain) {
            return false;
          }
          if (!(0, _isIP.default)(domain)) {
            if (!domain.startsWith("[") || !domain.endsWith("]")) {
              return false;
            }
            var noBracketdomain = domain.slice(1, -1);
            if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
              return false;
            }
          }
        }
        if (user[0] === '"') {
          user = user.slice(1, user.length - 1);
          return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
        }
        var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
        var user_parts = user.split(".");
        for (var _i = 0; _i < user_parts.length; _i++) {
          if (!pattern.test(user_parts[_i])) {
            return false;
          }
        }
        if (options.blacklisted_chars) {
          if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
            return false;
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isURL.js
  var require_isURL = __commonJS({
    "node_modules/validator/lib/isURL.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isURL;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isFQDN = _interopRequireDefault(require_isFQDN());
      var _isIP = _interopRequireDefault(require_isIP());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i5) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i5) || _unsupportedIterableToArray(arr, i5) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
          arr2[i5] = arr[i5];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i5) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n2 = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
            _arr.push(_s.value);
            if (i5 && _arr.length === i5)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n2 && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      var default_url_options = {
        protocols: ["http", "https", "ftp"],
        require_tld: true,
        require_protocol: false,
        require_host: true,
        require_port: false,
        require_valid_protocol: true,
        allow_underscores: false,
        allow_trailing_dot: false,
        allow_protocol_relative_urls: false,
        allow_fragments: true,
        allow_query_components: true,
        validate_length: true
      };
      var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
      function isRegExp2(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      }
      function checkHost(host, matches) {
        for (var i5 = 0; i5 < matches.length; i5++) {
          var match = matches[i5];
          if (host === match || isRegExp2(match) && match.test(host)) {
            return true;
          }
        }
        return false;
      }
      function isURL(url, options) {
        (0, _assertString.default)(url);
        if (!url || /[\s<>]/.test(url)) {
          return false;
        }
        if (url.indexOf("mailto:") === 0) {
          return false;
        }
        options = (0, _merge.default)(options, default_url_options);
        if (options.validate_length && url.length >= 2083) {
          return false;
        }
        if (!options.allow_fragments && url.includes("#")) {
          return false;
        }
        if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
          return false;
        }
        var protocol, auth, host, hostname, port, port_str, split, ipv6;
        split = url.split("#");
        url = split.shift();
        split = url.split("?");
        url = split.shift();
        split = url.split("://");
        if (split.length > 1) {
          protocol = split.shift().toLowerCase();
          if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
            return false;
          }
        } else if (options.require_protocol) {
          return false;
        } else if (url.slice(0, 2) === "//") {
          if (!options.allow_protocol_relative_urls) {
            return false;
          }
          split[0] = url.slice(2);
        }
        url = split.join("://");
        if (url === "") {
          return false;
        }
        split = url.split("/");
        url = split.shift();
        if (url === "" && !options.require_host) {
          return true;
        }
        split = url.split("@");
        if (split.length > 1) {
          if (options.disallow_auth) {
            return false;
          }
          if (split[0] === "") {
            return false;
          }
          auth = split.shift();
          if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
            return false;
          }
          var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
          if (user === "" && password === "") {
            return false;
          }
        }
        hostname = split.join("@");
        port_str = null;
        ipv6 = null;
        var ipv6_match = hostname.match(wrapped_ipv6);
        if (ipv6_match) {
          host = "";
          ipv6 = ipv6_match[1];
          port_str = ipv6_match[2] || null;
        } else {
          split = hostname.split(":");
          host = split.shift();
          if (split.length) {
            port_str = split.join(":");
          }
        }
        if (port_str !== null && port_str.length > 0) {
          port = parseInt(port_str, 10);
          if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
            return false;
          }
        } else if (options.require_port) {
          return false;
        }
        if (options.host_whitelist) {
          return checkHost(host, options.host_whitelist);
        }
        if (host === "" && !options.require_host) {
          return true;
        }
        if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
          return false;
        }
        host = host || ipv6;
        if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
          return false;
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMACAddress.js
  var require_isMACAddress = __commonJS({
    "node_modules/validator/lib/isMACAddress.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMACAddress;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
      var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
      var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
      var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
      var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
      var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
      function isMACAddress(str, options) {
        (0, _assertString.default)(str);
        if (options !== null && options !== void 0 && options.eui) {
          options.eui = String(options.eui);
        }
        if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
          if (options.eui === "48") {
            return macAddress48NoSeparators.test(str);
          }
          if (options.eui === "64") {
            return macAddress64NoSeparators.test(str);
          }
          return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
        }
        if ((options === null || options === void 0 ? void 0 : options.eui) === "48") {
          return macAddress48.test(str) || macAddress48WithDots.test(str);
        }
        if ((options === null || options === void 0 ? void 0 : options.eui) === "64") {
          return macAddress64.test(str) || macAddress64WithDots.test(str);
        }
        return isMACAddress(str, {
          eui: "48"
        }) || isMACAddress(str, {
          eui: "64"
        });
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIPRange.js
  var require_isIPRange = __commonJS({
    "node_modules/validator/lib/isIPRange.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIPRange;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isIP = _interopRequireDefault(require_isIP());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var subnetMaybe = /^\d{1,3}$/;
      var v4Subnet = 32;
      var v6Subnet = 128;
      function isIPRange(str) {
        var version3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        (0, _assertString.default)(str);
        var parts = str.split("/");
        if (parts.length !== 2) {
          return false;
        }
        if (!subnetMaybe.test(parts[1])) {
          return false;
        }
        if (parts[1].length > 1 && parts[1].startsWith("0")) {
          return false;
        }
        var isValidIP2 = (0, _isIP.default)(parts[0], version3);
        if (!isValidIP2) {
          return false;
        }
        var expectedSubnet = null;
        switch (String(version3)) {
          case "4":
            expectedSubnet = v4Subnet;
            break;
          case "6":
            expectedSubnet = v6Subnet;
            break;
          default:
            expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
        }
        return parts[1] <= expectedSubnet && parts[1] >= 0;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isDate.js
  var require_isDate = __commonJS({
    "node_modules/validator/lib/isDate.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isDate2;
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i5) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i5) || _unsupportedIterableToArray(arr, i5) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i5) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n2 = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
            _arr.push(_s.value);
            if (i5 && _arr.length === i5)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n2 && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper(o3, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o3[Symbol.iterator] == null) {
          if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
            if (it)
              o3 = it;
            var i5 = 0;
            var F4 = function F5() {
            };
            return { s: F4, n: function n3() {
              if (i5 >= o3.length)
                return { done: true };
              return { done: false, value: o3[i5++] };
            }, e: function e6(_e2) {
              throw _e2;
            }, f: F4 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s3() {
          it = o3[Symbol.iterator]();
        }, n: function n3() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e6(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f3() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
          arr2[i5] = arr[i5];
        }
        return arr2;
      }
      var default_date_options = {
        format: "YYYY/MM/DD",
        delimiters: ["/", "-"],
        strictMode: false
      };
      function isValidFormat(format5) {
        return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format5);
      }
      function zip(date, format5) {
        var zippedArr = [], len = Math.min(date.length, format5.length);
        for (var i5 = 0; i5 < len; i5++) {
          zippedArr.push([date[i5], format5[i5]]);
        }
        return zippedArr;
      }
      function isDate2(input, options) {
        if (typeof options === "string") {
          options = (0, _merge.default)({
            format: options
          }, default_date_options);
        } else {
          options = (0, _merge.default)(options, default_date_options);
        }
        if (typeof input === "string" && isValidFormat(options.format)) {
          var formatDelimiter = options.delimiters.find(function(delimiter) {
            return options.format.indexOf(delimiter) !== -1;
          });
          var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function(delimiter) {
            return input.indexOf(delimiter) !== -1;
          });
          var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
          var dateObj = {};
          var _iterator = _createForOfIteratorHelper(dateAndFormat), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _step$value = _slicedToArray(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
              if (dateWord.length !== formatWord.length) {
                return false;
              }
              dateObj[formatWord.charAt(0)] = dateWord;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var fullYear = dateObj.y;
          if (dateObj.y.length === 2) {
            var parsedYear = parseInt(dateObj.y, 10);
            if (isNaN(parsedYear)) {
              return false;
            }
            var currentYearLastTwoDigits = (/* @__PURE__ */ new Date()).getFullYear() % 100;
            if (parsedYear < currentYearLastTwoDigits) {
              fullYear = "20".concat(dateObj.y);
            } else {
              fullYear = "19".concat(dateObj.y);
            }
          }
          return new Date("".concat(fullYear, "-").concat(dateObj.m, "-").concat(dateObj.d)).getDate() === +dateObj.d;
        }
        if (!options.strictMode) {
          return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isTime.js
  var require_isTime = __commonJS({
    "node_modules/validator/lib/isTime.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isTime;
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_time_options = {
        hourFormat: "hour24",
        mode: "default"
      };
      var formats = {
        hour24: {
          default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
          withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
        },
        hour12: {
          default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
          withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
        }
      };
      function isTime(input, options) {
        options = (0, _merge.default)(options, default_time_options);
        if (typeof input !== "string")
          return false;
        return formats[options.hourFormat][options.mode].test(input);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isBoolean.js
  var require_isBoolean = __commonJS({
    "node_modules/validator/lib/isBoolean.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBoolean2;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var defaultOptions = {
        loose: false
      };
      var strictBooleans = ["true", "false", "1", "0"];
      var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
      function isBoolean2(str) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions;
        (0, _assertString.default)(str);
        if (options.loose) {
          return looseBooleans.includes(str.toLowerCase());
        }
        return strictBooleans.includes(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLocale.js
  var require_isLocale = __commonJS({
    "node_modules/validator/lib/isLocale.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLocale;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
      var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
      var script = "([A-Za-z]{4})";
      var region = "([A-Za-z]{2}|\\d{3})";
      var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
      var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
      var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
      var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
      var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
      var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
      var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
      var delimiter = "(-|_)";
      var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");
      var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
      function isLocale(str) {
        (0, _assertString.default)(str);
        return languageTagRegex.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isAlpha.js
  var require_isAlpha = __commonJS({
    "node_modules/validator/lib/isAlpha.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isAlpha;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      var _alpha = require_alpha();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isAlpha(_str) {
        var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        (0, _assertString.default)(_str);
        var str = _str;
        var ignore = options.ignore;
        if (ignore) {
          if (ignore instanceof RegExp) {
            str = str.replace(ignore, "");
          } else if (typeof ignore === "string") {
            str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
          } else {
            throw new Error("ignore should be instance of a String or RegExp");
          }
        }
        if (locale in _alpha.alpha) {
          return _alpha.alpha[locale].test(str);
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      var locales = Object.keys(_alpha.alpha);
      exports.locales = locales;
    }
  });

  // node_modules/validator/lib/isAlphanumeric.js
  var require_isAlphanumeric = __commonJS({
    "node_modules/validator/lib/isAlphanumeric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isAlphanumeric;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      var _alpha = require_alpha();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isAlphanumeric(_str) {
        var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        (0, _assertString.default)(_str);
        var str = _str;
        var ignore = options.ignore;
        if (ignore) {
          if (ignore instanceof RegExp) {
            str = str.replace(ignore, "");
          } else if (typeof ignore === "string") {
            str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
          } else {
            throw new Error("ignore should be instance of a String or RegExp");
          }
        }
        if (locale in _alpha.alphanumeric) {
          return _alpha.alphanumeric[locale].test(str);
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      var locales = Object.keys(_alpha.alphanumeric);
      exports.locales = locales;
    }
  });

  // node_modules/validator/lib/isNumeric.js
  var require_isNumeric = __commonJS({
    "node_modules/validator/lib/isNumeric.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isNumeric2;
      var _assertString = _interopRequireDefault(require_assertString());
      var _alpha = require_alpha();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var numericNoSymbols = /^[0-9]+$/;
      function isNumeric2(str, options) {
        (0, _assertString.default)(str);
        if (options && options.no_symbols) {
          return numericNoSymbols.test(str);
        }
        return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isPassportNumber.js
  var require_isPassportNumber = __commonJS({
    "node_modules/validator/lib/isPassportNumber.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isPassportNumber;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var passportRegexByCountryCode = {
        AM: /^[A-Z]{2}\d{7}$/,
        // ARMENIA
        AR: /^[A-Z]{3}\d{6}$/,
        // ARGENTINA
        AT: /^[A-Z]\d{7}$/,
        // AUSTRIA
        AU: /^[A-Z]\d{7}$/,
        // AUSTRALIA
        AZ: /^[A-Z]{2,3}\d{7,8}$/,
        // AZERBAIJAN
        BE: /^[A-Z]{2}\d{6}$/,
        // BELGIUM
        BG: /^\d{9}$/,
        // BULGARIA
        BR: /^[A-Z]{2}\d{6}$/,
        // BRAZIL
        BY: /^[A-Z]{2}\d{7}$/,
        // BELARUS
        CA: /^[A-Z]{2}\d{6}$/,
        // CANADA
        CH: /^[A-Z]\d{7}$/,
        // SWITZERLAND
        CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
        // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
        CY: /^[A-Z](\d{6}|\d{8})$/,
        // CYPRUS
        CZ: /^\d{8}$/,
        // CZECH REPUBLIC
        DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
        // GERMANY
        DK: /^\d{9}$/,
        // DENMARK
        DZ: /^\d{9}$/,
        // ALGERIA
        EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
        // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
        ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
        // SPAIN
        FI: /^[A-Z]{2}\d{7}$/,
        // FINLAND
        FR: /^\d{2}[A-Z]{2}\d{5}$/,
        // FRANCE
        GB: /^\d{9}$/,
        // UNITED KINGDOM
        GR: /^[A-Z]{2}\d{7}$/,
        // GREECE
        HR: /^\d{9}$/,
        // CROATIA
        HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
        // HUNGARY
        IE: /^[A-Z0-9]{2}\d{7}$/,
        // IRELAND
        IN: /^[A-Z]{1}-?\d{7}$/,
        // INDIA
        ID: /^[A-C]\d{7}$/,
        // INDONESIA
        IR: /^[A-Z]\d{8}$/,
        // IRAN
        IS: /^(A)\d{7}$/,
        // ICELAND
        IT: /^[A-Z0-9]{2}\d{7}$/,
        // ITALY
        JM: /^[Aa]\d{7}$/,
        // JAMAICA
        JP: /^[A-Z]{2}\d{7}$/,
        // JAPAN
        KR: /^[MS]\d{8}$/,
        // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
        KZ: /^[a-zA-Z]\d{7}$/,
        // KAZAKHSTAN
        LI: /^[a-zA-Z]\d{5}$/,
        // LIECHTENSTEIN
        LT: /^[A-Z0-9]{8}$/,
        // LITHUANIA
        LU: /^[A-Z0-9]{8}$/,
        // LUXEMBURG
        LV: /^[A-Z0-9]{2}\d{7}$/,
        // LATVIA
        LY: /^[A-Z0-9]{8}$/,
        // LIBYA
        MT: /^\d{7}$/,
        // MALTA
        MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
        // MOZAMBIQUE
        MY: /^[AHK]\d{8}$/,
        // MALAYSIA
        MX: /^\d{10,11}$/,
        // MEXICO
        NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
        // NETHERLANDS
        NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
        // NEW ZEALAND
        PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
        // PHILIPPINES
        PK: /^[A-Z]{2}\d{7}$/,
        // PAKISTAN
        PL: /^[A-Z]{2}\d{7}$/,
        // POLAND
        PT: /^[A-Z]\d{6}$/,
        // PORTUGAL
        RO: /^\d{8,9}$/,
        // ROMANIA
        RU: /^\d{9}$/,
        // RUSSIAN FEDERATION
        SE: /^\d{8}$/,
        // SWEDEN
        SL: /^(P)[A-Z]\d{7}$/,
        // SLOVENIA
        SK: /^[0-9A-Z]\d{7}$/,
        // SLOVAKIA
        TH: /^[A-Z]{1,2}\d{6,7}$/,
        // THAILAND
        TR: /^[A-Z]\d{8}$/,
        // TURKEY
        UA: /^[A-Z]{2}\d{6}$/,
        // UKRAINE
        US: /^\d{9}$/
        // UNITED STATES
      };
      function isPassportNumber(str, countryCode) {
        (0, _assertString.default)(str);
        var normalizedStr = str.replace(/\s/g, "").toUpperCase();
        return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isInt.js
  var require_isInt = __commonJS({
    "node_modules/validator/lib/isInt.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isInt;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
      var intLeadingZeroes = /^[-+]?[0-9]+$/;
      function isInt(str, options) {
        (0, _assertString.default)(str);
        options = options || {};
        var regex = options.hasOwnProperty("allow_leading_zeroes") && !options.allow_leading_zeroes ? int : intLeadingZeroes;
        var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
        var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
        var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
        var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
        return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isPort.js
  var require_isPort = __commonJS({
    "node_modules/validator/lib/isPort.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isPort;
      var _isInt = _interopRequireDefault(require_isInt());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isPort(str) {
        return (0, _isInt.default)(str, {
          min: 0,
          max: 65535
        });
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLowercase.js
  var require_isLowercase = __commonJS({
    "node_modules/validator/lib/isLowercase.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLowercase;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isLowercase(str) {
        (0, _assertString.default)(str);
        return str === str.toLowerCase();
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isUppercase.js
  var require_isUppercase = __commonJS({
    "node_modules/validator/lib/isUppercase.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isUppercase;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isUppercase(str) {
        (0, _assertString.default)(str);
        return str === str.toUpperCase();
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIMEI.js
  var require_isIMEI = __commonJS({
    "node_modules/validator/lib/isIMEI.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIMEI;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var imeiRegexWithoutHypens = /^[0-9]{15}$/;
      var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
      function isIMEI(str, options) {
        (0, _assertString.default)(str);
        options = options || {};
        var imeiRegex = imeiRegexWithoutHypens;
        if (options.allow_hyphens) {
          imeiRegex = imeiRegexWithHypens;
        }
        if (!imeiRegex.test(str)) {
          return false;
        }
        str = str.replace(/-/g, "");
        var sum3 = 0, mul2 = 2, l3 = 14;
        for (var i5 = 0; i5 < l3; i5++) {
          var digit = str.substring(l3 - i5 - 1, l3 - i5);
          var tp = parseInt(digit, 10) * mul2;
          if (tp >= 10) {
            sum3 += tp % 10 + 1;
          } else {
            sum3 += tp;
          }
          if (mul2 === 1) {
            mul2 += 1;
          } else {
            mul2 -= 1;
          }
        }
        var chk = (10 - sum3 % 10) % 10;
        if (chk !== parseInt(str.substring(14, 15), 10)) {
          return false;
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isAscii.js
  var require_isAscii = __commonJS({
    "node_modules/validator/lib/isAscii.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isAscii;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ascii = /^[\x00-\x7F]+$/;
      function isAscii(str) {
        (0, _assertString.default)(str);
        return ascii.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isFullWidth.js
  var require_isFullWidth = __commonJS({
    "node_modules/validator/lib/isFullWidth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isFullWidth;
      exports.fullWidth = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
      exports.fullWidth = fullWidth;
      function isFullWidth(str) {
        (0, _assertString.default)(str);
        return fullWidth.test(str);
      }
    }
  });

  // node_modules/validator/lib/isHalfWidth.js
  var require_isHalfWidth = __commonJS({
    "node_modules/validator/lib/isHalfWidth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isHalfWidth;
      exports.halfWidth = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
      exports.halfWidth = halfWidth;
      function isHalfWidth(str) {
        (0, _assertString.default)(str);
        return halfWidth.test(str);
      }
    }
  });

  // node_modules/validator/lib/isVariableWidth.js
  var require_isVariableWidth = __commonJS({
    "node_modules/validator/lib/isVariableWidth.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isVariableWidth;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isFullWidth = require_isFullWidth();
      var _isHalfWidth = require_isHalfWidth();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isVariableWidth(str) {
        (0, _assertString.default)(str);
        return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMultibyte.js
  var require_isMultibyte = __commonJS({
    "node_modules/validator/lib/isMultibyte.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMultibyte;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var multibyte = /[^\x00-\x7F]/;
      function isMultibyte(str) {
        (0, _assertString.default)(str);
        return multibyte.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/util/multilineRegex.js
  var require_multilineRegex = __commonJS({
    "node_modules/validator/lib/util/multilineRegex.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = multilineRegexp;
      function multilineRegexp(parts, flags) {
        var regexpAsStringLiteral = parts.join("");
        return new RegExp(regexpAsStringLiteral, flags);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isSemVer.js
  var require_isSemVer = __commonJS({
    "node_modules/validator/lib/isSemVer.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isSemVer;
      var _assertString = _interopRequireDefault(require_assertString());
      var _multilineRegex = _interopRequireDefault(require_multilineRegex());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
      function isSemVer(str) {
        (0, _assertString.default)(str);
        return semanticVersioningRegex.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isSurrogatePair.js
  var require_isSurrogatePair = __commonJS({
    "node_modules/validator/lib/isSurrogatePair.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isSurrogatePair;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
      function isSurrogatePair(str) {
        (0, _assertString.default)(str);
        return surrogatePair.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/util/includes.js
  var require_includes = __commonJS({
    "node_modules/validator/lib/util/includes.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var includes = function includes2(arr, val) {
        return arr.some(function(arrVal) {
          return val === arrVal;
        });
      };
      var _default = includes;
      exports.default = _default;
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isDecimal.js
  var require_isDecimal = __commonJS({
    "node_modules/validator/lib/isDecimal.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isDecimal2;
      var _merge = _interopRequireDefault(require_merge());
      var _assertString = _interopRequireDefault(require_assertString());
      var _includes = _interopRequireDefault(require_includes());
      var _alpha = require_alpha();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function decimalRegExp(options) {
        var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
        return regExp;
      }
      var default_decimal_options = {
        force_decimal: false,
        decimal_digits: "1,",
        locale: "en-US"
      };
      var blacklist = ["", "-", "+"];
      function isDecimal2(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, default_decimal_options);
        if (options.locale in _alpha.decimal) {
          return !(0, _includes.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
        }
        throw new Error("Invalid locale '".concat(options.locale, "'"));
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isHexadecimal.js
  var require_isHexadecimal = __commonJS({
    "node_modules/validator/lib/isHexadecimal.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isHexadecimal;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
      function isHexadecimal(str) {
        (0, _assertString.default)(str);
        return hexadecimal.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isOctal.js
  var require_isOctal = __commonJS({
    "node_modules/validator/lib/isOctal.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isOctal2;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var octal = /^(0o)?[0-7]+$/i;
      function isOctal2(str) {
        (0, _assertString.default)(str);
        return octal.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isDivisibleBy.js
  var require_isDivisibleBy = __commonJS({
    "node_modules/validator/lib/isDivisibleBy.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isDivisibleBy;
      var _assertString = _interopRequireDefault(require_assertString());
      var _toFloat = _interopRequireDefault(require_toFloat());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isDivisibleBy(str, num) {
        (0, _assertString.default)(str);
        return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isHexColor.js
  var require_isHexColor = __commonJS({
    "node_modules/validator/lib/isHexColor.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isHexColor;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
      function isHexColor(str) {
        (0, _assertString.default)(str);
        return hexcolor.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isRgbColor.js
  var require_isRgbColor = __commonJS({
    "node_modules/validator/lib/isRgbColor.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isRgbColor;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
      var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
      var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
      var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
      function isRgbColor(str) {
        var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        (0, _assertString.default)(str);
        if (!includePercentValues) {
          return rgbColor.test(str) || rgbaColor.test(str);
        }
        return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isHSL.js
  var require_isHSL = __commonJS({
    "node_modules/validator/lib/isHSL.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isHSL;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
      var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
      function isHSL(str) {
        (0, _assertString.default)(str);
        var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
        if (strippedStr.indexOf(",") !== -1) {
          return hslComma.test(strippedStr);
        }
        return hslSpace.test(strippedStr);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISRC.js
  var require_isISRC = __commonJS({
    "node_modules/validator/lib/isISRC.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISRC;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
      function isISRC(str) {
        (0, _assertString.default)(str);
        return isrc.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIBAN.js
  var require_isIBAN = __commonJS({
    "node_modules/validator/lib/isIBAN.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIBAN;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var ibanRegexThroughCountryCode = {
        AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
        AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
        AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        AT: /^(AT[0-9]{2})\d{16}$/,
        AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        BA: /^(BA[0-9]{2})\d{16}$/,
        BE: /^(BE[0-9]{2})\d{12}$/,
        BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
        BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
        BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
        BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        CR: /^(CR[0-9]{2})\d{18}$/,
        CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        CZ: /^(CZ[0-9]{2})\d{20}$/,
        DE: /^(DE[0-9]{2})\d{18}$/,
        DK: /^(DK[0-9]{2})\d{14}$/,
        DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
        EE: /^(EE[0-9]{2})\d{16}$/,
        EG: /^(EG[0-9]{2})\d{25}$/,
        ES: /^(ES[0-9]{2})\d{20}$/,
        FI: /^(FI[0-9]{2})\d{14}$/,
        FO: /^(FO[0-9]{2})\d{14}$/,
        FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
        GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
        GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
        GL: /^(GL[0-9]{2})\d{14}$/,
        GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
        GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
        HR: /^(HR[0-9]{2})\d{17}$/,
        HU: /^(HU[0-9]{2})\d{24}$/,
        IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
        IL: /^(IL[0-9]{2})\d{19}$/,
        IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
        IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
        IS: /^(IS[0-9]{2})\d{22}$/,
        IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
        KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
        KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
        LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
        LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        LT: /^(LT[0-9]{2})\d{16}$/,
        LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
        MA: /^(MA[0-9]{26})$/,
        MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
        ME: /^(ME[0-9]{2})\d{18}$/,
        MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
        MR: /^(MR[0-9]{2})\d{23}$/,
        MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
        MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
        MZ: /^(MZ[0-9]{2})\d{21}$/,
        NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
        NO: /^(NO[0-9]{2})\d{11}$/,
        PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        PL: /^(PL[0-9]{2})\d{24}$/,
        PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
        PT: /^(PT[0-9]{2})\d{21}$/,
        QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
        RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
        RS: /^(RS[0-9]{2})\d{18}$/,
        SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
        SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
        SE: /^(SE[0-9]{2})\d{20}$/,
        SI: /^(SI[0-9]{2})\d{15}$/,
        SK: /^(SK[0-9]{2})\d{20}$/,
        SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        TL: /^(TL[0-9]{2})\d{19}$/,
        TN: /^(TN[0-9]{2})\d{20}$/,
        TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
        UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
        VA: /^(VA[0-9]{2})\d{18}$/,
        VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        XK: /^(XK[0-9]{2})\d{16}$/
      };
      function hasOnlyValidCountryCodes(countryCodeArray) {
        var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
          return !(countryCode in ibanRegexThroughCountryCode);
        });
        if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
          return false;
        }
        return true;
      }
      function hasValidIbanFormat(str, options) {
        var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
        var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
        var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
        if (options.whitelist) {
          if (!hasOnlyValidCountryCodes(options.whitelist)) {
            return false;
          }
          var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
          if (!isoCountryCodeInWhiteList) {
            return false;
          }
        }
        if (options.blacklist) {
          var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
          if (isoCountryCodeInBlackList) {
            return false;
          }
        }
        return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
      }
      function hasValidIbanChecksum(str) {
        var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
        var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
        var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
          return char.charCodeAt(0) - 55;
        });
        var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
          return Number(acc + value) % 97;
        }, "");
        return remainder === 1;
      }
      function isIBAN(str) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (0, _assertString.default)(str);
        return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
      }
      var locales = Object.keys(ibanRegexThroughCountryCode);
      exports.locales = locales;
    }
  });

  // node_modules/validator/lib/isISO31661Alpha2.js
  var require_isISO31661Alpha2 = __commonJS({
    "node_modules/validator/lib/isISO31661Alpha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISO31661Alpha2;
      exports.CountryCodes = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
      function isISO31661Alpha2(str) {
        (0, _assertString.default)(str);
        return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
      }
      var CountryCodes = validISO31661Alpha2CountriesCodes;
      exports.CountryCodes = CountryCodes;
    }
  });

  // node_modules/validator/lib/isBIC.js
  var require_isBIC = __commonJS({
    "node_modules/validator/lib/isBIC.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBIC;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isISO31661Alpha = require_isISO31661Alpha2();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
      function isBIC(str) {
        (0, _assertString.default)(str);
        var countryCode = str.slice(4, 6).toUpperCase();
        if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
          return false;
        }
        return isBICReg.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMD5.js
  var require_isMD5 = __commonJS({
    "node_modules/validator/lib/isMD5.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMD5;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var md5 = /^[a-f0-9]{32}$/;
      function isMD5(str) {
        (0, _assertString.default)(str);
        return md5.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isHash.js
  var require_isHash = __commonJS({
    "node_modules/validator/lib/isHash.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isHash;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var lengths = {
        md5: 32,
        md4: 32,
        sha1: 40,
        sha256: 64,
        sha384: 96,
        sha512: 128,
        ripemd128: 32,
        ripemd160: 40,
        tiger128: 32,
        tiger160: 40,
        tiger192: 48,
        crc32: 8,
        crc32b: 8
      };
      function isHash(str, algorithm) {
        (0, _assertString.default)(str);
        var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
        return hash.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isBase64.js
  var require_isBase64 = __commonJS({
    "node_modules/validator/lib/isBase64.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBase64;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var notBase64 = /[^A-Z0-9+\/=]/i;
      var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
      var defaultBase64Options = {
        urlSafe: false
      };
      function isBase64(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, defaultBase64Options);
        var len = str.length;
        if (options.urlSafe) {
          return urlSafeBase64.test(str);
        }
        if (len % 4 !== 0 || notBase64.test(str)) {
          return false;
        }
        var firstPaddingChar = str.indexOf("=");
        return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isJWT.js
  var require_isJWT = __commonJS({
    "node_modules/validator/lib/isJWT.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isJWT;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isBase = _interopRequireDefault(require_isBase64());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isJWT(str) {
        (0, _assertString.default)(str);
        var dotSplit = str.split(".");
        var len = dotSplit.length;
        if (len !== 3) {
          return false;
        }
        return dotSplit.reduce(function(acc, currElem) {
          return acc && (0, _isBase.default)(currElem, {
            urlSafe: true
          });
        }, true);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isJSON.js
  var require_isJSON = __commonJS({
    "node_modules/validator/lib/isJSON.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isJSON;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var default_json_options = {
        allow_primitives: false
      };
      function isJSON(str, options) {
        (0, _assertString.default)(str);
        try {
          options = (0, _merge.default)(options, default_json_options);
          var primitives = [];
          if (options.allow_primitives) {
            primitives = [null, false, true];
          }
          var obj = JSON.parse(str);
          return primitives.includes(obj) || !!obj && _typeof2(obj) === "object";
        } catch (e6) {
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/validator/lib/isEmpty.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isEmpty;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_is_empty_options = {
        ignore_whitespace: false
      };
      function isEmpty(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, default_is_empty_options);
        return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLength.js
  var require_isLength = __commonJS({
    "node_modules/validator/lib/isLength.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLength;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function isLength(str, options) {
        (0, _assertString.default)(str);
        var min3;
        var max3;
        if (_typeof2(options) === "object") {
          min3 = options.min || 0;
          max3 = options.max;
        } else {
          min3 = arguments[1] || 0;
          max3 = arguments[2];
        }
        var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
        var len = str.length - presentationSequences.length - surrogatePairs.length;
        return len >= min3 && (typeof max3 === "undefined" || len <= max3);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isUUID.js
  var require_isUUID = __commonJS({
    "node_modules/validator/lib/isUUID.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isUUID;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var uuid = {
        1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
        4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
        all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
      };
      function isUUID(str, version3) {
        (0, _assertString.default)(str);
        var pattern = uuid[![void 0, null].includes(version3) ? version3 : "all"];
        return !!pattern && pattern.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMongoId.js
  var require_isMongoId = __commonJS({
    "node_modules/validator/lib/isMongoId.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMongoId;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isMongoId(str) {
        (0, _assertString.default)(str);
        return (0, _isHexadecimal.default)(str) && str.length === 24;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isAfter.js
  var require_isAfter = __commonJS({
    "node_modules/validator/lib/isAfter.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isAfter;
      var _toDate = _interopRequireDefault(require_toDate());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isAfter(date, options) {
        var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
        var comparison = (0, _toDate.default)(comparisonDate);
        var original = (0, _toDate.default)(date);
        return !!(original && comparison && original > comparison);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isBefore.js
  var require_isBefore = __commonJS({
    "node_modules/validator/lib/isBefore.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBefore;
      var _assertString = _interopRequireDefault(require_assertString());
      var _toDate = _interopRequireDefault(require_toDate());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isBefore(str) {
        var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
        (0, _assertString.default)(str);
        var comparison = (0, _toDate.default)(date);
        var original = (0, _toDate.default)(str);
        return !!(original && comparison && original < comparison);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIn.js
  var require_isIn = __commonJS({
    "node_modules/validator/lib/isIn.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIn;
      var _assertString = _interopRequireDefault(require_assertString());
      var _toString = _interopRequireDefault(require_toString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function isIn(str, options) {
        (0, _assertString.default)(str);
        var i5;
        if (Object.prototype.toString.call(options) === "[object Array]") {
          var array = [];
          for (i5 in options) {
            if ({}.hasOwnProperty.call(options, i5)) {
              array[i5] = (0, _toString.default)(options[i5]);
            }
          }
          return array.indexOf(str) >= 0;
        } else if (_typeof2(options) === "object") {
          return options.hasOwnProperty(str);
        } else if (options && typeof options.indexOf === "function") {
          return options.indexOf(str) >= 0;
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLuhnNumber.js
  var require_isLuhnNumber = __commonJS({
    "node_modules/validator/lib/isLuhnNumber.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLuhnNumber;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isLuhnNumber(str) {
        (0, _assertString.default)(str);
        var sanitized = str.replace(/[- ]+/g, "");
        var sum3 = 0;
        var digit;
        var tmpNum;
        var shouldDouble;
        for (var i5 = sanitized.length - 1; i5 >= 0; i5--) {
          digit = sanitized.substring(i5, i5 + 1);
          tmpNum = parseInt(digit, 10);
          if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
              sum3 += tmpNum % 10 + 1;
            } else {
              sum3 += tmpNum;
            }
          } else {
            sum3 += tmpNum;
          }
          shouldDouble = !shouldDouble;
        }
        return !!(sum3 % 10 === 0 ? sanitized : false);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isCreditCard.js
  var require_isCreditCard = __commonJS({
    "node_modules/validator/lib/isCreditCard.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isCreditCard;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var cards = {
        amex: /^3[47][0-9]{13}$/,
        dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
        discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
        jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
        mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
        // /^[25][1-7][0-9]{14}$/;
        unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
        visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
      };
      var allCards = function() {
        var tmpCardsArray = [];
        for (var cardProvider in cards) {
          if (cards.hasOwnProperty(cardProvider)) {
            tmpCardsArray.push(cards[cardProvider]);
          }
        }
        return tmpCardsArray;
      }();
      function isCreditCard(card) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (0, _assertString.default)(card);
        var provider = options.provider;
        var sanitized = card.replace(/[- ]+/g, "");
        if (provider && provider.toLowerCase() in cards) {
          if (!cards[provider.toLowerCase()].test(sanitized)) {
            return false;
          }
        } else if (provider && !(provider.toLowerCase() in cards)) {
          throw new Error("".concat(provider, " is not a valid credit card provider."));
        } else if (!allCards.some(function(cardProvider) {
          return cardProvider.test(sanitized);
        })) {
          return false;
        }
        return (0, _isLuhnNumber.default)(card);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isIdentityCard.js
  var require_isIdentityCard = __commonJS({
    "node_modules/validator/lib/isIdentityCard.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isIdentityCard;
      var _assertString = _interopRequireDefault(require_assertString());
      var _isInt = _interopRequireDefault(require_isInt());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validators = {
        PL: function PL(str) {
          (0, _assertString.default)(str);
          var weightOfDigits = {
            1: 1,
            2: 3,
            3: 7,
            4: 9,
            5: 1,
            6: 3,
            7: 7,
            8: 9,
            9: 1,
            10: 3,
            11: 0
          };
          if (str != null && str.length === 11 && (0, _isInt.default)(str, {
            allow_leading_zeroes: true
          })) {
            var digits2 = str.split("").slice(0, -1);
            var sum3 = digits2.reduce(function(acc, digit, index2) {
              return acc + Number(digit) * weightOfDigits[index2 + 1];
            }, 0);
            var modulo = sum3 % 10;
            var lastDigit = Number(str.charAt(str.length - 1));
            if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
              return true;
            }
          }
          return false;
        },
        ES: function ES(str) {
          (0, _assertString.default)(str);
          var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
          var charsValue = {
            X: 0,
            Y: 1,
            Z: 2
          };
          var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
          var sanitized = str.trim().toUpperCase();
          if (!DNI.test(sanitized)) {
            return false;
          }
          var number2 = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
            return charsValue[char];
          });
          return sanitized.endsWith(controlDigits[number2 % 23]);
        },
        FI: function FI(str) {
          (0, _assertString.default)(str);
          if (str.length !== 11) {
            return false;
          }
          if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
            return false;
          }
          var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
          var idAsNumber = parseInt(str.slice(0, 6), 10) * 1e3 + parseInt(str.slice(7, 10), 10);
          var remainder = idAsNumber % 31;
          var checkDigit = checkDigits[remainder];
          return checkDigit === str.slice(10, 11);
        },
        IN: function IN(str) {
          var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
          var d3 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
          var p3 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
          var sanitized = str.trim();
          if (!DNI.test(sanitized)) {
            return false;
          }
          var c3 = 0;
          var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
          invertedArray.forEach(function(val, i5) {
            c3 = d3[c3][p3[i5 % 8][val]];
          });
          return c3 === 0;
        },
        IR: function IR(str) {
          if (!str.match(/^\d{10}$/))
            return false;
          str = "0000".concat(str).slice(str.length - 6);
          if (parseInt(str.slice(3, 9), 10) === 0)
            return false;
          var lastNumber = parseInt(str.slice(9, 10), 10);
          var sum3 = 0;
          for (var i5 = 0; i5 < 9; i5++) {
            sum3 += parseInt(str.slice(i5, i5 + 1), 10) * (10 - i5);
          }
          sum3 %= 11;
          return sum3 < 2 && lastNumber === sum3 || sum3 >= 2 && lastNumber === 11 - sum3;
        },
        IT: function IT(str) {
          if (str.length !== 9)
            return false;
          if (str === "CA00000AA")
            return false;
          return str.search(/C[A-Z][0-9]{5}[A-Z]{2}/i) > -1;
        },
        NO: function NO(str) {
          var sanitized = str.trim();
          if (isNaN(Number(sanitized)))
            return false;
          if (sanitized.length !== 11)
            return false;
          if (sanitized === "00000000000")
            return false;
          var f3 = sanitized.split("").map(Number);
          var k1 = (11 - (3 * f3[0] + 7 * f3[1] + 6 * f3[2] + 1 * f3[3] + 8 * f3[4] + 9 * f3[5] + 4 * f3[6] + 5 * f3[7] + 2 * f3[8]) % 11) % 11;
          var k22 = (11 - (5 * f3[0] + 4 * f3[1] + 3 * f3[2] + 2 * f3[3] + 7 * f3[4] + 6 * f3[5] + 5 * f3[6] + 4 * f3[7] + 3 * f3[8] + 2 * k1) % 11) % 11;
          if (k1 !== f3[9] || k22 !== f3[10])
            return false;
          return true;
        },
        TH: function TH(str) {
          if (!str.match(/^[1-8]\d{12}$/))
            return false;
          var sum3 = 0;
          for (var i5 = 0; i5 < 12; i5++) {
            sum3 += parseInt(str[i5], 10) * (13 - i5);
          }
          return str[12] === ((11 - sum3 % 11) % 10).toString();
        },
        LK: function LK(str) {
          var old_nic = /^[1-9]\d{8}[vx]$/i;
          var new_nic = /^[1-9]\d{11}$/i;
          if (str.length === 10 && old_nic.test(str))
            return true;
          else if (str.length === 12 && new_nic.test(str))
            return true;
          return false;
        },
        "he-IL": function heIL(str) {
          var DNI = /^\d{9}$/;
          var sanitized = str.trim();
          if (!DNI.test(sanitized)) {
            return false;
          }
          var id = sanitized;
          var sum3 = 0, incNum;
          for (var i5 = 0; i5 < id.length; i5++) {
            incNum = Number(id[i5]) * (i5 % 2 + 1);
            sum3 += incNum > 9 ? incNum - 9 : incNum;
          }
          return sum3 % 10 === 0;
        },
        "ar-LY": function arLY(str) {
          var NIN = /^(1|2)\d{11}$/;
          var sanitized = str.trim();
          if (!NIN.test(sanitized)) {
            return false;
          }
          return true;
        },
        "ar-TN": function arTN(str) {
          var DNI = /^\d{8}$/;
          var sanitized = str.trim();
          if (!DNI.test(sanitized)) {
            return false;
          }
          return true;
        },
        "zh-CN": function zhCN(str) {
          var provincesAndCities = [
            "11",
            // 
            "12",
            // 
            "13",
            // 
            "14",
            // 
            "15",
            // 
            "21",
            // 
            "22",
            // 
            "23",
            // 
            "31",
            // 
            "32",
            // 
            "33",
            // 
            "34",
            // 
            "35",
            // 
            "36",
            // 
            "37",
            // 
            "41",
            // 
            "42",
            // 
            "43",
            // 
            "44",
            // 
            "45",
            // 
            "46",
            // 
            "50",
            // 
            "51",
            // 
            "52",
            // 
            "53",
            // 
            "54",
            // 
            "61",
            // 
            "62",
            // 
            "63",
            // 
            "64",
            // 
            "65",
            // 
            "71",
            // 
            "81",
            // 
            "82",
            // 
            "91"
            // 
          ];
          var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
          var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
          var checkAddressCode = function checkAddressCode2(addressCode) {
            return provincesAndCities.includes(addressCode);
          };
          var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
            var yyyy = parseInt(birDayCode.substring(0, 4), 10);
            var mm = parseInt(birDayCode.substring(4, 6), 10);
            var dd = parseInt(birDayCode.substring(6), 10);
            var xdata = new Date(yyyy, mm - 1, dd);
            if (xdata > /* @__PURE__ */ new Date()) {
              return false;
            } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
              return true;
            }
            return false;
          };
          var getParityBit = function getParityBit2(idCardNo) {
            var id17 = idCardNo.substring(0, 17);
            var power = 0;
            for (var i5 = 0; i5 < 17; i5++) {
              power += parseInt(id17.charAt(i5), 10) * parseInt(powers[i5], 10);
            }
            var mod3 = power % 11;
            return parityBit[mod3];
          };
          var checkParityBit = function checkParityBit2(idCardNo) {
            return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
          };
          var check15IdCardNo = function check15IdCardNo2(idCardNo) {
            var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
            if (!check)
              return false;
            var addressCode = idCardNo.substring(0, 2);
            check = checkAddressCode(addressCode);
            if (!check)
              return false;
            var birDayCode = "19".concat(idCardNo.substring(6, 12));
            check = checkBirthDayCode(birDayCode);
            if (!check)
              return false;
            return true;
          };
          var check18IdCardNo = function check18IdCardNo2(idCardNo) {
            var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
            if (!check)
              return false;
            var addressCode = idCardNo.substring(0, 2);
            check = checkAddressCode(addressCode);
            if (!check)
              return false;
            var birDayCode = idCardNo.substring(6, 14);
            check = checkBirthDayCode(birDayCode);
            if (!check)
              return false;
            return checkParityBit(idCardNo);
          };
          var checkIdCardNo = function checkIdCardNo2(idCardNo) {
            var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
            if (!check)
              return false;
            if (idCardNo.length === 15) {
              return check15IdCardNo(idCardNo);
            }
            return check18IdCardNo(idCardNo);
          };
          return checkIdCardNo(str);
        },
        "zh-HK": function zhHK(str) {
          str = str.trim();
          var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
          var regexIsDigit = /^[0-9]$/;
          str = str.toUpperCase();
          if (!regexHKID.test(str))
            return false;
          str = str.replace(/\[|\]|\(|\)/g, "");
          if (str.length === 8)
            str = "3".concat(str);
          var checkSumVal = 0;
          for (var i5 = 0; i5 <= 7; i5++) {
            var convertedChar = void 0;
            if (!regexIsDigit.test(str[i5]))
              convertedChar = (str[i5].charCodeAt(0) - 55) % 11;
            else
              convertedChar = str[i5];
            checkSumVal += convertedChar * (9 - i5);
          }
          checkSumVal %= 11;
          var checkSumConverted;
          if (checkSumVal === 0)
            checkSumConverted = "0";
          else if (checkSumVal === 1)
            checkSumConverted = "A";
          else
            checkSumConverted = String(11 - checkSumVal);
          if (checkSumConverted === str[str.length - 1])
            return true;
          return false;
        },
        "zh-TW": function zhTW(str) {
          var ALPHABET_CODES = {
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            G: 16,
            H: 17,
            I: 34,
            J: 18,
            K: 19,
            L: 20,
            M: 21,
            N: 22,
            O: 35,
            P: 23,
            Q: 24,
            R: 25,
            S: 26,
            T: 27,
            U: 28,
            V: 29,
            W: 32,
            X: 30,
            Y: 31,
            Z: 33
          };
          var sanitized = str.trim().toUpperCase();
          if (!/^[A-Z][0-9]{9}$/.test(sanitized))
            return false;
          return Array.from(sanitized).reduce(function(sum3, number2, index2) {
            if (index2 === 0) {
              var code = ALPHABET_CODES[number2];
              return code % 10 * 9 + Math.floor(code / 10);
            }
            if (index2 === 9) {
              return (10 - sum3 % 10 - Number(number2)) % 10 === 0;
            }
            return sum3 + Number(number2) * (9 - index2);
          }, 0);
        }
      };
      function isIdentityCard(str, locale) {
        (0, _assertString.default)(str);
        if (locale in validators) {
          return validators[locale](str);
        } else if (locale === "any") {
          for (var key in validators) {
            if (validators.hasOwnProperty(key)) {
              var validator2 = validators[key];
              if (validator2(str)) {
                return true;
              }
            }
          }
          return false;
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isEAN.js
  var require_isEAN = __commonJS({
    "node_modules/validator/lib/isEAN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isEAN;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var LENGTH_EAN_8 = 8;
      var LENGTH_EAN_14 = 14;
      var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
      function getPositionWeightThroughLengthAndIndex(length, index2) {
        if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
          return index2 % 2 === 0 ? 3 : 1;
        }
        return index2 % 2 === 0 ? 1 : 3;
      }
      function calculateCheckDigit(ean) {
        var checksum = ean.slice(0, -1).split("").map(function(char, index2) {
          return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index2);
        }).reduce(function(acc, partialSum) {
          return acc + partialSum;
        }, 0);
        var remainder = 10 - checksum % 10;
        return remainder < 10 ? remainder : 0;
      }
      function isEAN(str) {
        (0, _assertString.default)(str);
        var actualCheckDigit = Number(str.slice(-1));
        return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISIN.js
  var require_isISIN = __commonJS({
    "node_modules/validator/lib/isISIN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISIN;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
      function isISIN(str) {
        (0, _assertString.default)(str);
        if (!isin.test(str)) {
          return false;
        }
        var double = true;
        var sum3 = 0;
        for (var i5 = str.length - 2; i5 >= 0; i5--) {
          if (str[i5] >= "A" && str[i5] <= "Z") {
            var value = str[i5].charCodeAt(0) - 55;
            var lo = value % 10;
            var hi = Math.trunc(value / 10);
            for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
              var digit = _arr[_i];
              if (double) {
                if (digit >= 5) {
                  sum3 += 1 + (digit - 5) * 2;
                } else {
                  sum3 += digit * 2;
                }
              } else {
                sum3 += digit;
              }
              double = !double;
            }
          } else {
            var _digit = str[i5].charCodeAt(0) - "0".charCodeAt(0);
            if (double) {
              if (_digit >= 5) {
                sum3 += 1 + (_digit - 5) * 2;
              } else {
                sum3 += _digit * 2;
              }
            } else {
              sum3 += _digit;
            }
            double = !double;
          }
        }
        var check = Math.trunc((sum3 + 9) / 10) * 10 - sum3;
        return +str[str.length - 1] === check;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISBN.js
  var require_isISBN = __commonJS({
    "node_modules/validator/lib/isISBN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISBN;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
      var possibleIsbn13 = /^(?:[0-9]{13})$/;
      var factor = [1, 3];
      function isISBN(isbn, options) {
        (0, _assertString.default)(isbn);
        var version3 = String((options === null || options === void 0 ? void 0 : options.version) || options);
        if (!(options !== null && options !== void 0 && options.version || options)) {
          return isISBN(isbn, {
            version: 10
          }) || isISBN(isbn, {
            version: 13
          });
        }
        var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
        var checksum = 0;
        if (version3 === "10") {
          if (!possibleIsbn10.test(sanitizedIsbn)) {
            return false;
          }
          for (var i5 = 0; i5 < version3 - 1; i5++) {
            checksum += (i5 + 1) * sanitizedIsbn.charAt(i5);
          }
          if (sanitizedIsbn.charAt(9) === "X") {
            checksum += 10 * 10;
          } else {
            checksum += 10 * sanitizedIsbn.charAt(9);
          }
          if (checksum % 11 === 0) {
            return true;
          }
        } else if (version3 === "13") {
          if (!possibleIsbn13.test(sanitizedIsbn)) {
            return false;
          }
          for (var _i = 0; _i < 12; _i++) {
            checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
          }
          if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
            return true;
          }
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISSN.js
  var require_isISSN = __commonJS({
    "node_modules/validator/lib/isISSN.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISSN;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var issn = "^\\d{4}-?\\d{3}[\\dX]$";
      function isISSN(str) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (0, _assertString.default)(str);
        var testIssn = issn;
        testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
        testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
        if (!testIssn.test(str)) {
          return false;
        }
        var digits2 = str.replace("-", "").toUpperCase();
        var checksum = 0;
        for (var i5 = 0; i5 < digits2.length; i5++) {
          var digit = digits2[i5];
          checksum += (digit === "X" ? 10 : +digit) * (8 - i5);
        }
        return checksum % 11 === 0;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/util/algorithms.js
  var require_algorithms = __commonJS({
    "node_modules/validator/lib/util/algorithms.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.iso7064Check = iso7064Check;
      exports.luhnCheck = luhnCheck;
      exports.reverseMultiplyAndSum = reverseMultiplyAndSum;
      exports.verhoeffCheck = verhoeffCheck;
      function iso7064Check(str) {
        var checkvalue = 10;
        for (var i5 = 0; i5 < str.length - 1; i5++) {
          checkvalue = (parseInt(str[i5], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i5], 10) + checkvalue) % 10 * 2 % 11;
        }
        checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
        return checkvalue === parseInt(str[10], 10);
      }
      function luhnCheck(str) {
        var checksum = 0;
        var second = false;
        for (var i5 = str.length - 1; i5 >= 0; i5--) {
          if (second) {
            var product3 = parseInt(str[i5], 10) * 2;
            if (product3 > 9) {
              checksum += product3.toString().split("").map(function(a3) {
                return parseInt(a3, 10);
              }).reduce(function(a3, b3) {
                return a3 + b3;
              }, 0);
            } else {
              checksum += product3;
            }
          } else {
            checksum += parseInt(str[i5], 10);
          }
          second = !second;
        }
        return checksum % 10 === 0;
      }
      function reverseMultiplyAndSum(digits2, base) {
        var total = 0;
        for (var i5 = 0; i5 < digits2.length; i5++) {
          total += digits2[i5] * (base - i5);
        }
        return total;
      }
      function verhoeffCheck(str) {
        var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
        var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
        var str_copy = str.split("").reverse().join("");
        var checksum = 0;
        for (var i5 = 0; i5 < str_copy.length; i5++) {
          checksum = d_table[checksum][p_table[i5 % 8][parseInt(str_copy[i5], 10)]];
        }
        return checksum === 0;
      }
    }
  });

  // node_modules/validator/lib/isTaxID.js
  var require_isTaxID = __commonJS({
    "node_modules/validator/lib/isTaxID.js"(exports, module) {
      "use strict";
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isTaxID;
      var _assertString = _interopRequireDefault(require_assertString());
      var algorithms = _interopRequireWildcard(require_algorithms());
      var _isDate = _interopRequireDefault(require_isDate());
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache;
        };
        return cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
          arr2[i5] = arr[i5];
        }
        return arr2;
      }
      function bgBgCheck(tin) {
        var century_year = tin.slice(0, 2);
        var month = parseInt(tin.slice(2, 4), 10);
        if (month > 40) {
          month -= 40;
          century_year = "20".concat(century_year);
        } else if (month > 20) {
          month -= 20;
          century_year = "18".concat(century_year);
        } else {
          century_year = "19".concat(century_year);
        }
        if (month < 10) {
          month = "0".concat(month);
        }
        var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
        var checksum = 0;
        for (var i5 = 0; i5 < multip_lookup.length; i5++) {
          checksum += digits2[i5] * multip_lookup[i5];
        }
        checksum = checksum % 11 === 10 ? 0 : checksum % 11;
        return checksum === digits2[9];
      }
      function isCanadianSIN(input) {
        var digitsArray = input.split("");
        var even = digitsArray.filter(function(_3, idx) {
          return idx % 2;
        }).map(function(i5) {
          return Number(i5) * 2;
        }).join("").split("");
        var total = digitsArray.filter(function(_3, idx) {
          return !(idx % 2);
        }).concat(even).map(function(i5) {
          return Number(i5);
        }).reduce(function(acc, cur) {
          return acc + cur;
        });
        return total % 10 === 0;
      }
      function csCzCheck(tin) {
        tin = tin.replace(/\W/, "");
        var full_year = parseInt(tin.slice(0, 2), 10);
        if (tin.length === 10) {
          if (full_year < 54) {
            full_year = "20".concat(full_year);
          } else {
            full_year = "19".concat(full_year);
          }
        } else {
          if (tin.slice(6) === "000") {
            return false;
          }
          if (full_year < 54) {
            full_year = "19".concat(full_year);
          } else {
            return false;
          }
        }
        if (full_year.length === 3) {
          full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
        }
        var month = parseInt(tin.slice(2, 4), 10);
        if (month > 50) {
          month -= 50;
        }
        if (month > 20) {
          if (parseInt(full_year, 10) < 2004) {
            return false;
          }
          month -= 20;
        }
        if (month < 10) {
          month = "0".concat(month);
        }
        var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        if (tin.length === 10) {
          if (parseInt(tin, 10) % 11 !== 0) {
            var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
            if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
              if (parseInt(tin.slice(9), 10) !== 0) {
                return false;
              }
            } else {
              return false;
            }
          }
        }
        return true;
      }
      function deAtCheck(tin) {
        return algorithms.luhnCheck(tin);
      }
      function deDeCheck(tin) {
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var occurences = [];
        for (var i5 = 0; i5 < digits2.length - 1; i5++) {
          occurences.push("");
          for (var j4 = 0; j4 < digits2.length - 1; j4++) {
            if (digits2[i5] === digits2[j4]) {
              occurences[i5] += j4;
            }
          }
        }
        occurences = occurences.filter(function(a3) {
          return a3.length > 1;
        });
        if (occurences.length !== 2 && occurences.length !== 3) {
          return false;
        }
        if (occurences[0].length === 3) {
          var trip_locations = occurences[0].split("").map(function(a3) {
            return parseInt(a3, 10);
          });
          var recurrent = 0;
          for (var _i = 0; _i < trip_locations.length - 1; _i++) {
            if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
              recurrent += 1;
            }
          }
          if (recurrent === 2) {
            return false;
          }
        }
        return algorithms.iso7064Check(tin);
      }
      function dkDkCheck(tin) {
        tin = tin.replace(/\W/, "");
        var year = parseInt(tin.slice(4, 6), 10);
        var century_digit = tin.slice(6, 7);
        switch (century_digit) {
          case "0":
          case "1":
          case "2":
          case "3":
            year = "19".concat(year);
            break;
          case "4":
          case "9":
            if (year < 37) {
              year = "20".concat(year);
            } else {
              year = "19".concat(year);
            }
            break;
          default:
            if (year < 37) {
              year = "20".concat(year);
            } else if (year > 58) {
              year = "18".concat(year);
            } else {
              return false;
            }
            break;
        }
        if (year.length === 3) {
          year = [year.slice(0, 2), "0", year.slice(2)].join("");
        }
        var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var checksum = 0;
        var weight = 4;
        for (var i5 = 0; i5 < 9; i5++) {
          checksum += digits2[i5] * weight;
          weight -= 1;
          if (weight === 1) {
            weight = 7;
          }
        }
        checksum %= 11;
        if (checksum === 1) {
          return false;
        }
        return checksum === 0 ? digits2[9] === 0 : digits2[9] === 11 - checksum;
      }
      function elCyCheck(tin) {
        var digits2 = tin.slice(0, 8).split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var checksum = 0;
        for (var i5 = 1; i5 < digits2.length; i5 += 2) {
          checksum += digits2[i5];
        }
        for (var _i2 = 0; _i2 < digits2.length; _i2 += 2) {
          if (digits2[_i2] < 2) {
            checksum += 1 - digits2[_i2];
          } else {
            checksum += 2 * (digits2[_i2] - 2) + 5;
            if (digits2[_i2] > 4) {
              checksum += 2;
            }
          }
        }
        return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
      }
      function elGrCheck(tin) {
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var checksum = 0;
        for (var i5 = 0; i5 < 8; i5++) {
          checksum += digits2[i5] * Math.pow(2, 8 - i5);
        }
        return checksum % 11 % 10 === digits2[8];
      }
      function enIeCheck(tin) {
        var checksum = algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a3) {
          return parseInt(a3, 10);
        }), 8);
        if (tin.length === 9 && tin[8] !== "W") {
          checksum += (tin[8].charCodeAt(0) - 64) * 9;
        }
        checksum %= 23;
        if (checksum === 0) {
          return tin[7].toUpperCase() === "W";
        }
        return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
      }
      var enUsCampusPrefix = {
        andover: ["10", "12"],
        atlanta: ["60", "67"],
        austin: ["50", "53"],
        brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
        cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
        fresno: ["15", "24"],
        internet: ["20", "26", "27", "45", "46", "47"],
        kansas: ["40", "44"],
        memphis: ["94", "95"],
        ogden: ["80", "90"],
        philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
        sba: ["31"]
      };
      function enUsGetPrefixes() {
        var prefixes = [];
        for (var location in enUsCampusPrefix) {
          if (enUsCampusPrefix.hasOwnProperty(location)) {
            prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
          }
        }
        return prefixes;
      }
      function enUsCheck(tin) {
        return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
      }
      function esEsCheck(tin) {
        var chars = tin.toUpperCase().split("");
        if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
          var lead_replace = 0;
          switch (chars[0]) {
            case "Y":
              lead_replace = 1;
              break;
            case "Z":
              lead_replace = 2;
              break;
            default:
          }
          chars.splice(0, 1, lead_replace);
        } else {
          while (chars.length < 9) {
            chars.unshift(0);
          }
        }
        var lookup = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
        chars = chars.join("");
        var checksum = parseInt(chars.slice(0, 8), 10) % 23;
        return chars[8] === lookup[checksum];
      }
      function etEeCheck(tin) {
        var full_year = tin.slice(1, 3);
        var century_digit = tin.slice(0, 1);
        switch (century_digit) {
          case "1":
          case "2":
            full_year = "18".concat(full_year);
            break;
          case "3":
          case "4":
            full_year = "19".concat(full_year);
            break;
          default:
            full_year = "20".concat(full_year);
            break;
        }
        var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var checksum = 0;
        var weight = 1;
        for (var i5 = 0; i5 < 10; i5++) {
          checksum += digits2[i5] * weight;
          weight += 1;
          if (weight === 10) {
            weight = 1;
          }
        }
        if (checksum % 11 === 10) {
          checksum = 0;
          weight = 3;
          for (var _i3 = 0; _i3 < 10; _i3++) {
            checksum += digits2[_i3] * weight;
            weight += 1;
            if (weight === 10) {
              weight = 1;
            }
          }
          if (checksum % 11 === 10) {
            return digits2[10] === 0;
          }
        }
        return checksum % 11 === digits2[10];
      }
      function fiFiCheck(tin) {
        var full_year = tin.slice(4, 6);
        var century_symbol = tin.slice(6, 7);
        switch (century_symbol) {
          case "+":
            full_year = "18".concat(full_year);
            break;
          case "-":
            full_year = "19".concat(full_year);
            break;
          default:
            full_year = "20".concat(full_year);
            break;
        }
        var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
        if (checksum < 10) {
          return checksum === parseInt(tin.slice(10), 10);
        }
        checksum -= 10;
        var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
        return letters_lookup[checksum] === tin.slice(10);
      }
      function frBeCheck(tin) {
        if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
          var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
          if (!(0, _isDate.default)(date, "YY/MM/DD")) {
            return false;
          }
        }
        var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
        var checkdigits = parseInt(tin.slice(9, 11), 10);
        if (checksum !== checkdigits) {
          checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
          if (checksum !== checkdigits) {
            return false;
          }
        }
        return true;
      }
      function frFrCheck(tin) {
        tin = tin.replace(/\s/g, "");
        var checksum = parseInt(tin.slice(0, 10), 10) % 511;
        var checkdigits = parseInt(tin.slice(10, 13), 10);
        return checksum === checkdigits;
      }
      function frLuCheck(tin) {
        var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        if (!algorithms.luhnCheck(tin.slice(0, 12))) {
          return false;
        }
        return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
      }
      function hrHrCheck(tin) {
        return algorithms.iso7064Check(tin);
      }
      function huHuCheck(tin) {
        var digits2 = tin.split("").map(function(a3) {
          return parseInt(a3, 10);
        });
        var checksum = 8;
        for (var i5 = 1; i5 < 9; i5++) {
          checksum += digits2[i5] * (i5 + 1);
        }
        return checksum % 11 === digits2[9];
      }
      function itItNameCheck(name307) {
        var vowelflag = false;
        var xflag = false;
        for (var i5 = 0; i5 < 3; i5++) {
          if (!vowelflag && /[AEIOU]/.test(name307[i5])) {
            vowelflag = true;
          } else if (!xflag && vowelflag && name307[i5] === "X") {
            xflag = true;
          } else if (i5 > 0) {
            if (vowelflag && !xflag) {
              if (!/[AEIOU]/.test(name307[i5])) {
                return false;
              }
            }
            if (xflag) {
              if (!/X/.test(name307[i5])) {
                return false;
              }
            }
          }
        }
        return true;
      }
      function itItCheck(tin) {
        var chars = tin.toUpperCase().split("");
        if (!itItNameCheck(chars.slice(0, 3))) {
          return false;
        }
        if (!itItNameCheck(chars.slice(3, 6))) {
          return false;
        }
        var number_locations = [6, 7, 9, 10, 12, 13, 14];
        var number_replace = {
          L: "0",
          M: "1",
          N: "2",
          P: "3",
          Q: "4",
          R: "5",
          S: "6",
          T: "7",
          U: "8",
          V: "9"
        };
        for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
          var i5 = _number_locations[_i4];
          if (chars[i5] in number_replace) {
            chars.splice(i5, 1, number_replace[chars[i5]]);
          }
        }
        var month_replace = {
          A: "01",
          B: "02",
          C: "03",
          D: "04",
          E: "05",
          H: "06",
          L: "07",
          M: "08",
          P: "09",
          R: "10",
          S: "11",
          T: "12"
        };
        var month = month_replace[chars[8]];
        var day = parseInt(chars[9] + chars[10], 10);
        if (day > 40) {
          day -= 40;
        }
        if (day < 10) {
          day = "0".concat(day);
        }
        var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
        var checksum = 0;
        for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
          var char_to_int = parseInt(chars[_i5], 10);
          if (isNaN(char_to_int)) {
            char_to_int = chars[_i5].charCodeAt(0) - 65;
          }
          checksum += char_to_int;
        }
        var odd_convert = {
          // Maps of characters at odd places
          A: 1,
          B: 0,
          C: 5,
          D: 7,
          E: 9,
          F: 13,
          G: 15,
          H: 17,
          I: 19,
          J: 21,
          K: 2,
          L: 4,
          M: 18,
          N: 20,
          O: 11,
          P: 3,
          Q: 6,
          R: 8,
          S: 12,
          T: 14,
          U: 16,
          V: 10,
          W: 22,
          X: 25,
          Y: 24,
          Z: 23,
          0: 1,
          1: 0
        };
        for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
          var _char_to_int = 0;
          if (chars[_i6] in odd_convert) {
            _char_to_int = odd_convert[chars[_i6]];
          } else {
            var multiplier = parseInt(chars[_i6], 10);
            _char_to_int = 2 * multiplier + 1;
            if (multiplier > 4) {
              _char_to_int += 2;
            }
          }
          checksum += _char_to_int;
        }
        if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
          return false;
        }
        return true;
      }
      function lvLvCheck(tin) {
        tin = tin.replace(/\W/, "");
        var day = tin.slice(0, 2);
        if (day !== "32") {
          var month = tin.slice(2, 4);
          if (month !== "00") {
            var full_year = tin.slice(4, 6);
            switch (tin[6]) {
              case "0":
                full_year = "18".concat(full_year);
                break;
              case "1":
                full_year = "19".concat(full_year);
                break;
              default:
                full_year = "20".concat(full_year);
                break;
            }
            var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
            if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
              return false;
            }
          }
          var checksum = 1101;
          var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
          for (var i5 = 0; i5 < tin.length - 1; i5++) {
            checksum -= parseInt(tin[i5], 10) * multip_lookup[i5];
          }
          return parseInt(tin[10], 10) === checksum % 11;
        }
        return true;
      }
      function mtMtCheck(tin) {
        if (tin.length !== 9) {
          var chars = tin.toUpperCase().split("");
          while (chars.length < 8) {
            chars.unshift(0);
          }
          switch (tin[7]) {
            case "A":
            case "P":
              if (parseInt(chars[6], 10) === 0) {
                return false;
              }
              break;
            default: {
              var first_part = parseInt(chars.join("").slice(0, 5), 10);
              if (first_part > 32e3) {
                return false;
              }
              var second_part = parseInt(chars.join("").slice(5, 7), 10);
              if (first_part === second_part) {
                return false;
              }
            }
          }
        }
        return true;
      }
      function nlNlCheck(tin) {
        return algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a3) {
          return parseInt(a3, 10);
        }), 9) % 11 === parseInt(tin[8], 10);
      }
      function plPlCheck(tin) {
        if (tin.length === 10) {
          var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
          var _checksum = 0;
          for (var i5 = 0; i5 < lookup.length; i5++) {
            _checksum += parseInt(tin[i5], 10) * lookup[i5];
          }
          _checksum %= 11;
          if (_checksum === 10) {
            return false;
          }
          return _checksum === parseInt(tin[9], 10);
        }
        var full_year = tin.slice(0, 2);
        var month = parseInt(tin.slice(2, 4), 10);
        if (month > 80) {
          full_year = "18".concat(full_year);
          month -= 80;
        } else if (month > 60) {
          full_year = "22".concat(full_year);
          month -= 60;
        } else if (month > 40) {
          full_year = "21".concat(full_year);
          month -= 40;
        } else if (month > 20) {
          full_year = "20".concat(full_year);
          month -= 20;
        } else {
          full_year = "19".concat(full_year);
        }
        if (month < 10) {
          month = "0".concat(month);
        }
        var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var checksum = 0;
        var multiplier = 1;
        for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
          checksum += parseInt(tin[_i7], 10) * multiplier % 10;
          multiplier += 2;
          if (multiplier > 10) {
            multiplier = 1;
          } else if (multiplier === 5) {
            multiplier += 2;
          }
        }
        checksum = 10 - checksum % 10;
        return checksum === parseInt(tin[10], 10);
      }
      function ptBrCheck(tin) {
        if (tin.length === 11) {
          var _sum;
          var remainder;
          _sum = 0;
          if (
            // Reject known invalid CPFs
            tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000"
          )
            return false;
          for (var i5 = 1; i5 <= 9; i5++) {
            _sum += parseInt(tin.substring(i5 - 1, i5), 10) * (11 - i5);
          }
          remainder = _sum * 10 % 11;
          if (remainder === 10)
            remainder = 0;
          if (remainder !== parseInt(tin.substring(9, 10), 10))
            return false;
          _sum = 0;
          for (var _i8 = 1; _i8 <= 10; _i8++) {
            _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
          }
          remainder = _sum * 10 % 11;
          if (remainder === 10)
            remainder = 0;
          if (remainder !== parseInt(tin.substring(10, 11), 10))
            return false;
          return true;
        }
        if (
          // Reject know invalid CNPJs
          tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999"
        ) {
          return false;
        }
        var length = tin.length - 2;
        var identifiers = tin.substring(0, length);
        var verificators = tin.substring(length);
        var sum3 = 0;
        var pos = length - 7;
        for (var _i9 = length; _i9 >= 1; _i9--) {
          sum3 += identifiers.charAt(length - _i9) * pos;
          pos -= 1;
          if (pos < 2) {
            pos = 9;
          }
        }
        var result = sum3 % 11 < 2 ? 0 : 11 - sum3 % 11;
        if (result !== parseInt(verificators.charAt(0), 10)) {
          return false;
        }
        length += 1;
        identifiers = tin.substring(0, length);
        sum3 = 0;
        pos = length - 7;
        for (var _i10 = length; _i10 >= 1; _i10--) {
          sum3 += identifiers.charAt(length - _i10) * pos;
          pos -= 1;
          if (pos < 2) {
            pos = 9;
          }
        }
        result = sum3 % 11 < 2 ? 0 : 11 - sum3 % 11;
        if (result !== parseInt(verificators.charAt(1), 10)) {
          return false;
        }
        return true;
      }
      function ptPtCheck(tin) {
        var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a3) {
          return parseInt(a3, 10);
        }), 9) % 11;
        if (checksum > 9) {
          return parseInt(tin[8], 10) === 0;
        }
        return checksum === parseInt(tin[8], 10);
      }
      function roRoCheck(tin) {
        if (tin.slice(0, 4) !== "9000") {
          var full_year = tin.slice(1, 3);
          switch (tin[0]) {
            case "1":
            case "2":
              full_year = "19".concat(full_year);
              break;
            case "3":
            case "4":
              full_year = "18".concat(full_year);
              break;
            case "5":
            case "6":
              full_year = "20".concat(full_year);
              break;
            default:
          }
          var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
          if (date.length === 8) {
            if (!(0, _isDate.default)(date, "YY/MM/DD")) {
              return false;
            }
          } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
            return false;
          }
          var digits2 = tin.split("").map(function(a3) {
            return parseInt(a3, 10);
          });
          var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
          var checksum = 0;
          for (var i5 = 0; i5 < multipliers.length; i5++) {
            checksum += digits2[i5] * multipliers[i5];
          }
          if (checksum % 11 === 10) {
            return digits2[12] === 1;
          }
          return digits2[12] === checksum % 11;
        }
        return true;
      }
      function skSkCheck(tin) {
        if (tin.length === 9) {
          tin = tin.replace(/\W/, "");
          if (tin.slice(6) === "000") {
            return false;
          }
          var full_year = parseInt(tin.slice(0, 2), 10);
          if (full_year > 53) {
            return false;
          }
          if (full_year < 10) {
            full_year = "190".concat(full_year);
          } else {
            full_year = "19".concat(full_year);
          }
          var month = parseInt(tin.slice(2, 4), 10);
          if (month > 50) {
            month -= 50;
          }
          if (month < 10) {
            month = "0".concat(month);
          }
          var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
          if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
            return false;
          }
        }
        return true;
      }
      function slSiCheck(tin) {
        var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a3) {
          return parseInt(a3, 10);
        }), 8) % 11;
        if (checksum === 10) {
          return parseInt(tin[7], 10) === 0;
        }
        return checksum === parseInt(tin[7], 10);
      }
      function svSeCheck(tin) {
        var tin_copy = tin.slice(0);
        if (tin.length > 11) {
          tin_copy = tin_copy.slice(2);
        }
        var full_year = "";
        var month = tin_copy.slice(2, 4);
        var day = parseInt(tin_copy.slice(4, 6), 10);
        if (tin.length > 11) {
          full_year = tin.slice(0, 4);
        } else {
          full_year = tin.slice(0, 2);
          if (tin.length === 11 && day < 60) {
            var current_year = (/* @__PURE__ */ new Date()).getFullYear().toString();
            var current_century = parseInt(current_year.slice(0, 2), 10);
            current_year = parseInt(current_year, 10);
            if (tin[6] === "-") {
              if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
                full_year = "".concat(current_century - 1).concat(full_year);
              } else {
                full_year = "".concat(current_century).concat(full_year);
              }
            } else {
              full_year = "".concat(current_century - 1).concat(full_year);
              if (current_year - parseInt(full_year, 10) < 100) {
                return false;
              }
            }
          }
        }
        if (day > 60) {
          day -= 60;
        }
        if (day < 10) {
          day = "0".concat(day);
        }
        var date = "".concat(full_year, "/").concat(month, "/").concat(day);
        if (date.length === 8) {
          if (!(0, _isDate.default)(date, "YY/MM/DD")) {
            return false;
          }
        } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        return algorithms.luhnCheck(tin.replace(/\W/, ""));
      }
      var taxIdFormat = {
        "bg-BG": /^\d{10}$/,
        "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
        "de-AT": /^\d{9}$/,
        "de-DE": /^[1-9]\d{10}$/,
        "dk-DK": /^\d{6}-{0,1}\d{4}$/,
        "el-CY": /^[09]\d{7}[A-Z]$/,
        "el-GR": /^([0-4]|[7-9])\d{8}$/,
        "en-CA": /^\d{9}$/,
        "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
        "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
        "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
        "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
        "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
        "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
        "fr-BE": /^\d{11}$/,
        "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
        // Conforms both to official spec and provided example
        "fr-LU": /^\d{13}$/,
        "hr-HR": /^\d{11}$/,
        "hu-HU": /^8\d{9}$/,
        "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
        "lv-LV": /^\d{6}-{0,1}\d{5}$/,
        // Conforms both to DG TAXUD spec and original research
        "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
        "nl-NL": /^\d{9}$/,
        "pl-PL": /^\d{10,11}$/,
        "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
        "pt-PT": /^\d{9}$/,
        "ro-RO": /^\d{13}$/,
        "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
        "sl-SI": /^[1-9]\d{7}$/,
        "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/
      };
      taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
      taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
      taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
      taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
      var taxIdCheck = {
        "bg-BG": bgBgCheck,
        "cs-CZ": csCzCheck,
        "de-AT": deAtCheck,
        "de-DE": deDeCheck,
        "dk-DK": dkDkCheck,
        "el-CY": elCyCheck,
        "el-GR": elGrCheck,
        "en-CA": isCanadianSIN,
        "en-IE": enIeCheck,
        "en-US": enUsCheck,
        "es-ES": esEsCheck,
        "et-EE": etEeCheck,
        "fi-FI": fiFiCheck,
        "fr-BE": frBeCheck,
        "fr-FR": frFrCheck,
        "fr-LU": frLuCheck,
        "hr-HR": hrHrCheck,
        "hu-HU": huHuCheck,
        "it-IT": itItCheck,
        "lv-LV": lvLvCheck,
        "mt-MT": mtMtCheck,
        "nl-NL": nlNlCheck,
        "pl-PL": plPlCheck,
        "pt-BR": ptBrCheck,
        "pt-PT": ptPtCheck,
        "ro-RO": roRoCheck,
        "sk-SK": skSkCheck,
        "sl-SI": slSiCheck,
        "sv-SE": svSeCheck
      };
      taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
      taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
      taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
      taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
      var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
      var sanitizeRegexes = {
        "de-AT": allsymbols,
        "de-DE": /[\/\\]/g,
        "fr-BE": allsymbols
      };
      sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
      function isTaxID(str) {
        var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
        (0, _assertString.default)(str);
        var strcopy = str.slice(0);
        if (locale in taxIdFormat) {
          if (locale in sanitizeRegexes) {
            strcopy = strcopy.replace(sanitizeRegexes[locale], "");
          }
          if (!taxIdFormat[locale].test(strcopy)) {
            return false;
          }
          if (locale in taxIdCheck) {
            return taxIdCheck[locale](strcopy);
          }
          return true;
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMobilePhone.js
  var require_isMobilePhone = __commonJS({
    "node_modules/validator/lib/isMobilePhone.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMobilePhone;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var phones = {
        "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
        "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
        "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
        "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
        "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
        "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
        "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
        "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
        "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
        "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
        "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
        "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
        "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
        "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
        "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
        "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
        "ar-TN": /^(\+?216)?[2459]\d{7}$/,
        "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
        "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
        "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
        "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
        "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
        "ca-AD": /^(\+376)?[346]\d{5}$/,
        "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
        "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
        "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
        "de-LU": /^(\+352)?((6\d1)\d{6})$/,
        "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
        "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
        "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
        "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
        "en-AU": /^(\+?61|0)4\d{8}$/,
        "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
        "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
        "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
        "en-GB": /^(\+?44|0)7\d{9}$/,
        "en-GG": /^(\+?44|0)1481\d{6}$/,
        "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
        "en-GY": /^(\+592|0)6\d{6}$/,
        "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
        "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
        "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
        "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
        "en-JM": /^(\+?876)?\d{7}$/,
        "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
        "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
        "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
        "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
        "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
        "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
        "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
        "en-MU": /^(\+?230|0)?\d{8}$/,
        "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
        "en-NG": /^(\+?234|0)?[789]\d{9}$/,
        "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
        "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
        "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
        "en-PH": /^(09|\+639)\d{9}$/,
        "en-RW": /^(\+?250|0)?[7]\d{8}$/,
        "en-SG": /^(\+65)?[3689]\d{7}$/,
        "en-SL": /^(\+?232|0)\d{8}$/,
        "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
        "en-UG": /^(\+?256|0)?[7]\d{8}$/,
        "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
        "en-ZA": /^(\+?27|0)\d{9}$/,
        "en-ZM": /^(\+?26)?09[567]\d{7}$/,
        "en-ZW": /^(\+263)[0-9]{9}$/,
        "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
        "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
        "es-BO": /^(\+?591)?(6|7)\d{7}$/,
        "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
        "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
        "es-CR": /^(\+506)?[2-8]\d{7}$/,
        "es-CU": /^(\+53|0053)?5\d{7}$/,
        "es-DO": /^(\+?1)?8[024]9\d{7}$/,
        "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
        "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
        "es-ES": /^(\+?34)?[6|7]\d{8}$/,
        "es-PE": /^(\+?51)?9\d{8}$/,
        "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
        "es-NI": /^(\+?505)\d{7,8}$/,
        "es-PA": /^(\+?507)\d{7,8}$/,
        "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
        "es-SV": /^(\+?503)?[67]\d{7}$/,
        "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
        "es-VE": /^(\+?58)?(2|4)\d{9}$/,
        "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
        "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
        "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
        "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
        "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "fr-BF": /^(\+226|0)[67]\d{7}$/,
        "fr-BJ": /^(\+229)\d{8}$/,
        "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
        "fr-CM": /^(\+?237)6[0-9]{8}$/,
        "fr-FR": /^(\+?33|0)[67]\d{8}$/,
        "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
        "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
        "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
        "fr-PF": /^(\+?689)?8[789]\d{6}$/,
        "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
        "fr-WF": /^(\+681)?\d{6}$/,
        "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
        "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
        "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
        "ir-IR": /^(\+98|0)?9\d{9}$/,
        "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
        "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
        "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
        "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
        "kk-KZ": /^(\+?7|8)?7\d{9}$/,
        "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
        "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
        "lt-LT": /^(\+370|8)\d{8}$/,
        "lv-LV": /^(\+?371)2\d{7}$/,
        "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
        "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
        "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
        "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
        "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
        "nb-NO": /^(\+?47)?[49]\d{7}$/,
        "ne-NP": /^(\+?977)?9[78]\d{8}$/,
        "nl-BE": /^(\+?32|0)4\d{8}$/,
        "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
        "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
        "nn-NO": /^(\+?47)?[49]\d{7}$/,
        "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
        "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
        "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
        "pt-AO": /^(\+244)\d{9}$/,
        "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
        "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
        "ru-RU": /^(\+?7|8)?9\d{9}$/,
        "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
        "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
        "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
        "sq-AL": /^(\+355|0)6[789]\d{6}$/,
        "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
        "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
        "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
        "th-TH": /^(\+66|66|0)\d{9}$/,
        "tr-TR": /^(\+?90|0)?5\d{9}$/,
        "tk-TM": /^(\+993|993|8)\d{8}$/,
        "uk-UA": /^(\+?38|8)?0\d{9}$/,
        "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
        "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
        "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
        "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
        "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
        "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
        "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
        "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
      };
      phones["en-CA"] = phones["en-US"];
      phones["fr-CA"] = phones["en-CA"];
      phones["fr-BE"] = phones["nl-BE"];
      phones["zh-HK"] = phones["en-HK"];
      phones["zh-MO"] = phones["en-MO"];
      phones["ga-IE"] = phones["en-IE"];
      phones["fr-CH"] = phones["de-CH"];
      phones["it-CH"] = phones["fr-CH"];
      function isMobilePhone(str, locale, options) {
        (0, _assertString.default)(str);
        if (options && options.strictMode && !str.startsWith("+")) {
          return false;
        }
        if (Array.isArray(locale)) {
          return locale.some(function(key2) {
            if (phones.hasOwnProperty(key2)) {
              var phone2 = phones[key2];
              if (phone2.test(str)) {
                return true;
              }
            }
            return false;
          });
        } else if (locale in phones) {
          return phones[locale].test(str);
        } else if (!locale || locale === "any") {
          for (var key in phones) {
            if (phones.hasOwnProperty(key)) {
              var phone = phones[key];
              if (phone.test(str)) {
                return true;
              }
            }
          }
          return false;
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      var locales = Object.keys(phones);
      exports.locales = locales;
    }
  });

  // node_modules/validator/lib/isEthereumAddress.js
  var require_isEthereumAddress = __commonJS({
    "node_modules/validator/lib/isEthereumAddress.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isEthereumAddress;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var eth = /^(0x)[0-9a-f]{40}$/i;
      function isEthereumAddress(str) {
        (0, _assertString.default)(str);
        return eth.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isCurrency.js
  var require_isCurrency = __commonJS({
    "node_modules/validator/lib/isCurrency.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isCurrency;
      var _merge = _interopRequireDefault(require_merge());
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function currencyRegex(options) {
        var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
        options.digits_after_decimal.forEach(function(digit, index2) {
          if (index2 !== 0)
            decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
        });
        var symbol = "(".concat(options.symbol.replace(/\W/, function(m3) {
          return "\\".concat(m3);
        }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
        var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
        if (options.allow_negatives && !options.parens_for_negatives) {
          if (options.negative_sign_after_digits) {
            pattern += negative;
          } else if (options.negative_sign_before_digits) {
            pattern = negative + pattern;
          }
        }
        if (options.allow_negative_sign_placeholder) {
          pattern = "( (?!\\-))?".concat(pattern);
        } else if (options.allow_space_after_symbol) {
          pattern = " ?".concat(pattern);
        } else if (options.allow_space_after_digits) {
          pattern += "( (?!$))?";
        }
        if (options.symbol_after_digits) {
          pattern += symbol;
        } else {
          pattern = symbol + pattern;
        }
        if (options.allow_negatives) {
          if (options.parens_for_negatives) {
            pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
          } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
            pattern = negative + pattern;
          }
        }
        return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
      }
      var default_currency_options = {
        symbol: "$",
        require_symbol: false,
        allow_space_after_symbol: false,
        symbol_after_digits: false,
        allow_negatives: true,
        parens_for_negatives: false,
        negative_sign_before_digits: false,
        negative_sign_after_digits: false,
        allow_negative_sign_placeholder: false,
        thousands_separator: ",",
        decimal_separator: ".",
        allow_decimal: true,
        require_decimal: false,
        digits_after_decimal: [2],
        allow_space_after_digits: false
      };
      function isCurrency(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, default_currency_options);
        return currencyRegex(options).test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isBtcAddress.js
  var require_isBtcAddress = __commonJS({
    "node_modules/validator/lib/isBtcAddress.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBtcAddress;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
      var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
      function isBtcAddress(str) {
        (0, _assertString.default)(str);
        return bech32.test(str) || base58.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISO6346.js
  var require_isISO6346 = __commonJS({
    "node_modules/validator/lib/isISO6346.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isISO6346 = isISO6346;
      exports.isFreightContainerID = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
      var isDigit = /^[0-9]$/;
      function isISO6346(str) {
        (0, _assertString.default)(str);
        str = str.toUpperCase();
        if (!isISO6346Str.test(str))
          return false;
        if (str.length === 11) {
          var sum3 = 0;
          for (var i5 = 0; i5 < str.length - 1; i5++) {
            if (!isDigit.test(str[i5])) {
              var convertedCode = void 0;
              var letterCode = str.charCodeAt(i5) - 55;
              if (letterCode < 11)
                convertedCode = letterCode;
              else if (letterCode >= 11 && letterCode <= 20)
                convertedCode = 12 + letterCode % 11;
              else if (letterCode >= 21 && letterCode <= 30)
                convertedCode = 23 + letterCode % 21;
              else
                convertedCode = 34 + letterCode % 31;
              sum3 += convertedCode * Math.pow(2, i5);
            } else
              sum3 += str[i5] * Math.pow(2, i5);
          }
          var checkSumDigit = sum3 % 11;
          return Number(str[str.length - 1]) === checkSumDigit;
        }
        return true;
      }
      var isFreightContainerID = isISO6346;
      exports.isFreightContainerID = isFreightContainerID;
    }
  });

  // node_modules/validator/lib/isISO6391.js
  var require_isISO6391 = __commonJS({
    "node_modules/validator/lib/isISO6391.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISO6391;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isISO6391Set = /* @__PURE__ */ new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
      function isISO6391(str) {
        (0, _assertString.default)(str);
        return isISO6391Set.has(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISO8601.js
  var require_isISO8601 = __commonJS({
    "node_modules/validator/lib/isISO8601.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISO8601;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
      var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
      var isValidDate = function isValidDate2(str) {
        var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
        if (ordinalMatch) {
          var oYear = Number(ordinalMatch[1]);
          var oDay = Number(ordinalMatch[2]);
          if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
            return oDay <= 366;
          return oDay <= 365;
        }
        var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
        var year = match[1];
        var month = match[2];
        var day = match[3];
        var monthString = month ? "0".concat(month).slice(-2) : month;
        var dayString = day ? "0".concat(day).slice(-2) : day;
        var d3 = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
        if (month && day) {
          return d3.getUTCFullYear() === year && d3.getUTCMonth() + 1 === month && d3.getUTCDate() === day;
        }
        return true;
      };
      function isISO8601(str) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        (0, _assertString.default)(str);
        var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
        if (check && options.strict)
          return isValidDate(str);
        return check;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isRFC3339.js
  var require_isRFC3339 = __commonJS({
    "node_modules/validator/lib/isRFC3339.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isRFC3339;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var dateFullYear = /[0-9]{4}/;
      var dateMonth = /(0[1-9]|1[0-2])/;
      var dateMDay = /([12]\d|0[1-9]|3[01])/;
      var timeHour = /([01][0-9]|2[0-3])/;
      var timeMinute = /[0-5][0-9]/;
      var timeSecond = /([0-5][0-9]|60)/;
      var timeSecFrac = /(\.[0-9]+)?/;
      var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
      var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
      var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
      var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
      var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
      var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
      function isRFC3339(str) {
        (0, _assertString.default)(str);
        return rfc3339.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISO31661Alpha3.js
  var require_isISO31661Alpha3 = __commonJS({
    "node_modules/validator/lib/isISO31661Alpha3.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISO31661Alpha3;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
      function isISO31661Alpha3(str) {
        (0, _assertString.default)(str);
        return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isISO4217.js
  var require_isISO4217 = __commonJS({
    "node_modules/validator/lib/isISO4217.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isISO4217;
      exports.CurrencyCodes = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validISO4217CurrencyCodes = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
      function isISO4217(str) {
        (0, _assertString.default)(str);
        return validISO4217CurrencyCodes.has(str.toUpperCase());
      }
      var CurrencyCodes = validISO4217CurrencyCodes;
      exports.CurrencyCodes = CurrencyCodes;
    }
  });

  // node_modules/validator/lib/isBase32.js
  var require_isBase32 = __commonJS({
    "node_modules/validator/lib/isBase32.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBase32;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var base32 = /^[A-Z2-7]+=*$/;
      var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
      var defaultBase32Options = {
        crockford: false
      };
      function isBase32(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, defaultBase32Options);
        if (options.crockford) {
          return crockfordBase32.test(str);
        }
        var len = str.length;
        if (len % 8 === 0 && base32.test(str)) {
          return true;
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isBase58.js
  var require_isBase58 = __commonJS({
    "node_modules/validator/lib/isBase58.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isBase58;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
      function isBase58(str) {
        (0, _assertString.default)(str);
        if (base58Reg.test(str)) {
          return true;
        }
        return false;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isDataURI.js
  var require_isDataURI = __commonJS({
    "node_modules/validator/lib/isDataURI.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isDataURI;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
      var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
      var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
      function isDataURI(str) {
        (0, _assertString.default)(str);
        var data = str.split(",");
        if (data.length < 2) {
          return false;
        }
        var attributes = data.shift().trim().split(";");
        var schemeAndMediaType = attributes.shift();
        if (schemeAndMediaType.slice(0, 5) !== "data:") {
          return false;
        }
        var mediaType = schemeAndMediaType.slice(5);
        if (mediaType !== "" && !validMediaType.test(mediaType)) {
          return false;
        }
        for (var i5 = 0; i5 < attributes.length; i5++) {
          if (!(i5 === attributes.length - 1 && attributes[i5].toLowerCase() === "base64") && !validAttribute.test(attributes[i5])) {
            return false;
          }
        }
        for (var _i = 0; _i < data.length; _i++) {
          if (!validData.test(data[_i])) {
            return false;
          }
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMagnetURI.js
  var require_isMagnetURI = __commonJS({
    "node_modules/validator/lib/isMagnetURI.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMagnetURI;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
      function isMagnetURI(url) {
        (0, _assertString.default)(url);
        if (url.indexOf("magnet:?") !== 0) {
          return false;
        }
        return magnetURIComponent.test(url);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/rtrim.js
  var require_rtrim = __commonJS({
    "node_modules/validator/lib/rtrim.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = rtrim;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function rtrim(str, chars) {
        (0, _assertString.default)(str);
        if (chars) {
          var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
          return str.replace(pattern, "");
        }
        var strIndex = str.length - 1;
        while (/\s/.test(str.charAt(strIndex))) {
          strIndex -= 1;
        }
        return str.slice(0, strIndex + 1);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/ltrim.js
  var require_ltrim = __commonJS({
    "node_modules/validator/lib/ltrim.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = ltrim;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function ltrim(str, chars) {
        (0, _assertString.default)(str);
        var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
        return str.replace(pattern, "");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/trim.js
  var require_trim = __commonJS({
    "node_modules/validator/lib/trim.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = trim;
      var _rtrim = _interopRequireDefault(require_rtrim());
      var _ltrim = _interopRequireDefault(require_ltrim());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function trim(str, chars) {
        return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMailtoURI.js
  var require_isMailtoURI = __commonJS({
    "node_modules/validator/lib/isMailtoURI.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMailtoURI;
      var _trim = _interopRequireDefault(require_trim());
      var _isEmail = _interopRequireDefault(require_isEmail());
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _slicedToArray(arr, i5) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i5) || _unsupportedIterableToArray(arr, i5) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _iterableToArrayLimit(arr, i5) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n2 = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
            _arr.push(_s.value);
            if (i5 && _arr.length === i5)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n2 && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _createForOfIteratorHelper(o3, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o3[Symbol.iterator] == null) {
          if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
            if (it)
              o3 = it;
            var i5 = 0;
            var F4 = function F5() {
            };
            return { s: F4, n: function n3() {
              if (i5 >= o3.length)
                return { done: true };
              return { done: false, value: o3[i5++] };
            }, e: function e6(_e2) {
              throw _e2;
            }, f: F4 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s3() {
          it = o3[Symbol.iterator]();
        }, n: function n3() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e6(_e3) {
          didErr = true;
          err = _e3;
        }, f: function f3() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o3, minLen) {
        if (!o3)
          return;
        if (typeof o3 === "string")
          return _arrayLikeToArray(o3, minLen);
        var n3 = Object.prototype.toString.call(o3).slice(8, -1);
        if (n3 === "Object" && o3.constructor)
          n3 = o3.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o3, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
          arr2[i5] = arr[i5];
        }
        return arr2;
      }
      function parseMailtoQueryString(queryString) {
        var allowedParams = /* @__PURE__ */ new Set(["subject", "body", "cc", "bcc"]), query = {
          cc: "",
          bcc: ""
        };
        var isParseFailed = false;
        var queryParams = queryString.split("&");
        if (queryParams.length > 4) {
          return false;
        }
        var _iterator = _createForOfIteratorHelper(queryParams), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var q4 = _step.value;
            var _q$split = q4.split("="), _q$split2 = _slicedToArray(_q$split, 2), key = _q$split2[0], value = _q$split2[1];
            if (key && !allowedParams.has(key)) {
              isParseFailed = true;
              break;
            }
            if (value && (key === "cc" || key === "bcc")) {
              query[key] = value;
            }
            if (key) {
              allowedParams.delete(key);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return isParseFailed ? false : query;
      }
      function isMailtoURI(url, options) {
        (0, _assertString.default)(url);
        if (url.indexOf("mailto:") !== 0) {
          return false;
        }
        var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray(_url$replace$split, 2), _url$replace$split2$ = _url$replace$split2[0], to2 = _url$replace$split2$ === void 0 ? "" : _url$replace$split2$, _url$replace$split2$2 = _url$replace$split2[1], queryString = _url$replace$split2$2 === void 0 ? "" : _url$replace$split2$2;
        if (!to2 && !queryString) {
          return true;
        }
        var query = parseMailtoQueryString(queryString);
        if (!query) {
          return false;
        }
        return "".concat(to2, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
          email = (0, _trim.default)(email, " ");
          if (email) {
            return (0, _isEmail.default)(email, options);
          }
          return true;
        });
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isMimeType.js
  var require_isMimeType = __commonJS({
    "node_modules/validator/lib/isMimeType.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isMimeType;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
      var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
      var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
      function isMimeType(str) {
        (0, _assertString.default)(str);
        return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLatLong.js
  var require_isLatLong = __commonJS({
    "node_modules/validator/lib/isLatLong.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLatLong;
      var _assertString = _interopRequireDefault(require_assertString());
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
      var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
      var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
      var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
      var defaultLatLongOptions = {
        checkDMS: false
      };
      function isLatLong(str, options) {
        (0, _assertString.default)(str);
        options = (0, _merge.default)(options, defaultLatLongOptions);
        if (!str.includes(","))
          return false;
        var pair = str.split(",");
        if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
          return false;
        if (options.checkDMS) {
          return latDMS.test(pair[0]) && longDMS.test(pair[1]);
        }
        return lat.test(pair[0]) && long.test(pair[1]);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isPostalCode.js
  var require_isPostalCode = __commonJS({
    "node_modules/validator/lib/isPostalCode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isPostalCode;
      exports.locales = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var threeDigit = /^\d{3}$/;
      var fourDigit = /^\d{4}$/;
      var fiveDigit = /^\d{5}$/;
      var sixDigit = /^\d{6}$/;
      var patterns = {
        AD: /^AD\d{3}$/,
        AT: fourDigit,
        AU: fourDigit,
        AZ: /^AZ\d{4}$/,
        BA: /^([7-8]\d{4}$)/,
        BE: fourDigit,
        BG: fourDigit,
        BR: /^\d{5}-\d{3}$/,
        BY: /^2[1-4]\d{4}$/,
        CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
        CH: fourDigit,
        CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
        CZ: /^\d{3}\s?\d{2}$/,
        DE: fiveDigit,
        DK: fourDigit,
        DO: fiveDigit,
        DZ: fiveDigit,
        EE: fiveDigit,
        ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
        FI: fiveDigit,
        FR: /^\d{2}\s?\d{3}$/,
        GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
        GR: /^\d{3}\s?\d{2}$/,
        HR: /^([1-5]\d{4}$)/,
        HT: /^HT\d{4}$/,
        HU: fourDigit,
        ID: fiveDigit,
        IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
        IL: /^(\d{5}|\d{7})$/,
        IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
        IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
        IS: threeDigit,
        IT: fiveDigit,
        JP: /^\d{3}\-\d{4}$/,
        KE: fiveDigit,
        KR: /^(\d{5}|\d{6})$/,
        LI: /^(948[5-9]|949[0-7])$/,
        LT: /^LT\-\d{5}$/,
        LU: fourDigit,
        LV: /^LV\-\d{4}$/,
        LK: fiveDigit,
        MG: threeDigit,
        MX: fiveDigit,
        MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
        MY: fiveDigit,
        NL: /^\d{4}\s?[a-z]{2}$/i,
        NO: fourDigit,
        NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
        NZ: fourDigit,
        PL: /^\d{2}\-\d{3}$/,
        PR: /^00[679]\d{2}([ -]\d{4})?$/,
        PT: /^\d{4}\-\d{3}?$/,
        RO: sixDigit,
        RU: sixDigit,
        SA: fiveDigit,
        SE: /^[1-9]\d{2}\s?\d{2}$/,
        SG: sixDigit,
        SI: fourDigit,
        SK: /^\d{3}\s?\d{2}$/,
        TH: fiveDigit,
        TN: fourDigit,
        TW: /^\d{3}(\d{2})?$/,
        UA: fiveDigit,
        US: /^\d{5}(-\d{4})?$/,
        ZA: fourDigit,
        ZM: fiveDigit
      };
      var locales = Object.keys(patterns);
      exports.locales = locales;
      function isPostalCode(str, locale) {
        (0, _assertString.default)(str);
        if (locale in patterns) {
          return patterns[locale].test(str);
        } else if (locale === "any") {
          for (var key in patterns) {
            if (patterns.hasOwnProperty(key)) {
              var pattern = patterns[key];
              if (pattern.test(str)) {
                return true;
              }
            }
          }
          return false;
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
    }
  });

  // node_modules/validator/lib/escape.js
  var require_escape = __commonJS({
    "node_modules/validator/lib/escape.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = escape2;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function escape2(str) {
        (0, _assertString.default)(str);
        return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/unescape.js
  var require_unescape = __commonJS({
    "node_modules/validator/lib/unescape.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = unescape;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function unescape(str) {
        (0, _assertString.default)(str);
        return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/blacklist.js
  var require_blacklist = __commonJS({
    "node_modules/validator/lib/blacklist.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = blacklist;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function blacklist(str, chars) {
        (0, _assertString.default)(str);
        return str.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/stripLow.js
  var require_stripLow = __commonJS({
    "node_modules/validator/lib/stripLow.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = stripLow;
      var _assertString = _interopRequireDefault(require_assertString());
      var _blacklist = _interopRequireDefault(require_blacklist());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function stripLow(str, keep_new_lines) {
        (0, _assertString.default)(str);
        var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
        return (0, _blacklist.default)(str, chars);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/whitelist.js
  var require_whitelist = __commonJS({
    "node_modules/validator/lib/whitelist.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = whitelist;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function whitelist(str, chars) {
        (0, _assertString.default)(str);
        return str.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isWhitelisted.js
  var require_isWhitelisted = __commonJS({
    "node_modules/validator/lib/isWhitelisted.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isWhitelisted;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function isWhitelisted(str, chars) {
        (0, _assertString.default)(str);
        for (var i5 = str.length - 1; i5 >= 0; i5--) {
          if (chars.indexOf(str[i5]) === -1) {
            return false;
          }
        }
        return true;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/normalizeEmail.js
  var require_normalizeEmail = __commonJS({
    "node_modules/validator/lib/normalizeEmail.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = normalizeEmail;
      var _merge = _interopRequireDefault(require_merge());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var default_normalize_email_options = {
        // The following options apply to all email addresses
        // Lowercases the local part of the email address.
        // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
        // The domain is always lowercased, as per RFC 1035
        all_lowercase: true,
        // The following conversions are specific to GMail
        // Lowercases the local part of the GMail address (known to be case-insensitive)
        gmail_lowercase: true,
        // Removes dots from the local part of the email address, as that's ignored by GMail
        gmail_remove_dots: true,
        // Removes the subaddress (e.g. "+foo") from the email address
        gmail_remove_subaddress: true,
        // Conversts the googlemail.com domain to gmail.com
        gmail_convert_googlemaildotcom: true,
        // The following conversions are specific to Outlook.com / Windows Live / Hotmail
        // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
        outlookdotcom_lowercase: true,
        // Removes the subaddress (e.g. "+foo") from the email address
        outlookdotcom_remove_subaddress: true,
        // The following conversions are specific to Yahoo
        // Lowercases the local part of the Yahoo address (known to be case-insensitive)
        yahoo_lowercase: true,
        // Removes the subaddress (e.g. "-foo") from the email address
        yahoo_remove_subaddress: true,
        // The following conversions are specific to Yandex
        // Lowercases the local part of the Yandex address (known to be case-insensitive)
        yandex_lowercase: true,
        // The following conversions are specific to iCloud
        // Lowercases the local part of the iCloud address (known to be case-insensitive)
        icloud_lowercase: true,
        // Removes the subaddress (e.g. "+foo") from the email address
        icloud_remove_subaddress: true
      };
      var icloud_domains = ["icloud.com", "me.com"];
      var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
      var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
      var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
      function dotsReplacer(match) {
        if (match.length > 1) {
          return match;
        }
        return "";
      }
      function normalizeEmail(email, options) {
        options = (0, _merge.default)(options, default_normalize_email_options);
        var raw_parts = email.split("@");
        var domain = raw_parts.pop();
        var user = raw_parts.join("@");
        var parts = [user, domain];
        parts[1] = parts[1].toLowerCase();
        if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
          if (options.gmail_remove_subaddress) {
            parts[0] = parts[0].split("+")[0];
          }
          if (options.gmail_remove_dots) {
            parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
          }
          if (!parts[0].length) {
            return false;
          }
          if (options.all_lowercase || options.gmail_lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
          parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
        } else if (icloud_domains.indexOf(parts[1]) >= 0) {
          if (options.icloud_remove_subaddress) {
            parts[0] = parts[0].split("+")[0];
          }
          if (!parts[0].length) {
            return false;
          }
          if (options.all_lowercase || options.icloud_lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
        } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
          if (options.outlookdotcom_remove_subaddress) {
            parts[0] = parts[0].split("+")[0];
          }
          if (!parts[0].length) {
            return false;
          }
          if (options.all_lowercase || options.outlookdotcom_lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
        } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
          if (options.yahoo_remove_subaddress) {
            var components = parts[0].split("-");
            parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
          }
          if (!parts[0].length) {
            return false;
          }
          if (options.all_lowercase || options.yahoo_lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
        } else if (yandex_domains.indexOf(parts[1]) >= 0) {
          if (options.all_lowercase || options.yandex_lowercase) {
            parts[0] = parts[0].toLowerCase();
          }
          parts[1] = "yandex.ru";
        } else if (options.all_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        return parts.join("@");
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isSlug.js
  var require_isSlug = __commonJS({
    "node_modules/validator/lib/isSlug.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isSlug;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
      function isSlug(str) {
        (0, _assertString.default)(str);
        return charsetRegex.test(str);
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isLicensePlate.js
  var require_isLicensePlate = __commonJS({
    "node_modules/validator/lib/isLicensePlate.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isLicensePlate;
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var validators = {
        "cs-CZ": function csCZ(str) {
          return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
        },
        "de-DE": function deDE(str) {
          return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
        },
        "de-LI": function deLI(str) {
          return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
        },
        "en-IN": function enIN(str) {
          return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
        },
        "es-AR": function esAR(str) {
          return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
        },
        "fi-FI": function fiFI(str) {
          return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
        },
        "hu-HU": function huHU(str) {
          return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
        },
        "pt-BR": function ptBR(str) {
          return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
        },
        "pt-PT": function ptPT(str) {
          return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(str);
        },
        "sq-AL": function sqAL(str) {
          return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
        },
        "sv-SE": function svSE(str) {
          return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(str.trim());
        }
      };
      function isLicensePlate(str, locale) {
        (0, _assertString.default)(str);
        if (locale in validators) {
          return validators[locale](str);
        } else if (locale === "any") {
          for (var key in validators) {
            var validator2 = validators[key];
            if (validator2(str)) {
              return true;
            }
          }
          return false;
        }
        throw new Error("Invalid locale '".concat(locale, "'"));
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isStrongPassword.js
  var require_isStrongPassword = __commonJS({
    "node_modules/validator/lib/isStrongPassword.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isStrongPassword;
      var _merge = _interopRequireDefault(require_merge());
      var _assertString = _interopRequireDefault(require_assertString());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var upperCaseRegex = /^[A-Z]$/;
      var lowerCaseRegex = /^[a-z]$/;
      var numberRegex = /^[0-9]$/;
      var symbolRegex = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/;
      var defaultOptions = {
        minLength: 8,
        minLowercase: 1,
        minUppercase: 1,
        minNumbers: 1,
        minSymbols: 1,
        returnScore: false,
        pointsPerUnique: 1,
        pointsPerRepeat: 0.5,
        pointsForContainingLower: 10,
        pointsForContainingUpper: 10,
        pointsForContainingNumber: 10,
        pointsForContainingSymbol: 10
      };
      function countChars(str) {
        var result = {};
        Array.from(str).forEach(function(char) {
          var curVal = result[char];
          if (curVal) {
            result[char] += 1;
          } else {
            result[char] = 1;
          }
        });
        return result;
      }
      function analyzePassword(password) {
        var charMap = countChars(password);
        var analysis = {
          length: password.length,
          uniqueChars: Object.keys(charMap).length,
          uppercaseCount: 0,
          lowercaseCount: 0,
          numberCount: 0,
          symbolCount: 0
        };
        Object.keys(charMap).forEach(function(char) {
          if (upperCaseRegex.test(char)) {
            analysis.uppercaseCount += charMap[char];
          } else if (lowerCaseRegex.test(char)) {
            analysis.lowercaseCount += charMap[char];
          } else if (numberRegex.test(char)) {
            analysis.numberCount += charMap[char];
          } else if (symbolRegex.test(char)) {
            analysis.symbolCount += charMap[char];
          }
        });
        return analysis;
      }
      function scorePassword(analysis, scoringOptions) {
        var points = 0;
        points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
        points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
        if (analysis.lowercaseCount > 0) {
          points += scoringOptions.pointsForContainingLower;
        }
        if (analysis.uppercaseCount > 0) {
          points += scoringOptions.pointsForContainingUpper;
        }
        if (analysis.numberCount > 0) {
          points += scoringOptions.pointsForContainingNumber;
        }
        if (analysis.symbolCount > 0) {
          points += scoringOptions.pointsForContainingSymbol;
        }
        return points;
      }
      function isStrongPassword(str) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        (0, _assertString.default)(str);
        var analysis = analyzePassword(str);
        options = (0, _merge.default)(options || {}, defaultOptions);
        if (options.returnScore) {
          return scorePassword(analysis, options);
        }
        return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
      }
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/validator/lib/isVAT.js
  var require_isVAT = __commonJS({
    "node_modules/validator/lib/isVAT.js"(exports) {
      "use strict";
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = isVAT;
      exports.vatMatchers = void 0;
      var _assertString = _interopRequireDefault(require_assertString());
      var algorithms = _interopRequireWildcard(require_algorithms());
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache;
        };
        return cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var CH = function CH2(str) {
        var hasValidCheckNumber = function hasValidCheckNumber2(digits2) {
          var lastDigit = digits2.pop();
          var weights = [5, 4, 3, 2, 7, 6, 5, 4];
          var calculatedCheckNumber = (11 - digits2.reduce(function(acc, el, idx) {
            return acc + el * weights[idx];
          }, 0) % 11) % 11;
          return lastDigit === calculatedCheckNumber;
        };
        return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function(el) {
          return +el;
        }));
      };
      var PT = function PT2(str) {
        var match = str.match(/^(PT)?(\d{9})$/);
        if (!match) {
          return false;
        }
        var tin = match[2];
        var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a3) {
          return parseInt(a3, 10);
        }), 9) % 11;
        if (checksum > 9) {
          return parseInt(tin[8], 10) === 0;
        }
        return checksum === parseInt(tin[8], 10);
      };
      var vatMatchers = {
        /**
         * European Union VAT identification numbers
         */
        AT: function AT(str) {
          return /^(AT)?U\d{8}$/.test(str);
        },
        BE: function BE(str) {
          return /^(BE)?\d{10}$/.test(str);
        },
        BG: function BG(str) {
          return /^(BG)?\d{9,10}$/.test(str);
        },
        HR: function HR(str) {
          return /^(HR)?\d{11}$/.test(str);
        },
        CY: function CY(str) {
          return /^(CY)?\w{9}$/.test(str);
        },
        CZ: function CZ(str) {
          return /^(CZ)?\d{8,10}$/.test(str);
        },
        DK: function DK(str) {
          return /^(DK)?\d{8}$/.test(str);
        },
        EE: function EE(str) {
          return /^(EE)?\d{9}$/.test(str);
        },
        FI: function FI(str) {
          return /^(FI)?\d{8}$/.test(str);
        },
        FR: function FR(str) {
          return /^(FR)?\w{2}\d{9}$/.test(str);
        },
        DE: function DE(str) {
          return /^(DE)?\d{9}$/.test(str);
        },
        EL: function EL(str) {
          return /^(EL)?\d{9}$/.test(str);
        },
        HU: function HU(str) {
          return /^(HU)?\d{8}$/.test(str);
        },
        IE: function IE(str) {
          return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
        },
        IT: function IT(str) {
          return /^(IT)?\d{11}$/.test(str);
        },
        LV: function LV(str) {
          return /^(LV)?\d{11}$/.test(str);
        },
        LT: function LT(str) {
          return /^(LT)?\d{9,12}$/.test(str);
        },
        LU: function LU(str) {
          return /^(LU)?\d{8}$/.test(str);
        },
        MT: function MT(str) {
          return /^(MT)?\d{8}$/.test(str);
        },
        NL: function NL(str) {
          return /^(NL)?\d{9}B\d{2}$/.test(str);
        },
        PL: function PL(str) {
          return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
        },
        PT,
        RO: function RO(str) {
          return /^(RO)?\d{2,10}$/.test(str);
        },
        SK: function SK(str) {
          return /^(SK)?\d{10}$/.test(str);
        },
        SI: function SI(str) {
          return /^(SI)?\d{8}$/.test(str);
        },
        ES: function ES(str) {
          return /^(ES)?\w\d{7}[A-Z]$/.test(str);
        },
        SE: function SE(str) {
          return /^(SE)?\d{12}$/.test(str);
        },
        /**
         * VAT numbers of non-EU countries
         */
        AL: function AL(str) {
          return /^(AL)?\w{9}[A-Z]$/.test(str);
        },
        MK: function MK(str) {
          return /^(MK)?\d{13}$/.test(str);
        },
        AU: function AU(str) {
          return /^(AU)?\d{11}$/.test(str);
        },
        BY: function BY(str) {
          return /^( )?\d{9}$/.test(str);
        },
        CA: function CA(str) {
          return /^(CA)?\d{9}$/.test(str);
        },
        IS: function IS(str) {
          return /^(IS)?\d{5,6}$/.test(str);
        },
        IN: function IN(str) {
          return /^(IN)?\d{15}$/.test(str);
        },
        ID: function ID(str) {
          return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
        },
        IL: function IL(str) {
          return /^(IL)?\d{9}$/.test(str);
        },
        KZ: function KZ(str) {
          return /^(KZ)?\d{9}$/.test(str);
        },
        NZ: function NZ(str) {
          return /^(NZ)?\d{9}$/.test(str);
        },
        NG: function NG(str) {
          return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
        },
        NO: function NO(str) {
          return /^(NO)?\d{9}MVA$/.test(str);
        },
        PH: function PH(str) {
          return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
        },
        RU: function RU(str) {
          return /^(RU)?(\d{10}|\d{12})$/.test(str);
        },
        SM: function SM(str) {
          return /^(SM)?\d{5}$/.test(str);
        },
        SA: function SA(str) {
          return /^(SA)?\d{15}$/.test(str);
        },
        RS: function RS(str) {
          return /^(RS)?\d{9}$/.test(str);
        },
        CH,
        TR: function TR(str) {
          return /^(TR)?\d{10}$/.test(str);
        },
        UA: function UA(str) {
          return /^(UA)?\d{12}$/.test(str);
        },
        GB: function GB(str) {
          return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
        },
        UZ: function UZ(str) {
          return /^(UZ)?\d{9}$/.test(str);
        },
        /**
         * VAT numbers of Latin American countries
         */
        AR: function AR(str) {
          return /^(AR)?\d{11}$/.test(str);
        },
        BO: function BO(str) {
          return /^(BO)?\d{7}$/.test(str);
        },
        BR: function BR(str) {
          return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
        },
        CL: function CL(str) {
          return /^(CL)?\d{8}-\d{1}$/.test(str);
        },
        CO: function CO(str) {
          return /^(CO)?\d{10}$/.test(str);
        },
        CR: function CR(str) {
          return /^(CR)?\d{9,12}$/.test(str);
        },
        EC: function EC(str) {
          return /^(EC)?\d{13}$/.test(str);
        },
        SV: function SV(str) {
          return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
        },
        GT: function GT(str) {
          return /^(GT)?\d{7}-\d{1}$/.test(str);
        },
        HN: function HN(str) {
          return /^(HN)?$/.test(str);
        },
        MX: function MX(str) {
          return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
        },
        NI: function NI(str) {
          return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
        },
        PA: function PA(str) {
          return /^(PA)?$/.test(str);
        },
        PY: function PY(str) {
          return /^(PY)?\d{6,8}-\d{1}$/.test(str);
        },
        PE: function PE(str) {
          return /^(PE)?\d{11}$/.test(str);
        },
        DO: function DO(str) {
          return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
        },
        UY: function UY(str) {
          return /^(UY)?\d{12}$/.test(str);
        },
        VE: function VE(str) {
          return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
        }
      };
      exports.vatMatchers = vatMatchers;
      function isVAT(str, countryCode) {
        (0, _assertString.default)(str);
        (0, _assertString.default)(countryCode);
        if (countryCode in vatMatchers) {
          return vatMatchers[countryCode](str);
        }
        throw new Error("Invalid country code: '".concat(countryCode, "'"));
      }
    }
  });

  // node_modules/validator/index.js
  var require_validator = __commonJS({
    "node_modules/validator/index.js"(exports, module) {
      "use strict";
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _toDate = _interopRequireDefault(require_toDate());
      var _toFloat = _interopRequireDefault(require_toFloat());
      var _toInt = _interopRequireDefault(require_toInt());
      var _toBoolean = _interopRequireDefault(require_toBoolean());
      var _equals = _interopRequireDefault(require_equals());
      var _contains = _interopRequireDefault(require_contains());
      var _matches = _interopRequireDefault(require_matches());
      var _isEmail = _interopRequireDefault(require_isEmail());
      var _isURL = _interopRequireDefault(require_isURL());
      var _isMACAddress = _interopRequireDefault(require_isMACAddress());
      var _isIP = _interopRequireDefault(require_isIP());
      var _isIPRange = _interopRequireDefault(require_isIPRange());
      var _isFQDN = _interopRequireDefault(require_isFQDN());
      var _isDate = _interopRequireDefault(require_isDate());
      var _isTime = _interopRequireDefault(require_isTime());
      var _isBoolean = _interopRequireDefault(require_isBoolean());
      var _isLocale = _interopRequireDefault(require_isLocale());
      var _isAlpha = _interopRequireWildcard(require_isAlpha());
      var _isAlphanumeric = _interopRequireWildcard(require_isAlphanumeric());
      var _isNumeric = _interopRequireDefault(require_isNumeric());
      var _isPassportNumber = _interopRequireDefault(require_isPassportNumber());
      var _isPort = _interopRequireDefault(require_isPort());
      var _isLowercase = _interopRequireDefault(require_isLowercase());
      var _isUppercase = _interopRequireDefault(require_isUppercase());
      var _isIMEI = _interopRequireDefault(require_isIMEI());
      var _isAscii = _interopRequireDefault(require_isAscii());
      var _isFullWidth = _interopRequireDefault(require_isFullWidth());
      var _isHalfWidth = _interopRequireDefault(require_isHalfWidth());
      var _isVariableWidth = _interopRequireDefault(require_isVariableWidth());
      var _isMultibyte = _interopRequireDefault(require_isMultibyte());
      var _isSemVer = _interopRequireDefault(require_isSemVer());
      var _isSurrogatePair = _interopRequireDefault(require_isSurrogatePair());
      var _isInt = _interopRequireDefault(require_isInt());
      var _isFloat = _interopRequireWildcard(require_isFloat());
      var _isDecimal = _interopRequireDefault(require_isDecimal());
      var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
      var _isOctal = _interopRequireDefault(require_isOctal());
      var _isDivisibleBy = _interopRequireDefault(require_isDivisibleBy());
      var _isHexColor = _interopRequireDefault(require_isHexColor());
      var _isRgbColor = _interopRequireDefault(require_isRgbColor());
      var _isHSL = _interopRequireDefault(require_isHSL());
      var _isISRC = _interopRequireDefault(require_isISRC());
      var _isIBAN = _interopRequireWildcard(require_isIBAN());
      var _isBIC = _interopRequireDefault(require_isBIC());
      var _isMD = _interopRequireDefault(require_isMD5());
      var _isHash = _interopRequireDefault(require_isHash());
      var _isJWT = _interopRequireDefault(require_isJWT());
      var _isJSON = _interopRequireDefault(require_isJSON());
      var _isEmpty = _interopRequireDefault(require_isEmpty());
      var _isLength = _interopRequireDefault(require_isLength());
      var _isByteLength = _interopRequireDefault(require_isByteLength());
      var _isUUID = _interopRequireDefault(require_isUUID());
      var _isMongoId = _interopRequireDefault(require_isMongoId());
      var _isAfter = _interopRequireDefault(require_isAfter());
      var _isBefore = _interopRequireDefault(require_isBefore());
      var _isIn = _interopRequireDefault(require_isIn());
      var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
      var _isCreditCard = _interopRequireDefault(require_isCreditCard());
      var _isIdentityCard = _interopRequireDefault(require_isIdentityCard());
      var _isEAN = _interopRequireDefault(require_isEAN());
      var _isISIN = _interopRequireDefault(require_isISIN());
      var _isISBN = _interopRequireDefault(require_isISBN());
      var _isISSN = _interopRequireDefault(require_isISSN());
      var _isTaxID = _interopRequireDefault(require_isTaxID());
      var _isMobilePhone = _interopRequireWildcard(require_isMobilePhone());
      var _isEthereumAddress = _interopRequireDefault(require_isEthereumAddress());
      var _isCurrency = _interopRequireDefault(require_isCurrency());
      var _isBtcAddress = _interopRequireDefault(require_isBtcAddress());
      var _isISO = require_isISO6346();
      var _isISO2 = _interopRequireDefault(require_isISO6391());
      var _isISO3 = _interopRequireDefault(require_isISO8601());
      var _isRFC = _interopRequireDefault(require_isRFC3339());
      var _isISO31661Alpha = _interopRequireDefault(require_isISO31661Alpha2());
      var _isISO31661Alpha2 = _interopRequireDefault(require_isISO31661Alpha3());
      var _isISO4 = _interopRequireDefault(require_isISO4217());
      var _isBase = _interopRequireDefault(require_isBase32());
      var _isBase2 = _interopRequireDefault(require_isBase58());
      var _isBase3 = _interopRequireDefault(require_isBase64());
      var _isDataURI = _interopRequireDefault(require_isDataURI());
      var _isMagnetURI = _interopRequireDefault(require_isMagnetURI());
      var _isMailtoURI = _interopRequireDefault(require_isMailtoURI());
      var _isMimeType = _interopRequireDefault(require_isMimeType());
      var _isLatLong = _interopRequireDefault(require_isLatLong());
      var _isPostalCode = _interopRequireWildcard(require_isPostalCode());
      var _ltrim = _interopRequireDefault(require_ltrim());
      var _rtrim = _interopRequireDefault(require_rtrim());
      var _trim = _interopRequireDefault(require_trim());
      var _escape = _interopRequireDefault(require_escape());
      var _unescape = _interopRequireDefault(require_unescape());
      var _stripLow = _interopRequireDefault(require_stripLow());
      var _whitelist = _interopRequireDefault(require_whitelist());
      var _blacklist = _interopRequireDefault(require_blacklist());
      var _isWhitelisted = _interopRequireDefault(require_isWhitelisted());
      var _normalizeEmail = _interopRequireDefault(require_normalizeEmail());
      var _isSlug = _interopRequireDefault(require_isSlug());
      var _isLicensePlate = _interopRequireDefault(require_isLicensePlate());
      var _isStrongPassword = _interopRequireDefault(require_isStrongPassword());
      var _isVAT = _interopRequireDefault(require_isVAT());
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache;
        };
        return cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { default: obj };
        }
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var version3 = "13.11.0";
      var validator2 = {
        version: version3,
        toDate: _toDate.default,
        toFloat: _toFloat.default,
        toInt: _toInt.default,
        toBoolean: _toBoolean.default,
        equals: _equals.default,
        contains: _contains.default,
        matches: _matches.default,
        isEmail: _isEmail.default,
        isURL: _isURL.default,
        isMACAddress: _isMACAddress.default,
        isIP: _isIP.default,
        isIPRange: _isIPRange.default,
        isFQDN: _isFQDN.default,
        isBoolean: _isBoolean.default,
        isIBAN: _isIBAN.default,
        isBIC: _isBIC.default,
        isAlpha: _isAlpha.default,
        isAlphaLocales: _isAlpha.locales,
        isAlphanumeric: _isAlphanumeric.default,
        isAlphanumericLocales: _isAlphanumeric.locales,
        isNumeric: _isNumeric.default,
        isPassportNumber: _isPassportNumber.default,
        isPort: _isPort.default,
        isLowercase: _isLowercase.default,
        isUppercase: _isUppercase.default,
        isAscii: _isAscii.default,
        isFullWidth: _isFullWidth.default,
        isHalfWidth: _isHalfWidth.default,
        isVariableWidth: _isVariableWidth.default,
        isMultibyte: _isMultibyte.default,
        isSemVer: _isSemVer.default,
        isSurrogatePair: _isSurrogatePair.default,
        isInt: _isInt.default,
        isIMEI: _isIMEI.default,
        isFloat: _isFloat.default,
        isFloatLocales: _isFloat.locales,
        isDecimal: _isDecimal.default,
        isHexadecimal: _isHexadecimal.default,
        isOctal: _isOctal.default,
        isDivisibleBy: _isDivisibleBy.default,
        isHexColor: _isHexColor.default,
        isRgbColor: _isRgbColor.default,
        isHSL: _isHSL.default,
        isISRC: _isISRC.default,
        isMD5: _isMD.default,
        isHash: _isHash.default,
        isJWT: _isJWT.default,
        isJSON: _isJSON.default,
        isEmpty: _isEmpty.default,
        isLength: _isLength.default,
        isLocale: _isLocale.default,
        isByteLength: _isByteLength.default,
        isUUID: _isUUID.default,
        isMongoId: _isMongoId.default,
        isAfter: _isAfter.default,
        isBefore: _isBefore.default,
        isIn: _isIn.default,
        isLuhnNumber: _isLuhnNumber.default,
        isCreditCard: _isCreditCard.default,
        isIdentityCard: _isIdentityCard.default,
        isEAN: _isEAN.default,
        isISIN: _isISIN.default,
        isISBN: _isISBN.default,
        isISSN: _isISSN.default,
        isMobilePhone: _isMobilePhone.default,
        isMobilePhoneLocales: _isMobilePhone.locales,
        isPostalCode: _isPostalCode.default,
        isPostalCodeLocales: _isPostalCode.locales,
        isEthereumAddress: _isEthereumAddress.default,
        isCurrency: _isCurrency.default,
        isBtcAddress: _isBtcAddress.default,
        isISO6346: _isISO.isISO6346,
        isFreightContainerID: _isISO.isFreightContainerID,
        isISO6391: _isISO2.default,
        isISO8601: _isISO3.default,
        isRFC3339: _isRFC.default,
        isISO31661Alpha2: _isISO31661Alpha.default,
        isISO31661Alpha3: _isISO31661Alpha2.default,
        isISO4217: _isISO4.default,
        isBase32: _isBase.default,
        isBase58: _isBase2.default,
        isBase64: _isBase3.default,
        isDataURI: _isDataURI.default,
        isMagnetURI: _isMagnetURI.default,
        isMailtoURI: _isMailtoURI.default,
        isMimeType: _isMimeType.default,
        isLatLong: _isLatLong.default,
        ltrim: _ltrim.default,
        rtrim: _rtrim.default,
        trim: _trim.default,
        escape: _escape.default,
        unescape: _unescape.default,
        stripLow: _stripLow.default,
        whitelist: _whitelist.default,
        blacklist: _blacklist.default,
        isWhitelisted: _isWhitelisted.default,
        normalizeEmail: _normalizeEmail.default,
        toString,
        isSlug: _isSlug.default,
        isStrongPassword: _isStrongPassword.default,
        isTaxID: _isTaxID.default,
        isDate: _isDate.default,
        isTime: _isTime.default,
        isLicensePlate: _isLicensePlate.default,
        isVAT: _isVAT.default,
        ibanLocales: _isIBAN.locales
      };
      var _default = validator2;
      exports.default = _default;
      module.exports = exports.default;
      module.exports.default = exports.default;
    }
  });

  // node_modules/zustand/esm/vanilla.mjs
  var import_meta, createStoreImpl, createStore;
  var init_vanilla = __esm({
    "node_modules/zustand/esm/vanilla.mjs"() {
      import_meta = {};
      createStoreImpl = (createState) => {
        let state;
        const listeners = /* @__PURE__ */ new Set();
        const setState = (partial, replace) => {
          const nextState = typeof partial === "function" ? partial(state) : partial;
          if (!Object.is(nextState, state)) {
            const previousState = state;
            state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
            listeners.forEach((listener) => listener(state, previousState));
          }
        };
        const getState = () => state;
        const subscribe = (listener) => {
          listeners.add(listener);
          return () => listeners.delete(listener);
        };
        const destroy = () => {
          if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
            console.warn(
              "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
            );
          }
          listeners.clear();
        };
        const api = { setState, getState, subscribe, destroy };
        state = createState(setState, getState, api);
        return api;
      };
      createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
    }
  });

  // node_modules/preact/compat/dist/compat.module.js
  var compat_module_exports = {};
  __export(compat_module_exports, {
    Children: () => A3,
    Component: () => b,
    Fragment: () => g,
    PureComponent: () => E2,
    StrictMode: () => mn,
    Suspense: () => L2,
    SuspenseList: () => M2,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => on,
    cloneElement: () => sn,
    createContext: () => F,
    createElement: () => y,
    createFactory: () => cn,
    createPortal: () => j3,
    createRef: () => _,
    default: () => wn,
    findDOMNode: () => vn,
    flushSync: () => pn,
    forwardRef: () => N2,
    hydrate: () => G,
    isElement: () => gn,
    isFragment: () => an,
    isValidElement: () => fn,
    lazy: () => D2,
    memo: () => w3,
    render: () => q3,
    startTransition: () => yn,
    unmountComponentAtNode: () => hn,
    unstable_batchedUpdates: () => dn,
    useCallback: () => T2,
    useContext: () => q2,
    useDebugValue: () => x2,
    useDeferredValue: () => _n,
    useEffect: () => p2,
    useErrorBoundary: () => P2,
    useId: () => V,
    useImperativeHandle: () => A2,
    useInsertionEffect: () => Sn,
    useLayoutEffect: () => y2,
    useMemo: () => F2,
    useReducer: () => s2,
    useRef: () => _2,
    useState: () => h2,
    useSyncExternalStore: () => Cn,
    useTransition: () => bn,
    version: () => ln
  });
  function g3(n3, t3) {
    for (var e6 in t3)
      n3[e6] = t3[e6];
    return n3;
  }
  function C2(n3, t3) {
    for (var e6 in n3)
      if ("__source" !== e6 && !(e6 in t3))
        return true;
    for (var r3 in t3)
      if ("__source" !== r3 && n3[r3] !== t3[r3])
        return true;
    return false;
  }
  function E2(n3) {
    this.props = n3;
  }
  function w3(n3, e6) {
    function r3(n4) {
      var t3 = this.props.ref, r4 = t3 == n4.ref;
      return !r4 && t3 && (t3.call ? t3(null) : t3.current = null), e6 ? !e6(this.props, n4) || !r4 : C2(this.props, n4);
    }
    function u3(e7) {
      return this.shouldComponentUpdate = r3, y(n3, e7);
    }
    return u3.displayName = "Memo(" + (n3.displayName || n3.name) + ")", u3.prototype.isReactComponent = true, u3.__f = true, u3;
  }
  function N2(n3) {
    function t3(t4) {
      var e6 = g3({}, t4);
      return delete e6.ref, n3(e6, t4.ref || null);
    }
    return t3.$$typeof = R, t3.render = t3, t3.prototype.isReactComponent = t3.__f = true, t3.displayName = "ForwardRef(" + (n3.displayName || n3.name) + ")", t3;
  }
  function F3(n3, t3, e6) {
    return n3 && (n3.__c && n3.__c.__H && (n3.__c.__H.__.forEach(function(n4) {
      "function" == typeof n4.__c && n4.__c();
    }), n3.__c.__H = null), null != (n3 = g3({}, n3)).__c && (n3.__c.__P === e6 && (n3.__c.__P = t3), n3.__c = null), n3.__k = n3.__k && n3.__k.map(function(n4) {
      return F3(n4, t3, e6);
    })), n3;
  }
  function I2(n3, t3, e6) {
    return n3 && e6 && (n3.__v = null, n3.__k = n3.__k && n3.__k.map(function(n4) {
      return I2(n4, t3, e6);
    }), n3.__c && n3.__c.__P === t3 && (n3.__e && e6.appendChild(n3.__e), n3.__c.__e = true, n3.__c.__P = e6)), n3;
  }
  function L2() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function U(n3) {
    var t3 = n3.__.__c;
    return t3 && t3.__a && t3.__a(n3);
  }
  function D2(n3) {
    var e6, r3, u3;
    function o3(o4) {
      if (e6 || (e6 = n3()).then(function(n4) {
        r3 = n4.default || n4;
      }, function(n4) {
        u3 = n4;
      }), u3)
        throw u3;
      if (!r3)
        throw e6;
      return y(r3, o4);
    }
    return o3.displayName = "Lazy", o3.__f = true, o3;
  }
  function M2() {
    this.u = null, this.o = null;
  }
  function W(n3) {
    return this.getChildContext = function() {
      return n3.context;
    }, n3.children;
  }
  function P3(n3) {
    var e6 = this, r3 = n3.i;
    e6.componentWillUnmount = function() {
      q(null, e6.l), e6.l = null, e6.i = null;
    }, e6.i && e6.i !== r3 && e6.componentWillUnmount(), e6.l || (e6.i = r3, e6.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n4) {
      this.childNodes.push(n4), e6.i.appendChild(n4);
    }, insertBefore: function(n4, t3) {
      this.childNodes.push(n4), e6.i.appendChild(n4);
    }, removeChild: function(n4) {
      this.childNodes.splice(this.childNodes.indexOf(n4) >>> 1, 1), e6.i.removeChild(n4);
    } }), q(y(W, { context: e6.context }, n3.__v), e6.l);
  }
  function j3(n3, e6) {
    var r3 = y(P3, { __v: n3, i: e6 });
    return r3.containerInfo = e6, r3;
  }
  function q3(n3, t3, e6) {
    return null == t3.__k && (t3.textContent = ""), q(n3, t3), "function" == typeof e6 && e6(), n3 ? n3.__c : null;
  }
  function G(n3, t3, e6) {
    return B(n3, t3), "function" == typeof e6 && e6(), n3 ? n3.__c : null;
  }
  function K() {
  }
  function Q() {
    return this.cancelBubble;
  }
  function X() {
    return this.defaultPrevented;
  }
  function cn(n3) {
    return y.bind(null, n3);
  }
  function fn(n3) {
    return !!n3 && n3.$$typeof === z4;
  }
  function an(n3) {
    return fn(n3) && n3.type === g;
  }
  function sn(n3) {
    return fn(n3) ? E.apply(null, arguments) : n3;
  }
  function hn(n3) {
    return !!n3.__k && (q(null, n3), true);
  }
  function vn(n3) {
    return n3 && (n3.base || 1 === n3.nodeType && n3) || null;
  }
  function yn(n3) {
    n3();
  }
  function _n(n3) {
    return n3;
  }
  function bn() {
    return [false, yn];
  }
  function Cn(n3, t3) {
    var e6 = t3(), r3 = h2({ h: { __: e6, v: t3 } }), u3 = r3[0].h, o3 = r3[1];
    return y2(function() {
      u3.__ = e6, u3.v = t3, En(u3) && o3({ h: u3 });
    }, [n3, e6, t3]), p2(function() {
      return En(u3) && o3({ h: u3 }), n3(function() {
        En(u3) && o3({ h: u3 });
      });
    }, [n3]), e6;
  }
  function En(n3) {
    var t3, e6, r3 = n3.v, u3 = n3.__;
    try {
      var o3 = r3();
      return !((t3 = u3) === (e6 = o3) && (0 !== t3 || 1 / t3 == 1 / e6) || t3 != t3 && e6 != e6);
    } catch (n4) {
      return true;
    }
  }
  var x3, R, k3, A3, O2, T3, V2, z4, B3, H2, Z, Y, $2, J, nn, tn, en, rn, un, on, ln, dn, pn, mn, Sn, gn, wn;
  var init_compat_module = __esm({
    "node_modules/preact/compat/dist/compat.module.js"() {
      init_preact_module();
      init_preact_module();
      init_hooks_module();
      init_hooks_module();
      (E2.prototype = new b()).isPureReactComponent = true, E2.prototype.shouldComponentUpdate = function(n3, t3) {
        return C2(this.props, n3) || C2(this.state, t3);
      };
      x3 = l.__b;
      l.__b = function(n3) {
        n3.type && n3.type.__f && n3.ref && (n3.props.ref = n3.ref, n3.ref = null), x3 && x3(n3);
      };
      R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
      k3 = function(n3, t3) {
        return null == n3 ? null : $($(n3).map(t3));
      };
      A3 = { map: k3, forEach: k3, count: function(n3) {
        return n3 ? $(n3).length : 0;
      }, only: function(n3) {
        var t3 = $(n3);
        if (1 !== t3.length)
          throw "Children.only";
        return t3[0];
      }, toArray: $ };
      O2 = l.__e;
      l.__e = function(n3, t3, e6, r3) {
        if (n3.then) {
          for (var u3, o3 = t3; o3 = o3.__; )
            if ((u3 = o3.__c) && u3.__c)
              return null == t3.__e && (t3.__e = e6.__e, t3.__k = e6.__k), u3.__c(n3, t3);
        }
        O2(n3, t3, e6, r3);
      };
      T3 = l.unmount;
      l.unmount = function(n3) {
        var t3 = n3.__c;
        t3 && t3.__R && t3.__R(), t3 && 32 & n3.__u && (n3.type = null), T3 && T3(n3);
      }, (L2.prototype = new b()).__c = function(n3, t3) {
        var e6 = t3.__c, r3 = this;
        null == r3.t && (r3.t = []), r3.t.push(e6);
        var u3 = U(r3.__v), o3 = false, i5 = function() {
          o3 || (o3 = true, e6.__R = null, u3 ? u3(l3) : l3());
        };
        e6.__R = i5;
        var l3 = function() {
          if (!--r3.__u) {
            if (r3.state.__a) {
              var n4 = r3.state.__a;
              r3.__v.__k[0] = I2(n4, n4.__c.__P, n4.__c.__O);
            }
            var t4;
            for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
              t4.forceUpdate();
          }
        };
        r3.__u++ || 32 & t3.__u || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n3.then(i5, i5);
      }, L2.prototype.componentWillUnmount = function() {
        this.t = [];
      }, L2.prototype.render = function(n3, e6) {
        if (this.__b) {
          if (this.__v.__k) {
            var r3 = document.createElement("div"), o3 = this.__v.__k[0].__c;
            this.__v.__k[0] = F3(this.__b, r3, o3.__O = o3.__P);
          }
          this.__b = null;
        }
        var i5 = e6.__a && y(g, null, n3.fallback);
        return i5 && (i5.__u &= -33), [y(g, null, e6.__a ? null : n3.children), i5];
      };
      V2 = function(n3, t3, e6) {
        if (++e6[1] === e6[0] && n3.o.delete(t3), n3.props.revealOrder && ("t" !== n3.props.revealOrder[0] || !n3.o.size))
          for (e6 = n3.u; e6; ) {
            for (; e6.length > 3; )
              e6.pop()();
            if (e6[1] < e6[0])
              break;
            n3.u = e6 = e6[2];
          }
      };
      (M2.prototype = new b()).__a = function(n3) {
        var t3 = this, e6 = U(t3.__v), r3 = t3.o.get(n3);
        return r3[0]++, function(u3) {
          var o3 = function() {
            t3.props.revealOrder ? (r3.push(u3), V2(t3, n3, r3)) : u3();
          };
          e6 ? e6(o3) : o3();
        };
      }, M2.prototype.render = function(n3) {
        this.u = null, this.o = /* @__PURE__ */ new Map();
        var t3 = $(n3.children);
        n3.revealOrder && "b" === n3.revealOrder[0] && t3.reverse();
        for (var e6 = t3.length; e6--; )
          this.o.set(t3[e6], this.u = [1, 0, this.u]);
        return n3.children;
      }, M2.prototype.componentDidUpdate = M2.prototype.componentDidMount = function() {
        var n3 = this;
        this.o.forEach(function(t3, e6) {
          V2(n3, e6, t3);
        });
      };
      z4 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
      B3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
      H2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
      Z = /[A-Z0-9]/g;
      Y = "undefined" != typeof document;
      $2 = function(n3) {
        return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n3);
      };
      b.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
        Object.defineProperty(b.prototype, t3, { configurable: true, get: function() {
          return this["UNSAFE_" + t3];
        }, set: function(n3) {
          Object.defineProperty(this, t3, { configurable: true, writable: true, value: n3 });
        } });
      });
      J = l.event;
      l.event = function(n3) {
        return J && (n3 = J(n3)), n3.persist = K, n3.isPropagationStopped = Q, n3.isDefaultPrevented = X, n3.nativeEvent = n3;
      };
      tn = { enumerable: false, configurable: true, get: function() {
        return this.class;
      } };
      en = l.vnode;
      l.vnode = function(n3) {
        "string" == typeof n3.type && function(n4) {
          var t3 = n4.props, e6 = n4.type, u3 = {};
          for (var o3 in t3) {
            var i5 = t3[o3];
            if (!("value" === o3 && "defaultValue" in t3 && null == i5 || Y && "children" === o3 && "noscript" === e6 || "class" === o3 || "className" === o3)) {
              var l3 = o3.toLowerCase();
              "defaultValue" === o3 && "value" in t3 && null == t3.value ? o3 = "value" : "download" === o3 && true === i5 ? i5 = "" : "ondoubleclick" === l3 ? o3 = "ondblclick" : "onchange" !== l3 || "input" !== e6 && "textarea" !== e6 || $2(t3.type) ? "onfocus" === l3 ? o3 = "onfocusin" : "onblur" === l3 ? o3 = "onfocusout" : H2.test(o3) ? o3 = l3 : -1 === e6.indexOf("-") && B3.test(o3) ? o3 = o3.replace(Z, "-$&").toLowerCase() : null === i5 && (i5 = void 0) : l3 = o3 = "oninput", "oninput" === l3 && u3[o3 = l3] && (o3 = "oninputCapture"), u3[o3] = i5;
            }
          }
          "select" == e6 && u3.multiple && Array.isArray(u3.value) && (u3.value = $(t3.children).forEach(function(n5) {
            n5.props.selected = -1 != u3.value.indexOf(n5.props.value);
          })), "select" == e6 && null != u3.defaultValue && (u3.value = $(t3.children).forEach(function(n5) {
            n5.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n5.props.value) : u3.defaultValue == n5.props.value;
          })), t3.class && !t3.className ? (u3.class = t3.class, Object.defineProperty(u3, "className", tn)) : (t3.className && !t3.class || t3.class && t3.className) && (u3.class = u3.className = t3.className), n4.props = u3;
        }(n3), n3.$$typeof = z4, en && en(n3);
      };
      rn = l.__r;
      l.__r = function(n3) {
        rn && rn(n3), nn = n3.__c;
      };
      un = l.diffed;
      l.diffed = function(n3) {
        un && un(n3);
        var t3 = n3.props, e6 = n3.__e;
        null != e6 && "textarea" === n3.type && "value" in t3 && t3.value !== e6.value && (e6.value = null == t3.value ? "" : t3.value), nn = null;
      };
      on = { ReactCurrentDispatcher: { current: { readContext: function(n3) {
        return nn.__n[n3.__c].props.value;
      } } } };
      ln = "17.0.2";
      dn = function(n3, t3) {
        return n3(t3);
      };
      pn = function(n3, t3) {
        return n3(t3);
      };
      mn = g;
      Sn = y2;
      gn = fn;
      wn = { useState: h2, useId: V, useReducer: s2, useEffect: p2, useLayoutEffect: y2, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: Cn, startTransition: yn, useRef: _2, useImperativeHandle: A2, useMemo: F2, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: A3, render: q3, hydrate: G, unmountComponentAtNode: hn, createPortal: j3, createElement: y, createContext: F, createFactory: cn, cloneElement: sn, createRef: _, Fragment: g, isValidElement: fn, isElement: gn, isFragment: an, findDOMNode: vn, Component: b, PureComponent: E2, memo: w3, forwardRef: N2, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: L2, SuspenseList: M2, lazy: D2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: on };
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React = (init_compat_module(), __toCommonJS(compat_module_exports));
          var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format5) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format5, args);
              }
            }
          }
          function printWarning(level, format5, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format5 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format5);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is(x4, y3) {
            return x4 === y3 && (x4 !== 0 || 1 / x4 === 1 / y3) || x4 !== x4 && y3 !== y3;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useState = React.useState, useEffect3 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe, value, getSnapshot]);
            useEffect3(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            }, [subscribe]);
            useDebugValue(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
          var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
          exports.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
  var require_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React = (init_compat_module(), __toCommonJS(compat_module_exports));
          var shim = require_shim();
          function is(x4, y3) {
            return x4 === y3 && (x4 !== 0 || 1 / x4 === 1 / y3) || x4 !== x4 && y3 !== y3;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useSyncExternalStore = shim.useSyncExternalStore;
          var useRef = React.useRef, useEffect3 = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
          function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
            var instRef = useRef(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector(nextSnapshot);
                  if (isEqual !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
            useEffect3(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue(value);
            return value;
          }
          exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_with_selector_development();
      }
    }
  });

  // node_modules/zustand/esm/index.mjs
  function useStore(api, selector = api.getState, equalityFn) {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getState,
      selector,
      equalityFn
    );
    x2(slice);
    return slice;
  }
  var import_with_selector, import_meta2, useSyncExternalStoreWithSelector, didWarnAboutEqualityFn, createImpl, create;
  var init_esm = __esm({
    "node_modules/zustand/esm/index.mjs"() {
      init_vanilla();
      init_vanilla();
      init_compat_module();
      import_with_selector = __toESM(require_with_selector(), 1);
      import_meta2 = {};
      ({ useSyncExternalStoreWithSelector } = import_with_selector.default);
      didWarnAboutEqualityFn = false;
      createImpl = (createState) => {
        if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && typeof createState !== "function") {
          console.warn(
            "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
          );
        }
        const api = typeof createState === "function" ? createStore(createState) : createState;
        const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
        Object.assign(useBoundStore, api);
        return useBoundStore;
      };
      create = (createState) => createState ? createImpl(createState) : createImpl;
    }
  });

  // src/hooks/useColor.ts
  var import_validator, RgbaSchema, HctSchema, SolidColorSchema, ColorDataSchema, ColorActionsSchema, ColorSchema, cleanedHexColor, updateHctValues, setHue, setChroma, setTone, hexFromString, HctFromHex, argbFromHct, rgbFromHex, rgbaFromHct, hexFromHct, SolidColorFromRgbColor, colorStore, useColorStore, useColor;
  var init_useColor = __esm({
    "src/hooks/useColor.ts"() {
      "use strict";
      init_hooks_module();
      init_material_color_utilities();
      init_lib();
      init_lib3();
      import_validator = __toESM(require_validator());
      init_esm();
      RgbaSchema = z3.object({
        r: z3.number().min(0).max(255),
        g: z3.number().min(0).max(255),
        b: z3.number().min(0).max(255),
        a: z3.number().min(0).max(255)
      });
      HctSchema = z3.object({
        hue: z3.number().min(0).max(360),
        chroma: z3.number().min(0).max(150),
        tone: z3.number().min(0).max(100)
      });
      SolidColorSchema = z3.object({
        type: z3.literal("SOLID"),
        color: z3.object({
          r: z3.number().min(0).max(255),
          g: z3.number().min(0).max(255),
          b: z3.number().min(0).max(255)
        })
      });
      ColorDataSchema = z3.object({
        sourceHex: z3.string(),
        hct: HctSchema,
        rgba: z3.union([z3.string(), RgbaSchema]),
        hex: z3.string().refine(import_validator.default.isHexColor),
        figmaSolidColor: SolidColorSchema
      });
      ColorActionsSchema = z3.object({
        setSourceHex: z3.function().args(z3.string(), z3.void()),
        setHct: z3.function().args(HctSchema, z3.void()),
        setRgba: z3.function().args(z3.union([z3.string(), RgbaSchema]), z3.void()),
        setHex: z3.function().args(z3.string(), z3.void()),
        setFigmaSolidColor: z3.function().args(SolidColorSchema, z3.void()),
        setHue: z3.function().args(z3.number(), z3.void()),
        setChroma: z3.function().args(z3.number(), z3.void()),
        setTone: z3.function().args(z3.number(), z3.void())
      });
      ColorSchema = ColorDataSchema.merge(ColorActionsSchema);
      cleanedHexColor = (hexColor) => {
        return hexColor.startsWith("#") ? hexColor.slice(1) : hexColor;
      };
      updateHctValues = (newHue, newChroma, newTone) => {
        const updatedHct = Hct.from(newHue, newChroma, newTone);
        return useColorStore.setState({ hct: updatedHct });
      };
      setHue = (newHue) => updateHctValues(
        newHue,
        useColorStore.getState().hct.chroma,
        useColorStore.getState().hct.tone
      );
      setChroma = (newChroma) => updateHctValues(
        useColorStore.getState().hct.hue,
        newChroma,
        useColorStore.getState().hct.tone
      );
      setTone = (newTone) => updateHctValues(
        useColorStore.getState().hct.hue,
        useColorStore.getState().hct.chroma,
        newTone
      );
      hexFromString = (hexColor) => cleanedHexColor(hexColor);
      HctFromHex = (hexColor) => Hct.fromInt(argbFromHex(hexFromString(hexColor)));
      argbFromHct = (hctColor) => (hctColor == null ? void 0 : hctColor.toInt()) || Hct.from(0, 0, 0).toInt();
      rgbFromHex = (hex2) => {
        const result = convertHexColorToRgbColor(cleanedHexColor(hex2));
        return result !== null ? result : { r: 0, g: 0, b: 0 };
      };
      rgbaFromHct = (hct) => {
        const argb = argbFromHct(hct);
        return rgbaFromArgb(argb);
      };
      hexFromHct = (hct) => {
        const argb = argbFromHct(hct);
        return hexFromArgb(argb);
      };
      SolidColorFromRgbColor = (rgbColor) => {
        if (!rgbColor) {
          return { type: "SOLID", color: { r: 0, g: 0, b: 0 } };
        }
        return { type: "SOLID", color: rgbColor };
      };
      colorStore = (set, get) => ({
        sourceHex: "397456",
        hct: { hue: 0, chroma: 0, tone: 0 },
        rgba: { r: 0, g: 0, b: 0, a: 0 },
        hex: "000000",
        figmaSolidColor: { type: "SOLID", color: { r: 0, g: 0, b: 0 } },
        setSourceHex: (sourceHex) => set(() => ({ sourceHex })),
        setHct: (hct) => set(() => ({ hct })),
        setRgba: (rgba) => set(() => ({ rgba })),
        setHex: (hex2) => set(() => ({ hex: hex2 })),
        setFigmaSolidColor: (figmaSolidColor) => set(() => ({ figmaSolidColor })),
        setHue: (hue) => set((state) => ({ hct: __spreadProps(__spreadValues({}, state.hct), { hue }) })),
        setChroma: (chroma) => set((state) => ({ hct: __spreadProps(__spreadValues({}, state.hct), { chroma }) })),
        setTone: (tone) => set((state) => ({ hct: __spreadProps(__spreadValues({}, state.hct), { tone }) }))
      });
      useColorStore = create()((...a3) => __spreadValues({}, colorStore(...a3)));
      useColor = (hexColor) => {
        const colorStore2 = useColorStore;
        const color2 = colorStore2((state) => state);
        const sourceHex = color2.sourceHex;
        const setSourceHex = (sourceHex2) => color2.setSourceHex(sourceHex2);
        const hct = color2.hct;
        const setHct = (hct2) => {
          if (typeof hct2 === "string") {
            const hctFromString = HctFromHex(hct2);
            return color2.setHct(hctFromString);
          }
          if (typeof hct2 === "object") {
            const hctFromObject = Hct.from(hct2.hue, hct2.chroma, hct2.tone);
            return color2.setHct(hctFromObject);
          }
          color2.setHct(hct2);
        };
        const rgba = color2.rgba;
        const setRgba = (rgba2) => color2.setRgba(rgba2);
        const hex2 = color2.hex;
        const setHex = (hex3) => color2.setHex(hex3);
        const figmaSolidColor = color2.figmaSolidColor;
        const setFigmaSolidColor = (figmaSolidColor2) => color2.setFigmaSolidColor(figmaSolidColor2);
        const sourceHexRef = _2(colorStore2.getState().sourceHex);
        const hctRef = _2(colorStore2.getState().hct);
        p2(() => {
          colorStore2.subscribe((state) => {
            if (sourceHexRef.current !== state.sourceHex) {
              const newHct = HctFromHex(state.sourceHex);
              sourceHexRef.current = state.sourceHex;
              setHct(newHct);
            }
            if (hctRef.current.hue !== state.hct.hue || hctRef.current.chroma !== state.hct.chroma || hctRef.current.tone !== state.hct.tone) {
              hctRef.current = state.hct;
              const newHex = hexFromHct(
                Hct.from(state.hct.hue, state.hct.chroma, state.hct.tone)
              );
              setRgba(
                rgbaFromHct(Hct.from(state.hct.hue, state.hct.chroma, state.hct.tone))
              );
              setHex(newHex);
              setFigmaSolidColor(SolidColorFromRgbColor(rgbFromHex(newHex)));
            }
          });
        }, []);
        p2(() => {
          if (sourceHex !== hexColor) {
            setSourceHex(hexColor);
          }
        }, []);
        return {
          sourceHex,
          rgba,
          hct,
          hex: hex2,
          figmaSolidColor,
          setSourceHex,
          setHct,
          setRgba,
          setHex,
          setFigmaSolidColor,
          setHue,
          setChroma,
          setTone
        };
      };
    }
  });

  // src/ref.ts
  var maxChromaAtTonePerHue;
  var init_ref = __esm({
    "src/ref.ts"() {
      "use strict";
      maxChromaAtTonePerHue = [
        {
          hue: 0,
          chroma: 102.29059338702712,
          tone: 55
        },
        {
          hue: 1,
          chroma: 102.60908130866443,
          tone: 55
        },
        {
          hue: 2,
          chroma: 102.49542053829066,
          tone: 55
        },
        {
          hue: 3,
          chroma: 102.08145536873461,
          tone: 55
        },
        {
          hue: 4,
          chroma: 102.16913211242463,
          tone: 54
        },
        {
          hue: 5,
          chroma: 102.27654497635527,
          tone: 54
        },
        {
          hue: 6,
          chroma: 102.43910613233591,
          tone: 54
        },
        {
          hue: 7,
          chroma: 102.90135248561594,
          tone: 54
        },
        {
          hue: 8,
          chroma: 103.11157064918604,
          tone: 54
        },
        {
          hue: 9,
          chroma: 103.62646560864816,
          tone: 54
        },
        {
          hue: 10,
          chroma: 103.81816538540784,
          tone: 54
        },
        {
          hue: 11,
          chroma: 104.37910991276874,
          tone: 54
        },
        {
          hue: 12,
          chroma: 104.67975202037647,
          tone: 54
        },
        {
          hue: 13,
          chroma: 104.79125496278046,
          tone: 54
        },
        {
          hue: 14,
          chroma: 104.81726491509593,
          tone: 54
        },
        {
          hue: 15,
          chroma: 104.86291062587007,
          tone: 54
        },
        {
          hue: 16,
          chroma: 105.12617401612707,
          tone: 53
        },
        {
          hue: 17,
          chroma: 105.83330416206427,
          tone: 53
        },
        {
          hue: 18,
          chroma: 106.37288152030361,
          tone: 53
        },
        {
          hue: 19,
          chroma: 106.82101286495468,
          tone: 53
        },
        {
          hue: 20,
          chroma: 107.39718347819962,
          tone: 53
        },
        {
          hue: 21,
          chroma: 108.2813156649379,
          tone: 53
        },
        {
          hue: 22,
          chroma: 108.87200270627048,
          tone: 53
        },
        {
          hue: 23,
          chroma: 109.4567110079303,
          tone: 53
        },
        {
          hue: 24,
          chroma: 110.13577108164388,
          tone: 53
        },
        {
          hue: 25,
          chroma: 110.87202195538732,
          tone: 53
        },
        {
          hue: 26,
          chroma: 111.96761442146209,
          tone: 53
        },
        {
          hue: 27,
          chroma: 112.75851418586231,
          tone: 53
        },
        {
          hue: 28,
          chroma: 110.39041621596458,
          tone: 53
        },
        {
          hue: 29,
          chroma: 107.24485236456015,
          tone: 54
        },
        {
          hue: 30,
          chroma: 104.89060563676703,
          tone: 55
        },
        {
          hue: 31,
          chroma: 100.70883398953252,
          tone: 55
        },
        {
          hue: 32,
          chroma: 98.64353473041776,
          tone: 56
        },
        {
          hue: 33,
          chroma: 96.84310501500768,
          tone: 57
        },
        {
          hue: 34,
          chroma: 93.5440352291353,
          tone: 57
        },
        {
          hue: 35,
          chroma: 92.02487731893764,
          tone: 58
        },
        {
          hue: 36,
          chroma: 89.46376427519503,
          tone: 59
        },
        {
          hue: 37,
          chroma: 87.45559272184552,
          tone: 59
        },
        {
          hue: 38,
          chroma: 86.34935583158709,
          tone: 60
        },
        {
          hue: 39,
          chroma: 84.15989201695757,
          tone: 60
        },
        {
          hue: 40,
          chroma: 83.06802795706868,
          tone: 61
        },
        {
          hue: 41,
          chroma: 80.50064097512386,
          tone: 61
        },
        {
          hue: 42,
          chroma: 79.83901092777586,
          tone: 62
        },
        {
          hue: 43,
          chroma: 77.76516127143402,
          tone: 62
        },
        {
          hue: 44,
          chroma: 77.1522237062303,
          tone: 63
        },
        {
          hue: 45,
          chroma: 75.55717010295571,
          tone: 63
        },
        {
          hue: 46,
          chroma: 74.99444826792882,
          tone: 64
        },
        {
          hue: 47,
          chroma: 73.39919052490602,
          tone: 64
        },
        {
          hue: 48,
          chroma: 72.92918926544144,
          tone: 65
        },
        {
          hue: 49,
          chroma: 71.39199992945922,
          tone: 65
        },
        {
          hue: 50,
          chroma: 70.47828504777686,
          tone: 66
        },
        {
          hue: 51,
          chroma: 69.50461725115296,
          tone: 66
        },
        {
          hue: 52,
          chroma: 68.78627732522996,
          tone: 66
        },
        {
          hue: 53,
          chroma: 68.09931602199272,
          tone: 67
        },
        {
          hue: 54,
          chroma: 67.07591347120717,
          tone: 67
        },
        {
          hue: 55,
          chroma: 66.79228424908683,
          tone: 68
        },
        {
          hue: 56,
          chroma: 66.1486048722401,
          tone: 68
        },
        {
          hue: 57,
          chroma: 65.62079735089364,
          tone: 69
        },
        {
          hue: 58,
          chroma: 64.70604086100727,
          tone: 69
        },
        {
          hue: 59,
          chroma: 64.16118228560536,
          tone: 70
        },
        {
          hue: 60,
          chroma: 63.97573912510994,
          tone: 70
        },
        {
          hue: 61,
          chroma: 63.140124886688106,
          tone: 70
        },
        {
          hue: 62,
          chroma: 63.32973391422233,
          tone: 71
        },
        {
          hue: 63,
          chroma: 62.54740711153246,
          tone: 71
        },
        {
          hue: 64,
          chroma: 62.11522975746191,
          tone: 72
        },
        {
          hue: 65,
          chroma: 61.863686893396526,
          tone: 72
        },
        {
          hue: 66,
          chroma: 61.34876803629307,
          tone: 72
        },
        {
          hue: 67,
          chroma: 61.22773921667122,
          tone: 73
        },
        {
          hue: 68,
          chroma: 60.85225254408652,
          tone: 73
        },
        {
          hue: 69,
          chroma: 60.93759914191806,
          tone: 74
        },
        {
          hue: 70,
          chroma: 60.38811031949195,
          tone: 74
        },
        {
          hue: 71,
          chroma: 60.08302703044345,
          tone: 74
        },
        {
          hue: 72,
          chroma: 60.242973648133955,
          tone: 75
        },
        {
          hue: 73,
          chroma: 59.98041731175445,
          tone: 75
        },
        {
          hue: 74,
          chroma: 60.182249836404196,
          tone: 76
        },
        {
          hue: 75,
          chroma: 59.79086812274401,
          tone: 76
        },
        {
          hue: 76,
          chroma: 59.714122439848445,
          tone: 77
        },
        {
          hue: 77,
          chroma: 59.87086592655791,
          tone: 77
        },
        {
          hue: 78,
          chroma: 59.57346846336722,
          tone: 77
        },
        {
          hue: 79,
          chroma: 59.89606898962922,
          tone: 78
        },
        {
          hue: 80,
          chroma: 59.7661552718325,
          tone: 78
        },
        {
          hue: 81,
          chroma: 60.14687891631389,
          tone: 79
        },
        {
          hue: 82,
          chroma: 59.924179646800305,
          tone: 79
        },
        {
          hue: 83,
          chroma: 60.30758024765616,
          tone: 80
        },
        {
          hue: 84,
          chroma: 60.19007211099443,
          tone: 80
        },
        {
          hue: 85,
          chroma: 60.25199489655309,
          tone: 81
        },
        {
          hue: 86,
          chroma: 60.628800986845526,
          tone: 81
        },
        {
          hue: 87,
          chroma: 60.604867598712495,
          tone: 81
        },
        {
          hue: 88,
          chroma: 61.07594562205954,
          tone: 82
        },
        {
          hue: 89,
          chroma: 61.11328622276819,
          tone: 82
        },
        {
          hue: 90,
          chroma: 61.76397746151332,
          tone: 83
        },
        {
          hue: 91,
          chroma: 61.71112466059479,
          tone: 83
        },
        {
          hue: 92,
          chroma: 62.41046157296223,
          tone: 84
        },
        {
          hue: 93,
          chroma: 62.39227671214189,
          tone: 84
        },
        {
          hue: 94,
          chroma: 63.135782988548144,
          tone: 85
        },
        {
          hue: 95,
          chroma: 63.28723523495631,
          tone: 86
        },
        {
          hue: 96,
          chroma: 63.955262514770205,
          tone: 86
        },
        {
          hue: 97,
          chroma: 64.54723464587967,
          tone: 87
        },
        {
          hue: 98,
          chroma: 64.83489545801278,
          tone: 87
        },
        {
          hue: 99,
          chroma: 65.72461428999073,
          tone: 88
        },
        {
          hue: 100,
          chroma: 65.82745530110579,
          tone: 88
        },
        {
          hue: 101,
          chroma: 66.76857545501109,
          tone: 89
        },
        {
          hue: 102,
          chroma: 67.47462239728755,
          tone: 90
        },
        {
          hue: 103,
          chroma: 67.88906023661976,
          tone: 90
        },
        {
          hue: 104,
          chroma: 68.89841099268399,
          tone: 91
        },
        {
          hue: 105,
          chroma: 69.64578435810003,
          tone: 92
        },
        {
          hue: 106,
          chroma: 70.30989528674206,
          tone: 93
        },
        {
          hue: 107,
          chroma: 71.18464958430162,
          tone: 93
        },
        {
          hue: 108,
          chroma: 72.07503835407262,
          tone: 94
        },
        {
          hue: 109,
          chroma: 73.16592493962365,
          tone: 95
        },
        {
          hue: 110,
          chroma: 74.39320979793726,
          tone: 96
        },
        {
          hue: 111,
          chroma: 75.5094876234589,
          tone: 97
        },
        {
          hue: 112,
          chroma: 75.36615401576177,
          tone: 96
        },
        {
          hue: 113,
          chroma: 76.10865278164698,
          tone: 96
        },
        {
          hue: 114,
          chroma: 76.87502507561472,
          tone: 96
        },
        {
          hue: 115,
          chroma: 77.50892220560529,
          tone: 96
        },
        {
          hue: 116,
          chroma: 77.77956106354266,
          tone: 95
        },
        {
          hue: 117,
          chroma: 78.26482715891835,
          tone: 95
        },
        {
          hue: 118,
          chroma: 79.10482618822675,
          tone: 95
        },
        {
          hue: 119,
          chroma: 79.51588168127346,
          tone: 95
        },
        {
          hue: 120,
          chroma: 80.48887899604091,
          tone: 94
        },
        {
          hue: 121,
          chroma: 81.37768433814313,
          tone: 94
        },
        {
          hue: 122,
          chroma: 82.45984346377152,
          tone: 94
        },
        {
          hue: 123,
          chroma: 82.51017475152366,
          tone: 93
        },
        {
          hue: 124,
          chroma: 83.6182222179724,
          tone: 93
        },
        {
          hue: 125,
          chroma: 84.73387847213296,
          tone: 93
        },
        {
          hue: 126,
          chroma: 85.75031741409109,
          tone: 93
        },
        {
          hue: 127,
          chroma: 86.4914021191396,
          tone: 92
        },
        {
          hue: 128,
          chroma: 87.81009434595934,
          tone: 92
        },
        {
          hue: 129,
          chroma: 89.12344650906145,
          tone: 92
        },
        {
          hue: 130,
          chroma: 89.41394403463258,
          tone: 91
        },
        {
          hue: 131,
          chroma: 90.71341984988584,
          tone: 91
        },
        {
          hue: 132,
          chroma: 92.18225469009533,
          tone: 91
        },
        {
          hue: 133,
          chroma: 93.15355359090579,
          tone: 90
        },
        {
          hue: 134,
          chroma: 94.56258533730878,
          tone: 90
        },
        {
          hue: 135,
          chroma: 96.27314359969833,
          tone: 90
        },
        {
          hue: 136,
          chroma: 97.27208299651996,
          tone: 89
        },
        {
          hue: 137,
          chroma: 98.98687083306768,
          tone: 89
        },
        {
          hue: 138,
          chroma: 100.73384267947965,
          tone: 89
        },
        {
          hue: 139,
          chroma: 101.9440077545218,
          tone: 88
        },
        {
          hue: 140,
          chroma: 103.89896334567975,
          tone: 88
        },
        {
          hue: 141,
          chroma: 105.98734694526831,
          tone: 88
        },
        {
          hue: 142,
          chroma: 107.34464988510916,
          tone: 87
        },
        {
          hue: 143,
          chroma: 104.77191200796756,
          tone: 87
        },
        {
          hue: 144,
          chroma: 101.64909649501216,
          tone: 87
        },
        {
          hue: 145,
          chroma: 98.9065522948837,
          tone: 87
        },
        {
          hue: 146,
          chroma: 96.9775891751188,
          tone: 88
        },
        {
          hue: 147,
          chroma: 94.39033654042633,
          tone: 88
        },
        {
          hue: 148,
          chroma: 91.87973725444252,
          tone: 88
        },
        {
          hue: 149,
          chroma: 89.62917230001072,
          tone: 88
        },
        {
          hue: 150,
          chroma: 87.90946087006364,
          tone: 88
        },
        {
          hue: 151,
          chroma: 85.88195830853766,
          tone: 88
        },
        {
          hue: 152,
          chroma: 84.42702442880764,
          tone: 88
        },
        {
          hue: 153,
          chroma: 82.3277210447377,
          tone: 88
        },
        {
          hue: 154,
          chroma: 80.87783702409875,
          tone: 88
        },
        {
          hue: 155,
          chroma: 79.43862821895317,
          tone: 88
        },
        {
          hue: 156,
          chroma: 78.29795702251404,
          tone: 88
        },
        {
          hue: 157,
          chroma: 76.88916663502451,
          tone: 88
        },
        {
          hue: 158,
          chroma: 75.42462687658826,
          tone: 88
        },
        {
          hue: 159,
          chroma: 74.4184468916744,
          tone: 89
        },
        {
          hue: 160,
          chroma: 73.65626046324942,
          tone: 89
        },
        {
          hue: 161,
          chroma: 72.99098362664623,
          tone: 89
        },
        {
          hue: 162,
          chroma: 71.96102453955005,
          tone: 89
        },
        {
          hue: 163,
          chroma: 70.86238313119111,
          tone: 89
        },
        {
          hue: 164,
          chroma: 70.12355159299447,
          tone: 89
        },
        {
          hue: 165,
          chroma: 69.40068285991154,
          tone: 89
        },
        {
          hue: 166,
          chroma: 68.69463271252172,
          tone: 89
        },
        {
          hue: 167,
          chroma: 68.00625302899738,
          tone: 89
        },
        {
          hue: 168,
          chroma: 67.01047824970789,
          tone: 89
        },
        {
          hue: 169,
          chroma: 66.36415172771942,
          tone: 89
        },
        {
          hue: 170,
          chroma: 65.73833778792111,
          tone: 89
        },
        {
          hue: 171,
          chroma: 65.33293729372076,
          tone: 89
        },
        {
          hue: 172,
          chroma: 64.74316316106923,
          tone: 89
        },
        {
          hue: 173,
          chroma: 64.36255220537348,
          tone: 89
        },
        {
          hue: 174,
          chroma: 63.512274727676854,
          tone: 89
        },
        {
          hue: 175,
          chroma: 63.161932460401545,
          tone: 89
        },
        {
          hue: 176,
          chroma: 62.87731474025355,
          tone: 90
        },
        {
          hue: 177,
          chroma: 62.71039242351542,
          tone: 90
        },
        {
          hue: 178,
          chroma: 62.40371942484275,
          tone: 90
        },
        {
          hue: 179,
          chroma: 62.10876864749398,
          tone: 90
        },
        {
          hue: 180,
          chroma: 61.559402350453574,
          tone: 90
        },
        {
          hue: 181,
          chroma: 61.293501260752656,
          tone: 90
        },
        {
          hue: 182,
          chroma: 60.918067399452546,
          tone: 90
        },
        {
          hue: 183,
          chroma: 60.68365229981702,
          tone: 90
        },
        {
          hue: 184,
          chroma: 60.46213527539749,
          tone: 90
        },
        {
          hue: 185,
          chroma: 60.253676453123646,
          tone: 90
        },
        {
          hue: 186,
          chroma: 59.82945671274357,
          tone: 90
        },
        {
          hue: 187,
          chroma: 59.65353920591639,
          tone: 90
        },
        {
          hue: 188,
          chroma: 59.49122428441756,
          tone: 90
        },
        {
          hue: 189,
          chroma: 59.34262486386894,
          tone: 90
        },
        {
          hue: 190,
          chroma: 59.27350034436179,
          tone: 90
        },
        {
          hue: 191,
          chroma: 58.94737198732147,
          tone: 90
        },
        {
          hue: 192,
          chroma: 58.840063538189966,
          tone: 90
        },
        {
          hue: 193,
          chroma: 58.746863163127585,
          tone: 90
        },
        {
          hue: 194,
          chroma: 58.88816911439717,
          tone: 91
        },
        {
          hue: 195,
          chroma: 59.02462926066998,
          tone: 91
        },
        {
          hue: 196,
          chroma: 58.97431923306657,
          tone: 91
        },
        {
          hue: 197,
          chroma: 58.374671585908466,
          tone: 90
        },
        {
          hue: 198,
          chroma: 58.35242934142467,
          tone: 90
        },
        {
          hue: 199,
          chroma: 57.9199516120261,
          tone: 89
        },
        {
          hue: 200,
          chroma: 57.921505543069586,
          tone: 89
        },
        {
          hue: 201,
          chroma: 57.380318693693376,
          tone: 88
        },
        {
          hue: 202,
          chroma: 57.416949230189445,
          tone: 88
        },
        {
          hue: 203,
          chroma: 57.0144125303021,
          tone: 87
        },
        {
          hue: 204,
          chroma: 57.074049560091844,
          tone: 87
        },
        {
          hue: 205,
          chroma: 56.683205844465036,
          tone: 86
        },
        {
          hue: 206,
          chroma: 56.67167507363697,
          tone: 86
        },
        {
          hue: 207,
          chroma: 56.297670825457175,
          tone: 85
        },
        {
          hue: 208,
          chroma: 56.392924323714894,
          tone: 85
        },
        {
          hue: 209,
          chroma: 56.05203766835074,
          tone: 84
        },
        {
          hue: 210,
          chroma: 56.125675818941026,
          tone: 84
        },
        {
          hue: 211,
          chroma: 55.78448198138266,
          tone: 83
        },
        {
          hue: 212,
          chroma: 55.95582281511038,
          tone: 83
        },
        {
          hue: 213,
          chroma: 55.629924813449186,
          tone: 82
        },
        {
          hue: 214,
          chroma: 55.82562875904896,
          tone: 82
        },
        {
          hue: 215,
          chroma: 55.48670981997196,
          tone: 81
        },
        {
          hue: 216,
          chroma: 55.714796289595974,
          tone: 81
        },
        {
          hue: 217,
          chroma: 55.42716162861507,
          tone: 80
        },
        {
          hue: 218,
          chroma: 55.55161294962171,
          tone: 80
        },
        {
          hue: 219,
          chroma: 55.27586066607938,
          tone: 79
        },
        {
          hue: 220,
          chroma: 55.55261390679999,
          tone: 79
        },
        {
          hue: 221,
          chroma: 55.300706259965814,
          tone: 78
        },
        {
          hue: 222,
          chroma: 55.601715603617265,
          tone: 78
        },
        {
          hue: 223,
          chroma: 55.46398039804439,
          tone: 78
        },
        {
          hue: 224,
          chroma: 55.69216350938455,
          tone: 77
        },
        {
          hue: 225,
          chroma: 55.78010091889009,
          tone: 77
        },
        {
          hue: 226,
          chroma: 55.69836608409741,
          tone: 76
        },
        {
          hue: 227,
          chroma: 56.057393694485285,
          tone: 76
        },
        {
          hue: 228,
          chroma: 55.87322525323942,
          tone: 75
        },
        {
          hue: 229,
          chroma: 56.32744687126684,
          tone: 75
        },
        {
          hue: 230,
          chroma: 56.16859886147888,
          tone: 74
        },
        {
          hue: 231,
          chroma: 56.57557180806456,
          tone: 74
        },
        {
          hue: 232,
          chroma: 56.4356709329321,
          tone: 73
        },
        {
          hue: 233,
          chroma: 56.6476418038246,
          tone: 73
        },
        {
          hue: 234,
          chroma: 56.62835694282038,
          tone: 72
        },
        {
          hue: 235,
          chroma: 57.07450010721276,
          tone: 72
        },
        {
          hue: 236,
          chroma: 56.97326344499638,
          tone: 71
        },
        {
          hue: 237,
          chroma: 57.43646115801881,
          tone: 71
        },
        {
          hue: 238,
          chroma: 57.44382467362261,
          tone: 71
        },
        {
          hue: 239,
          chroma: 57.9721470970516,
          tone: 70
        },
        {
          hue: 240,
          chroma: 57.91297207368124,
          tone: 69
        },
        {
          hue: 241,
          chroma: 58.41171493161684,
          tone: 69
        },
        {
          hue: 242,
          chroma: 58.469893763440744,
          tone: 69
        },
        {
          hue: 243,
          chroma: 59.04506949275394,
          tone: 68
        },
        {
          hue: 244,
          chroma: 59.02511739678505,
          tone: 67
        },
        {
          hue: 245,
          chroma: 59.81873184247422,
          tone: 67
        },
        {
          hue: 246,
          chroma: 59.81809476446227,
          tone: 66
        },
        {
          hue: 247,
          chroma: 60.54388328749216,
          tone: 66
        },
        {
          hue: 248,
          chroma: 60.562711104495065,
          tone: 65
        },
        {
          hue: 249,
          chroma: 60.99045141960158,
          tone: 65
        },
        {
          hue: 250,
          chroma: 61.62880294086075,
          tone: 64
        },
        {
          hue: 251,
          chroma: 61.675502067752696,
          tone: 63
        },
        {
          hue: 252,
          chroma: 62.529243184693044,
          tone: 63
        },
        {
          hue: 253,
          chroma: 62.59022925090998,
          tone: 62
        },
        {
          hue: 254,
          chroma: 63.26331829256812,
          tone: 62
        },
        {
          hue: 255,
          chroma: 63.746141159990394,
          tone: 61
        },
        {
          hue: 256,
          chroma: 64.1210280517239,
          tone: 60
        },
        {
          hue: 257,
          chroma: 64.83448023719015,
          tone: 60
        },
        {
          hue: 258,
          chroma: 65.32006498036212,
          tone: 59
        },
        {
          hue: 259,
          chroma: 65.94810703100538,
          tone: 58
        },
        {
          hue: 260,
          chroma: 66.40000753127174,
          tone: 58
        },
        {
          hue: 261,
          chroma: 67.47222124200388,
          tone: 57
        },
        {
          hue: 262,
          chroma: 67.88382958017982,
          tone: 56
        },
        {
          hue: 263,
          chroma: 68.29838362477237,
          tone: 55
        },
        {
          hue: 264,
          chroma: 68.96857531931842,
          tone: 55
        },
        {
          hue: 265,
          chroma: 69.98682718539115,
          tone: 54
        },
        {
          hue: 266,
          chroma: 70.74900359922937,
          tone: 53
        },
        {
          hue: 267,
          chroma: 71.71317742298201,
          tone: 52
        },
        {
          hue: 268,
          chroma: 72.35494971900033,
          tone: 51
        },
        {
          hue: 269,
          chroma: 73.27384870384091,
          tone: 50
        },
        {
          hue: 270,
          chroma: 73.9533042036866,
          tone: 49
        },
        {
          hue: 271,
          chroma: 74.84393104083992,
          tone: 48
        },
        {
          hue: 272,
          chroma: 75.71451042805361,
          tone: 47
        },
        {
          hue: 273,
          chroma: 77.04163226762485,
          tone: 46
        },
        {
          hue: 274,
          chroma: 77.8259730231015,
          tone: 45
        },
        {
          hue: 275,
          chroma: 78.57682910212898,
          tone: 44
        },
        {
          hue: 276,
          chroma: 79.60324922246727,
          tone: 42
        },
        {
          hue: 277,
          chroma: 80.88789666896237,
          tone: 41
        },
        {
          hue: 278,
          chroma: 81.90481632803404,
          tone: 40
        },
        {
          hue: 279,
          chroma: 82.7496507668004,
          tone: 39
        },
        {
          hue: 280,
          chroma: 84.1831161875188,
          tone: 37
        },
        {
          hue: 281,
          chroma: 84.92790329338081,
          tone: 35
        },
        {
          hue: 282,
          chroma: 86.23810231597862,
          tone: 34
        },
        {
          hue: 283,
          chroma: 86.90394291180358,
          tone: 33
        },
        {
          hue: 284,
          chroma: 87.08082861285786,
          tone: 33
        },
        {
          hue: 285,
          chroma: 87.24506419043743,
          tone: 33
        },
        {
          hue: 286,
          chroma: 86.952684743878,
          tone: 34
        },
        {
          hue: 287,
          chroma: 87.18086387818107,
          tone: 34
        },
        {
          hue: 288,
          chroma: 87.14447857778784,
          tone: 34
        },
        {
          hue: 289,
          chroma: 87.11918107348718,
          tone: 35
        },
        {
          hue: 290,
          chroma: 87.43053774908645,
          tone: 35
        },
        {
          hue: 291,
          chroma: 87.15634203979539,
          tone: 35
        },
        {
          hue: 292,
          chroma: 87.44526977704604,
          tone: 36
        },
        {
          hue: 293,
          chroma: 87.79987495142663,
          tone: 36
        },
        {
          hue: 294,
          chroma: 87.5130714461638,
          tone: 37
        },
        {
          hue: 295,
          chroma: 87.90423869811676,
          tone: 37
        },
        {
          hue: 296,
          chroma: 87.98368523822299,
          tone: 37
        },
        {
          hue: 297,
          chroma: 88.11409244048949,
          tone: 38
        },
        {
          hue: 298,
          chroma: 88.56661997617809,
          tone: 38
        },
        {
          hue: 299,
          chroma: 88.29748676991436,
          tone: 39
        },
        {
          hue: 300,
          chroma: 88.88320737734239,
          tone: 39
        },
        {
          hue: 301,
          chroma: 88.7727810946839,
          tone: 39
        },
        {
          hue: 302,
          chroma: 89.21447953385142,
          tone: 40
        },
        {
          hue: 303,
          chroma: 89.48070573767065,
          tone: 40
        },
        {
          hue: 304,
          chroma: 89.6608824511493,
          tone: 41
        },
        {
          hue: 305,
          chroma: 89.99541374058613,
          tone: 41
        },
        {
          hue: 306,
          chroma: 90.09450756617315,
          tone: 42
        },
        {
          hue: 307,
          chroma: 90.82769298230927,
          tone: 42
        },
        {
          hue: 308,
          chroma: 90.72421043246295,
          tone: 43
        },
        {
          hue: 309,
          chroma: 91.45942674104516,
          tone: 43
        },
        {
          hue: 310,
          chroma: 91.38285503232278,
          tone: 44
        },
        {
          hue: 311,
          chroma: 92.08758829120774,
          tone: 44
        },
        {
          hue: 312,
          chroma: 92.2609866968918,
          tone: 45
        },
        {
          hue: 313,
          chroma: 92.84200860797634,
          tone: 45
        },
        {
          hue: 314,
          chroma: 93.15443236769123,
          tone: 46
        },
        {
          hue: 315,
          chroma: 93.64807555314712,
          tone: 46
        },
        {
          hue: 316,
          chroma: 94.16209871968593,
          tone: 47
        },
        {
          hue: 317,
          chroma: 94.48654900082282,
          tone: 47
        },
        {
          hue: 318,
          chroma: 95.41312587073348,
          tone: 48
        },
        {
          hue: 319,
          chroma: 95.47216850513806,
          tone: 49
        },
        {
          hue: 320,
          chroma: 96.21411379664595,
          tone: 49
        },
        {
          hue: 321,
          chroma: 96.85764631441657,
          tone: 50
        },
        {
          hue: 322,
          chroma: 96.94706115665727,
          tone: 51
        },
        {
          hue: 323,
          chroma: 98.06908261497591,
          tone: 51
        },
        {
          hue: 324,
          chroma: 98.75204696049269,
          tone: 52
        },
        {
          hue: 325,
          chroma: 98.88863214567131,
          tone: 52
        },
        {
          hue: 326,
          chroma: 99.78182434342499,
          tone: 53
        },
        {
          hue: 327,
          chroma: 100.95278346973463,
          tone: 54
        },
        {
          hue: 328,
          chroma: 101.33018156605723,
          tone: 55
        },
        {
          hue: 329,
          chroma: 101.7743383038679,
          tone: 55
        },
        {
          hue: 330,
          chroma: 102.87717601836594,
          tone: 56
        },
        {
          hue: 331,
          chroma: 103.99097603224963,
          tone: 57
        },
        {
          hue: 332,
          chroma: 104.9420517158155,
          tone: 58
        },
        {
          hue: 333,
          chroma: 105.68670780905971,
          tone: 59
        },
        {
          hue: 334,
          chroma: 106.2143672757169,
          tone: 60
        },
        {
          hue: 335,
          chroma: 106.97580762842179,
          tone: 60
        },
        {
          hue: 336,
          chroma: 106.53263145170487,
          tone: 60
        },
        {
          hue: 337,
          chroma: 105.66469785241135,
          tone: 59
        },
        {
          hue: 338,
          chroma: 105.55565530633167,
          tone: 59
        },
        {
          hue: 339,
          chroma: 105.65533894573977,
          tone: 59
        },
        {
          hue: 340,
          chroma: 104.64330725609823,
          tone: 59
        },
        {
          hue: 341,
          chroma: 104.26530320060418,
          tone: 58
        },
        {
          hue: 342,
          chroma: 104.42370398510621,
          tone: 58
        },
        {
          hue: 343,
          chroma: 104.39762917339176,
          tone: 58
        },
        {
          hue: 344,
          chroma: 103.66441029926824,
          tone: 58
        },
        {
          hue: 345,
          chroma: 103.17935570868941,
          tone: 57
        },
        {
          hue: 346,
          chroma: 103.20108117223944,
          tone: 57
        },
        {
          hue: 347,
          chroma: 103.24101321493077,
          tone: 57
        },
        {
          hue: 348,
          chroma: 103.2995050951176,
          tone: 57
        },
        {
          hue: 349,
          chroma: 102.58608840944547,
          tone: 57
        },
        {
          hue: 350,
          chroma: 102.23336002907227,
          tone: 56
        },
        {
          hue: 351,
          chroma: 102.37550361713498,
          tone: 56
        },
        {
          hue: 352,
          chroma: 102.27101316564784,
          tone: 56
        },
        {
          hue: 353,
          chroma: 102.41970083380389,
          tone: 56
        },
        {
          hue: 354,
          chroma: 102.58971996971019,
          tone: 56
        },
        {
          hue: 355,
          chroma: 102.00536806857933,
          tone: 56
        },
        {
          hue: 356,
          chroma: 101.7473979431004,
          tone: 55
        },
        {
          hue: 357,
          chroma: 101.72945377180396,
          tone: 55
        },
        {
          hue: 358,
          chroma: 101.98279067416397,
          tone: 55
        },
        {
          hue: 359,
          chroma: 102.2524247595348,
          tone: 55
        },
        {
          hue: 360,
          chroma: 102.29059338702712,
          tone: 55
        }
      ];
    }
  });

  // src/hooks/useAlias.ts
  var aliasId, AliasDataSchema, AliasActionsSchema, AliasSchema, useAliasStore;
  var init_useAlias = __esm({
    "src/hooks/useAlias.ts"() {
      "use strict";
      init_lib3();
      init_esm();
      aliasId = 0;
      AliasDataSchema = z3.object({
        id: z3.number(),
        name: z3.string(),
        color: z3.array(
          z3.object({
            mode: z3.string(),
            tone: z3.number()
          })
        )
      });
      AliasActionsSchema = z3.object({
        setId: z3.function().args(z3.number(), z3.void()),
        setName: z3.function().args(z3.string(), z3.void()),
        setColor: z3.function().args(
          z3.array(
            z3.object({
              mode: z3.string(),
              tone: z3.number()
            })
          ),
          z3.void()
        ),
        setToneForMode: z3.function().args(z3.union([z3.string(), z3.number()]), z3.number(), z3.void())
      });
      AliasSchema = AliasDataSchema.merge(AliasActionsSchema);
      useAliasStore = create((set) => ({
        id: aliasId++,
        name: `Alias ${aliasId}`,
        color: [
          { mode: "light", tone: 100 },
          { mode: "dark", tone: 0 }
        ],
        setId: (id) => set(() => ({ id })),
        setName: (name307) => set(() => ({ name: name307 })),
        setColor: (color2) => set(() => ({ color: color2 })),
        setToneForMode: (mode2, tone) => set((state) => {
          const newColor = [...state.color];
          const colorIndex = newColor.findIndex(
            (newColor2) => newColor2.mode === mode2
          );
          if (colorIndex === -1) {
            newColor.push({ mode: mode2.toString(), tone });
          } else {
            newColor[colorIndex].tone = tone;
          }
          return { color: newColor };
        })
      }));
    }
  });

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var init_extends = __esm({
    "node_modules/@babel/runtime/helpers/esm/extends.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG;
  var init_config = __esm({
    "node_modules/mathjs/lib/esm/core/config.js"() {
      DEFAULT_CONFIG = {
        // minimum relative difference between two compared values,
        // used by all comparison functions
        epsilon: 1e-12,
        // type of default matrix output. Choose 'matrix' (default) or 'array'
        matrix: "Matrix",
        // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
        number: "number",
        // number of significant digits in BigNumbers
        precision: 64,
        // predictable output type of functions. When true, output type depends only
        // on the input types. When false (default), output type can vary depending
        // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
        // predictable is false, and returns `NaN` when true.
        predictable: false,
        // random seed for seeded pseudo random number generation
        // null = randomly seed
        randomSeed: null
      };
    }
  });

  // node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x4) {
    return typeof x4 === "number";
  }
  function isBigNumber(x4) {
    if (!x4 || typeof x4 !== "object" || typeof x4.constructor !== "function") {
      return false;
    }
    if (x4.isBigNumber === true && typeof x4.constructor.prototype === "object" && x4.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x4.constructor.isDecimal === "function" && x4.constructor.isDecimal(x4) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x4) {
    return x4 && typeof x4 === "object" && Object.getPrototypeOf(x4).isComplex === true || false;
  }
  function isFraction(x4) {
    return x4 && typeof x4 === "object" && Object.getPrototypeOf(x4).isFraction === true || false;
  }
  function isUnit(x4) {
    return x4 && x4.constructor.prototype.isUnit === true || false;
  }
  function isString(x4) {
    return typeof x4 === "string";
  }
  function isMatrix(x4) {
    return x4 && x4.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x4) {
    return Array.isArray(x4) || isMatrix(x4);
  }
  function isDenseMatrix(x4) {
    return x4 && x4.isDenseMatrix && x4.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x4) {
    return x4 && x4.isSparseMatrix && x4.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x4) {
    return x4 && x4.constructor.prototype.isRange === true || false;
  }
  function isIndex(x4) {
    return x4 && x4.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x4) {
    return typeof x4 === "boolean";
  }
  function isResultSet(x4) {
    return x4 && x4.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x4) {
    return x4 && x4.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x4) {
    return typeof x4 === "function";
  }
  function isDate(x4) {
    return x4 instanceof Date;
  }
  function isRegExp(x4) {
    return x4 instanceof RegExp;
  }
  function isObject(x4) {
    return !!(x4 && typeof x4 === "object" && x4.constructor === Object && !isComplex(x4) && !isFraction(x4));
  }
  function isNull(x4) {
    return x4 === null;
  }
  function isUndefined(x4) {
    return x4 === void 0;
  }
  function isAccessorNode(x4) {
    return x4 && x4.isAccessorNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x4) {
    return x4 && x4.isArrayNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x4) {
    return x4 && x4.isAssignmentNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x4) {
    return x4 && x4.isBlockNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x4) {
    return x4 && x4.isConditionalNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x4) {
    return x4 && x4.isConstantNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function rule2Node(node) {
    return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
  }
  function isFunctionAssignmentNode(x4) {
    return x4 && x4.isFunctionAssignmentNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x4) {
    return x4 && x4.isFunctionNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x4) {
    return x4 && x4.isIndexNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isNode(x4) {
    return x4 && x4.isNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x4) {
    return x4 && x4.isObjectNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x4) {
    return x4 && x4.isOperatorNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x4) {
    return x4 && x4.isParenthesisNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x4) {
    return x4 && x4.isRangeNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isRelationalNode(x4) {
    return x4 && x4.isRelationalNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x4) {
    return x4 && x4.isSymbolNode === true && x4.constructor.prototype.isNode === true || false;
  }
  function isChain(x4) {
    return x4 && x4.constructor.prototype.isChain === true || false;
  }
  function typeOf(x4) {
    var t3 = typeof x4;
    if (t3 === "object") {
      if (x4 === null)
        return "null";
      if (isBigNumber(x4))
        return "BigNumber";
      if (x4.constructor && x4.constructor.name)
        return x4.constructor.name;
      return "Object";
    }
    return t3;
  }
  var isArray;
  var init_is = __esm({
    "node_modules/mathjs/lib/esm/utils/is.js"() {
      isArray = Array.isArray;
    }
  });

  // node_modules/mathjs/lib/esm/utils/object.js
  function clone(x4) {
    var type = typeof x4;
    if (type === "number" || type === "string" || type === "boolean" || x4 === null || x4 === void 0) {
      return x4;
    }
    if (typeof x4.clone === "function") {
      return x4.clone();
    }
    if (Array.isArray(x4)) {
      return x4.map(function(value) {
        return clone(value);
      });
    }
    if (x4 instanceof Date)
      return new Date(x4.valueOf());
    if (isBigNumber(x4))
      return x4;
    if (x4 instanceof RegExp)
      throw new TypeError("Cannot clone " + x4);
    return mapObject(x4, clone);
  }
  function mapObject(object, callback) {
    var clone5 = {};
    for (var key in object) {
      if (hasOwnProperty2(object, key)) {
        clone5[key] = callback(object[key]);
      }
    }
    return clone5;
  }
  function extend(a3, b3) {
    for (var prop in b3) {
      if (hasOwnProperty2(b3, prop)) {
        a3[prop] = b3[prop];
      }
    }
    return a3;
  }
  function deepStrictEqual(a3, b3) {
    var prop, i5, len;
    if (Array.isArray(a3)) {
      if (!Array.isArray(b3)) {
        return false;
      }
      if (a3.length !== b3.length) {
        return false;
      }
      for (i5 = 0, len = a3.length; i5 < len; i5++) {
        if (!deepStrictEqual(a3[i5], b3[i5])) {
          return false;
        }
      }
      return true;
    } else if (typeof a3 === "function") {
      return a3 === b3;
    } else if (a3 instanceof Object) {
      if (Array.isArray(b3) || !(b3 instanceof Object)) {
        return false;
      }
      for (prop in a3) {
        if (!(prop in b3) || !deepStrictEqual(a3[prop], b3[prop])) {
          return false;
        }
      }
      for (prop in b3) {
        if (!(prop in a3)) {
          return false;
        }
      }
      return true;
    } else {
      return a3 === b3;
    }
  }
  function lazy(object, prop, valueResolver) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function get() {
        if (_uninitialized) {
          _value = valueResolver();
          _uninitialized = false;
        }
        return _value;
      },
      set: function set(value) {
        _value = value;
        _uninitialized = false;
      },
      configurable: true,
      enumerable: true
    });
  }
  function hasOwnProperty2(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function pickShallow(object, properties2) {
    var copy = {};
    for (var i5 = 0; i5 < properties2.length; i5++) {
      var key = properties2[i5];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }
  var init_object = __esm({
    "node_modules/mathjs/lib/esm/utils/object.js"() {
      init_is();
    }
  });

  // node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS, NUMBER_OPTIONS;
  var init_config2 = __esm({
    "node_modules/mathjs/lib/esm/core/function/config.js"() {
      MATRIX_OPTIONS = ["Matrix", "Array"];
      NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
    }
  });

  // node_modules/mathjs/lib/esm/entry/configReadonly.js
  var config;
  var init_configReadonly = __esm({
    "node_modules/mathjs/lib/esm/entry/configReadonly.js"() {
      init_extends();
      init_config();
      init_config2();
      config = function config2(options) {
        if (options) {
          throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
        }
        return Object.freeze(DEFAULT_CONFIG);
      };
      _extends(config, DEFAULT_CONFIG, {
        MATRIX_OPTIONS,
        NUMBER_OPTIONS
      });
    }
  });

  // node_modules/typed-function/lib/umd/typed-function.js
  var require_typed_function = __commonJS({
    "node_modules/typed-function/lib/umd/typed-function.js"(exports, module) {
      (function(global, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.typed = factory2());
      })(exports, function() {
        "use strict";
        function _createForOfIteratorHelper(o3, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
          if (!it) {
            if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
              if (it)
                o3 = it;
              var i5 = 0;
              var F4 = function F5() {
              };
              return { s: F4, n: function n3() {
                if (i5 >= o3.length)
                  return { done: true };
                return { done: false, value: o3[i5++] };
              }, e: function e6(_e) {
                throw _e;
              }, f: F4 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s3() {
            it = it.call(o3);
          }, n: function n3() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e6(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f3() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function _unsupportedIterableToArray(o3, minLen) {
          if (!o3)
            return;
          if (typeof o3 === "string")
            return _arrayLikeToArray(o3, minLen);
          var n3 = Object.prototype.toString.call(o3).slice(8, -1);
          if (n3 === "Object" && o3.constructor)
            n3 = o3.constructor.name;
          if (n3 === "Map" || n3 === "Set")
            return Array.from(o3);
          if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
            return _arrayLikeToArray(o3, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
            arr2[i5] = arr[i5];
          }
          return arr2;
        }
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof2(obj);
        }
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return void 0;
        }
        var NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
        function create2() {
          function isPlainObject2(x4) {
            return _typeof2(x4) === "object" && x4 !== null && x4.constructor === Object;
          }
          var _types = [{
            name: "number",
            test: function test(x4) {
              return typeof x4 === "number";
            }
          }, {
            name: "string",
            test: function test(x4) {
              return typeof x4 === "string";
            }
          }, {
            name: "boolean",
            test: function test(x4) {
              return typeof x4 === "boolean";
            }
          }, {
            name: "Function",
            test: function test(x4) {
              return typeof x4 === "function";
            }
          }, {
            name: "Array",
            test: Array.isArray
          }, {
            name: "Date",
            test: function test(x4) {
              return x4 instanceof Date;
            }
          }, {
            name: "RegExp",
            test: function test(x4) {
              return x4 instanceof RegExp;
            }
          }, {
            name: "Object",
            test: isPlainObject2
          }, {
            name: "null",
            test: function test(x4) {
              return x4 === null;
            }
          }, {
            name: "undefined",
            test: function test(x4) {
              return x4 === void 0;
            }
          }];
          var anyType2 = {
            name: "any",
            test: ok,
            isAny: true
          };
          var typeMap;
          var typeList;
          var nConversions = 0;
          var typed3 = {
            createCount: 0
          };
          function findType(typeName) {
            var type = typeMap.get(typeName);
            if (type) {
              return type;
            }
            var message = 'Unknown type "' + typeName + '"';
            var name307 = typeName.toLowerCase();
            var otherName;
            var _iterator = _createForOfIteratorHelper(typeList), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                otherName = _step.value;
                if (otherName.toLowerCase() === name307) {
                  message += '. Did you mean "' + otherName + '" ?';
                  break;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            throw new TypeError(message);
          }
          function addTypes(types) {
            var beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
            var beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
            var newTypes = [];
            for (var i5 = 0; i5 < types.length; ++i5) {
              if (!types[i5] || typeof types[i5].name !== "string" || typeof types[i5].test !== "function") {
                throw new TypeError("Object with properties {name: string, test: function} expected");
              }
              var typeName = types[i5].name;
              if (typeMap.has(typeName)) {
                throw new TypeError('Duplicate type name "' + typeName + '"');
              }
              newTypes.push(typeName);
              typeMap.set(typeName, {
                name: typeName,
                test: types[i5].test,
                isAny: types[i5].isAny,
                index: beforeIndex + i5,
                conversionsTo: []
                // Newly added type can't have any conversions to it
              });
            }
            var affectedTypes = typeList.slice(beforeIndex);
            typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
            for (var _i = beforeIndex + newTypes.length; _i < typeList.length; ++_i) {
              typeMap.get(typeList[_i]).index = _i;
            }
          }
          function clear() {
            typeMap = /* @__PURE__ */ new Map();
            typeList = [];
            nConversions = 0;
            addTypes([anyType2], false);
          }
          clear();
          addTypes(_types);
          function clearConversions() {
            var typeName;
            var _iterator2 = _createForOfIteratorHelper(typeList), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                typeName = _step2.value;
                typeMap.get(typeName).conversionsTo = [];
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            nConversions = 0;
          }
          function findTypeNames(value) {
            var matches = typeList.filter(function(name307) {
              var type = typeMap.get(name307);
              return !type.isAny && type.test(value);
            });
            if (matches.length) {
              return matches;
            }
            return ["any"];
          }
          function isTypedFunction(entity) {
            return entity && typeof entity === "function" && "_typedFunctionData" in entity;
          }
          function findSignature(fn2, signature, options) {
            if (!isTypedFunction(fn2)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            var exact = options && options.exact;
            var stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
            var params = parseSignature(stringSignature);
            var canonicalSignature = stringifyParams(params);
            if (!exact || canonicalSignature in fn2.signatures) {
              var match = fn2._typedFunctionData.signatureMap.get(canonicalSignature);
              if (match) {
                return match;
              }
            }
            var nParams = params.length;
            var remainingSignatures;
            if (exact) {
              remainingSignatures = [];
              var name307;
              for (name307 in fn2.signatures) {
                remainingSignatures.push(fn2._typedFunctionData.signatureMap.get(name307));
              }
            } else {
              remainingSignatures = fn2._typedFunctionData.signatures;
            }
            for (var i5 = 0; i5 < nParams; ++i5) {
              var want = params[i5];
              var filteredSignatures = [];
              var possibility = void 0;
              var _iterator3 = _createForOfIteratorHelper(remainingSignatures), _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                  possibility = _step3.value;
                  var have = getParamAtIndex(possibility.params, i5);
                  if (!have || want.restParam && !have.restParam) {
                    continue;
                  }
                  if (!have.hasAny) {
                    var _ret = function() {
                      var haveTypes = paramTypeSet(have);
                      if (want.types.some(function(wtype) {
                        return !haveTypes.has(wtype.name);
                      })) {
                        return "continue";
                      }
                    }();
                    if (_ret === "continue")
                      continue;
                  }
                  filteredSignatures.push(possibility);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              remainingSignatures = filteredSignatures;
              if (remainingSignatures.length === 0)
                break;
            }
            var candidate;
            var _iterator4 = _createForOfIteratorHelper(remainingSignatures), _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                candidate = _step4.value;
                if (candidate.params.length <= nParams) {
                  return candidate;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            throw new TypeError("Signature not found (signature: " + (fn2.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
          }
          function find(fn2, signature, options) {
            return findSignature(fn2, signature, options).implementation;
          }
          function convert(value, typeName) {
            var type = findType(typeName);
            if (type.test(value)) {
              return value;
            }
            var conversions = type.conversionsTo;
            if (conversions.length === 0) {
              throw new Error("There are no conversions to " + typeName + " defined.");
            }
            for (var i5 = 0; i5 < conversions.length; i5++) {
              var fromType = findType(conversions[i5].from);
              if (fromType.test(value)) {
                return conversions[i5].convert(value);
              }
            }
            throw new Error("Cannot convert " + value + " to " + typeName);
          }
          function stringifyParams(params) {
            var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
            return params.map(function(p3) {
              return p3.name;
            }).join(separator);
          }
          function parseParam(param) {
            var restParam = param.indexOf("...") === 0;
            var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
            var typeDefs = types.split("|").map(function(s3) {
              return findType(s3.trim());
            });
            var hasAny = false;
            var paramName = restParam ? "..." : "";
            var exactTypes = typeDefs.map(function(type) {
              hasAny = type.isAny || hasAny;
              paramName += type.name + "|";
              return {
                name: type.name,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion: null,
                conversionIndex: -1
              };
            });
            return {
              types: exactTypes,
              name: paramName.slice(0, -1),
              // remove trailing '|' from above
              hasAny,
              hasConversion: false,
              restParam
            };
          }
          function expandParam(param) {
            var typeNames = param.types.map(function(t3) {
              return t3.name;
            });
            var matchingConversions = availableConversions(typeNames);
            var hasAny = param.hasAny;
            var newName = param.name;
            var convertibleTypes = matchingConversions.map(function(conversion) {
              var type = findType(conversion.from);
              hasAny = type.isAny || hasAny;
              newName += "|" + conversion.from;
              return {
                name: conversion.from,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion,
                conversionIndex: conversion.index
              };
            });
            return {
              types: param.types.concat(convertibleTypes),
              name: newName,
              hasAny,
              hasConversion: convertibleTypes.length > 0,
              restParam: param.restParam
            };
          }
          function paramTypeSet(param) {
            if (!param.typeSet) {
              param.typeSet = /* @__PURE__ */ new Set();
              param.types.forEach(function(type) {
                return param.typeSet.add(type.name);
              });
            }
            return param.typeSet;
          }
          function parseSignature(rawSignature) {
            var params = [];
            if (typeof rawSignature !== "string") {
              throw new TypeError("Signatures must be strings");
            }
            var signature = rawSignature.trim();
            if (signature === "") {
              return params;
            }
            var rawParams = signature.split(",");
            for (var i5 = 0; i5 < rawParams.length; ++i5) {
              var parsedParam = parseParam(rawParams[i5].trim());
              if (parsedParam.restParam && i5 !== rawParams.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + rawParams[i5] + '": only allowed for the last parameter');
              }
              if (parsedParam.types.length === 0) {
                return null;
              }
              params.push(parsedParam);
            }
            return params;
          }
          function hasRestParam(params) {
            var param = last(params);
            return param ? param.restParam : false;
          }
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              return ok;
            } else if (param.types.length === 1) {
              return findType(param.types[0].name).test;
            } else if (param.types.length === 2) {
              var test0 = findType(param.types[0].name).test;
              var test1 = findType(param.types[1].name).test;
              return function or2(x4) {
                return test0(x4) || test1(x4);
              };
            } else {
              var tests = param.types.map(function(type) {
                return findType(type.name).test;
              });
              return function or2(x4) {
                for (var i5 = 0; i5 < tests.length; i5++) {
                  if (tests[i5](x4)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }
          function compileTests(params) {
            var tests, test0, test1;
            if (hasRestParam(params)) {
              tests = initial(params).map(compileTest);
              var varIndex = tests.length;
              var lastTest = compileTest(last(params));
              var testRestParam = function testRestParam2(args) {
                for (var i5 = varIndex; i5 < args.length; i5++) {
                  if (!lastTest(args[i5])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (var i5 = 0; i5 < tests.length; i5++) {
                  if (!tests[i5](args[i5])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (var i5 = 0; i5 < tests.length; i5++) {
                    if (!tests[i5](args[i5])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }
          function getParamAtIndex(params, index2) {
            return index2 < params.length ? params[index2] : hasRestParam(params) ? last(params) : null;
          }
          function getTypeSetAtIndex(params, index2) {
            var param = getParamAtIndex(params, index2);
            if (!param) {
              return /* @__PURE__ */ new Set();
            }
            return paramTypeSet(param);
          }
          function isExactType(type) {
            return type.conversion === null || type.conversion === void 0;
          }
          function mergeExpectedParams(signatures, index2) {
            var typeSet = /* @__PURE__ */ new Set();
            signatures.forEach(function(signature) {
              var paramSet = getTypeSetAtIndex(signature.params, index2);
              var name307;
              var _iterator5 = _createForOfIteratorHelper(paramSet), _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                  name307 = _step5.value;
                  typeSet.add(name307);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            });
            return typeSet.has("any") ? ["any"] : Array.from(typeSet);
          }
          function createError(name307, args, signatures) {
            var err, expected;
            var _name = name307 || "unnamed";
            var matchingSignatures = signatures;
            var index2;
            var _loop = function _loop2() {
              var nextMatchingDefs = [];
              matchingSignatures.forEach(function(signature) {
                var param = getParamAtIndex(signature.params, index2);
                var test = compileTest(param);
                if ((index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2])) {
                  nextMatchingDefs.push(signature);
                }
              });
              if (nextMatchingDefs.length === 0) {
                expected = mergeExpectedParams(matchingSignatures, index2);
                if (expected.length > 0) {
                  var actualTypes = findTypeNames(args[index2]);
                  err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index2 + ")");
                  err.data = {
                    category: "wrongType",
                    fn: _name,
                    index: index2,
                    actual: actualTypes,
                    expected
                  };
                  return {
                    v: err
                  };
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            };
            for (index2 = 0; index2 < args.length; index2++) {
              var _ret2 = _loop();
              if (_typeof2(_ret2) === "object")
                return _ret2.v;
            }
            var lengths = matchingSignatures.map(function(signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index2);
              err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
              err.data = {
                category: "tooFewArgs",
                fn: _name,
                index: args.length,
                expected
              };
              return err;
            }
            var maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
              err.data = {
                category: "tooManyArgs",
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            var argTypes = [];
            for (var i5 = 0; i5 < args.length; ++i5) {
              argTypes.push(findTypeNames(args[i5]).join("|"));
            }
            err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
            err.data = {
              category: "mismatch",
              actual: argTypes
            };
            return err;
          }
          function getLowestTypeIndex(param) {
            var min3 = typeList.length + 1;
            for (var i5 = 0; i5 < param.types.length; i5++) {
              if (isExactType(param.types[i5])) {
                min3 = Math.min(min3, param.types[i5].typeIndex);
              }
            }
            return min3;
          }
          function getLowestConversionIndex(param) {
            var min3 = nConversions + 1;
            for (var i5 = 0; i5 < param.types.length; i5++) {
              if (!isExactType(param.types[i5])) {
                min3 = Math.min(min3, param.types[i5].conversionIndex);
              }
            }
            return min3;
          }
          function compareParams(param1, param2) {
            if (param1.hasAny) {
              if (!param2.hasAny) {
                return 1;
              }
            } else if (param2.hasAny) {
              return -1;
            }
            if (param1.restParam) {
              if (!param2.restParam) {
                return 1;
              }
            } else if (param2.restParam) {
              return -1;
            }
            if (param1.hasConversion) {
              if (!param2.hasConversion) {
                return 1;
              }
            } else if (param2.hasConversion) {
              return -1;
            }
            var typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (typeDiff < 0) {
              return -1;
            }
            if (typeDiff > 0) {
              return 1;
            }
            var convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
            if (convDiff < 0) {
              return -1;
            }
            if (convDiff > 0) {
              return 1;
            }
            return 0;
          }
          function compareSignatures(signature1, signature2) {
            var pars1 = signature1.params;
            var pars2 = signature2.params;
            var last1 = last(pars1);
            var last2 = last(pars2);
            var hasRest1 = hasRestParam(pars1);
            var hasRest2 = hasRestParam(pars2);
            if (hasRest1 && last1.hasAny) {
              if (!hasRest2 || !last2.hasAny) {
                return 1;
              }
            } else if (hasRest2 && last2.hasAny) {
              return -1;
            }
            var any1 = 0;
            var conv1 = 0;
            var par;
            var _iterator6 = _createForOfIteratorHelper(pars1), _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                par = _step6.value;
                if (par.hasAny)
                  ++any1;
                if (par.hasConversion)
                  ++conv1;
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            var any2 = 0;
            var conv2 = 0;
            var _iterator7 = _createForOfIteratorHelper(pars2), _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                par = _step7.value;
                if (par.hasAny)
                  ++any2;
                if (par.hasConversion)
                  ++conv2;
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            if (any1 !== any2) {
              return any1 - any2;
            }
            if (hasRest1 && last1.hasConversion) {
              if (!hasRest2 || !last2.hasConversion) {
                return 1;
              }
            } else if (hasRest2 && last2.hasConversion) {
              return -1;
            }
            if (conv1 !== conv2) {
              return conv1 - conv2;
            }
            if (hasRest1) {
              if (!hasRest2) {
                return 1;
              }
            } else if (hasRest2) {
              return -1;
            }
            var lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
            if (lengthCriterion !== 0) {
              return lengthCriterion;
            }
            var comparisons = [];
            var tc = 0;
            for (var i5 = 0; i5 < pars1.length; ++i5) {
              var thisComparison = compareParams(pars1[i5], pars2[i5]);
              comparisons.push(thisComparison);
              tc += thisComparison;
            }
            if (tc !== 0) {
              return tc;
            }
            var c3;
            for (var _i2 = 0, _comparisons = comparisons; _i2 < _comparisons.length; _i2++) {
              c3 = _comparisons[_i2];
              if (c3 !== 0) {
                return c3;
              }
            }
            return 0;
          }
          function availableConversions(typeNames) {
            if (typeNames.length === 0) {
              return [];
            }
            var types = typeNames.map(findType);
            if (typeNames.length > 1) {
              types.sort(function(t1, t22) {
                return t1.index - t22.index;
              });
            }
            var matches = types[0].conversionsTo;
            if (typeNames.length === 1) {
              return matches;
            }
            matches = matches.concat([]);
            var knownTypes = new Set(typeNames);
            for (var i5 = 1; i5 < types.length; ++i5) {
              var newMatch = void 0;
              var _iterator8 = _createForOfIteratorHelper(types[i5].conversionsTo), _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                  newMatch = _step8.value;
                  if (!knownTypes.has(newMatch.from)) {
                    matches.push(newMatch);
                    knownTypes.add(newMatch.from);
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
            return matches;
          }
          function compileArgsPreprocessing(params, fn2) {
            var fnConvert = fn2;
            if (params.some(function(p3) {
              return p3.hasConversion;
            })) {
              var restParam = hasRestParam(params);
              var compiledConversions = params.map(compileArgConversion);
              fnConvert = function convertArgs() {
                var args = [];
                var last2 = restParam ? arguments.length - 1 : arguments.length;
                for (var i5 = 0; i5 < last2; i5++) {
                  args[i5] = compiledConversions[i5](arguments[i5]);
                }
                if (restParam) {
                  args[last2] = arguments[last2].map(compiledConversions[last2]);
                }
                return fn2.apply(this, args);
              };
            }
            var fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              var offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
              };
            }
            return fnPreprocess;
          }
          function compileArgConversion(param) {
            var test0, test1, conversion0, conversion1;
            var tests = [];
            var conversions = [];
            param.types.forEach(function(type) {
              if (type.conversion) {
                tests.push(findType(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });
            switch (conversions.length) {
              case 0:
                return function convertArg(arg2) {
                  return arg2;
                };
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                return function convertArg(arg2) {
                  if (test0(arg2)) {
                    return conversion0(arg2);
                  }
                  return arg2;
                };
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                return function convertArg(arg2) {
                  if (test0(arg2)) {
                    return conversion0(arg2);
                  }
                  if (test1(arg2)) {
                    return conversion1(arg2);
                  }
                  return arg2;
                };
              default:
                return function convertArg(arg2) {
                  for (var i5 = 0; i5 < conversions.length; i5++) {
                    if (tests[i5](arg2)) {
                      return conversions[i5](arg2);
                    }
                  }
                  return arg2;
                };
            }
          }
          function splitParams(params) {
            function _splitParams(params2, index2, paramsSoFar) {
              if (index2 < params2.length) {
                var param = params2[index2];
                var resultingParams = [];
                if (param.restParam) {
                  var exactTypes = param.types.filter(isExactType);
                  if (exactTypes.length < param.types.length) {
                    resultingParams.push({
                      types: exactTypes,
                      name: "..." + exactTypes.map(function(t3) {
                        return t3.name;
                      }).join("|"),
                      hasAny: exactTypes.some(function(t3) {
                        return t3.isAny;
                      }),
                      hasConversion: false,
                      restParam: true
                    });
                  }
                  resultingParams.push(param);
                } else {
                  resultingParams = param.types.map(function(type) {
                    return {
                      types: [type],
                      name: type.name,
                      hasAny: type.isAny,
                      hasConversion: type.conversion,
                      restParam: false
                    };
                  });
                }
                return flatMap(resultingParams, function(nextParam) {
                  return _splitParams(params2, index2 + 1, paramsSoFar.concat([nextParam]));
                });
              } else {
                return [paramsSoFar];
              }
            }
            return _splitParams(params, 0, []);
          }
          function conflicting(params1, params2) {
            var ii = Math.max(params1.length, params2.length);
            for (var i5 = 0; i5 < ii; i5++) {
              var typeSet1 = getTypeSetAtIndex(params1, i5);
              var typeSet2 = getTypeSetAtIndex(params2, i5);
              var overlap = false;
              var name307 = void 0;
              var _iterator9 = _createForOfIteratorHelper(typeSet2), _step9;
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                  name307 = _step9.value;
                  if (typeSet1.has(name307)) {
                    overlap = true;
                    break;
                  }
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
              if (!overlap) {
                return false;
              }
            }
            var len1 = params1.length;
            var len2 = params2.length;
            var restParam1 = hasRestParam(params1);
            var restParam2 = hasRestParam(params2);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }
          function clearResolutions(functionList) {
            return functionList.map(function(fn2) {
              if (isReferToSelf(fn2)) {
                return referToSelf(fn2.referToSelf.callback);
              }
              if (isReferTo(fn2)) {
                return makeReferTo(fn2.referTo.references, fn2.referTo.callback);
              }
              return fn2;
            });
          }
          function collectResolutions(references, functionList, signatureMap) {
            var resolvedReferences = [];
            var reference;
            var _iterator10 = _createForOfIteratorHelper(references), _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                reference = _step10.value;
                var resolution = signatureMap[reference];
                if (typeof resolution !== "number") {
                  throw new TypeError('No definition for referenced signature "' + reference + '"');
                }
                resolution = functionList[resolution];
                if (typeof resolution !== "function") {
                  return false;
                }
                resolvedReferences.push(resolution);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            return resolvedReferences;
          }
          function resolveReferences(functionList, signatureMap, self2) {
            var resolvedFunctions = clearResolutions(functionList);
            var isResolved = new Array(resolvedFunctions.length).fill(false);
            var leftUnresolved = true;
            while (leftUnresolved) {
              leftUnresolved = false;
              var nothingResolved = true;
              for (var i5 = 0; i5 < resolvedFunctions.length; ++i5) {
                if (isResolved[i5])
                  continue;
                var fn2 = resolvedFunctions[i5];
                if (isReferToSelf(fn2)) {
                  resolvedFunctions[i5] = fn2.referToSelf.callback(self2);
                  resolvedFunctions[i5].referToSelf = fn2.referToSelf;
                  isResolved[i5] = true;
                  nothingResolved = false;
                } else if (isReferTo(fn2)) {
                  var resolvedReferences = collectResolutions(fn2.referTo.references, resolvedFunctions, signatureMap);
                  if (resolvedReferences) {
                    resolvedFunctions[i5] = fn2.referTo.callback.apply(this, resolvedReferences);
                    resolvedFunctions[i5].referTo = fn2.referTo;
                    isResolved[i5] = true;
                    nothingResolved = false;
                  } else {
                    leftUnresolved = true;
                  }
                }
              }
              if (nothingResolved && leftUnresolved) {
                throw new SyntaxError("Circular reference detected in resolving typed.referTo");
              }
            }
            return resolvedFunctions;
          }
          function validateDeprecatedThis(signaturesMap) {
            var deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
            Object.keys(signaturesMap).forEach(function(signature) {
              var fn2 = signaturesMap[signature];
              if (deprecatedThisRegex.test(fn2.toString())) {
                throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
              }
            });
          }
          function createTypedFunction(name307, rawSignaturesMap) {
            typed3.createCount++;
            if (Object.keys(rawSignaturesMap).length === 0) {
              throw new SyntaxError("No signatures provided");
            }
            if (typed3.warnAgainstDeprecatedThis) {
              validateDeprecatedThis(rawSignaturesMap);
            }
            var parsedParams = [];
            var originalFunctions = [];
            var signaturesMap = {};
            var preliminarySignatures = [];
            var signature;
            var _loop2 = function _loop22() {
              if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
                return "continue";
              }
              var params = parseSignature(signature);
              if (!params)
                return "continue";
              parsedParams.forEach(function(pp) {
                if (conflicting(pp, params)) {
                  throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
                }
              });
              parsedParams.push(params);
              var functionIndex = originalFunctions.length;
              originalFunctions.push(rawSignaturesMap[signature]);
              var conversionParams = params.map(expandParam);
              var sp = void 0;
              var _iterator11 = _createForOfIteratorHelper(splitParams(conversionParams)), _step11;
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                  sp = _step11.value;
                  var spName = stringifyParams(sp);
                  preliminarySignatures.push({
                    params: sp,
                    name: spName,
                    fn: functionIndex
                  });
                  if (sp.every(function(p3) {
                    return !p3.hasConversion;
                  })) {
                    signaturesMap[spName] = functionIndex;
                  }
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
            };
            for (signature in rawSignaturesMap) {
              var _ret3 = _loop2();
              if (_ret3 === "continue")
                continue;
            }
            preliminarySignatures.sort(compareSignatures);
            var resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
            var s3;
            for (s3 in signaturesMap) {
              if (Object.prototype.hasOwnProperty.call(signaturesMap, s3)) {
                signaturesMap[s3] = resolvedFunctions[signaturesMap[s3]];
              }
            }
            var signatures = [];
            var internalSignatureMap = /* @__PURE__ */ new Map();
            for (var _i3 = 0, _preliminarySignature = preliminarySignatures; _i3 < _preliminarySignature.length; _i3++) {
              s3 = _preliminarySignature[_i3];
              if (!internalSignatureMap.has(s3.name)) {
                s3.fn = resolvedFunctions[s3.fn];
                signatures.push(s3);
                internalSignatureMap.set(s3.name, s3);
              }
            }
            var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
            for (var i5 = 0; i5 < signatures.length; ++i5) {
              signatures[i5].test = compileTests(signatures[i5].params);
            }
            var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
            for (var _i4 = 0; _i4 < signatures.length; ++_i4) {
              signatures[_i4].implementation = compileArgsPreprocessing(signatures[_i4].params, signatures[_i4].fn);
            }
            var fn0 = ok0 ? signatures[0].implementation : undef;
            var fn1 = ok1 ? signatures[1].implementation : undef;
            var fn2 = ok2 ? signatures[2].implementation : undef;
            var fn3 = ok3 ? signatures[3].implementation : undef;
            var fn4 = ok4 ? signatures[4].implementation : undef;
            var fn5 = ok5 ? signatures[5].implementation : undef;
            var len0 = ok0 ? signatures[0].params.length : -1;
            var len1 = ok1 ? signatures[1].params.length : -1;
            var len2 = ok2 ? signatures[2].params.length : -1;
            var len3 = ok3 ? signatures[3].params.length : -1;
            var len4 = ok4 ? signatures[4].params.length : -1;
            var len5 = ok5 ? signatures[5].params.length : -1;
            var iStart = allOk ? 6 : 0;
            var iEnd = signatures.length;
            var tests = signatures.map(function(s4) {
              return s4.test;
            });
            var fns = signatures.map(function(s4) {
              return s4.implementation;
            });
            var generic = function generic2() {
              for (var _i5 = iStart; _i5 < iEnd; _i5++) {
                if (tests[_i5](arguments)) {
                  return fns[_i5].apply(this, arguments);
                }
              }
              return typed3.onMismatch(name307, arguments, signatures);
            };
            function theTypedFn(arg0, arg1) {
              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(this, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(this, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(this, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(this, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(this, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(this, arguments);
              }
              return generic.apply(this, arguments);
            }
            try {
              Object.defineProperty(theTypedFn, "name", {
                value: name307
              });
            } catch (err) {
            }
            theTypedFn.signatures = signaturesMap;
            theTypedFn._typedFunctionData = {
              signatures,
              signatureMap: internalSignatureMap
            };
            return theTypedFn;
          }
          function _onMismatch(name307, args, signatures) {
            throw createError(name307, args, signatures);
          }
          function initial(arr) {
            return slice(arr, 0, arr.length - 1);
          }
          function last(arr) {
            return arr[arr.length - 1];
          }
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }
          function findInArray(arr, test) {
            for (var i5 = 0; i5 < arr.length; i5++) {
              if (test(arr[i5])) {
                return arr[i5];
              }
            }
            return void 0;
          }
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }
          function referTo() {
            var references = initial(arguments).map(function(s3) {
              return stringifyParams(parseSignature(s3));
            });
            var callback = last(arguments);
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as last argument");
            }
            return makeReferTo(references, callback);
          }
          function makeReferTo(references, callback) {
            return {
              referTo: {
                references,
                callback
              }
            };
          }
          function referToSelf(callback) {
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as first argument");
            }
            return {
              referToSelf: {
                callback
              }
            };
          }
          function isReferTo(objectOrFn) {
            return objectOrFn && _typeof2(objectOrFn.referTo) === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
          }
          function isReferToSelf(objectOrFn) {
            return objectOrFn && _typeof2(objectOrFn.referToSelf) === "object" && typeof objectOrFn.referToSelf.callback === "function";
          }
          function checkName(nameSoFar, newName) {
            if (!nameSoFar) {
              return newName;
            }
            if (newName && newName !== nameSoFar) {
              var err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
              err.data = {
                actual: newName,
                expected: nameSoFar
              };
              throw err;
            }
            return nameSoFar;
          }
          function getObjectName(obj) {
            var name307;
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
                name307 = checkName(name307, obj[key].name);
              }
            }
            return name307;
          }
          function mergeSignatures(dest, source) {
            var key;
            for (key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (key in dest) {
                  if (source[key] !== dest[key]) {
                    var err = new Error('Signature "' + key + '" is defined twice');
                    err.data = {
                      signature: key,
                      sourceFunction: source[key],
                      destFunction: dest[key]
                    };
                    throw err;
                  }
                }
                dest[key] = source[key];
              }
            }
          }
          var saveTyped = typed3;
          typed3 = function typed4(maybeName) {
            var named = typeof maybeName === "string";
            var start = named ? 1 : 0;
            var name307 = named ? maybeName : "";
            var allSignatures = {};
            for (var i5 = start; i5 < arguments.length; ++i5) {
              var item = arguments[i5];
              var theseSignatures = {};
              var thisName = void 0;
              if (typeof item === "function") {
                thisName = item.name;
                if (typeof item.signature === "string") {
                  theseSignatures[item.signature] = item;
                } else if (isTypedFunction(item)) {
                  theseSignatures = item.signatures;
                }
              } else if (isPlainObject2(item)) {
                theseSignatures = item;
                if (!named) {
                  thisName = getObjectName(item);
                }
              }
              if (Object.keys(theseSignatures).length === 0) {
                var err = new TypeError("Argument to 'typed' at index " + i5 + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
                err.data = {
                  index: i5,
                  argument: item
                };
                throw err;
              }
              if (!named) {
                name307 = checkName(name307, thisName);
              }
              mergeSignatures(allSignatures, theseSignatures);
            }
            return createTypedFunction(name307 || "", allSignatures);
          };
          typed3.create = create2;
          typed3.createCount = saveTyped.createCount;
          typed3.onMismatch = _onMismatch;
          typed3.throwMismatchError = _onMismatch;
          typed3.createError = createError;
          typed3.clear = clear;
          typed3.clearConversions = clearConversions;
          typed3.addTypes = addTypes;
          typed3._findType = findType;
          typed3.referTo = referTo;
          typed3.referToSelf = referToSelf;
          typed3.convert = convert;
          typed3.findSignature = findSignature;
          typed3.find = find;
          typed3.isTypedFunction = isTypedFunction;
          typed3.warnAgainstDeprecatedThis = true;
          typed3.addType = function(type, beforeObjectTest) {
            var before = "any";
            if (beforeObjectTest !== false && typeMap.has("Object")) {
              before = "Object";
            }
            typed3.addTypes([type], before);
          };
          function _validateConversion(conversion) {
            if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
              throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
            }
            if (conversion.to === conversion.from) {
              throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
            }
          }
          typed3.addConversion = function(conversion) {
            _validateConversion(conversion);
            var to2 = findType(conversion.to);
            if (to2.conversionsTo.every(function(other) {
              return other.from !== conversion.from;
            })) {
              to2.conversionsTo.push({
                from: conversion.from,
                convert: conversion.convert,
                index: nConversions++
              });
            } else {
              throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to2.name + '"');
            }
          };
          typed3.addConversions = function(conversions) {
            conversions.forEach(typed3.addConversion);
          };
          typed3.removeConversion = function(conversion) {
            _validateConversion(conversion);
            var to2 = findType(conversion.to);
            var existingConversion = findInArray(to2.conversionsTo, function(c3) {
              return c3.from === conversion.from;
            });
            if (!existingConversion) {
              throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
            }
            if (existingConversion.convert !== conversion.convert) {
              throw new Error("Conversion to remove does not match existing conversion");
            }
            var index2 = to2.conversionsTo.indexOf(existingConversion);
            to2.conversionsTo.splice(index2, 1);
          };
          typed3.resolve = function(tf, argList) {
            if (!isTypedFunction(tf)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            var sigs = tf._typedFunctionData.signatures;
            for (var i5 = 0; i5 < sigs.length; ++i5) {
              if (sigs[i5].test(argList)) {
                return sigs[i5];
              }
            }
            return null;
          };
          return typed3;
        }
        var typedFunction2 = create2();
        return typedFunction2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  function formatNumberToBase(n3, base, size2) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n3 > 2 ** (size2 - 1) - 1 || n3 < -(2 ** (size2 - 1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!isInteger(n3)) {
        throw new Error("Value must be an integer");
      }
      if (n3 < 0) {
        n3 = n3 + 2 ** size2;
      }
      suffix = "i".concat(size2);
    }
    var sign4 = "";
    if (n3 < 0) {
      n3 = -n3;
      sign4 = "-";
    }
    return "".concat(sign4).concat(prefix).concat(n3.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options) {
      if (options.notation) {
        notation = options.notation;
      }
      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e6 = arguments[4];
          return digits2 !== "." ? digits2 + e6 : e6;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign4 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot2 = digits2.indexOf(".");
    exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros3) {
      exponent -= zeros3.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d3) {
      return parseInt(d3);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign4,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e6 = rounded.exponent;
    var c3 = rounded.coefficients;
    var newExp = e6 % 3 === 0 ? e6 : e6 < 0 ? e6 - 3 - e6 % 3 : e6 - e6 % 3;
    if (isNumber(precision)) {
      while (precision > c3.length || e6 - newExp + 1 > c3.length) {
        c3.push(0);
      }
    } else {
      var missingZeros = Math.abs(e6 - newExp) - (c3.length - 1);
      for (var i5 = 0; i5 < missingZeros; i5++) {
        c3.push(0);
      }
    }
    var expDiff = Math.abs(e6 - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c3.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c3.slice(0, decimalIdx).join("") + decimalVal + "e" + (e6 >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c3 = rounded.coefficients;
    var p3 = rounded.exponent + 1;
    var pp = p3 + (precision || 0);
    if (c3.length < pp) {
      c3 = c3.concat(zeros(pp - c3.length));
    }
    if (p3 < 0) {
      c3 = zeros(-p3 + 1).concat(c3);
      p3 = 1;
    }
    if (p3 < c3.length) {
      c3.splice(p3, 0, p3 === 0 ? "0." : ".");
    }
    return rounded.sign + c3.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c3 = rounded.coefficients;
    var e6 = rounded.exponent;
    if (c3.length < precision) {
      c3 = c3.concat(zeros(precision - c3.length));
    }
    var first = c3.shift();
    return rounded.sign + first + (c3.length > 0 ? "." + c3.join("") : "") + "e" + (e6 >= 0 ? "+" : "") + e6;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c3 = rounded.coefficients;
      var e6 = rounded.exponent;
      if (c3.length < precision) {
        c3 = c3.concat(zeros(precision - c3.length));
      }
      c3 = c3.concat(zeros(e6 - c3.length + 1 + (c3.length < precision ? precision - c3.length : 0)));
      c3 = zeros(-e6).concat(c3);
      var dot2 = e6 > 0 ? e6 : 0;
      if (dot2 < c3.length - 1) {
        c3.splice(dot2 + 1, 0, ".");
      }
      return rounded.sign + c3.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c3 = rounded.coefficients;
    while (precision <= 0) {
      c3.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c3.length > precision) {
      var removed = c3.splice(precision, c3.length - precision);
      if (removed[0] >= 5) {
        var i5 = precision - 1;
        c3[i5]++;
        while (c3[i5] === 10) {
          c3.pop();
          if (i5 === 0) {
            c3.unshift(0);
            rounded.exponent++;
            i5++;
          }
          i5--;
          c3[i5]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i5 = 0; i5 < length; i5++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  function nearlyEqual(x4, y3, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x4 === y3;
    }
    if (x4 === y3) {
      return true;
    }
    if (isNaN(x4) || isNaN(y3)) {
      return false;
    }
    if (isFinite(x4) && isFinite(y3)) {
      var diff2 = Math.abs(x4 - y3);
      if (diff2 < DBL_EPSILON) {
        return true;
      } else {
        return diff2 <= Math.max(Math.abs(x4), Math.abs(y3)) * epsilon;
      }
    }
    return false;
  }
  function copysign(x4, y3) {
    var signx = x4 > 0 ? true : x4 < 0 ? false : 1 / x4 === Infinity;
    var signy = y3 > 0 ? true : y3 < 0 ? false : 1 / y3 === Infinity;
    return signx ^ signy ? -x4 : x4;
  }
  var sign, log2, log10, log1p, cbrt, expm1, DBL_EPSILON, acosh, asinh, atanh, cosh, sinh, tanh;
  var init_number = __esm({
    "node_modules/mathjs/lib/esm/utils/number.js"() {
      init_is();
      sign = Math.sign || function(x4) {
        if (x4 > 0) {
          return 1;
        } else if (x4 < 0) {
          return -1;
        } else {
          return 0;
        }
      };
      log2 = Math.log2 || function log22(x4) {
        return Math.log(x4) / Math.LN2;
      };
      log10 = Math.log10 || function log102(x4) {
        return Math.log(x4) / Math.LN10;
      };
      log1p = Math.log1p || function(x4) {
        return Math.log(x4 + 1);
      };
      cbrt = Math.cbrt || function cbrt2(x4) {
        if (x4 === 0) {
          return x4;
        }
        var negate = x4 < 0;
        var result;
        if (negate) {
          x4 = -x4;
        }
        if (isFinite(x4)) {
          result = Math.exp(Math.log(x4) / 3);
          result = (x4 / (result * result) + 2 * result) / 3;
        } else {
          result = x4;
        }
        return negate ? -result : result;
      };
      expm1 = Math.expm1 || function expm12(x4) {
        return x4 >= 2e-4 || x4 <= -2e-4 ? Math.exp(x4) - 1 : x4 + x4 * x4 / 2 + x4 * x4 * x4 / 6;
      };
      DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
      acosh = Math.acosh || function(x4) {
        return Math.log(Math.sqrt(x4 * x4 - 1) + x4);
      };
      asinh = Math.asinh || function(x4) {
        return Math.log(Math.sqrt(x4 * x4 + 1) + x4);
      };
      atanh = Math.atanh || function(x4) {
        return Math.log((1 + x4) / (1 - x4)) / 2;
      };
      cosh = Math.cosh || function(x4) {
        return (Math.exp(x4) + Math.exp(-x4)) / 2;
      };
      sinh = Math.sinh || function(x4) {
        return (Math.exp(x4) - Math.exp(-x4)) / 2;
      };
      tanh = Math.tanh || function(x4) {
        var e6 = Math.exp(2 * x4);
        return (e6 - 1) / (e6 + 1);
      };
    }
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n3, base, size2) {
    var BigNumberCtor = n3.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n3.greaterThan(big2.pow(size2 - 1).sub(1)) || n3.lessThan(big2.pow(size2 - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!n3.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n3.lessThan(0)) {
        n3 = n3.add(big2.pow(size2));
      }
      suffix = "i".concat(size2);
    }
    switch (base) {
      case 2:
        return "".concat(n3.toBinary()).concat(suffix);
      case 8:
        return "".concat(n3.toOctal()).concat(suffix);
      case 16:
        return "".concat(n3.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (options.notation) {
        notation = options.notation;
      }
      if (typeof options === "number") {
        precision = options;
      } else if (options.precision !== void 0) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
        var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
        if (value.isZero())
          return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp3 = rounded.e;
        if (exp3 >= lowerExp && exp3 < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e6 = arguments[4];
          return digits2 !== "." ? digits2 + e6 : e6;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e6 = value.e;
    var newExp = e6 % 3 === 0 ? e6 : e6 < 0 ? e6 - 3 - e6 % 3 : e6 - e6 % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf("e") !== -1) {
      var BigNumber2 = value.constructor;
      valueStr = new BigNumber2(valueStr).toFixed();
    }
    return valueStr + "e" + (e6 >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }
  var init_formatter = __esm({
    "node_modules/mathjs/lib/esm/utils/bignumber/formatter.js"() {
      init_number();
    }
  });

  // node_modules/mathjs/lib/esm/utils/string.js
  function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
  }
  function format3(value, options) {
    var result = _format(value, options);
    if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + "...";
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return '"' + value + '"';
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return '"' + key + '": ' + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function stringify(value) {
    var text = String(value);
    var escaped = "";
    var i5 = 0;
    while (i5 < text.length) {
      var c3 = text.charAt(i5);
      if (c3 === "\\") {
        escaped += c3;
        i5++;
        c3 = text.charAt(i5);
        if (c3 === "" || '"\\/bfnrtu'.indexOf(c3) === -1) {
          escaped += "\\";
        }
        escaped += c3;
      } else if (c3 === '"') {
        escaped += '\\"';
      } else {
        escaped += c3;
      }
      i5++;
    }
    return '"' + escaped + '"';
  }
  function escape(value) {
    var text = String(value);
    text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return text;
  }
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i5 = 0; i5 < len; i5++) {
        if (i5 !== 0) {
          str += ", ";
        }
        str += formatArray(array[i5], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }
  function compareText(x4, y3) {
    if (!isString(x4)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x4) + ", index: 0)");
    }
    if (!isString(y3)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y3) + ", index: 1)");
    }
    return x4 === y3 ? 0 : x4 > y3 ? 1 : -1;
  }
  var init_string = __esm({
    "node_modules/mathjs/lib/esm/utils/string.js"() {
      init_is();
      init_number();
      init_formatter();
    }
  });

  // node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  var init_DimensionError = __esm({
    "node_modules/mathjs/lib/esm/error/DimensionError.js"() {
      DimensionError.prototype = new RangeError();
      DimensionError.prototype.constructor = RangeError;
      DimensionError.prototype.name = "DimensionError";
      DimensionError.prototype.isDimensionError = true;
    }
  });

  // node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index2, min3, max3) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index2;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min3;
    } else {
      this.min = min3;
      this.max = max3;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  var init_IndexError = __esm({
    "node_modules/mathjs/lib/esm/error/IndexError.js"() {
      IndexError.prototype = new RangeError();
      IndexError.prototype.constructor = RangeError;
      IndexError.prototype.name = "IndexError";
      IndexError.prototype.isIndexError = true;
    }
  });

  // node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x4) {
    var s3 = [];
    while (Array.isArray(x4)) {
      s3.push(x4.length);
      x4 = x4[0];
    }
    return s3;
  }
  function _validate(array, size2, dim) {
    var i5;
    var len = array.length;
    if (len !== size2[dim]) {
      throw new DimensionError(len, size2[dim]);
    }
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i5 = 0; i5 < len; i5++) {
        var child = array[i5];
        if (!Array.isArray(child)) {
          throw new DimensionError(size2.length - 1, size2.length, "<");
        }
        _validate(array[i5], size2, dimNext);
      }
    } else {
      for (i5 = 0; i5 < len; i5++) {
        if (Array.isArray(array[i5])) {
          throw new DimensionError(size2.length + 1, size2.length, ">");
        }
      }
    }
  }
  function validate(array, size2) {
    var isScalar = size2.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size2, 0);
    }
  }
  function validateIndexSourceSize(value, index2) {
    var valueSize = value.isMatrix ? value._size : arraySize(value);
    var sourceSize = index2._sourceSize;
    sourceSize.forEach((sourceDim, i5) => {
      if (sourceDim !== null && sourceDim !== valueSize[i5]) {
        throw new DimensionError(sourceDim, valueSize[i5]);
      }
    });
  }
  function validateIndex(index2, length) {
    if (index2 !== void 0) {
      if (!isNumber(index2) || !isInteger(index2)) {
        throw new TypeError("Index must be an integer (value: " + index2 + ")");
      }
      if (index2 < 0 || typeof length === "number" && index2 >= length) {
        throw new IndexError(index2, length);
      }
    }
  }
  function isEmptyIndex(index2) {
    for (var i5 = 0; i5 < index2._dimensions.length; ++i5) {
      var dimension = index2._dimensions[i5];
      if (dimension._data && isArray(dimension._data)) {
        if (dimension._size[0] === 0) {
          return true;
        }
      } else if (dimension.isRange) {
        if (dimension.start === dimension.end) {
          return true;
        }
      } else if (isString(dimension)) {
        if (dimension.length === 0) {
          return true;
        }
      }
    }
    return false;
  }
  function resize(array, size2, defaultValue) {
    if (!Array.isArray(size2)) {
      throw new TypeError("Array expected");
    }
    if (size2.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size2.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
      }
    });
    if (isNumber(array) || isBigNumber(array)) {
      array = [array];
    }
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size2, 0, _defaultValue);
    return array;
  }
  function _resize(array, size2, dim, defaultValue) {
    var i5;
    var elem;
    var oldLen = array.length;
    var newLen = size2[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i5 = 0; i5 < minLen; i5++) {
        elem = array[i5];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i5] = elem;
        }
        _resize(elem, size2, dimNext, defaultValue);
      }
      for (i5 = minLen; i5 < newLen; i5++) {
        elem = [];
        array[i5] = elem;
        _resize(elem, size2, dimNext, defaultValue);
      }
    } else {
      for (i5 = 0; i5 < minLen; i5++) {
        while (Array.isArray(array[i5])) {
          array[i5] = array[i5][0];
        }
      }
      for (i5 = minLen; i5 < newLen; i5++) {
        array[i5] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e6) {
      if (e6 instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e6;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size2 = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size2;
      for (var i5 = 0; i5 < length; i5++) {
        tmpArray2.push(tmpArray.slice(i5 * size2, (i5 + 1) * size2));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function squeeze(array, size2) {
    var s3 = size2 || arraySize(array);
    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s3.shift();
    }
    var dims = s3.length;
    while (s3[dims - 1] === 1) {
      dims--;
    }
    if (dims < s3.length) {
      array = _squeeze(array, dims, 0);
      s3.length = dims;
    }
    return array;
  }
  function _squeeze(array, dims, dim) {
    var i5, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i5 = 0, ii = array.length; i5 < ii; i5++) {
        array[i5] = _squeeze(array[i5], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  function unsqueeze(array, dims, outer, size2) {
    var s3 = size2 || arraySize(array);
    if (outer) {
      for (var i5 = 0; i5 < outer; i5++) {
        array = [array];
        s3.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s3.length < dims) {
      s3.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i5, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i5 = 0, ii = array.length; i5 < ii; i5++) {
        array[i5] = _unsqueeze(array[i5], dims, next);
      }
    } else {
      for (var d3 = dim; d3 < dims; d3++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function map(array, callback) {
    return Array.prototype.map.call(array, callback);
  }
  function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
  }
  function filter(array, callback) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, callback);
  }
  function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
  }
  function join(array, separator) {
    return Array.prototype.join.call(array, separator);
  }
  function identify(a3) {
    if (!Array.isArray(a3)) {
      throw new TypeError("Array input expected");
    }
    if (a3.length === 0) {
      return a3;
    }
    var b3 = [];
    var count2 = 0;
    b3[0] = {
      value: a3[0],
      identifier: 0
    };
    for (var i5 = 1; i5 < a3.length; i5++) {
      if (a3[i5] === a3[i5 - 1]) {
        count2++;
      } else {
        count2 = 0;
      }
      b3.push({
        value: a3[i5],
        identifier: count2
      });
    }
    return b3;
  }
  function generalize(a3) {
    if (!Array.isArray(a3)) {
      throw new TypeError("Array input expected");
    }
    if (a3.length === 0) {
      return a3;
    }
    var b3 = [];
    for (var i5 = 0; i5 < a3.length; i5++) {
      b3.push(a3[i5].value);
    }
    return b3;
  }
  function getArrayDataType(array, typeOf3) {
    var type;
    var length = 0;
    for (var i5 = 0; i5 < array.length; i5++) {
      var item = array[i5];
      var _isArray = Array.isArray(item);
      if (i5 === 0 && _isArray) {
        length = item.length;
      }
      if (_isArray && item.length !== length) {
        return void 0;
      }
      var itemType = _isArray ? getArrayDataType(item, typeOf3) : typeOf3(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }
  function concatRecursive(a3, b3, concatDim, dim) {
    if (dim < concatDim) {
      if (a3.length !== b3.length) {
        throw new DimensionError(a3.length, b3.length);
      }
      var c3 = [];
      for (var i5 = 0; i5 < a3.length; i5++) {
        c3[i5] = concatRecursive(a3[i5], b3[i5], concatDim, dim + 1);
      }
      return c3;
    } else {
      return a3.concat(b3);
    }
  }
  function concat() {
    var arrays = Array.prototype.slice.call(arguments, 0, -1);
    var concatDim = Array.prototype.slice.call(arguments, -1);
    if (arrays.length === 1) {
      return arrays[0];
    }
    if (arrays.length > 1) {
      return arrays.slice(1).reduce(function(A4, B4) {
        return concatRecursive(A4, B4, concatDim, 0);
      }, arrays[0]);
    } else {
      throw new Error("Wrong number of arguments in function concat");
    }
  }
  function broadcastSizes() {
    for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
      sizes[_key] = arguments[_key];
    }
    var dimensions = sizes.map((s3) => s3.length);
    var N3 = Math.max(...dimensions);
    var sizeMax = new Array(N3).fill(null);
    for (var i5 = 0; i5 < sizes.length; i5++) {
      var size2 = sizes[i5];
      var dim = dimensions[i5];
      for (var j4 = 0; j4 < dim; j4++) {
        var n3 = N3 - dim + j4;
        if (size2[j4] > sizeMax[n3]) {
          sizeMax[n3] = size2[j4];
        }
      }
    }
    for (var _i = 0; _i < sizes.length; _i++) {
      checkBroadcastingRules(sizes[_i], sizeMax);
    }
    return sizeMax;
  }
  function checkBroadcastingRules(size2, toSize) {
    var N3 = toSize.length;
    var dim = size2.length;
    for (var j4 = 0; j4 < dim; j4++) {
      var n3 = N3 - dim + j4;
      if (size2[j4] < toSize[n3] && size2[j4] > 1 || size2[j4] > toSize[n3]) {
        throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j4], " to size ").concat(toSize[n3]));
      }
    }
  }
  function broadcastTo(array, toSize) {
    var Asize = arraySize(array);
    if (deepStrictEqual(Asize, toSize)) {
      return array;
    }
    checkBroadcastingRules(Asize, toSize);
    var broadcastedSize = broadcastSizes(Asize, toSize);
    var N3 = broadcastedSize.length;
    var paddedSize = [...Array(N3 - Asize.length).fill(1), ...Asize];
    var A4 = clone2(array);
    if (Asize.length < N3) {
      A4 = reshape(A4, paddedSize);
      Asize = arraySize(A4);
    }
    for (var dim = 0; dim < N3; dim++) {
      if (Asize[dim] < broadcastedSize[dim]) {
        A4 = stretch(A4, broadcastedSize[dim], dim);
        Asize = arraySize(A4);
      }
    }
    return A4;
  }
  function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
  function clone2(array) {
    return _extends([], array);
  }
  var init_array = __esm({
    "node_modules/mathjs/lib/esm/utils/array.js"() {
      init_extends();
      init_number();
      init_is();
      init_string();
      init_DimensionError();
      init_IndexError();
      init_object();
    }
  });

  // node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name307, dependencies307, create2, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies307.map(stripOptionalNotation));
      assertDependencies(name307, dependencies307, scope);
      return create2(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name307;
    assertAndCreate.dependencies = dependencies307.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function assertDependencies(name307, dependencies307, scope) {
    var allDefined = dependencies307.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies307.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name307, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d3) => '"'.concat(d3, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }
  var init_factory = __esm({
    "node_modules/mathjs/lib/esm/utils/factory.js"() {
      init_object();
    }
  });

  // node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty2(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function getSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
      throw new Error('No access to method "' + method + '"');
    }
    return object[method];
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty2(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty2(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties, safeNativeMethods;
  var init_customs = __esm({
    "node_modules/mathjs/lib/esm/utils/customs.js"() {
      init_object();
      safeNativeProperties = {
        length: true,
        name: true
      };
      safeNativeMethods = {
        toString: true,
        valueOf: true,
        toLocaleString: true
      };
    }
  });

  // node_modules/mathjs/lib/esm/utils/map.js
  function createEmptyMap() {
    return /* @__PURE__ */ new Map();
  }
  function createMap(mapOrObject) {
    if (!mapOrObject) {
      return createEmptyMap();
    }
    if (isMap(mapOrObject)) {
      return mapOrObject;
    }
    if (isObject(mapOrObject)) {
      return new ObjectWrappingMap(mapOrObject);
    }
    throw new Error("createMap can create maps from objects or Maps");
  }
  function toObject(map3) {
    if (map3 instanceof ObjectWrappingMap) {
      return map3.wrappedObject;
    }
    var object = {};
    for (var key of map3.keys()) {
      var value = map3.get(key);
      setSafeProperty(object, key, value);
    }
    return object;
  }
  function isMap(object) {
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
  }
  function assign(map3) {
    for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      objects[_key - 1] = arguments[_key];
    }
    for (var args of objects) {
      if (!args) {
        continue;
      }
      if (isMap(args)) {
        for (var key of args.keys()) {
          map3.set(key, args.get(key));
        }
      } else if (isObject(args)) {
        for (var _key2 of Object.keys(args)) {
          map3.set(_key2, args[_key2]);
        }
      }
    }
    return map3;
  }
  var ObjectWrappingMap;
  var init_map = __esm({
    "node_modules/mathjs/lib/esm/utils/map.js"() {
      init_customs();
      init_is();
      ObjectWrappingMap = class {
        constructor(object) {
          this.wrappedObject = object;
        }
        keys() {
          return Object.keys(this.wrappedObject);
        }
        get(key) {
          return getSafeProperty(this.wrappedObject, key);
        }
        set(key, value) {
          setSafeProperty(this.wrappedObject, key, value);
          return this;
        }
        has(key) {
          return hasSafeProperty(this.wrappedObject, key);
        }
      };
    }
  });

  // node_modules/mathjs/lib/esm/core/function/typed.js
  function throwNoBignumber(x4) {
    throw new Error("Cannot convert value ".concat(x4, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x4) {
    throw new Error("Cannot convert value ".concat(x4, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x4) {
    throw new Error("Cannot convert value ".concat(x4, " into a Fraction, no class 'Fraction' provided."));
  }
  var import_typed_function, _createTyped2, dependencies, createTyped;
  var init_typed = __esm({
    "node_modules/mathjs/lib/esm/core/function/typed.js"() {
      init_is();
      import_typed_function = __toESM(require_typed_function(), 1);
      init_number();
      init_factory();
      init_map();
      _createTyped2 = function _createTyped() {
        _createTyped2 = import_typed_function.default.create;
        return import_typed_function.default;
      };
      dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
      createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
        var {
          BigNumber: BigNumber2,
          Complex: Complex3,
          DenseMatrix: DenseMatrix2,
          Fraction: Fraction3
        } = _ref;
        var typed3 = _createTyped2();
        typed3.clear();
        typed3.addTypes([
          {
            name: "number",
            test: isNumber
          },
          {
            name: "Complex",
            test: isComplex
          },
          {
            name: "BigNumber",
            test: isBigNumber
          },
          {
            name: "Fraction",
            test: isFraction
          },
          {
            name: "Unit",
            test: isUnit
          },
          // The following type matches a valid variable name, i.e., an alphanumeric
          // string starting with an alphabetic character. It is used (at least)
          // in the definition of the derivative() function, as the argument telling
          // what to differentiate over must (currently) be a variable.
          {
            name: "identifier",
            test: (s3) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s3)
          },
          {
            name: "string",
            test: isString
          },
          {
            name: "Chain",
            test: isChain
          },
          {
            name: "Array",
            test: isArray
          },
          {
            name: "Matrix",
            test: isMatrix
          },
          {
            name: "DenseMatrix",
            test: isDenseMatrix
          },
          {
            name: "SparseMatrix",
            test: isSparseMatrix
          },
          {
            name: "Range",
            test: isRange
          },
          {
            name: "Index",
            test: isIndex
          },
          {
            name: "boolean",
            test: isBoolean
          },
          {
            name: "ResultSet",
            test: isResultSet
          },
          {
            name: "Help",
            test: isHelp
          },
          {
            name: "function",
            test: isFunction
          },
          {
            name: "Date",
            test: isDate
          },
          {
            name: "RegExp",
            test: isRegExp
          },
          {
            name: "null",
            test: isNull
          },
          {
            name: "undefined",
            test: isUndefined
          },
          {
            name: "AccessorNode",
            test: isAccessorNode
          },
          {
            name: "ArrayNode",
            test: isArrayNode
          },
          {
            name: "AssignmentNode",
            test: isAssignmentNode
          },
          {
            name: "BlockNode",
            test: isBlockNode
          },
          {
            name: "ConditionalNode",
            test: isConditionalNode
          },
          {
            name: "ConstantNode",
            test: isConstantNode
          },
          {
            name: "FunctionNode",
            test: isFunctionNode
          },
          {
            name: "FunctionAssignmentNode",
            test: isFunctionAssignmentNode
          },
          {
            name: "IndexNode",
            test: isIndexNode
          },
          {
            name: "Node",
            test: isNode
          },
          {
            name: "ObjectNode",
            test: isObjectNode
          },
          {
            name: "OperatorNode",
            test: isOperatorNode
          },
          {
            name: "ParenthesisNode",
            test: isParenthesisNode
          },
          {
            name: "RangeNode",
            test: isRangeNode
          },
          {
            name: "RelationalNode",
            test: isRelationalNode
          },
          {
            name: "SymbolNode",
            test: isSymbolNode
          },
          {
            name: "Map",
            test: isMap
          },
          {
            name: "Object",
            test: isObject
          }
          // order 'Object' last, it matches on other classes too
        ]);
        typed3.addConversions([{
          from: "number",
          to: "BigNumber",
          convert: function convert(x4) {
            if (!BigNumber2) {
              throwNoBignumber(x4);
            }
            if (digits(x4) > 15) {
              throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x4 + "). Use function bignumber(x) to convert to BigNumber.");
            }
            return new BigNumber2(x4);
          }
        }, {
          from: "number",
          to: "Complex",
          convert: function convert(x4) {
            if (!Complex3) {
              throwNoComplex(x4);
            }
            return new Complex3(x4, 0);
          }
        }, {
          from: "BigNumber",
          to: "Complex",
          convert: function convert(x4) {
            if (!Complex3) {
              throwNoComplex(x4);
            }
            return new Complex3(x4.toNumber(), 0);
          }
        }, {
          from: "Fraction",
          to: "BigNumber",
          convert: function convert(x4) {
            throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
          }
        }, {
          from: "Fraction",
          to: "Complex",
          convert: function convert(x4) {
            if (!Complex3) {
              throwNoComplex(x4);
            }
            return new Complex3(x4.valueOf(), 0);
          }
        }, {
          from: "number",
          to: "Fraction",
          convert: function convert(x4) {
            if (!Fraction3) {
              throwNoFraction(x4);
            }
            var f3 = new Fraction3(x4);
            if (f3.valueOf() !== x4) {
              throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x4 + "). Use function fraction(x) to convert to Fraction.");
            }
            return f3;
          }
        }, {
          // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
          //  from: 'Fraction',
          //  to: 'number',
          //  convert: function (x) {
          //    return x.valueOf()
          //  }
          // }, {
          from: "string",
          to: "number",
          convert: function convert(x4) {
            var n3 = Number(x4);
            if (isNaN(n3)) {
              throw new Error('Cannot convert "' + x4 + '" to a number');
            }
            return n3;
          }
        }, {
          from: "string",
          to: "BigNumber",
          convert: function convert(x4) {
            if (!BigNumber2) {
              throwNoBignumber(x4);
            }
            try {
              return new BigNumber2(x4);
            } catch (err) {
              throw new Error('Cannot convert "' + x4 + '" to BigNumber');
            }
          }
        }, {
          from: "string",
          to: "Fraction",
          convert: function convert(x4) {
            if (!Fraction3) {
              throwNoFraction(x4);
            }
            try {
              return new Fraction3(x4);
            } catch (err) {
              throw new Error('Cannot convert "' + x4 + '" to Fraction');
            }
          }
        }, {
          from: "string",
          to: "Complex",
          convert: function convert(x4) {
            if (!Complex3) {
              throwNoComplex(x4);
            }
            try {
              return new Complex3(x4);
            } catch (err) {
              throw new Error('Cannot convert "' + x4 + '" to Complex');
            }
          }
        }, {
          from: "boolean",
          to: "number",
          convert: function convert(x4) {
            return +x4;
          }
        }, {
          from: "boolean",
          to: "BigNumber",
          convert: function convert(x4) {
            if (!BigNumber2) {
              throwNoBignumber(x4);
            }
            return new BigNumber2(+x4);
          }
        }, {
          from: "boolean",
          to: "Fraction",
          convert: function convert(x4) {
            if (!Fraction3) {
              throwNoFraction(x4);
            }
            return new Fraction3(+x4);
          }
        }, {
          from: "boolean",
          to: "string",
          convert: function convert(x4) {
            return String(x4);
          }
        }, {
          from: "Array",
          to: "Matrix",
          convert: function convert(array) {
            if (!DenseMatrix2) {
              throwNoMatrix();
            }
            return new DenseMatrix2(array);
          }
        }, {
          from: "Matrix",
          to: "Array",
          convert: function convert(matrix2) {
            return matrix2.valueOf();
          }
        }]);
        typed3.onMismatch = (name307, args, signatures) => {
          var usualError = typed3.createError(name307, args, signatures);
          if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
          signatures.some((sig) => !sig.params.includes(","))) {
            var err = new TypeError("Function '".concat(name307, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name307, ")'."));
            err.data = usualError.data;
            throw err;
          }
          throw usualError;
        };
        typed3.onMismatch = (name307, args, signatures) => {
          var usualError = typed3.createError(name307, args, signatures);
          if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
          signatures.some((sig) => !sig.params.includes(","))) {
            var err = new TypeError("Function '".concat(name307, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name307, ")'."));
            err.data = usualError.data;
            throw err;
          }
          throw usualError;
        };
        return typed3;
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
  var name, dependencies2, createResultSet;
  var init_ResultSet = __esm({
    "node_modules/mathjs/lib/esm/type/resultset/ResultSet.js"() {
      init_factory();
      name = "ResultSet";
      dependencies2 = [];
      createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
        function ResultSet2(entries) {
          if (!(this instanceof ResultSet2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this.entries = entries || [];
        }
        ResultSet2.prototype.type = "ResultSet";
        ResultSet2.prototype.isResultSet = true;
        ResultSet2.prototype.valueOf = function() {
          return this.entries;
        };
        ResultSet2.prototype.toString = function() {
          return "[" + this.entries.join(", ") + "]";
        };
        ResultSet2.prototype.toJSON = function() {
          return {
            mathjs: "ResultSet",
            entries: this.entries
          };
        };
        ResultSet2.fromJSON = function(json) {
          return new ResultSet2(json.entries);
        };
        return ResultSet2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/decimal.js/decimal.mjs
  function digitsToString(d3) {
    var i5, k4, ws, indexOfLastWord = d3.length - 1, str = "", w4 = d3[0];
    if (indexOfLastWord > 0) {
      str += w4;
      for (i5 = 1; i5 < indexOfLastWord; i5++) {
        ws = d3[i5] + "";
        k4 = LOG_BASE - ws.length;
        if (k4)
          str += getZeroString(k4);
        str += ws;
      }
      w4 = d3[i5];
      ws = w4 + "";
      k4 = LOG_BASE - ws.length;
      if (k4)
        str += getZeroString(k4);
    } else if (w4 === 0) {
      return "0";
    }
    for (; w4 % 10 === 0; )
      w4 /= 10;
    return str + w4;
  }
  function checkInt32(i5, min3, max3) {
    if (i5 !== ~~i5 || i5 < min3 || i5 > max3) {
      throw Error(invalidArgument + i5);
    }
  }
  function checkRoundingDigits(d3, i5, rm, repeating) {
    var di, k4, r3, rd;
    for (k4 = d3[0]; k4 >= 10; k4 /= 10)
      --i5;
    if (--i5 < 0) {
      i5 += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i5 + 1) / LOG_BASE);
      i5 %= LOG_BASE;
    }
    k4 = mathpow(10, LOG_BASE - i5);
    rd = d3[di] % k4 | 0;
    if (repeating == null) {
      if (i5 < 3) {
        if (i5 == 0)
          rd = rd / 100 | 0;
        else if (i5 == 1)
          rd = rd / 10 | 0;
        r3 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r3 = (rm < 4 && rd + 1 == k4 || rm > 3 && rd + 1 == k4 / 2) && (d3[di + 1] / k4 / 100 | 0) == mathpow(10, i5 - 2) - 1 || (rd == k4 / 2 || rd == 0) && (d3[di + 1] / k4 / 100 | 0) == 0;
      }
    } else {
      if (i5 < 4) {
        if (i5 == 0)
          rd = rd / 1e3 | 0;
        else if (i5 == 1)
          rd = rd / 100 | 0;
        else if (i5 == 2)
          rd = rd / 10 | 0;
        r3 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r3 = ((repeating || rm < 4) && rd + 1 == k4 || !repeating && rm > 3 && rd + 1 == k4 / 2) && (d3[di + 1] / k4 / 1e3 | 0) == mathpow(10, i5 - 3) - 1;
      }
    }
    return r3;
  }
  function convertBase(str, baseIn, baseOut) {
    var j4, arr = [0], arrL, i5 = 0, strL = str.length;
    for (; i5 < strL; ) {
      for (arrL = arr.length; arrL--; )
        arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i5++));
      for (j4 = 0; j4 < arr.length; j4++) {
        if (arr[j4] > baseOut - 1) {
          if (arr[j4 + 1] === void 0)
            arr[j4 + 1] = 0;
          arr[j4 + 1] += arr[j4] / baseOut | 0;
          arr[j4] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x4) {
    var k4, len, y3;
    if (x4.isZero())
      return x4;
    len = x4.d.length;
    if (len < 32) {
      k4 = Math.ceil(len / 3);
      y3 = (1 / tinyPow(4, k4)).toString();
    } else {
      k4 = 16;
      y3 = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k4;
    x4 = taylorSeries(Ctor, 1, x4.times(y3), new Ctor(1));
    for (var i5 = k4; i5--; ) {
      var cos2x = x4.times(x4);
      x4 = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k4;
    return x4;
  }
  function finalise(x4, sd, rm, isTruncated) {
    var digits2, i5, j4, k4, rd, roundUp, w4, xd, xdi, Ctor = x4.constructor;
    out:
      if (sd != null) {
        xd = x4.d;
        if (!xd)
          return x4;
        for (digits2 = 1, k4 = xd[0]; k4 >= 10; k4 /= 10)
          digits2++;
        i5 = sd - digits2;
        if (i5 < 0) {
          i5 += LOG_BASE;
          j4 = sd;
          w4 = xd[xdi = 0];
          rd = w4 / mathpow(10, digits2 - j4 - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i5 + 1) / LOG_BASE);
          k4 = xd.length;
          if (xdi >= k4) {
            if (isTruncated) {
              for (; k4++ <= xdi; )
                xd.push(0);
              w4 = rd = 0;
              digits2 = 1;
              i5 %= LOG_BASE;
              j4 = i5 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w4 = k4 = xd[xdi];
            for (digits2 = 1; k4 >= 10; k4 /= 10)
              digits2++;
            i5 %= LOG_BASE;
            j4 = i5 - LOG_BASE + digits2;
            rd = j4 < 0 ? 0 : w4 / mathpow(10, digits2 - j4 - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j4 < 0 ? w4 : w4 % mathpow(10, digits2 - j4 - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x4.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i5 > 0 ? j4 > 0 ? w4 / mathpow(10, digits2 - j4) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x4.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x4.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x4.e = -sd || 0;
          } else {
            xd[0] = x4.e = 0;
          }
          return x4;
        }
        if (i5 == 0) {
          xd.length = xdi;
          k4 = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k4 = mathpow(10, LOG_BASE - i5);
          xd[xdi] = j4 > 0 ? (w4 / mathpow(10, digits2 - j4) % mathpow(10, j4) | 0) * k4 : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i5 = 1, j4 = xd[0]; j4 >= 10; j4 /= 10)
                i5++;
              j4 = xd[0] += k4;
              for (k4 = 1; j4 >= 10; j4 /= 10)
                k4++;
              if (i5 != k4) {
                x4.e++;
                if (xd[0] == BASE)
                  xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k4;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k4 = 1;
            }
          }
        }
        for (i5 = xd.length; xd[--i5] === 0; )
          xd.pop();
      }
    if (external) {
      if (x4.e > Ctor.maxE) {
        x4.d = null;
        x4.e = NaN;
      } else if (x4.e < Ctor.minE) {
        x4.e = 0;
        x4.d = [0];
      }
    }
    return x4;
  }
  function finiteToString(x4, isExp, sd) {
    if (!x4.isFinite())
      return nonFiniteToString(x4);
    var k4, e6 = x4.e, str = digitsToString(x4.d), len = str.length;
    if (isExp) {
      if (sd && (k4 = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k4);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x4.e < 0 ? "e" : "e+") + x4.e;
    } else if (e6 < 0) {
      str = "0." + getZeroString(-e6 - 1) + str;
      if (sd && (k4 = sd - len) > 0)
        str += getZeroString(k4);
    } else if (e6 >= len) {
      str += getZeroString(e6 + 1 - len);
      if (sd && (k4 = sd - e6 - 1) > 0)
        str = str + "." + getZeroString(k4);
    } else {
      if ((k4 = e6 + 1) < len)
        str = str.slice(0, k4) + "." + str.slice(k4);
      if (sd && (k4 = sd - len) > 0) {
        if (e6 + 1 === len)
          str += ".";
        str += getZeroString(k4);
      }
    }
    return str;
  }
  function getBase10Exponent(digits2, e6) {
    var w4 = digits2[0];
    for (e6 *= LOG_BASE; w4 >= 10; w4 /= 10)
      e6++;
    return e6;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr)
        Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION)
      throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits2) {
    var w4 = digits2.length - 1, len = w4 * LOG_BASE + 1;
    w4 = digits2[w4];
    if (w4) {
      for (; w4 % 10 == 0; w4 /= 10)
        len--;
      for (w4 = digits2[0]; w4 >= 10; w4 /= 10)
        len++;
    }
    return len;
  }
  function getZeroString(k4) {
    var zs = "";
    for (; k4--; )
      zs += "0";
    return zs;
  }
  function intPow(Ctor, x4, n3, pr) {
    var isTruncated, r3 = new Ctor(1), k4 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n3 % 2) {
        r3 = r3.times(x4);
        if (truncate(r3.d, k4))
          isTruncated = true;
      }
      n3 = mathfloor(n3 / 2);
      if (n3 === 0) {
        n3 = r3.d.length - 1;
        if (isTruncated && r3.d[n3] === 0)
          ++r3.d[n3];
        break;
      }
      x4 = x4.times(x4);
      truncate(x4.d, k4);
    }
    external = true;
    return r3;
  }
  function isOdd(n3) {
    return n3.d[n3.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, ltgt) {
    var y3, x4 = new Ctor(args[0]), i5 = 0;
    for (; ++i5 < args.length; ) {
      y3 = new Ctor(args[i5]);
      if (!y3.s) {
        x4 = y3;
        break;
      } else if (x4[ltgt](y3)) {
        x4 = y3;
      }
    }
    return x4;
  }
  function naturalExponential(x4, sd) {
    var denominator, guard, j4, pow3, sum3, t3, wpr, rep = 0, i5 = 0, k4 = 0, Ctor = x4.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x4.d || !x4.d[0] || x4.e > 17) {
      return new Ctor(x4.d ? !x4.d[0] ? 1 : x4.s < 0 ? 0 : 1 / 0 : x4.s ? x4.s < 0 ? 0 : x4 : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t3 = new Ctor(0.03125);
    while (x4.e > -2) {
      x4 = x4.times(t3);
      k4 += 5;
    }
    guard = Math.log(mathpow(2, k4)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow3 = sum3 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow3 = finalise(pow3.times(x4), wpr, 1);
      denominator = denominator.times(++i5);
      t3 = sum3.plus(divide(pow3, denominator, wpr, 1));
      if (digitsToString(t3.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
        j4 = k4;
        while (j4--)
          sum3 = finalise(sum3.times(sum3), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow3 = t3 = new Ctor(1);
            i5 = 0;
            rep++;
          } else {
            return finalise(sum3, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum3;
        }
      }
      sum3 = t3;
    }
  }
  function naturalLogarithm(y3, sd) {
    var c3, c0, denominator, e6, numerator, rep, sum3, t3, wpr, x1, x22, n3 = 1, guard = 10, x4 = y3, xd = x4.d, Ctor = x4.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x4.s < 0 || !xd || !xd[0] || !x4.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x4.s != 1 ? NaN : xd ? 0 : x4);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c3 = digitsToString(xd);
    c0 = c3.charAt(0);
    if (Math.abs(e6 = x4.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c3.charAt(1) > 3) {
        x4 = x4.times(y3);
        c3 = digitsToString(x4.d);
        c0 = c3.charAt(0);
        n3++;
      }
      e6 = x4.e;
      if (c0 > 1) {
        x4 = new Ctor("0." + c3);
        e6++;
      } else {
        x4 = new Ctor(c0 + "." + c3.slice(1));
      }
    } else {
      t3 = getLn10(Ctor, wpr + 2, pr).times(e6 + "");
      x4 = naturalLogarithm(new Ctor(c0 + "." + c3.slice(1)), wpr - guard).plus(t3);
      Ctor.precision = pr;
      return sd == null ? finalise(x4, pr, rm, external = true) : x4;
    }
    x1 = x4;
    sum3 = numerator = x4 = divide(x4.minus(1), x4.plus(1), wpr, 1);
    x22 = finalise(x4.times(x4), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x22), wpr, 1);
      t3 = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t3.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
        sum3 = sum3.times(2);
        if (e6 !== 0)
          sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e6 + ""));
        sum3 = divide(sum3, new Ctor(n3), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t3 = numerator = x4 = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x22 = finalise(x4.times(x4), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum3, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum3;
        }
      }
      sum3 = t3;
      denominator += 2;
    }
  }
  function nonFiniteToString(x4) {
    return String(x4.s * x4.s / 0);
  }
  function parseDecimal(x4, str) {
    var e6, i5, len;
    if ((e6 = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i5 = str.search(/e/i)) > 0) {
      if (e6 < 0)
        e6 = i5;
      e6 += +str.slice(i5 + 1);
      str = str.substring(0, i5);
    } else if (e6 < 0) {
      e6 = str.length;
    }
    for (i5 = 0; str.charCodeAt(i5) === 48; i5++)
      ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
      ;
    str = str.slice(i5, len);
    if (str) {
      len -= i5;
      x4.e = e6 = e6 - i5 - 1;
      x4.d = [];
      i5 = (e6 + 1) % LOG_BASE;
      if (e6 < 0)
        i5 += LOG_BASE;
      if (i5 < len) {
        if (i5)
          x4.d.push(+str.slice(0, i5));
        for (len -= LOG_BASE; i5 < len; )
          x4.d.push(+str.slice(i5, i5 += LOG_BASE));
        str = str.slice(i5);
        i5 = LOG_BASE - str.length;
      } else {
        i5 -= len;
      }
      for (; i5--; )
        str += "0";
      x4.d.push(+str);
      if (external) {
        if (x4.e > x4.constructor.maxE) {
          x4.d = null;
          x4.e = NaN;
        } else if (x4.e < x4.constructor.minE) {
          x4.e = 0;
          x4.d = [0];
        }
      }
    } else {
      x4.e = 0;
      x4.d = [0];
    }
    return x4;
  }
  function parseOther(x4, str) {
    var base, Ctor, divisor, i5, isFloat, len, p3, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str))
        return parseDecimal(x4, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str)
        x4.s = NaN;
      x4.e = NaN;
      x4.d = null;
      return x4;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i5 = str.search(/p/i);
    if (i5 > 0) {
      p3 = +str.slice(i5 + 1);
      str = str.substring(2, i5);
    } else {
      str = str.slice(2);
    }
    i5 = str.indexOf(".");
    isFloat = i5 >= 0;
    Ctor = x4.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i5 = len - i5;
      divisor = intPow(Ctor, new Ctor(base), i5, i5 * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i5 = xe; xd[i5] === 0; --i5)
      xd.pop();
    if (i5 < 0)
      return new Ctor(x4.s * 0);
    x4.e = getBase10Exponent(xd, xe);
    x4.d = xd;
    external = false;
    if (isFloat)
      x4 = divide(x4, divisor, len * 4);
    if (p3)
      x4 = x4.times(Math.abs(p3) < 54 ? mathpow(2, p3) : Decimal.pow(2, p3));
    external = true;
    return x4;
  }
  function sine(Ctor, x4) {
    var k4, len = x4.d.length;
    if (len < 3) {
      return x4.isZero() ? x4 : taylorSeries(Ctor, 2, x4, x4);
    }
    k4 = 1.4 * Math.sqrt(len);
    k4 = k4 > 16 ? 16 : k4 | 0;
    x4 = x4.times(1 / tinyPow(5, k4));
    x4 = taylorSeries(Ctor, 2, x4, x4);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k4--; ) {
      sin2_x = x4.times(x4);
      x4 = x4.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x4;
  }
  function taylorSeries(Ctor, n3, x4, y3, isHyperbolic) {
    var j4, t3, u3, x22, i5 = 1, pr = Ctor.precision, k4 = Math.ceil(pr / LOG_BASE);
    external = false;
    x22 = x4.times(x4);
    u3 = new Ctor(y3);
    for (; ; ) {
      t3 = divide(u3.times(x22), new Ctor(n3++ * n3++), pr, 1);
      u3 = isHyperbolic ? y3.plus(t3) : y3.minus(t3);
      y3 = divide(t3.times(x22), new Ctor(n3++ * n3++), pr, 1);
      t3 = u3.plus(y3);
      if (t3.d[k4] !== void 0) {
        for (j4 = k4; t3.d[j4] === u3.d[j4] && j4--; )
          ;
        if (j4 == -1)
          break;
      }
      j4 = u3;
      u3 = y3;
      y3 = t3;
      t3 = j4;
      i5++;
    }
    external = true;
    t3.d.length = k4 + 1;
    return t3;
  }
  function tinyPow(b3, e6) {
    var n3 = b3;
    while (--e6)
      n3 *= b3;
    return n3;
  }
  function toLessThanHalfPi(Ctor, x4) {
    var t3, isNeg = x4.s < 0, pi3 = getPi(Ctor, Ctor.precision, 1), halfPi = pi3.times(0.5);
    x4 = x4.abs();
    if (x4.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x4;
    }
    t3 = x4.divToInt(pi3);
    if (t3.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x4 = x4.minus(t3.times(pi3));
      if (x4.lte(halfPi)) {
        quadrant = isOdd(t3) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x4;
      }
      quadrant = isOdd(t3) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x4.minus(pi3).abs();
  }
  function toStringBinary(x4, baseOut, sd, rm) {
    var base, e6, i5, k4, len, roundUp, str, xd, y3, Ctor = x4.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x4.isFinite()) {
      str = nonFiniteToString(x4);
    } else {
      str = finiteToString(x4);
      i5 = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i5 >= 0) {
        str = str.replace(".", "");
        y3 = new Ctor(1);
        y3.e = str.length - i5;
        y3.d = convertBase(finiteToString(y3), 10, base);
        y3.e = y3.d.length;
      }
      xd = convertBase(str, 10, base);
      e6 = len = xd.length;
      for (; xd[--len] == 0; )
        xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i5 < 0) {
          e6--;
        } else {
          x4 = new Ctor(x4);
          x4.d = xd;
          x4.e = e6;
          x4 = divide(x4, y3, sd, rm, 0, base);
          xd = x4.d;
          e6 = x4.e;
          roundUp = inexact;
        }
        i5 = xd[sd];
        k4 = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i5 !== void 0 || roundUp) && (rm === 0 || rm === (x4.s < 0 ? 3 : 2)) : i5 > k4 || i5 === k4 && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x4.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e6;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len)
          ;
        for (i5 = 0, str = ""; i5 < len; i5++)
          str += NUMERALS.charAt(xd[i5]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i5 = baseOut == 16 ? 4 : 3;
              for (--len; len % i5; len++)
                str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i5 = 1, str = "1."; i5 < len; i5++)
                str += NUMERALS.charAt(xd[i5]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e6 < 0 ? "p" : "p+") + e6;
        } else if (e6 < 0) {
          for (; ++e6; )
            str = "0" + str;
          str = "0." + str;
        } else {
          if (++e6 > len)
            for (e6 -= len; e6--; )
              str += "0";
          else if (e6 < len)
            str = str.slice(0, e6) + "." + str.slice(e6);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x4.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x4) {
    return new this(x4).abs();
  }
  function acos(x4) {
    return new this(x4).acos();
  }
  function acosh2(x4) {
    return new this(x4).acosh();
  }
  function add(x4, y3) {
    return new this(x4).plus(y3);
  }
  function asin(x4) {
    return new this(x4).asin();
  }
  function asinh2(x4) {
    return new this(x4).asinh();
  }
  function atan(x4) {
    return new this(x4).atan();
  }
  function atanh2(x4) {
    return new this(x4).atanh();
  }
  function atan2(y3, x4) {
    y3 = new this(y3);
    x4 = new this(x4);
    var r3, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y3.s || !x4.s) {
      r3 = new this(NaN);
    } else if (!y3.d && !x4.d) {
      r3 = getPi(this, wpr, 1).times(x4.s > 0 ? 0.25 : 0.75);
      r3.s = y3.s;
    } else if (!x4.d || y3.isZero()) {
      r3 = x4.s < 0 ? getPi(this, pr, rm) : new this(0);
      r3.s = y3.s;
    } else if (!y3.d || x4.isZero()) {
      r3 = getPi(this, wpr, 1).times(0.5);
      r3.s = y3.s;
    } else if (x4.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r3 = this.atan(divide(y3, x4, wpr, 1));
      x4 = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r3 = y3.s < 0 ? r3.minus(x4) : r3.plus(x4);
    } else {
      r3 = this.atan(divide(y3, x4, wpr, 1));
    }
    return r3;
  }
  function cbrt3(x4) {
    return new this(x4).cbrt();
  }
  function ceil(x4) {
    return finalise(x4 = new this(x4), x4.e + 1, 2);
  }
  function clamp(x4, min3, max3) {
    return new this(x4).clamp(min3, max3);
  }
  function config3(obj) {
    if (!obj || typeof obj !== "object")
      throw Error(decimalError + "Object expected");
    var i5, p3, v3, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i5 = 0; i5 < ps.length; i5 += 3) {
      if (p3 = ps[i5], useDefaults)
        this[p3] = DEFAULTS[p3];
      if ((v3 = obj[p3]) !== void 0) {
        if (mathfloor(v3) === v3 && v3 >= ps[i5 + 1] && v3 <= ps[i5 + 2])
          this[p3] = v3;
        else
          throw Error(invalidArgument + p3 + ": " + v3);
      }
    }
    if (p3 = "crypto", useDefaults)
      this[p3] = DEFAULTS[p3];
    if ((v3 = obj[p3]) !== void 0) {
      if (v3 === true || v3 === false || v3 === 0 || v3 === 1) {
        if (v3) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p3] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p3] = false;
        }
      } else {
        throw Error(invalidArgument + p3 + ": " + v3);
      }
    }
    return this;
  }
  function cos(x4) {
    return new this(x4).cos();
  }
  function cosh2(x4) {
    return new this(x4).cosh();
  }
  function clone3(obj) {
    var i5, p3, ps;
    function Decimal2(v3) {
      var e6, i6, t3, x4 = this;
      if (!(x4 instanceof Decimal2))
        return new Decimal2(v3);
      x4.constructor = Decimal2;
      if (isDecimalInstance(v3)) {
        x4.s = v3.s;
        if (external) {
          if (!v3.d || v3.e > Decimal2.maxE) {
            x4.e = NaN;
            x4.d = null;
          } else if (v3.e < Decimal2.minE) {
            x4.e = 0;
            x4.d = [0];
          } else {
            x4.e = v3.e;
            x4.d = v3.d.slice();
          }
        } else {
          x4.e = v3.e;
          x4.d = v3.d ? v3.d.slice() : v3.d;
        }
        return;
      }
      t3 = typeof v3;
      if (t3 === "number") {
        if (v3 === 0) {
          x4.s = 1 / v3 < 0 ? -1 : 1;
          x4.e = 0;
          x4.d = [0];
          return;
        }
        if (v3 < 0) {
          v3 = -v3;
          x4.s = -1;
        } else {
          x4.s = 1;
        }
        if (v3 === ~~v3 && v3 < 1e7) {
          for (e6 = 0, i6 = v3; i6 >= 10; i6 /= 10)
            e6++;
          if (external) {
            if (e6 > Decimal2.maxE) {
              x4.e = NaN;
              x4.d = null;
            } else if (e6 < Decimal2.minE) {
              x4.e = 0;
              x4.d = [0];
            } else {
              x4.e = e6;
              x4.d = [v3];
            }
          } else {
            x4.e = e6;
            x4.d = [v3];
          }
          return;
        } else if (v3 * 0 !== 0) {
          if (!v3)
            x4.s = NaN;
          x4.e = NaN;
          x4.d = null;
          return;
        }
        return parseDecimal(x4, v3.toString());
      } else if (t3 !== "string") {
        throw Error(invalidArgument + v3);
      }
      if ((i6 = v3.charCodeAt(0)) === 45) {
        v3 = v3.slice(1);
        x4.s = -1;
      } else {
        if (i6 === 43)
          v3 = v3.slice(1);
        x4.s = 1;
      }
      return isDecimal.test(v3) ? parseDecimal(x4, v3) : parseOther(x4, v3);
    }
    Decimal2.prototype = P4;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config3;
    Decimal2.clone = clone3;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh2;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh2;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh2;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt3;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh2;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln2;
    Decimal2.log = log;
    Decimal2.log10 = log103;
    Decimal2.log2 = log23;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign2;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh2;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh2;
    Decimal2.trunc = trunc;
    if (obj === void 0)
      obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i5 = 0; i5 < ps.length; )
          if (!obj.hasOwnProperty(p3 = ps[i5++]))
            obj[p3] = this[p3];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x4, y3) {
    return new this(x4).div(y3);
  }
  function exp(x4) {
    return new this(x4).exp();
  }
  function floor(x4) {
    return finalise(x4 = new this(x4), x4.e + 1, 3);
  }
  function hypot() {
    var i5, n3, t3 = new this(0);
    external = false;
    for (i5 = 0; i5 < arguments.length; ) {
      n3 = new this(arguments[i5++]);
      if (!n3.d) {
        if (n3.s) {
          external = true;
          return new this(1 / 0);
        }
        t3 = n3;
      } else if (t3.d) {
        t3 = t3.plus(n3.times(n3));
      }
    }
    external = true;
    return t3.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln2(x4) {
    return new this(x4).ln();
  }
  function log(x4, y3) {
    return new this(x4).log(y3);
  }
  function log23(x4) {
    return new this(x4).log(2);
  }
  function log103(x4) {
    return new this(x4).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, "lt");
  }
  function min() {
    return maxOrMin(this, arguments, "gt");
  }
  function mod(x4, y3) {
    return new this(x4).mod(y3);
  }
  function mul(x4, y3) {
    return new this(x4).mul(y3);
  }
  function pow(x4, y3) {
    return new this(x4).pow(y3);
  }
  function random(sd) {
    var d3, e6, k4, n3, i5 = 0, r3 = new this(1), rd = [];
    if (sd === void 0)
      sd = this.precision;
    else
      checkInt32(sd, 1, MAX_DIGITS);
    k4 = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i5 < k4; )
        rd[i5++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d3 = crypto.getRandomValues(new Uint32Array(k4));
      for (; i5 < k4; ) {
        n3 = d3[i5];
        if (n3 >= 429e7) {
          d3[i5] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i5++] = n3 % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d3 = crypto.randomBytes(k4 *= 4);
      for (; i5 < k4; ) {
        n3 = d3[i5] + (d3[i5 + 1] << 8) + (d3[i5 + 2] << 16) + ((d3[i5 + 3] & 127) << 24);
        if (n3 >= 214e7) {
          crypto.randomBytes(4).copy(d3, i5);
        } else {
          rd.push(n3 % 1e7);
          i5 += 4;
        }
      }
      i5 = k4 / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k4 = rd[--i5];
    sd %= LOG_BASE;
    if (k4 && sd) {
      n3 = mathpow(10, LOG_BASE - sd);
      rd[i5] = (k4 / n3 | 0) * n3;
    }
    for (; rd[i5] === 0; i5--)
      rd.pop();
    if (i5 < 0) {
      e6 = 0;
      rd = [0];
    } else {
      e6 = -1;
      for (; rd[0] === 0; e6 -= LOG_BASE)
        rd.shift();
      for (k4 = 1, n3 = rd[0]; n3 >= 10; n3 /= 10)
        k4++;
      if (k4 < LOG_BASE)
        e6 -= LOG_BASE - k4;
    }
    r3.e = e6;
    r3.d = rd;
    return r3;
  }
  function round(x4) {
    return finalise(x4 = new this(x4), x4.e + 1, this.rounding);
  }
  function sign2(x4) {
    x4 = new this(x4);
    return x4.d ? x4.d[0] ? x4.s : 0 * x4.s : x4.s || NaN;
  }
  function sin(x4) {
    return new this(x4).sin();
  }
  function sinh2(x4) {
    return new this(x4).sinh();
  }
  function sqrt(x4) {
    return new this(x4).sqrt();
  }
  function sub(x4, y3) {
    return new this(x4).sub(y3);
  }
  function sum() {
    var i5 = 0, args = arguments, x4 = new this(args[i5]);
    external = false;
    for (; x4.s && ++i5 < args.length; )
      x4 = x4.plus(args[i5]);
    external = true;
    return finalise(x4, this.precision, this.rounding);
  }
  function tan(x4) {
    return new this(x4).tan();
  }
  function tanh2(x4) {
    return new this(x4).tanh();
  }
  function trunc(x4) {
    return finalise(x4 = new this(x4), x4.e + 1, 1);
  }
  var EXP_LIMIT, MAX_DIGITS, NUMERALS, LN10, PI, DEFAULTS, inexact, quadrant, external, decimalError, invalidArgument, precisionLimitExceeded, cryptoUnavailable, tag, mathfloor, mathpow, isBinary, isHex, isOctal, isDecimal, BASE, LOG_BASE, MAX_SAFE_INTEGER, LN10_PRECISION, PI_PRECISION, P4, divide, Decimal, decimal_default;
  var init_decimal = __esm({
    "node_modules/decimal.js/decimal.mjs"() {
      EXP_LIMIT = 9e15;
      MAX_DIGITS = 1e9;
      NUMERALS = "0123456789abcdef";
      LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
      PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
      DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      };
      external = true;
      decimalError = "[DecimalError] ";
      invalidArgument = decimalError + "Invalid argument: ";
      precisionLimitExceeded = decimalError + "Precision limit exceeded";
      cryptoUnavailable = decimalError + "crypto unavailable";
      tag = "[object Decimal]";
      mathfloor = Math.floor;
      mathpow = Math.pow;
      isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
      isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
      isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
      isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      BASE = 1e7;
      LOG_BASE = 7;
      MAX_SAFE_INTEGER = 9007199254740991;
      LN10_PRECISION = LN10.length - 1;
      PI_PRECISION = PI.length - 1;
      P4 = { toStringTag: tag };
      P4.absoluteValue = P4.abs = function() {
        var x4 = new this.constructor(this);
        if (x4.s < 0)
          x4.s = 1;
        return finalise(x4);
      };
      P4.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P4.clampedTo = P4.clamp = function(min3, max3) {
        var k4, x4 = this, Ctor = x4.constructor;
        min3 = new Ctor(min3);
        max3 = new Ctor(max3);
        if (!min3.s || !max3.s)
          return new Ctor(NaN);
        if (min3.gt(max3))
          throw Error(invalidArgument + max3);
        k4 = x4.cmp(min3);
        return k4 < 0 ? min3 : x4.cmp(max3) > 0 ? max3 : new Ctor(x4);
      };
      P4.comparedTo = P4.cmp = function(y3) {
        var i5, j4, xdL, ydL, x4 = this, xd = x4.d, yd = (y3 = new x4.constructor(y3)).d, xs = x4.s, ys = y3.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0])
          return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys)
          return xs;
        if (x4.e !== y3.e)
          return x4.e > y3.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i5 = 0, j4 = xdL < ydL ? xdL : ydL; i5 < j4; ++i5) {
          if (xd[i5] !== yd[i5])
            return xd[i5] > yd[i5] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P4.cosine = P4.cos = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (!x4.d)
          return new Ctor(NaN);
        if (!x4.d[0])
          return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x4.e, x4.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x4 = cosine(Ctor, toLessThanHalfPi(Ctor, x4));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x4.neg() : x4, pr, rm, true);
      };
      P4.cubeRoot = P4.cbrt = function() {
        var e6, m3, n3, r3, rep, s3, sd, t3, t32, t3plusx, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite() || x4.isZero())
          return new Ctor(x4);
        external = false;
        s3 = x4.s * mathpow(x4.s * x4, 1 / 3);
        if (!s3 || Math.abs(s3) == 1 / 0) {
          n3 = digitsToString(x4.d);
          e6 = x4.e;
          if (s3 = (e6 - n3.length + 1) % 3)
            n3 += s3 == 1 || s3 == -2 ? "0" : "00";
          s3 = mathpow(n3, 1 / 3);
          e6 = mathfloor((e6 + 1) / 3) - (e6 % 3 == (e6 < 0 ? -1 : 2));
          if (s3 == 1 / 0) {
            n3 = "5e" + e6;
          } else {
            n3 = s3.toExponential();
            n3 = n3.slice(0, n3.indexOf("e") + 1) + e6;
          }
          r3 = new Ctor(n3);
          r3.s = x4.s;
        } else {
          r3 = new Ctor(s3.toString());
        }
        sd = (e6 = Ctor.precision) + 3;
        for (; ; ) {
          t3 = r3;
          t32 = t3.times(t3).times(t3);
          t3plusx = t32.plus(x4);
          r3 = divide(t3plusx.plus(x4).times(t3), t3plusx.plus(t32), sd + 2, 1);
          if (digitsToString(t3.d).slice(0, sd) === (n3 = digitsToString(r3.d)).slice(0, sd)) {
            n3 = n3.slice(sd - 3, sd + 1);
            if (n3 == "9999" || !rep && n3 == "4999") {
              if (!rep) {
                finalise(t3, e6 + 1, 0);
                if (t3.times(t3).times(t3).eq(x4)) {
                  r3 = t3;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                finalise(r3, e6 + 1, 1);
                m3 = !r3.times(r3).times(r3).eq(x4);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r3, e6, Ctor.rounding, m3);
      };
      P4.decimalPlaces = P4.dp = function() {
        var w4, d3 = this.d, n3 = NaN;
        if (d3) {
          w4 = d3.length - 1;
          n3 = (w4 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w4 = d3[w4];
          if (w4)
            for (; w4 % 10 == 0; w4 /= 10)
              n3--;
          if (n3 < 0)
            n3 = 0;
        }
        return n3;
      };
      P4.dividedBy = P4.div = function(y3) {
        return divide(this, new this.constructor(y3));
      };
      P4.dividedToIntegerBy = P4.divToInt = function(y3) {
        var x4 = this, Ctor = x4.constructor;
        return finalise(divide(x4, new Ctor(y3), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P4.equals = P4.eq = function(y3) {
        return this.cmp(y3) === 0;
      };
      P4.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P4.greaterThan = P4.gt = function(y3) {
        return this.cmp(y3) > 0;
      };
      P4.greaterThanOrEqualTo = P4.gte = function(y3) {
        var k4 = this.cmp(y3);
        return k4 == 1 || k4 === 0;
      };
      P4.hyperbolicCosine = P4.cosh = function() {
        var k4, n3, pr, rm, len, x4 = this, Ctor = x4.constructor, one = new Ctor(1);
        if (!x4.isFinite())
          return new Ctor(x4.s ? 1 / 0 : NaN);
        if (x4.isZero())
          return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x4.e, x4.sd()) + 4;
        Ctor.rounding = 1;
        len = x4.d.length;
        if (len < 32) {
          k4 = Math.ceil(len / 3);
          n3 = (1 / tinyPow(4, k4)).toString();
        } else {
          k4 = 16;
          n3 = "2.3283064365386962890625e-10";
        }
        x4 = taylorSeries(Ctor, 1, x4.times(n3), new Ctor(1), true);
        var cosh2_x, i5 = k4, d8 = new Ctor(8);
        for (; i5--; ) {
          cosh2_x = x4.times(x4);
          x4 = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x4, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P4.hyperbolicSine = P4.sinh = function() {
        var k4, pr, rm, len, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite() || x4.isZero())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x4.e, x4.sd()) + 4;
        Ctor.rounding = 1;
        len = x4.d.length;
        if (len < 3) {
          x4 = taylorSeries(Ctor, 2, x4, x4, true);
        } else {
          k4 = 1.4 * Math.sqrt(len);
          k4 = k4 > 16 ? 16 : k4 | 0;
          x4 = x4.times(1 / tinyPow(5, k4));
          x4 = taylorSeries(Ctor, 2, x4, x4, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k4--; ) {
            sinh2_x = x4.times(x4);
            x4 = x4.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x4, pr, rm, true);
      };
      P4.hyperbolicTangent = P4.tanh = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite())
          return new Ctor(x4.s);
        if (x4.isZero())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x4.sinh(), x4.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P4.inverseCosine = P4.acos = function() {
        var halfPi, x4 = this, Ctor = x4.constructor, k4 = x4.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k4 !== -1) {
          return k4 === 0 ? x4.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x4.isZero())
          return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x4 = x4.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x4);
      };
      P4.inverseHyperbolicCosine = P4.acosh = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (x4.lte(1))
          return new Ctor(x4.eq(1) ? 0 : NaN);
        if (!x4.isFinite())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x4.e), x4.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x4 = x4.times(x4).minus(1).sqrt().plus(x4);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x4.ln();
      };
      P4.inverseHyperbolicSine = P4.asinh = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite() || x4.isZero())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x4.e), x4.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x4 = x4.times(x4).plus(1).sqrt().plus(x4);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x4.ln();
      };
      P4.inverseHyperbolicTangent = P4.atanh = function() {
        var pr, rm, wpr, xsd, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite())
          return new Ctor(NaN);
        if (x4.e >= 0)
          return new Ctor(x4.abs().eq(1) ? x4.s / 0 : x4.isZero() ? x4 : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x4.sd();
        if (Math.max(xsd, pr) < 2 * -x4.e - 1)
          return finalise(new Ctor(x4), pr, rm, true);
        Ctor.precision = wpr = xsd - x4.e;
        x4 = divide(x4.plus(1), new Ctor(1).minus(x4), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x4 = x4.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x4.times(0.5);
      };
      P4.inverseSine = P4.asin = function() {
        var halfPi, k4, pr, rm, x4 = this, Ctor = x4.constructor;
        if (x4.isZero())
          return new Ctor(x4);
        k4 = x4.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k4 !== -1) {
          if (k4 === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x4.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x4 = x4.div(new Ctor(1).minus(x4.times(x4)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x4.times(2);
      };
      P4.inverseTangent = P4.atan = function() {
        var i5, j4, k4, n3, px, t3, r3, wpr, x22, x4 = this, Ctor = x4.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x4.isFinite()) {
          if (!x4.s)
            return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r3 = getPi(Ctor, pr + 4, rm).times(0.5);
            r3.s = x4.s;
            return r3;
          }
        } else if (x4.isZero()) {
          return new Ctor(x4);
        } else if (x4.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r3 = getPi(Ctor, pr + 4, rm).times(0.25);
          r3.s = x4.s;
          return r3;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k4 = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i5 = k4; i5; --i5)
          x4 = x4.div(x4.times(x4).plus(1).sqrt().plus(1));
        external = false;
        j4 = Math.ceil(wpr / LOG_BASE);
        n3 = 1;
        x22 = x4.times(x4);
        r3 = new Ctor(x4);
        px = x4;
        for (; i5 !== -1; ) {
          px = px.times(x22);
          t3 = r3.minus(px.div(n3 += 2));
          px = px.times(x22);
          r3 = t3.plus(px.div(n3 += 2));
          if (r3.d[j4] !== void 0)
            for (i5 = j4; r3.d[i5] === t3.d[i5] && i5--; )
              ;
        }
        if (k4)
          r3 = r3.times(2 << k4 - 1);
        external = true;
        return finalise(r3, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P4.isFinite = function() {
        return !!this.d;
      };
      P4.isInteger = P4.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P4.isNaN = function() {
        return !this.s;
      };
      P4.isNegative = P4.isNeg = function() {
        return this.s < 0;
      };
      P4.isPositive = P4.isPos = function() {
        return this.s > 0;
      };
      P4.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P4.lessThan = P4.lt = function(y3) {
        return this.cmp(y3) < 0;
      };
      P4.lessThanOrEqualTo = P4.lte = function(y3) {
        return this.cmp(y3) < 1;
      };
      P4.logarithm = P4.log = function(base) {
        var isBase10, d3, denominator, k4, inf, num, sd, r3, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d3 = base.d;
          if (base.s < 0 || !d3 || !d3[0] || base.eq(1))
            return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d3 = arg2.d;
        if (arg2.s < 0 || !d3 || !d3[0] || arg2.eq(1)) {
          return new Ctor(d3 && !d3[0] ? -1 / 0 : arg2.s != 1 ? NaN : d3 ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d3.length > 1) {
            inf = true;
          } else {
            for (k4 = d3[0]; k4 % 10 === 0; )
              k4 /= 10;
            inf = k4 !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg2, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r3 = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r3.d, k4 = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg2, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r3 = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r3.d).slice(k4 + 1, k4 + 15) + 1 == 1e14) {
                r3 = finalise(r3, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r3.d, k4 += 10, rm));
        }
        external = true;
        return finalise(r3, pr, rm);
      };
      P4.minus = P4.sub = function(y3) {
        var d3, e6, i5, j4, k4, len, pr, rm, xd, xe, xLTy, yd, x4 = this, Ctor = x4.constructor;
        y3 = new Ctor(y3);
        if (!x4.d || !y3.d) {
          if (!x4.s || !y3.s)
            y3 = new Ctor(NaN);
          else if (x4.d)
            y3.s = -y3.s;
          else
            y3 = new Ctor(y3.d || x4.s !== y3.s ? x4 : NaN);
          return y3;
        }
        if (x4.s != y3.s) {
          y3.s = -y3.s;
          return x4.plus(y3);
        }
        xd = x4.d;
        yd = y3.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0])
            y3.s = -y3.s;
          else if (xd[0])
            y3 = new Ctor(x4);
          else
            return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y3, pr, rm) : y3;
        }
        e6 = mathfloor(y3.e / LOG_BASE);
        xe = mathfloor(x4.e / LOG_BASE);
        xd = xd.slice();
        k4 = xe - e6;
        if (k4) {
          xLTy = k4 < 0;
          if (xLTy) {
            d3 = xd;
            k4 = -k4;
            len = yd.length;
          } else {
            d3 = yd;
            e6 = xe;
            len = xd.length;
          }
          i5 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k4 > i5) {
            k4 = i5;
            d3.length = 1;
          }
          d3.reverse();
          for (i5 = k4; i5--; )
            d3.push(0);
          d3.reverse();
        } else {
          i5 = xd.length;
          len = yd.length;
          xLTy = i5 < len;
          if (xLTy)
            len = i5;
          for (i5 = 0; i5 < len; i5++) {
            if (xd[i5] != yd[i5]) {
              xLTy = xd[i5] < yd[i5];
              break;
            }
          }
          k4 = 0;
        }
        if (xLTy) {
          d3 = xd;
          xd = yd;
          yd = d3;
          y3.s = -y3.s;
        }
        len = xd.length;
        for (i5 = yd.length - len; i5 > 0; --i5)
          xd[len++] = 0;
        for (i5 = yd.length; i5 > k4; ) {
          if (xd[--i5] < yd[i5]) {
            for (j4 = i5; j4 && xd[--j4] === 0; )
              xd[j4] = BASE - 1;
            --xd[j4];
            xd[i5] += BASE;
          }
          xd[i5] -= yd[i5];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e6;
        if (!xd[0])
          return new Ctor(rm === 3 ? -0 : 0);
        y3.d = xd;
        y3.e = getBase10Exponent(xd, e6);
        return external ? finalise(y3, pr, rm) : y3;
      };
      P4.modulo = P4.mod = function(y3) {
        var q4, x4 = this, Ctor = x4.constructor;
        y3 = new Ctor(y3);
        if (!x4.d || !y3.s || y3.d && !y3.d[0])
          return new Ctor(NaN);
        if (!y3.d || x4.d && !x4.d[0]) {
          return finalise(new Ctor(x4), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q4 = divide(x4, y3.abs(), 0, 3, 1);
          q4.s *= y3.s;
        } else {
          q4 = divide(x4, y3, 0, Ctor.modulo, 1);
        }
        q4 = q4.times(y3);
        external = true;
        return x4.minus(q4);
      };
      P4.naturalExponential = P4.exp = function() {
        return naturalExponential(this);
      };
      P4.naturalLogarithm = P4.ln = function() {
        return naturalLogarithm(this);
      };
      P4.negated = P4.neg = function() {
        var x4 = new this.constructor(this);
        x4.s = -x4.s;
        return finalise(x4);
      };
      P4.plus = P4.add = function(y3) {
        var carry, d3, e6, i5, k4, len, pr, rm, xd, yd, x4 = this, Ctor = x4.constructor;
        y3 = new Ctor(y3);
        if (!x4.d || !y3.d) {
          if (!x4.s || !y3.s)
            y3 = new Ctor(NaN);
          else if (!x4.d)
            y3 = new Ctor(y3.d || x4.s === y3.s ? x4 : NaN);
          return y3;
        }
        if (x4.s != y3.s) {
          y3.s = -y3.s;
          return x4.minus(y3);
        }
        xd = x4.d;
        yd = y3.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0])
            y3 = new Ctor(x4);
          return external ? finalise(y3, pr, rm) : y3;
        }
        k4 = mathfloor(x4.e / LOG_BASE);
        e6 = mathfloor(y3.e / LOG_BASE);
        xd = xd.slice();
        i5 = k4 - e6;
        if (i5) {
          if (i5 < 0) {
            d3 = xd;
            i5 = -i5;
            len = yd.length;
          } else {
            d3 = yd;
            e6 = k4;
            len = xd.length;
          }
          k4 = Math.ceil(pr / LOG_BASE);
          len = k4 > len ? k4 + 1 : len + 1;
          if (i5 > len) {
            i5 = len;
            d3.length = 1;
          }
          d3.reverse();
          for (; i5--; )
            d3.push(0);
          d3.reverse();
        }
        len = xd.length;
        i5 = yd.length;
        if (len - i5 < 0) {
          i5 = len;
          d3 = yd;
          yd = xd;
          xd = d3;
        }
        for (carry = 0; i5; ) {
          carry = (xd[--i5] = xd[i5] + yd[i5] + carry) / BASE | 0;
          xd[i5] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e6;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y3.d = xd;
        y3.e = getBase10Exponent(xd, e6);
        return external ? finalise(y3, pr, rm) : y3;
      };
      P4.precision = P4.sd = function(z5) {
        var k4, x4 = this;
        if (z5 !== void 0 && z5 !== !!z5 && z5 !== 1 && z5 !== 0)
          throw Error(invalidArgument + z5);
        if (x4.d) {
          k4 = getPrecision(x4.d);
          if (z5 && x4.e + 1 > k4)
            k4 = x4.e + 1;
        } else {
          k4 = NaN;
        }
        return k4;
      };
      P4.round = function() {
        var x4 = this, Ctor = x4.constructor;
        return finalise(new Ctor(x4), x4.e + 1, Ctor.rounding);
      };
      P4.sine = P4.sin = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite())
          return new Ctor(NaN);
        if (x4.isZero())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x4.e, x4.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x4 = sine(Ctor, toLessThanHalfPi(Ctor, x4));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x4.neg() : x4, pr, rm, true);
      };
      P4.squareRoot = P4.sqrt = function() {
        var m3, n3, sd, r3, rep, t3, x4 = this, d3 = x4.d, e6 = x4.e, s3 = x4.s, Ctor = x4.constructor;
        if (s3 !== 1 || !d3 || !d3[0]) {
          return new Ctor(!s3 || s3 < 0 && (!d3 || d3[0]) ? NaN : d3 ? x4 : 1 / 0);
        }
        external = false;
        s3 = Math.sqrt(+x4);
        if (s3 == 0 || s3 == 1 / 0) {
          n3 = digitsToString(d3);
          if ((n3.length + e6) % 2 == 0)
            n3 += "0";
          s3 = Math.sqrt(n3);
          e6 = mathfloor((e6 + 1) / 2) - (e6 < 0 || e6 % 2);
          if (s3 == 1 / 0) {
            n3 = "5e" + e6;
          } else {
            n3 = s3.toExponential();
            n3 = n3.slice(0, n3.indexOf("e") + 1) + e6;
          }
          r3 = new Ctor(n3);
        } else {
          r3 = new Ctor(s3.toString());
        }
        sd = (e6 = Ctor.precision) + 3;
        for (; ; ) {
          t3 = r3;
          r3 = t3.plus(divide(x4, t3, sd + 2, 1)).times(0.5);
          if (digitsToString(t3.d).slice(0, sd) === (n3 = digitsToString(r3.d)).slice(0, sd)) {
            n3 = n3.slice(sd - 3, sd + 1);
            if (n3 == "9999" || !rep && n3 == "4999") {
              if (!rep) {
                finalise(t3, e6 + 1, 0);
                if (t3.times(t3).eq(x4)) {
                  r3 = t3;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                finalise(r3, e6 + 1, 1);
                m3 = !r3.times(r3).eq(x4);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r3, e6, Ctor.rounding, m3);
      };
      P4.tangent = P4.tan = function() {
        var pr, rm, x4 = this, Ctor = x4.constructor;
        if (!x4.isFinite())
          return new Ctor(NaN);
        if (x4.isZero())
          return new Ctor(x4);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x4 = x4.sin();
        x4.s = 1;
        x4 = divide(x4, new Ctor(1).minus(x4.times(x4)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x4.neg() : x4, pr, rm, true);
      };
      P4.times = P4.mul = function(y3) {
        var carry, e6, i5, k4, r3, rL, t3, xdL, ydL, x4 = this, Ctor = x4.constructor, xd = x4.d, yd = (y3 = new Ctor(y3)).d;
        y3.s *= x4.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y3.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y3.s / 0 : y3.s * 0);
        }
        e6 = mathfloor(x4.e / LOG_BASE) + mathfloor(y3.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r3 = xd;
          xd = yd;
          yd = r3;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r3 = [];
        rL = xdL + ydL;
        for (i5 = rL; i5--; )
          r3.push(0);
        for (i5 = ydL; --i5 >= 0; ) {
          carry = 0;
          for (k4 = xdL + i5; k4 > i5; ) {
            t3 = r3[k4] + yd[i5] * xd[k4 - i5 - 1] + carry;
            r3[k4--] = t3 % BASE | 0;
            carry = t3 / BASE | 0;
          }
          r3[k4] = (r3[k4] + carry) % BASE | 0;
        }
        for (; !r3[--rL]; )
          r3.pop();
        if (carry)
          ++e6;
        else
          r3.shift();
        y3.d = r3;
        y3.e = getBase10Exponent(r3, e6);
        return external ? finalise(y3, Ctor.precision, Ctor.rounding) : y3;
      };
      P4.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P4.toDecimalPlaces = P4.toDP = function(dp, rm) {
        var x4 = this, Ctor = x4.constructor;
        x4 = new Ctor(x4);
        if (dp === void 0)
          return x4;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        return finalise(x4, dp + x4.e + 1, rm);
      };
      P4.toExponential = function(dp, rm) {
        var str, x4 = this, Ctor = x4.constructor;
        if (dp === void 0) {
          str = finiteToString(x4, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x4 = finalise(new Ctor(x4), dp + 1, rm);
          str = finiteToString(x4, true, dp + 1);
        }
        return x4.isNeg() && !x4.isZero() ? "-" + str : str;
      };
      P4.toFixed = function(dp, rm) {
        var str, y3, x4 = this, Ctor = x4.constructor;
        if (dp === void 0) {
          str = finiteToString(x4);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          y3 = finalise(new Ctor(x4), dp + x4.e + 1, rm);
          str = finiteToString(y3, false, dp + y3.e + 1);
        }
        return x4.isNeg() && !x4.isZero() ? "-" + str : str;
      };
      P4.toFraction = function(maxD) {
        var d3, d0, d1, d22, e6, k4, n3, n0, n16, pr, q4, r3, x4 = this, xd = x4.d, Ctor = x4.constructor;
        if (!xd)
          return new Ctor(x4);
        n16 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d3 = new Ctor(d1);
        e6 = d3.e = getPrecision(xd) - x4.e - 1;
        k4 = e6 % LOG_BASE;
        d3.d[0] = mathpow(10, k4 < 0 ? LOG_BASE + k4 : k4);
        if (maxD == null) {
          maxD = e6 > 0 ? d3 : n16;
        } else {
          n3 = new Ctor(maxD);
          if (!n3.isInt() || n3.lt(n16))
            throw Error(invalidArgument + n3);
          maxD = n3.gt(d3) ? e6 > 0 ? d3 : n16 : n3;
        }
        external = false;
        n3 = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e6 = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q4 = divide(n3, d3, 0, 1, 1);
          d22 = d0.plus(q4.times(d1));
          if (d22.cmp(maxD) == 1)
            break;
          d0 = d1;
          d1 = d22;
          d22 = n16;
          n16 = n0.plus(q4.times(d22));
          n0 = d22;
          d22 = d3;
          d3 = n3.minus(q4.times(d22));
          n3 = d22;
        }
        d22 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d22.times(n16));
        d0 = d0.plus(d22.times(d1));
        n0.s = n16.s = x4.s;
        r3 = divide(n16, d1, e6, 1).minus(x4).abs().cmp(divide(n0, d0, e6, 1).minus(x4).abs()) < 1 ? [n16, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r3;
      };
      P4.toHexadecimal = P4.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P4.toNearest = function(y3, rm) {
        var x4 = this, Ctor = x4.constructor;
        x4 = new Ctor(x4);
        if (y3 == null) {
          if (!x4.d)
            return x4;
          y3 = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y3 = new Ctor(y3);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x4.d)
            return y3.s ? x4 : y3;
          if (!y3.d) {
            if (y3.s)
              y3.s = x4.s;
            return y3;
          }
        }
        if (y3.d[0]) {
          external = false;
          x4 = divide(x4, y3, 0, rm, 1).times(y3);
          external = true;
          finalise(x4);
        } else {
          y3.s = x4.s;
          x4 = y3;
        }
        return x4;
      };
      P4.toNumber = function() {
        return +this;
      };
      P4.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P4.toPower = P4.pow = function(y3) {
        var e6, k4, pr, r3, rm, s3, x4 = this, Ctor = x4.constructor, yn2 = +(y3 = new Ctor(y3));
        if (!x4.d || !y3.d || !x4.d[0] || !y3.d[0])
          return new Ctor(mathpow(+x4, yn2));
        x4 = new Ctor(x4);
        if (x4.eq(1))
          return x4;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y3.eq(1))
          return finalise(x4, pr, rm);
        e6 = mathfloor(y3.e / LOG_BASE);
        if (e6 >= y3.d.length - 1 && (k4 = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER) {
          r3 = intPow(Ctor, x4, k4, pr);
          return y3.s < 0 ? new Ctor(1).div(r3) : finalise(r3, pr, rm);
        }
        s3 = x4.s;
        if (s3 < 0) {
          if (e6 < y3.d.length - 1)
            return new Ctor(NaN);
          if ((y3.d[e6] & 1) == 0)
            s3 = 1;
          if (x4.e == 0 && x4.d[0] == 1 && x4.d.length == 1) {
            x4.s = s3;
            return x4;
          }
        }
        k4 = mathpow(+x4, yn2);
        e6 = k4 == 0 || !isFinite(k4) ? mathfloor(yn2 * (Math.log("0." + digitsToString(x4.d)) / Math.LN10 + x4.e + 1)) : new Ctor(k4 + "").e;
        if (e6 > Ctor.maxE + 1 || e6 < Ctor.minE - 1)
          return new Ctor(e6 > 0 ? s3 / 0 : 0);
        external = false;
        Ctor.rounding = x4.s = 1;
        k4 = Math.min(12, (e6 + "").length);
        r3 = naturalExponential(y3.times(naturalLogarithm(x4, pr + k4)), pr);
        if (r3.d) {
          r3 = finalise(r3, pr + 5, 1);
          if (checkRoundingDigits(r3.d, pr, rm)) {
            e6 = pr + 10;
            r3 = finalise(naturalExponential(y3.times(naturalLogarithm(x4, e6 + k4)), e6), e6 + 5, 1);
            if (+digitsToString(r3.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r3 = finalise(r3, pr + 1, 0);
            }
          }
        }
        r3.s = s3;
        external = true;
        Ctor.rounding = rm;
        return finalise(r3, pr, rm);
      };
      P4.toPrecision = function(sd, rm) {
        var str, x4 = this, Ctor = x4.constructor;
        if (sd === void 0) {
          str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x4 = finalise(new Ctor(x4), sd, rm);
          str = finiteToString(x4, sd <= x4.e || x4.e <= Ctor.toExpNeg, sd);
        }
        return x4.isNeg() && !x4.isZero() ? "-" + str : str;
      };
      P4.toSignificantDigits = P4.toSD = function(sd, rm) {
        var x4 = this, Ctor = x4.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x4), sd, rm);
      };
      P4.toString = function() {
        var x4 = this, Ctor = x4.constructor, str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
        return x4.isNeg() && !x4.isZero() ? "-" + str : str;
      };
      P4.truncated = P4.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P4.valueOf = P4.toJSON = function() {
        var x4 = this, Ctor = x4.constructor, str = finiteToString(x4, x4.e <= Ctor.toExpNeg || x4.e >= Ctor.toExpPos);
        return x4.isNeg() ? "-" + str : str;
      };
      divide = function() {
        function multiplyInteger(x4, k4, base) {
          var temp, carry = 0, i5 = x4.length;
          for (x4 = x4.slice(); i5--; ) {
            temp = x4[i5] * k4 + carry;
            x4[i5] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry)
            x4.unshift(carry);
          return x4;
        }
        function compare3(a3, b3, aL, bL) {
          var i5, r3;
          if (aL != bL) {
            r3 = aL > bL ? 1 : -1;
          } else {
            for (i5 = r3 = 0; i5 < aL; i5++) {
              if (a3[i5] != b3[i5]) {
                r3 = a3[i5] > b3[i5] ? 1 : -1;
                break;
              }
            }
          }
          return r3;
        }
        function subtract2(a3, b3, aL, base) {
          var i5 = 0;
          for (; aL--; ) {
            a3[aL] -= i5;
            i5 = a3[aL] < b3[aL] ? 1 : 0;
            a3[aL] = i5 * base + a3[aL] - b3[aL];
          }
          for (; !a3[0] && a3.length > 1; )
            a3.shift();
        }
        return function(x4, y3, pr, rm, dp, base) {
          var cmp, e6, i5, k4, logBase, more, prod2, prodL, q4, qd, rem, remL, rem0, sd, t3, xi, xL, yd0, yL, yz, Ctor = x4.constructor, sign4 = x4.s == y3.s ? 1 : -1, xd = x4.d, yd = y3.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x4.s || !y3.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e6 = x4.e - y3.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e6 = mathfloor(x4.e / logBase) - mathfloor(y3.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q4 = new Ctor(sign4);
          qd = q4.d = [];
          for (i5 = 0; yd[i5] == (xd[i5] || 0); i5++)
            ;
          if (yd[i5] > (xd[i5] || 0))
            e6--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x4.e - y3.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i5 = 0;
            if (yL == 1) {
              k4 = 0;
              yd = yd[0];
              sd++;
              for (; (i5 < xL || k4) && sd--; i5++) {
                t3 = k4 * base + (xd[i5] || 0);
                qd[i5] = t3 / yd | 0;
                k4 = t3 % yd | 0;
              }
              more = k4 || i5 < xL;
            } else {
              k4 = base / (yd[0] + 1) | 0;
              if (k4 > 1) {
                yd = multiplyInteger(yd, k4, base);
                xd = multiplyInteger(xd, k4, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; )
                rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2)
                ++yd0;
              do {
                k4 = 0;
                cmp = compare3(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  k4 = rem0 / yd0 | 0;
                  if (k4 > 1) {
                    if (k4 >= base)
                      k4 = base - 1;
                    prod2 = multiplyInteger(yd, k4, base);
                    prodL = prod2.length;
                    remL = rem.length;
                    cmp = compare3(prod2, rem, prodL, remL);
                    if (cmp == 1) {
                      k4--;
                      subtract2(prod2, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k4 == 0)
                      cmp = k4 = 1;
                    prod2 = yd.slice();
                  }
                  prodL = prod2.length;
                  if (prodL < remL)
                    prod2.unshift(0);
                  subtract2(rem, prod2, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare3(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k4++;
                      subtract2(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k4++;
                  rem = [0];
                }
                qd[i5++] = k4;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0])
              qd.shift();
          }
          if (logBase == 1) {
            q4.e = e6;
            inexact = more;
          } else {
            for (i5 = 1, k4 = qd[0]; k4 >= 10; k4 /= 10)
              i5++;
            q4.e = i5 + e6 * logBase - 1;
            finalise(q4, dp ? pr + q4.e + 1 : pr, rm, more);
          }
          return q4;
        };
      }();
      P4[Symbol.for("nodejs.util.inspect.custom")] = P4.toString;
      P4[Symbol.toStringTag] = "Decimal";
      Decimal = P4.constructor = clone3(DEFAULTS);
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);
      decimal_default = Decimal;
    }
  });

  // node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var name2, dependencies3, createBigNumberClass;
  var init_BigNumber = __esm({
    "node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js"() {
      init_decimal();
      init_factory();
      name2 = "BigNumber";
      dependencies3 = ["?on", "config"];
      createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
        var {
          on: on2,
          config: config4
        } = _ref;
        var BigNumber2 = decimal_default.clone({
          precision: config4.precision,
          modulo: decimal_default.EUCLID
        });
        BigNumber2.prototype = Object.create(BigNumber2.prototype);
        BigNumber2.prototype.type = "BigNumber";
        BigNumber2.prototype.isBigNumber = true;
        BigNumber2.prototype.toJSON = function() {
          return {
            mathjs: "BigNumber",
            value: this.toString()
          };
        };
        BigNumber2.fromJSON = function(json) {
          return new BigNumber2(json.value);
        };
        if (on2) {
          on2("config", function(curr, prev) {
            if (curr.precision !== prev.precision) {
              BigNumber2.config({
                precision: curr.precision
              });
            }
          });
        }
        return BigNumber2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/complex.js/complex.js
  var require_complex = __commonJS({
    "node_modules/complex.js/complex.js"(exports, module) {
      (function(root) {
        "use strict";
        var cosh4 = Math.cosh || function(x4) {
          return Math.abs(x4) < 1e-9 ? 1 - x4 : (Math.exp(x4) + Math.exp(-x4)) * 0.5;
        };
        var sinh4 = Math.sinh || function(x4) {
          return Math.abs(x4) < 1e-9 ? x4 : (Math.exp(x4) - Math.exp(-x4)) * 0.5;
        };
        var cosm1 = function(x4) {
          var b3 = Math.PI / 4;
          if (-b3 > x4 || x4 > b3) {
            return Math.cos(x4) - 1;
          }
          var xx = x4 * x4;
          return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
        };
        var hypot3 = function(x4, y3) {
          var a3 = Math.abs(x4);
          var b3 = Math.abs(y3);
          if (a3 < 3e3 && b3 < 3e3) {
            return Math.sqrt(a3 * a3 + b3 * b3);
          }
          if (a3 < b3) {
            a3 = b3;
            b3 = x4 / y3;
          } else {
            b3 = y3 / x4;
          }
          return a3 * Math.sqrt(1 + b3 * b3);
        };
        var parser_exit = function() {
          throw SyntaxError("Invalid Param");
        };
        function logHypot(a3, b3) {
          var _a = Math.abs(a3);
          var _b = Math.abs(b3);
          if (a3 === 0) {
            return Math.log(_b);
          }
          if (b3 === 0) {
            return Math.log(_a);
          }
          if (_a < 3e3 && _b < 3e3) {
            return Math.log(a3 * a3 + b3 * b3) * 0.5;
          }
          a3 = a3 / 2;
          b3 = b3 / 2;
          return 0.5 * Math.log(a3 * a3 + b3 * b3) + Math.LN2;
        }
        var parse2 = function(a3, b3) {
          var z5 = { "re": 0, "im": 0 };
          if (a3 === void 0 || a3 === null) {
            z5["re"] = z5["im"] = 0;
          } else if (b3 !== void 0) {
            z5["re"] = a3;
            z5["im"] = b3;
          } else
            switch (typeof a3) {
              case "object":
                if ("im" in a3 && "re" in a3) {
                  z5["re"] = a3["re"];
                  z5["im"] = a3["im"];
                } else if ("abs" in a3 && "arg" in a3) {
                  if (!Number.isFinite(a3["abs"]) && Number.isFinite(a3["arg"])) {
                    return Complex3["INFINITY"];
                  }
                  z5["re"] = a3["abs"] * Math.cos(a3["arg"]);
                  z5["im"] = a3["abs"] * Math.sin(a3["arg"]);
                } else if ("r" in a3 && "phi" in a3) {
                  if (!Number.isFinite(a3["r"]) && Number.isFinite(a3["phi"])) {
                    return Complex3["INFINITY"];
                  }
                  z5["re"] = a3["r"] * Math.cos(a3["phi"]);
                  z5["im"] = a3["r"] * Math.sin(a3["phi"]);
                } else if (a3.length === 2) {
                  z5["re"] = a3[0];
                  z5["im"] = a3[1];
                } else {
                  parser_exit();
                }
                break;
              case "string":
                z5["im"] = /* void */
                z5["re"] = 0;
                var tokens = a3.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
                var plus = 1;
                var minus = 0;
                if (tokens === null) {
                  parser_exit();
                }
                for (var i5 = 0; i5 < tokens.length; i5++) {
                  var c3 = tokens[i5];
                  if (c3 === " " || c3 === "	" || c3 === "\n") {
                  } else if (c3 === "+") {
                    plus++;
                  } else if (c3 === "-") {
                    minus++;
                  } else if (c3 === "i" || c3 === "I") {
                    if (plus + minus === 0) {
                      parser_exit();
                    }
                    if (tokens[i5 + 1] !== " " && !isNaN(tokens[i5 + 1])) {
                      z5["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i5 + 1]);
                      i5++;
                    } else {
                      z5["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                    }
                    plus = minus = 0;
                  } else {
                    if (plus + minus === 0 || isNaN(c3)) {
                      parser_exit();
                    }
                    if (tokens[i5 + 1] === "i" || tokens[i5 + 1] === "I") {
                      z5["im"] += parseFloat((minus % 2 ? "-" : "") + c3);
                      i5++;
                    } else {
                      z5["re"] += parseFloat((minus % 2 ? "-" : "") + c3);
                    }
                    plus = minus = 0;
                  }
                }
                if (plus + minus > 0) {
                  parser_exit();
                }
                break;
              case "number":
                z5["im"] = 0;
                z5["re"] = a3;
                break;
              default:
                parser_exit();
            }
          if (isNaN(z5["re"]) || isNaN(z5["im"])) {
          }
          return z5;
        };
        function Complex3(a3, b3) {
          if (!(this instanceof Complex3)) {
            return new Complex3(a3, b3);
          }
          var z5 = parse2(a3, b3);
          this["re"] = z5["re"];
          this["im"] = z5["im"];
        }
        Complex3.prototype = {
          "re": 0,
          "im": 0,
          /**
           * Calculates the sign of a complex number, which is a normalized complex
           *
           * @returns {Complex}
           */
          "sign": function() {
            var abs3 = this["abs"]();
            return new Complex3(
              this["re"] / abs3,
              this["im"] / abs3
            );
          },
          /**
           * Adds two complex numbers
           *
           * @returns {Complex}
           */
          "add": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            if (this["isInfinite"]() && z5["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z5["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] + z5["re"],
              this["im"] + z5["im"]
            );
          },
          /**
           * Subtracts two complex numbers
           *
           * @returns {Complex}
           */
          "sub": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            if (this["isInfinite"]() && z5["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z5["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] - z5["re"],
              this["im"] - z5["im"]
            );
          },
          /**
           * Multiplies two complex numbers
           *
           * @returns {Complex}
           */
          "mul": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            if (this["isInfinite"]() && z5["isZero"]() || this["isZero"]() && z5["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z5["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            if (z5["im"] === 0 && this["im"] === 0) {
              return new Complex3(this["re"] * z5["re"], 0);
            }
            return new Complex3(
              this["re"] * z5["re"] - this["im"] * z5["im"],
              this["re"] * z5["im"] + this["im"] * z5["re"]
            );
          },
          /**
           * Divides two complex numbers
           *
           * @returns {Complex}
           */
          "div": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            if (this["isZero"]() && z5["isZero"]() || this["isInfinite"]() && z5["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z5["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isZero"]() || z5["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            a3 = this["re"];
            b3 = this["im"];
            var c3 = z5["re"];
            var d3 = z5["im"];
            var t3, x4;
            if (0 === d3) {
              return new Complex3(a3 / c3, b3 / c3);
            }
            if (Math.abs(c3) < Math.abs(d3)) {
              x4 = c3 / d3;
              t3 = c3 * x4 + d3;
              return new Complex3(
                (a3 * x4 + b3) / t3,
                (b3 * x4 - a3) / t3
              );
            } else {
              x4 = d3 / c3;
              t3 = d3 * x4 + c3;
              return new Complex3(
                (a3 + b3 * x4) / t3,
                (b3 - a3 * x4) / t3
              );
            }
          },
          /**
           * Calculate the power of two complex numbers
           *
           * @returns {Complex}
           */
          "pow": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            a3 = this["re"];
            b3 = this["im"];
            if (z5["isZero"]()) {
              return Complex3["ONE"];
            }
            if (z5["im"] === 0) {
              if (b3 === 0 && a3 > 0) {
                return new Complex3(Math.pow(a3, z5["re"]), 0);
              } else if (a3 === 0) {
                switch ((z5["re"] % 4 + 4) % 4) {
                  case 0:
                    return new Complex3(Math.pow(b3, z5["re"]), 0);
                  case 1:
                    return new Complex3(0, Math.pow(b3, z5["re"]));
                  case 2:
                    return new Complex3(-Math.pow(b3, z5["re"]), 0);
                  case 3:
                    return new Complex3(0, -Math.pow(b3, z5["re"]));
                }
              }
            }
            if (a3 === 0 && b3 === 0 && z5["re"] > 0 && z5["im"] >= 0) {
              return Complex3["ZERO"];
            }
            var arg2 = Math.atan2(b3, a3);
            var loh = logHypot(a3, b3);
            a3 = Math.exp(z5["re"] * loh - z5["im"] * arg2);
            b3 = z5["im"] * loh + z5["re"] * arg2;
            return new Complex3(
              a3 * Math.cos(b3),
              a3 * Math.sin(b3)
            );
          },
          /**
           * Calculate the complex square root
           *
           * @returns {Complex}
           */
          "sqrt": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var r3 = this["abs"]();
            var re2, im2;
            if (a3 >= 0) {
              if (b3 === 0) {
                return new Complex3(Math.sqrt(a3), 0);
              }
              re2 = 0.5 * Math.sqrt(2 * (r3 + a3));
            } else {
              re2 = Math.abs(b3) / Math.sqrt(2 * (r3 - a3));
            }
            if (a3 <= 0) {
              im2 = 0.5 * Math.sqrt(2 * (r3 - a3));
            } else {
              im2 = Math.abs(b3) / Math.sqrt(2 * (r3 + a3));
            }
            return new Complex3(re2, b3 < 0 ? -im2 : im2);
          },
          /**
           * Calculate the complex exponent
           *
           * @returns {Complex}
           */
          "exp": function() {
            var tmp = Math.exp(this["re"]);
            if (this["im"] === 0) {
            }
            return new Complex3(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"])
            );
          },
          /**
           * Calculate the complex exponent and subtracts one.
           *
           * This may be more accurate than `Complex(x).exp().sub(1)` if
           * `x` is small.
           *
           * @returns {Complex}
           */
          "expm1": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            return new Complex3(
              Math.expm1(a3) * Math.cos(b3) + cosm1(b3),
              Math.exp(a3) * Math.sin(b3)
            );
          },
          /**
           * Calculate the natural log
           *
           * @returns {Complex}
           */
          "log": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (b3 === 0 && a3 > 0) {
            }
            return new Complex3(
              logHypot(a3, b3),
              Math.atan2(b3, a3)
            );
          },
          /**
           * Calculate the magnitude of the complex number
           *
           * @returns {number}
           */
          "abs": function() {
            return hypot3(this["re"], this["im"]);
          },
          /**
           * Calculate the angle of the complex number
           *
           * @returns {number}
           */
          "arg": function() {
            return Math.atan2(this["im"], this["re"]);
          },
          /**
           * Calculate the sine of the complex number
           *
           * @returns {Complex}
           */
          "sin": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            return new Complex3(
              Math.sin(a3) * cosh4(b3),
              Math.cos(a3) * sinh4(b3)
            );
          },
          /**
           * Calculate the cosine
           *
           * @returns {Complex}
           */
          "cos": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            return new Complex3(
              Math.cos(a3) * cosh4(b3),
              -Math.sin(a3) * sinh4(b3)
            );
          },
          /**
           * Calculate the tangent
           *
           * @returns {Complex}
           */
          "tan": function() {
            var a3 = 2 * this["re"];
            var b3 = 2 * this["im"];
            var d3 = Math.cos(a3) + cosh4(b3);
            return new Complex3(
              Math.sin(a3) / d3,
              sinh4(b3) / d3
            );
          },
          /**
           * Calculate the cotangent
           *
           * @returns {Complex}
           */
          "cot": function() {
            var a3 = 2 * this["re"];
            var b3 = 2 * this["im"];
            var d3 = Math.cos(a3) - cosh4(b3);
            return new Complex3(
              -Math.sin(a3) / d3,
              sinh4(b3) / d3
            );
          },
          /**
           * Calculate the secant
           *
           * @returns {Complex}
           */
          "sec": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var d3 = 0.5 * cosh4(2 * b3) + 0.5 * Math.cos(2 * a3);
            return new Complex3(
              Math.cos(a3) * cosh4(b3) / d3,
              Math.sin(a3) * sinh4(b3) / d3
            );
          },
          /**
           * Calculate the cosecans
           *
           * @returns {Complex}
           */
          "csc": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var d3 = 0.5 * cosh4(2 * b3) - 0.5 * Math.cos(2 * a3);
            return new Complex3(
              Math.sin(a3) * cosh4(b3) / d3,
              -Math.cos(a3) * sinh4(b3) / d3
            );
          },
          /**
           * Calculate the complex arcus sinus
           *
           * @returns {Complex}
           */
          "asin": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var t1 = new Complex3(
              b3 * b3 - a3 * a3 + 1,
              -2 * a3 * b3
            )["sqrt"]();
            var t22 = new Complex3(
              t1["re"] - b3,
              t1["im"] + a3
            )["log"]();
            return new Complex3(t22["im"], -t22["re"]);
          },
          /**
           * Calculate the complex arcus cosinus
           *
           * @returns {Complex}
           */
          "acos": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var t1 = new Complex3(
              b3 * b3 - a3 * a3 + 1,
              -2 * a3 * b3
            )["sqrt"]();
            var t22 = new Complex3(
              t1["re"] - b3,
              t1["im"] + a3
            )["log"]();
            return new Complex3(Math.PI / 2 - t22["im"], t22["re"]);
          },
          /**
           * Calculate the complex arcus tangent
           *
           * @returns {Complex}
           */
          "atan": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (a3 === 0) {
              if (b3 === 1) {
                return new Complex3(0, Infinity);
              }
              if (b3 === -1) {
                return new Complex3(0, -Infinity);
              }
            }
            var d3 = a3 * a3 + (1 - b3) * (1 - b3);
            var t1 = new Complex3(
              (1 - b3 * b3 - a3 * a3) / d3,
              -2 * a3 / d3
            ).log();
            return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
          },
          /**
           * Calculate the complex arcus cotangent
           *
           * @returns {Complex}
           */
          "acot": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (b3 === 0) {
              return new Complex3(Math.atan2(1, a3), 0);
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).atan() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).atan();
          },
          /**
           * Calculate the complex arcus secant
           *
           * @returns {Complex}
           */
          "asec": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (a3 === 0 && b3 === 0) {
              return new Complex3(0, Infinity);
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).acos() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).acos();
          },
          /**
           * Calculate the complex arcus cosecans
           *
           * @returns {Complex}
           */
          "acsc": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (a3 === 0 && b3 === 0) {
              return new Complex3(Math.PI / 2, Infinity);
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).asin() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).asin();
          },
          /**
           * Calculate the complex sinh
           *
           * @returns {Complex}
           */
          "sinh": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            return new Complex3(
              sinh4(a3) * Math.cos(b3),
              cosh4(a3) * Math.sin(b3)
            );
          },
          /**
           * Calculate the complex cosh
           *
           * @returns {Complex}
           */
          "cosh": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            return new Complex3(
              cosh4(a3) * Math.cos(b3),
              sinh4(a3) * Math.sin(b3)
            );
          },
          /**
           * Calculate the complex tanh
           *
           * @returns {Complex}
           */
          "tanh": function() {
            var a3 = 2 * this["re"];
            var b3 = 2 * this["im"];
            var d3 = cosh4(a3) + Math.cos(b3);
            return new Complex3(
              sinh4(a3) / d3,
              Math.sin(b3) / d3
            );
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          "coth": function() {
            var a3 = 2 * this["re"];
            var b3 = 2 * this["im"];
            var d3 = cosh4(a3) - Math.cos(b3);
            return new Complex3(
              sinh4(a3) / d3,
              -Math.sin(b3) / d3
            );
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          "csch": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var d3 = Math.cos(2 * b3) - cosh4(2 * a3);
            return new Complex3(
              -2 * sinh4(a3) * Math.cos(b3) / d3,
              2 * cosh4(a3) * Math.sin(b3) / d3
            );
          },
          /**
           * Calculate the complex sech
           *
           * @returns {Complex}
           */
          "sech": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var d3 = Math.cos(2 * b3) + cosh4(2 * a3);
            return new Complex3(
              2 * cosh4(a3) * Math.cos(b3) / d3,
              -2 * sinh4(a3) * Math.sin(b3) / d3
            );
          },
          /**
           * Calculate the complex asinh
           *
           * @returns {Complex}
           */
          "asinh": function() {
            var tmp = this["im"];
            this["im"] = -this["re"];
            this["re"] = tmp;
            var res = this["asin"]();
            this["re"] = -this["im"];
            this["im"] = tmp;
            tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
            return res;
          },
          /**
           * Calculate the complex acosh
           *
           * @returns {Complex}
           */
          "acosh": function() {
            var res = this["acos"]();
            if (res["im"] <= 0) {
              var tmp = res["re"];
              res["re"] = -res["im"];
              res["im"] = tmp;
            } else {
              var tmp = res["im"];
              res["im"] = -res["re"];
              res["re"] = tmp;
            }
            return res;
          },
          /**
           * Calculate the complex atanh
           *
           * @returns {Complex}
           */
          "atanh": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var noIM = a3 > 1 && b3 === 0;
            var oneMinus = 1 - a3;
            var onePlus = 1 + a3;
            var d3 = oneMinus * oneMinus + b3 * b3;
            var x4 = d3 !== 0 ? new Complex3(
              (onePlus * oneMinus - b3 * b3) / d3,
              (b3 * oneMinus + onePlus * b3) / d3
            ) : new Complex3(
              a3 !== -1 ? a3 / 0 : 0,
              b3 !== 0 ? b3 / 0 : 0
            );
            var temp = x4["re"];
            x4["re"] = logHypot(x4["re"], x4["im"]) / 2;
            x4["im"] = Math.atan2(x4["im"], temp) / 2;
            if (noIM) {
              x4["im"] = -x4["im"];
            }
            return x4;
          },
          /**
           * Calculate the complex acoth
           *
           * @returns {Complex}
           */
          "acoth": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (a3 === 0 && b3 === 0) {
              return new Complex3(0, Math.PI / 2);
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).atanh() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).atanh();
          },
          /**
           * Calculate the complex acsch
           *
           * @returns {Complex}
           */
          "acsch": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (b3 === 0) {
              return new Complex3(
                a3 !== 0 ? Math.log(a3 + Math.sqrt(a3 * a3 + 1)) : Infinity,
                0
              );
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).asinh() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).asinh();
          },
          /**
           * Calculate the complex asech
           *
           * @returns {Complex}
           */
          "asech": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            var d3 = a3 * a3 + b3 * b3;
            return d3 !== 0 ? new Complex3(
              a3 / d3,
              -b3 / d3
            ).acosh() : new Complex3(
              a3 !== 0 ? a3 / 0 : 0,
              b3 !== 0 ? -b3 / 0 : 0
            ).acosh();
          },
          /**
           * Calculate the complex inverse 1/z
           *
           * @returns {Complex}
           */
          "inverse": function() {
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            var a3 = this["re"];
            var b3 = this["im"];
            var d3 = a3 * a3 + b3 * b3;
            return new Complex3(a3 / d3, -b3 / d3);
          },
          /**
           * Returns the complex conjugate
           *
           * @returns {Complex}
           */
          "conjugate": function() {
            return new Complex3(this["re"], -this["im"]);
          },
          /**
           * Gets the negated complex number
           *
           * @returns {Complex}
           */
          "neg": function() {
            return new Complex3(-this["re"], -this["im"]);
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places
            );
          },
          /**
           * Floors the actual complex number
           *
           * @returns {Complex}
           */
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places
            );
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          "round": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places
            );
          },
          /**
           * Compares two complex numbers
           *
           * **Note:** new Complex(Infinity).equals(Infinity) === false
           *
           * @returns {boolean}
           */
          "equals": function(a3, b3) {
            var z5 = new Complex3(a3, b3);
            return Math.abs(z5["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z5["im"] - this["im"]) <= Complex3["EPSILON"];
          },
          /**
           * Clones the actual object
           *
           * @returns {Complex}
           */
          "clone": function() {
            return new Complex3(this["re"], this["im"]);
          },
          /**
           * Gets a string of the actual complex number
           *
           * @returns {string}
           */
          "toString": function() {
            var a3 = this["re"];
            var b3 = this["im"];
            var ret = "";
            if (this["isNaN"]()) {
              return "NaN";
            }
            if (this["isInfinite"]()) {
              return "Infinity";
            }
            if (Math.abs(a3) < Complex3["EPSILON"]) {
              a3 = 0;
            }
            if (Math.abs(b3) < Complex3["EPSILON"]) {
              b3 = 0;
            }
            if (b3 === 0) {
              return ret + a3;
            }
            if (a3 !== 0) {
              ret += a3;
              ret += " ";
              if (b3 < 0) {
                b3 = -b3;
                ret += "-";
              } else {
                ret += "+";
              }
              ret += " ";
            } else if (b3 < 0) {
              b3 = -b3;
              ret += "-";
            }
            if (1 !== b3) {
              ret += b3;
            }
            return ret + "i";
          },
          /**
           * Returns the actual number as a vector
           *
           * @returns {Array}
           */
          "toVector": function() {
            return [this["re"], this["im"]];
          },
          /**
           * Returns the actual real value of the current object
           *
           * @returns {number|null}
           */
          "valueOf": function() {
            if (this["im"] === 0) {
              return this["re"];
            }
            return null;
          },
          /**
           * Determines whether a complex number is not on the Riemann sphere.
           *
           * @returns {boolean}
           */
          "isNaN": function() {
            return isNaN(this["re"]) || isNaN(this["im"]);
          },
          /**
           * Determines whether or not a complex number is at the zero pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isZero": function() {
            return this["im"] === 0 && this["re"] === 0;
          },
          /**
           * Determines whether a complex number is not at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isFinite": function() {
            return isFinite(this["re"]) && isFinite(this["im"]);
          },
          /**
           * Determines whether or not a complex number is at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isInfinite": function() {
            return !(this["isNaN"]() || this["isFinite"]());
          }
        };
        Complex3["ZERO"] = new Complex3(0, 0);
        Complex3["ONE"] = new Complex3(1, 0);
        Complex3["I"] = new Complex3(0, 1);
        Complex3["PI"] = new Complex3(Math.PI, 0);
        Complex3["E"] = new Complex3(Math.E, 0);
        Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
        Complex3["NAN"] = new Complex3(NaN, NaN);
        Complex3["EPSILON"] = 1e-15;
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Complex3;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Complex3, "__esModule", { "value": true });
          Complex3["default"] = Complex3;
          Complex3["Complex"] = Complex3;
          module["exports"] = Complex3;
        } else {
          root["Complex"] = Complex3;
        }
      })(exports);
    }
  });

  // node_modules/mathjs/lib/esm/type/complex/Complex.js
  var import_complex, name3, dependencies4, createComplexClass;
  var init_Complex = __esm({
    "node_modules/mathjs/lib/esm/type/complex/Complex.js"() {
      import_complex = __toESM(require_complex(), 1);
      init_number();
      init_is();
      init_factory();
      name3 = "Complex";
      dependencies4 = [];
      createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
        Object.defineProperty(import_complex.default, "name", {
          value: "Complex"
        });
        import_complex.default.prototype.constructor = import_complex.default;
        import_complex.default.prototype.type = "Complex";
        import_complex.default.prototype.isComplex = true;
        import_complex.default.prototype.toJSON = function() {
          return {
            mathjs: "Complex",
            re: this.re,
            im: this.im
          };
        };
        import_complex.default.prototype.toPolar = function() {
          return {
            r: this.abs(),
            phi: this.arg()
          };
        };
        import_complex.default.prototype.format = function(options) {
          var str = "";
          var im2 = this.im;
          var re2 = this.re;
          var strRe = format(this.re, options);
          var strIm = format(this.im, options);
          var precision = isNumber(options) ? options : options ? options.precision : null;
          if (precision !== null) {
            var epsilon = Math.pow(10, -precision);
            if (Math.abs(re2 / im2) < epsilon) {
              re2 = 0;
            }
            if (Math.abs(im2 / re2) < epsilon) {
              im2 = 0;
            }
          }
          if (im2 === 0) {
            str = strRe;
          } else if (re2 === 0) {
            if (im2 === 1) {
              str = "i";
            } else if (im2 === -1) {
              str = "-i";
            } else {
              str = strIm + "i";
            }
          } else {
            if (im2 < 0) {
              if (im2 === -1) {
                str = strRe + " - i";
              } else {
                str = strRe + " - " + strIm.substring(1) + "i";
              }
            } else {
              if (im2 === 1) {
                str = strRe + " + i";
              } else {
                str = strRe + " + " + strIm + "i";
              }
            }
          }
          return str;
        };
        import_complex.default.fromPolar = function(args) {
          switch (arguments.length) {
            case 1: {
              var arg2 = arguments[0];
              if (typeof arg2 === "object") {
                return (0, import_complex.default)(arg2);
              } else {
                throw new TypeError("Input has to be an object with r and phi keys.");
              }
            }
            case 2: {
              var r3 = arguments[0];
              var phi3 = arguments[1];
              if (isNumber(r3)) {
                if (isUnit(phi3) && phi3.hasBase("ANGLE")) {
                  phi3 = phi3.toNumber("rad");
                }
                if (isNumber(phi3)) {
                  return new import_complex.default({
                    r: r3,
                    phi: phi3
                  });
                }
                throw new TypeError("Phi is not a number nor an angle unit.");
              } else {
                throw new TypeError("Radius r is not a number.");
              }
            }
            default:
              throw new SyntaxError("Wrong number of arguments in function fromPolar");
          }
        };
        import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
        import_complex.default.fromJSON = function(json) {
          return new import_complex.default(json);
        };
        import_complex.default.compare = function(a3, b3) {
          if (a3.re > b3.re) {
            return 1;
          }
          if (a3.re < b3.re) {
            return -1;
          }
          if (a3.im > b3.im) {
            return 1;
          }
          if (a3.im < b3.im) {
            return -1;
          }
          return 0;
        };
        return import_complex.default;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS({
    "node_modules/fraction.js/fraction.js"(exports, module) {
      (function(root) {
        "use strict";
        var MAX_CYCLE_LEN = 2e3;
        var P6 = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign2(n3, s3) {
          if (isNaN(n3 = parseInt(n3, 10))) {
            throw Fraction3["InvalidParameter"];
          }
          return n3 * s3;
        }
        function newFraction(n3, d3) {
          if (d3 === 0) {
            throw Fraction3["DivisionByZero"];
          }
          var f3 = Object.create(Fraction3.prototype);
          f3["s"] = n3 < 0 ? -1 : 1;
          n3 = n3 < 0 ? -n3 : n3;
          var a3 = gcd2(n3, d3);
          f3["n"] = n3 / a3;
          f3["d"] = d3 / a3;
          return f3;
        }
        function factorize(num) {
          var factors = {};
          var n3 = num;
          var i5 = 2;
          var s3 = 4;
          while (s3 <= n3) {
            while (n3 % i5 === 0) {
              n3 /= i5;
              factors[i5] = (factors[i5] || 0) + 1;
            }
            s3 += 1 + 2 * i5++;
          }
          if (n3 !== num) {
            if (n3 > 1)
              factors[n3] = (factors[n3] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse2 = function(p1, p22) {
          var n3 = 0, d3 = 1, s3 = 1;
          var v3 = 0, w4 = 0, x4 = 0, y3 = 1, z5 = 1;
          var A4 = 0, B4 = 1;
          var C3 = 1, D3 = 1;
          var N3 = 1e7;
          var M3;
          if (p1 === void 0 || p1 === null) {
          } else if (p22 !== void 0) {
            n3 = p1;
            d3 = p22;
            s3 = n3 * d3;
            if (n3 % 1 !== 0 || d3 % 1 !== 0) {
              throw Fraction3["NonIntegerParameter"];
            }
          } else
            switch (typeof p1) {
              case "object": {
                if ("d" in p1 && "n" in p1) {
                  n3 = p1["n"];
                  d3 = p1["d"];
                  if ("s" in p1)
                    n3 *= p1["s"];
                } else if (0 in p1) {
                  n3 = p1[0];
                  if (1 in p1)
                    d3 = p1[1];
                } else {
                  throw Fraction3["InvalidParameter"];
                }
                s3 = n3 * d3;
                break;
              }
              case "number": {
                if (p1 < 0) {
                  s3 = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n3 = p1;
                } else if (p1 > 0) {
                  if (p1 >= 1) {
                    z5 = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z5;
                  }
                  while (B4 <= N3 && D3 <= N3) {
                    M3 = (A4 + C3) / (B4 + D3);
                    if (p1 === M3) {
                      if (B4 + D3 <= N3) {
                        n3 = A4 + C3;
                        d3 = B4 + D3;
                      } else if (D3 > B4) {
                        n3 = C3;
                        d3 = D3;
                      } else {
                        n3 = A4;
                        d3 = B4;
                      }
                      break;
                    } else {
                      if (p1 > M3) {
                        A4 += C3;
                        B4 += D3;
                      } else {
                        C3 += A4;
                        D3 += B4;
                      }
                      if (B4 > N3) {
                        n3 = C3;
                        d3 = D3;
                      } else {
                        n3 = A4;
                        d3 = B4;
                      }
                    }
                  }
                  n3 *= z5;
                } else if (isNaN(p1) || isNaN(p22)) {
                  d3 = n3 = NaN;
                }
                break;
              }
              case "string": {
                B4 = p1.match(/\d+|./g);
                if (B4 === null)
                  throw Fraction3["InvalidParameter"];
                if (B4[A4] === "-") {
                  s3 = -1;
                  A4++;
                } else if (B4[A4] === "+") {
                  A4++;
                }
                if (B4.length === A4 + 1) {
                  w4 = assign2(B4[A4++], s3);
                } else if (B4[A4 + 1] === "." || B4[A4] === ".") {
                  if (B4[A4] !== ".") {
                    v3 = assign2(B4[A4++], s3);
                  }
                  A4++;
                  if (A4 + 1 === B4.length || B4[A4 + 1] === "(" && B4[A4 + 3] === ")" || B4[A4 + 1] === "'" && B4[A4 + 3] === "'") {
                    w4 = assign2(B4[A4], s3);
                    y3 = Math.pow(10, B4[A4].length);
                    A4++;
                  }
                  if (B4[A4] === "(" && B4[A4 + 2] === ")" || B4[A4] === "'" && B4[A4 + 2] === "'") {
                    x4 = assign2(B4[A4 + 1], s3);
                    z5 = Math.pow(10, B4[A4 + 1].length) - 1;
                    A4 += 3;
                  }
                } else if (B4[A4 + 1] === "/" || B4[A4 + 1] === ":") {
                  w4 = assign2(B4[A4], s3);
                  y3 = assign2(B4[A4 + 2], 1);
                  A4 += 3;
                } else if (B4[A4 + 3] === "/" && B4[A4 + 1] === " ") {
                  v3 = assign2(B4[A4], s3);
                  w4 = assign2(B4[A4 + 2], s3);
                  y3 = assign2(B4[A4 + 4], 1);
                  A4 += 5;
                }
                if (B4.length <= A4) {
                  d3 = y3 * z5;
                  s3 = /* void */
                  n3 = x4 + d3 * v3 + z5 * w4;
                  break;
                }
              }
              default:
                throw Fraction3["InvalidParameter"];
            }
          if (d3 === 0) {
            throw Fraction3["DivisionByZero"];
          }
          P6["s"] = s3 < 0 ? -1 : 1;
          P6["n"] = Math.abs(n3);
          P6["d"] = Math.abs(d3);
        };
        function modpow(b3, e6, m3) {
          var r3 = 1;
          for (; e6 > 0; b3 = b3 * b3 % m3, e6 >>= 1) {
            if (e6 & 1) {
              r3 = r3 * b3 % m3;
            }
          }
          return r3;
        }
        function cycleLen(n3, d3) {
          for (; d3 % 2 === 0; d3 /= 2) {
          }
          for (; d3 % 5 === 0; d3 /= 5) {
          }
          if (d3 === 1)
            return 0;
          var rem = 10 % d3;
          var t3 = 1;
          for (; rem !== 1; t3++) {
            rem = rem * 10 % d3;
            if (t3 > MAX_CYCLE_LEN)
              return 0;
          }
          return t3;
        }
        function cycleStart(n3, d3, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d3);
          for (var t3 = 0; t3 < 300; t3++) {
            if (rem1 === rem2)
              return t3;
            rem1 = rem1 * 10 % d3;
            rem2 = rem2 * 10 % d3;
          }
          return 0;
        }
        function gcd2(a3, b3) {
          if (!a3)
            return b3;
          if (!b3)
            return a3;
          while (1) {
            a3 %= b3;
            if (!a3)
              return b3;
            b3 %= a3;
            if (!b3)
              return a3;
          }
        }
        ;
        function Fraction3(a3, b3) {
          parse2(a3, b3);
          if (this instanceof Fraction3) {
            a3 = gcd2(P6["d"], P6["n"]);
            this["s"] = P6["s"];
            this["n"] = P6["n"] / a3;
            this["d"] = P6["d"] / a3;
          } else {
            return newFraction(P6["s"] * P6["n"], P6["d"]);
          }
        }
        Fraction3["DivisionByZero"] = new Error("Division by Zero");
        Fraction3["InvalidParameter"] = new Error("Invalid argument");
        Fraction3["NonIntegerParameter"] = new Error("Parameters must be integer");
        Fraction3.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          /**
           * Calculates the absolute value
           *
           * Ex: new Fraction(-4).abs() => 4
           **/
          "abs": function() {
            return newFraction(this["n"], this["d"]);
          },
          /**
           * Inverts the sign of the current fraction
           *
           * Ex: new Fraction(-4).neg() => 4
           **/
          "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          /**
           * Adds two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
           **/
          "add": function(a3, b3) {
            parse2(a3, b3);
            return newFraction(
              this["s"] * this["n"] * P6["d"] + P6["s"] * this["d"] * P6["n"],
              this["d"] * P6["d"]
            );
          },
          /**
           * Subtracts two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
           **/
          "sub": function(a3, b3) {
            parse2(a3, b3);
            return newFraction(
              this["s"] * this["n"] * P6["d"] - P6["s"] * this["d"] * P6["n"],
              this["d"] * P6["d"]
            );
          },
          /**
           * Multiplies two rational numbers
           *
           * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
           **/
          "mul": function(a3, b3) {
            parse2(a3, b3);
            return newFraction(
              this["s"] * P6["s"] * this["n"] * P6["n"],
              this["d"] * P6["d"]
            );
          },
          /**
           * Divides two rational numbers
           *
           * Ex: new Fraction("-17.(345)").inverse().div(3)
           **/
          "div": function(a3, b3) {
            parse2(a3, b3);
            return newFraction(
              this["s"] * P6["s"] * this["n"] * P6["d"],
              this["d"] * P6["n"]
            );
          },
          /**
           * Clones the actual object
           *
           * Ex: new Fraction("-17.(345)").clone()
           **/
          "clone": function() {
            return newFraction(this["s"] * this["n"], this["d"]);
          },
          /**
           * Calculates the modulo of two rational numbers - a more precise fmod
           *
           * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
           **/
          "mod": function(a3, b3) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            if (a3 === void 0) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse2(a3, b3);
            if (0 === P6["n"] && 0 === this["d"]) {
              throw Fraction3["DivisionByZero"];
            }
            return newFraction(
              this["s"] * (P6["d"] * this["n"]) % (P6["n"] * this["d"]),
              P6["d"] * this["d"]
            );
          },
          /**
           * Calculates the fractional gcd of two rational numbers
           *
           * Ex: new Fraction(5,8).gcd(3,7) => 1/56
           */
          "gcd": function(a3, b3) {
            parse2(a3, b3);
            return newFraction(gcd2(P6["n"], this["n"]) * gcd2(P6["d"], this["d"]), P6["d"] * this["d"]);
          },
          /**
           * Calculates the fractional lcm of two rational numbers
           *
           * Ex: new Fraction(5,8).lcm(3,7) => 15
           */
          "lcm": function(a3, b3) {
            parse2(a3, b3);
            if (P6["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P6["n"] * this["n"], gcd2(P6["n"], this["n"]) * gcd2(P6["d"], this["d"]));
          },
          /**
           * Calculates the ceil of a rational number
           *
           * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
           **/
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Calculates the floor of a rational number
           *
           * Ex: new Fraction('4.(3)').floor() => (4 / 1)
           **/
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Rounds a rational numbers
           *
           * Ex: new Fraction('4.(3)').round() => (4 / 1)
           **/
          "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Gets the inverse of the fraction, means numerator and denominator are exchanged
           *
           * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
           **/
          "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          /**
           * Calculates the fraction to some rational exponent, if possible
           *
           * Ex: new Fraction(-1,2).pow(-3) => -8
           */
          "pow": function(a3, b3) {
            parse2(a3, b3);
            if (P6["d"] === 1) {
              if (P6["s"] < 0) {
                return newFraction(Math.pow(this["s"] * this["d"], P6["n"]), Math.pow(this["n"], P6["n"]));
              } else {
                return newFraction(Math.pow(this["s"] * this["n"], P6["n"]), Math.pow(this["d"], P6["n"]));
              }
            }
            if (this["s"] < 0)
              return null;
            var N3 = factorize(this["n"]);
            var D3 = factorize(this["d"]);
            var n3 = 1;
            var d3 = 1;
            for (var k4 in N3) {
              if (k4 === "1")
                continue;
              if (k4 === "0") {
                n3 = 0;
                break;
              }
              N3[k4] *= P6["n"];
              if (N3[k4] % P6["d"] === 0) {
                N3[k4] /= P6["d"];
              } else
                return null;
              n3 *= Math.pow(k4, N3[k4]);
            }
            for (var k4 in D3) {
              if (k4 === "1")
                continue;
              D3[k4] *= P6["n"];
              if (D3[k4] % P6["d"] === 0) {
                D3[k4] /= P6["d"];
              } else
                return null;
              d3 *= Math.pow(k4, D3[k4]);
            }
            if (P6["s"] < 0) {
              return newFraction(d3, n3);
            }
            return newFraction(n3, d3);
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "equals": function(a3, b3) {
            parse2(a3, b3);
            return this["s"] * this["n"] * P6["d"] === P6["s"] * P6["n"] * this["d"];
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "compare": function(a3, b3) {
            parse2(a3, b3);
            var t3 = this["s"] * this["n"] * P6["d"] - P6["s"] * P6["n"] * this["d"];
            return (0 < t3) - (t3 < 0);
          },
          "simplify": function(eps) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return this;
            }
            eps = eps || 1e-3;
            var thisABS = this["abs"]();
            var cont = thisABS["toContinued"]();
            for (var i5 = 1; i5 < cont.length; i5++) {
              var s3 = newFraction(cont[i5 - 1], 1);
              for (var k4 = i5 - 2; k4 >= 0; k4--) {
                s3 = s3["inverse"]()["add"](cont[k4]);
              }
              if (s3["sub"](thisABS)["abs"]().valueOf() < eps) {
                return s3["mul"](this["s"]);
              }
            }
            return this;
          },
          /**
           * Check if two rational numbers are divisible
           *
           * Ex: new Fraction(19.6).divisible(1.5);
           */
          "divisible": function(a3, b3) {
            parse2(a3, b3);
            return !(!(P6["n"] * this["d"]) || this["n"] * P6["d"] % (P6["n"] * this["d"]));
          },
          /**
           * Returns a decimal representation of the fraction
           *
           * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
           **/
          "valueOf": function() {
            return this["s"] * this["n"] / this["d"];
          },
          /**
           * Returns a string-fraction representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
           **/
          "toFraction": function(excludeWhole) {
            var whole, str = "";
            var n3 = this["n"];
            var d3 = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d3 === 1) {
              str += n3;
            } else {
              if (excludeWhole && (whole = Math.floor(n3 / d3)) > 0) {
                str += whole;
                str += " ";
                n3 %= d3;
              }
              str += n3;
              str += "/";
              str += d3;
            }
            return str;
          },
          /**
           * Returns a latex representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
           **/
          "toLatex": function(excludeWhole) {
            var whole, str = "";
            var n3 = this["n"];
            var d3 = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d3 === 1) {
              str += n3;
            } else {
              if (excludeWhole && (whole = Math.floor(n3 / d3)) > 0) {
                str += whole;
                n3 %= d3;
              }
              str += "\\frac{";
              str += n3;
              str += "}{";
              str += d3;
              str += "}";
            }
            return str;
          },
          /**
           * Returns an array of continued fraction elements
           *
           * Ex: new Fraction("7/8").toContinued() => [0,1,7]
           */
          "toContinued": function() {
            var t3;
            var a3 = this["n"];
            var b3 = this["d"];
            var res = [];
            if (isNaN(a3) || isNaN(b3)) {
              return res;
            }
            do {
              res.push(Math.floor(a3 / b3));
              t3 = a3 % b3;
              a3 = b3;
              b3 = t3;
            } while (a3 !== 1);
            return res;
          },
          /**
           * Creates a string representation of a fraction with all digits
           *
           * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
           **/
          "toString": function(dec) {
            var N3 = this["n"];
            var D3 = this["d"];
            if (isNaN(N3) || isNaN(D3)) {
              return "NaN";
            }
            dec = dec || 15;
            var cycLen = cycleLen(N3, D3);
            var cycOff = cycleStart(N3, D3, cycLen);
            var str = this["s"] < 0 ? "-" : "";
            str += N3 / D3 | 0;
            N3 %= D3;
            N3 *= 10;
            if (N3)
              str += ".";
            if (cycLen) {
              for (var i5 = cycOff; i5--; ) {
                str += N3 / D3 | 0;
                N3 %= D3;
                N3 *= 10;
              }
              str += "(";
              for (var i5 = cycLen; i5--; ) {
                str += N3 / D3 | 0;
                N3 %= D3;
                N3 *= 10;
              }
              str += ")";
            } else {
              for (var i5 = dec; N3 && i5--; ) {
                str += N3 / D3 | 0;
                N3 %= D3;
                N3 *= 10;
              }
            }
            return str;
          }
        };
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Fraction3;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Fraction3, "__esModule", { "value": true });
          Fraction3["default"] = Fraction3;
          Fraction3["Fraction"] = Fraction3;
          module["exports"] = Fraction3;
        } else {
          root["Fraction"] = Fraction3;
        }
      })(exports);
    }
  });

  // node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction, name4, dependencies5, createFractionClass;
  var init_Fraction = __esm({
    "node_modules/mathjs/lib/esm/type/fraction/Fraction.js"() {
      import_fraction = __toESM(require_fraction(), 1);
      init_factory();
      name4 = "Fraction";
      dependencies5 = [];
      createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
        Object.defineProperty(import_fraction.default, "name", {
          value: "Fraction"
        });
        import_fraction.default.prototype.constructor = import_fraction.default;
        import_fraction.default.prototype.type = "Fraction";
        import_fraction.default.prototype.isFraction = true;
        import_fraction.default.prototype.toJSON = function() {
          return {
            mathjs: "Fraction",
            n: this.s * this.n,
            d: this.d
          };
        };
        import_fraction.default.fromJSON = function(json) {
          return new import_fraction.default(json);
        };
        return import_fraction.default;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/Range.js
  var name5, dependencies6, createRangeClass;
  var init_Range = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/Range.js"() {
      init_is();
      init_number();
      init_factory();
      name5 = "Range";
      dependencies6 = [];
      createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
        function Range2(start, end, step) {
          if (!(this instanceof Range2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          var hasStart = start !== null && start !== void 0;
          var hasEnd = end !== null && end !== void 0;
          var hasStep = step !== null && step !== void 0;
          if (hasStart) {
            if (isBigNumber(start)) {
              start = start.toNumber();
            } else if (typeof start !== "number") {
              throw new TypeError("Parameter start must be a number");
            }
          }
          if (hasEnd) {
            if (isBigNumber(end)) {
              end = end.toNumber();
            } else if (typeof end !== "number") {
              throw new TypeError("Parameter end must be a number");
            }
          }
          if (hasStep) {
            if (isBigNumber(step)) {
              step = step.toNumber();
            } else if (typeof step !== "number") {
              throw new TypeError("Parameter step must be a number");
            }
          }
          this.start = hasStart ? parseFloat(start) : 0;
          this.end = hasEnd ? parseFloat(end) : 0;
          this.step = hasStep ? parseFloat(step) : 1;
        }
        Range2.prototype.type = "Range";
        Range2.prototype.isRange = true;
        Range2.parse = function(str) {
          if (typeof str !== "string") {
            return null;
          }
          var args = str.split(":");
          var nums = args.map(function(arg2) {
            return parseFloat(arg2);
          });
          var invalid = nums.some(function(num) {
            return isNaN(num);
          });
          if (invalid) {
            return null;
          }
          switch (nums.length) {
            case 2:
              return new Range2(nums[0], nums[1]);
            case 3:
              return new Range2(nums[0], nums[2], nums[1]);
            default:
              return null;
          }
        };
        Range2.prototype.clone = function() {
          return new Range2(this.start, this.end, this.step);
        };
        Range2.prototype.size = function() {
          var len = 0;
          var start = this.start;
          var step = this.step;
          var end = this.end;
          var diff2 = end - start;
          if (sign(step) === sign(diff2)) {
            len = Math.ceil(diff2 / step);
          } else if (diff2 === 0) {
            len = 0;
          }
          if (isNaN(len)) {
            len = 0;
          }
          return [len];
        };
        Range2.prototype.min = function() {
          var size2 = this.size()[0];
          if (size2 > 0) {
            if (this.step > 0) {
              return this.start;
            } else {
              return this.start + (size2 - 1) * this.step;
            }
          } else {
            return void 0;
          }
        };
        Range2.prototype.max = function() {
          var size2 = this.size()[0];
          if (size2 > 0) {
            if (this.step > 0) {
              return this.start + (size2 - 1) * this.step;
            } else {
              return this.start;
            }
          } else {
            return void 0;
          }
        };
        Range2.prototype.forEach = function(callback) {
          var x4 = this.start;
          var step = this.step;
          var end = this.end;
          var i5 = 0;
          if (step > 0) {
            while (x4 < end) {
              callback(x4, [i5], this);
              x4 += step;
              i5++;
            }
          } else if (step < 0) {
            while (x4 > end) {
              callback(x4, [i5], this);
              x4 += step;
              i5++;
            }
          }
        };
        Range2.prototype.map = function(callback) {
          var array = [];
          this.forEach(function(value, index2, obj) {
            array[index2[0]] = callback(value, index2, obj);
          });
          return array;
        };
        Range2.prototype.toArray = function() {
          var array = [];
          this.forEach(function(value, index2) {
            array[index2[0]] = value;
          });
          return array;
        };
        Range2.prototype.valueOf = function() {
          return this.toArray();
        };
        Range2.prototype.format = function(options) {
          var str = format(this.start, options);
          if (this.step !== 1) {
            str += ":" + format(this.step, options);
          }
          str += ":" + format(this.end, options);
          return str;
        };
        Range2.prototype.toString = function() {
          return this.format();
        };
        Range2.prototype.toJSON = function() {
          return {
            mathjs: "Range",
            start: this.start,
            end: this.end,
            step: this.step
          };
        };
        Range2.fromJSON = function(json) {
          return new Range2(json.start, json.end, json.step);
        };
        return Range2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name6, dependencies7, createMatrixClass;
  var init_Matrix = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/Matrix.js"() {
      init_factory();
      name6 = "Matrix";
      dependencies7 = [];
      createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
        function Matrix2() {
          if (!(this instanceof Matrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
        }
        Matrix2.prototype.type = "Matrix";
        Matrix2.prototype.isMatrix = true;
        Matrix2.prototype.storage = function() {
          throw new Error("Cannot invoke storage on a Matrix interface");
        };
        Matrix2.prototype.datatype = function() {
          throw new Error("Cannot invoke datatype on a Matrix interface");
        };
        Matrix2.prototype.create = function(data, datatype) {
          throw new Error("Cannot invoke create on a Matrix interface");
        };
        Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
          throw new Error("Cannot invoke subset on a Matrix interface");
        };
        Matrix2.prototype.get = function(index2) {
          throw new Error("Cannot invoke get on a Matrix interface");
        };
        Matrix2.prototype.set = function(index2, value, defaultValue) {
          throw new Error("Cannot invoke set on a Matrix interface");
        };
        Matrix2.prototype.resize = function(size2, defaultValue) {
          throw new Error("Cannot invoke resize on a Matrix interface");
        };
        Matrix2.prototype.reshape = function(size2, defaultValue) {
          throw new Error("Cannot invoke reshape on a Matrix interface");
        };
        Matrix2.prototype.clone = function() {
          throw new Error("Cannot invoke clone on a Matrix interface");
        };
        Matrix2.prototype.size = function() {
          throw new Error("Cannot invoke size on a Matrix interface");
        };
        Matrix2.prototype.map = function(callback, skipZeros) {
          throw new Error("Cannot invoke map on a Matrix interface");
        };
        Matrix2.prototype.forEach = function(callback) {
          throw new Error("Cannot invoke forEach on a Matrix interface");
        };
        Matrix2.prototype[Symbol.iterator] = function() {
          throw new Error("Cannot iterate a Matrix interface");
        };
        Matrix2.prototype.toArray = function() {
          throw new Error("Cannot invoke toArray on a Matrix interface");
        };
        Matrix2.prototype.valueOf = function() {
          throw new Error("Cannot invoke valueOf on a Matrix interface");
        };
        Matrix2.prototype.format = function(options) {
          throw new Error("Cannot invoke format on a Matrix interface");
        };
        Matrix2.prototype.toString = function() {
          throw new Error("Cannot invoke toString on a Matrix interface");
        };
        return Matrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/lruQueue.js
  function lruQueue(limit) {
    var size2 = 0;
    var base = 1;
    var queue = /* @__PURE__ */ Object.create(null);
    var map3 = /* @__PURE__ */ Object.create(null);
    var index2 = 0;
    var del = function del2(id) {
      var oldIndex = map3[id];
      if (!oldIndex)
        return;
      delete queue[oldIndex];
      delete map3[id];
      --size2;
      if (base !== oldIndex)
        return;
      if (!size2) {
        index2 = 0;
        base = 1;
        return;
      }
      while (!hasOwnProperty.call(queue, ++base))
        continue;
    };
    limit = Math.abs(limit);
    return {
      hit: function hit(id) {
        var oldIndex = map3[id];
        var nuIndex = ++index2;
        queue[nuIndex] = id;
        map3[id] = nuIndex;
        if (!oldIndex) {
          ++size2;
          if (size2 <= limit)
            return void 0;
          id = queue[base];
          del(id);
          return id;
        }
        delete queue[oldIndex];
        if (base !== oldIndex)
          return void 0;
        while (!hasOwnProperty.call(queue, ++base))
          continue;
        return void 0;
      },
      delete: del,
      clear: function clear() {
        size2 = index2 = 0;
        base = 1;
        queue = /* @__PURE__ */ Object.create(null);
        map3 = /* @__PURE__ */ Object.create(null);
      }
    };
  }
  var init_lruQueue = __esm({
    "node_modules/mathjs/lib/esm/utils/lruQueue.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/utils/function.js
  function memoize(fn2) {
    var {
      hasher: hasher2,
      limit
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    limit = limit == null ? Number.POSITIVE_INFINITY : limit;
    hasher2 = hasher2 == null ? JSON.stringify : hasher2;
    return function memoize2() {
      if (typeof memoize2.cache !== "object") {
        memoize2.cache = {
          values: /* @__PURE__ */ new Map(),
          lru: lruQueue(limit || Number.POSITIVE_INFINITY)
        };
      }
      var args = [];
      for (var i5 = 0; i5 < arguments.length; i5++) {
        args[i5] = arguments[i5];
      }
      var hash = hasher2(args);
      if (memoize2.cache.values.has(hash)) {
        memoize2.cache.lru.hit(hash);
        return memoize2.cache.values.get(hash);
      }
      var newVal = fn2.apply(fn2, args);
      memoize2.cache.values.set(hash, newVal);
      memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
      return newVal;
    };
  }
  function maxArgumentCount(fn2) {
    return Object.keys(fn2.signatures || {}).reduce(function(args, signature) {
      var count2 = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count2);
    }, -1);
  }
  var init_function = __esm({
    "node_modules/mathjs/lib/esm/utils/function.js"() {
      init_lruQueue();
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name7, dependencies8, createDenseMatrixClass;
  var init_DenseMatrix = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js"() {
      init_is();
      init_array();
      init_string();
      init_number();
      init_object();
      init_DimensionError();
      init_factory();
      init_function();
      name7 = "DenseMatrix";
      dependencies8 = ["Matrix"];
      createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
        var {
          Matrix: Matrix2
        } = _ref;
        function DenseMatrix2(data, datatype) {
          if (!(this instanceof DenseMatrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !isString(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if (isMatrix(data)) {
            if (data.type === "DenseMatrix") {
              this._data = clone(data._data);
              this._size = clone(data._size);
              this._datatype = datatype || data._datatype;
            } else {
              this._data = data.toArray();
              this._size = data.size();
              this._datatype = datatype || data._datatype;
            }
          } else if (data && isArray(data.data) && isArray(data.size)) {
            this._data = data.data;
            this._size = data.size;
            validate(this._data, this._size);
            this._datatype = datatype || data.datatype;
          } else if (isArray(data)) {
            this._data = preprocess(data);
            this._size = arraySize(this._data);
            validate(this._data, this._size);
            this._datatype = datatype;
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
          } else {
            this._data = [];
            this._size = [0];
            this._datatype = datatype;
          }
        }
        DenseMatrix2.prototype = new Matrix2();
        DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
          return new DenseMatrix2(data, datatype);
        };
        Object.defineProperty(DenseMatrix2, "name", {
          value: "DenseMatrix"
        });
        DenseMatrix2.prototype.constructor = DenseMatrix2;
        DenseMatrix2.prototype.type = "DenseMatrix";
        DenseMatrix2.prototype.isDenseMatrix = true;
        DenseMatrix2.prototype.getDataType = function() {
          return getArrayDataType(this._data, typeOf);
        };
        DenseMatrix2.prototype.storage = function() {
          return "dense";
        };
        DenseMatrix2.prototype.datatype = function() {
          return this._datatype;
        };
        DenseMatrix2.prototype.create = function(data, datatype) {
          return new DenseMatrix2(data, datatype);
        };
        DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
          switch (arguments.length) {
            case 1:
              return _get(this, index2);
            case 2:
            case 3:
              return _set(this, index2, replacement, defaultValue);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        DenseMatrix2.prototype.get = function(index2) {
          if (!isArray(index2)) {
            throw new TypeError("Array expected");
          }
          if (index2.length !== this._size.length) {
            throw new DimensionError(index2.length, this._size.length);
          }
          for (var x4 = 0; x4 < index2.length; x4++) {
            validateIndex(index2[x4], this._size[x4]);
          }
          var data = this._data;
          for (var i5 = 0, ii = index2.length; i5 < ii; i5++) {
            var indexI = index2[i5];
            validateIndex(indexI, data.length);
            data = data[indexI];
          }
          return data;
        };
        DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
          if (!isArray(index2)) {
            throw new TypeError("Array expected");
          }
          if (index2.length < this._size.length) {
            throw new DimensionError(index2.length, this._size.length, "<");
          }
          var i5, ii, indexI;
          var size2 = index2.map(function(i6) {
            return i6 + 1;
          });
          _fit(this, size2, defaultValue);
          var data = this._data;
          for (i5 = 0, ii = index2.length - 1; i5 < ii; i5++) {
            indexI = index2[i5];
            validateIndex(indexI, data.length);
            data = data[indexI];
          }
          indexI = index2[index2.length - 1];
          validateIndex(indexI, data.length);
          data[indexI] = value;
          return this;
        };
        function _get(matrix2, index2) {
          if (!isIndex(index2)) {
            throw new TypeError("Invalid index");
          }
          var isScalar = index2.isScalar();
          if (isScalar) {
            return matrix2.get(index2.min());
          } else {
            var size2 = index2.size();
            if (size2.length !== matrix2._size.length) {
              throw new DimensionError(size2.length, matrix2._size.length);
            }
            var min3 = index2.min();
            var max3 = index2.max();
            for (var i5 = 0, ii = matrix2._size.length; i5 < ii; i5++) {
              validateIndex(min3[i5], matrix2._size[i5]);
              validateIndex(max3[i5], matrix2._size[i5]);
            }
            return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
          }
        }
        function _getSubmatrix(data, index2, dims, dim) {
          var last = dim === dims - 1;
          var range2 = index2.dimension(dim);
          if (last) {
            return range2.map(function(i5) {
              validateIndex(i5, data.length);
              return data[i5];
            }).valueOf();
          } else {
            return range2.map(function(i5) {
              validateIndex(i5, data.length);
              var child = data[i5];
              return _getSubmatrix(child, index2, dims, dim + 1);
            }).valueOf();
          }
        }
        function _set(matrix2, index2, submatrix, defaultValue) {
          if (!index2 || index2.isIndex !== true) {
            throw new TypeError("Invalid index");
          }
          var iSize = index2.size();
          var isScalar = index2.isScalar();
          var sSize;
          if (isMatrix(submatrix)) {
            sSize = submatrix.size();
            submatrix = submatrix.valueOf();
          } else {
            sSize = arraySize(submatrix);
          }
          if (isScalar) {
            if (sSize.length !== 0) {
              throw new TypeError("Scalar expected");
            }
            matrix2.set(index2.min(), submatrix, defaultValue);
          } else {
            if (!deepStrictEqual(sSize, iSize)) {
              try {
                if (sSize.length === 0) {
                  submatrix = broadcastTo([submatrix], iSize);
                } else {
                  submatrix = broadcastTo(submatrix, iSize);
                }
                sSize = arraySize(submatrix);
              } catch (_unused) {
              }
            }
            if (iSize.length < matrix2._size.length) {
              throw new DimensionError(iSize.length, matrix2._size.length, "<");
            }
            if (sSize.length < iSize.length) {
              var i5 = 0;
              var outer = 0;
              while (iSize[i5] === 1 && sSize[i5] === 1) {
                i5++;
              }
              while (iSize[i5] === 1) {
                outer++;
                i5++;
              }
              submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
            }
            if (!deepStrictEqual(iSize, sSize)) {
              throw new DimensionError(iSize, sSize, ">");
            }
            var size2 = index2.max().map(function(i6) {
              return i6 + 1;
            });
            _fit(matrix2, size2, defaultValue);
            var dims = iSize.length;
            var dim = 0;
            _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
          }
          return matrix2;
        }
        function _setSubmatrix(data, index2, submatrix, dims, dim) {
          var last = dim === dims - 1;
          var range2 = index2.dimension(dim);
          if (last) {
            range2.forEach(function(dataIndex, subIndex) {
              validateIndex(dataIndex);
              data[dataIndex] = submatrix[subIndex[0]];
            });
          } else {
            range2.forEach(function(dataIndex, subIndex) {
              validateIndex(dataIndex);
              _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
            });
          }
        }
        DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
          if (!isCollection(size2)) {
            throw new TypeError("Array or Matrix expected");
          }
          var sizeArray = size2.valueOf().map((value) => {
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
          });
          var m3 = copy ? this.clone() : this;
          return _resize2(m3, sizeArray, defaultValue);
        };
        function _resize2(matrix2, size2, defaultValue) {
          if (size2.length === 0) {
            var v3 = matrix2._data;
            while (isArray(v3)) {
              v3 = v3[0];
            }
            return v3;
          }
          matrix2._size = size2.slice(0);
          matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
          return matrix2;
        }
        DenseMatrix2.prototype.reshape = function(size2, copy) {
          var m3 = copy ? this.clone() : this;
          m3._data = reshape(m3._data, size2);
          var currentLength = m3._size.reduce((length, size3) => length * size3);
          m3._size = processSizesWildcard(size2, currentLength);
          return m3;
        };
        function _fit(matrix2, size2, defaultValue) {
          var newSize = matrix2._size.slice(0);
          var changed = false;
          while (newSize.length < size2.length) {
            newSize.push(0);
            changed = true;
          }
          for (var i5 = 0, ii = size2.length; i5 < ii; i5++) {
            if (size2[i5] > newSize[i5]) {
              newSize[i5] = size2[i5];
              changed = true;
            }
          }
          if (changed) {
            _resize2(matrix2, newSize, defaultValue);
          }
        }
        DenseMatrix2.prototype.clone = function() {
          var m3 = new DenseMatrix2({
            data: clone(this._data),
            size: clone(this._size),
            datatype: this._datatype
          });
          return m3;
        };
        DenseMatrix2.prototype.size = function() {
          return this._size.slice(0);
        };
        DenseMatrix2.prototype.map = function(callback) {
          var me = this;
          var args = maxArgumentCount(callback);
          var recurse = function recurse2(value, index2) {
            if (isArray(value)) {
              return value.map(function(child, i5) {
                return recurse2(child, index2.concat(i5));
              });
            } else {
              if (args === 1) {
                return callback(value);
              } else if (args === 2) {
                return callback(value, index2);
              } else {
                return callback(value, index2, me);
              }
            }
          };
          var data = recurse(this._data, []);
          var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
          return new DenseMatrix2(data, datatype);
        };
        DenseMatrix2.prototype.forEach = function(callback) {
          var me = this;
          var recurse = function recurse2(value, index2) {
            if (isArray(value)) {
              value.forEach(function(child, i5) {
                recurse2(child, index2.concat(i5));
              });
            } else {
              callback(value, index2, me);
            }
          };
          recurse(this._data, []);
        };
        DenseMatrix2.prototype[Symbol.iterator] = function* () {
          var recurse = function* recurse2(value, index2) {
            if (isArray(value)) {
              for (var i5 = 0; i5 < value.length; i5++) {
                yield* recurse2(value[i5], index2.concat(i5));
              }
            } else {
              yield {
                value,
                index: index2
              };
            }
          };
          yield* recurse(this._data, []);
        };
        DenseMatrix2.prototype.rows = function() {
          var result = [];
          var s3 = this.size();
          if (s3.length !== 2) {
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          }
          var data = this._data;
          for (var row2 of data) {
            result.push(new DenseMatrix2([row2], this._datatype));
          }
          return result;
        };
        DenseMatrix2.prototype.columns = function() {
          var _this = this;
          var result = [];
          var s3 = this.size();
          if (s3.length !== 2) {
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          }
          var data = this._data;
          var _loop = function _loop2(i6) {
            var col = data.map((row2) => [row2[i6]]);
            result.push(new DenseMatrix2(col, _this._datatype));
          };
          for (var i5 = 0; i5 < s3[1]; i5++) {
            _loop(i5);
          }
          return result;
        };
        DenseMatrix2.prototype.toArray = function() {
          return clone(this._data);
        };
        DenseMatrix2.prototype.valueOf = function() {
          return this._data;
        };
        DenseMatrix2.prototype.format = function(options) {
          return format3(this._data, options);
        };
        DenseMatrix2.prototype.toString = function() {
          return format3(this._data);
        };
        DenseMatrix2.prototype.toJSON = function() {
          return {
            mathjs: "DenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype
          };
        };
        DenseMatrix2.prototype.diagonal = function(k4) {
          if (k4) {
            if (isBigNumber(k4)) {
              k4 = k4.toNumber();
            }
            if (!isNumber(k4) || !isInteger(k4)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k4 = 0;
          }
          var kSuper = k4 > 0 ? k4 : 0;
          var kSub = k4 < 0 ? -k4 : 0;
          var rows = this._size[0];
          var columns = this._size[1];
          var n3 = Math.min(rows - kSub, columns - kSuper);
          var data = [];
          for (var i5 = 0; i5 < n3; i5++) {
            data[i5] = this._data[i5 + kSub][i5 + kSuper];
          }
          return new DenseMatrix2({
            data,
            size: [n3],
            datatype: this._datatype
          });
        };
        DenseMatrix2.diagonal = function(size2, value, k4, defaultValue) {
          if (!isArray(size2)) {
            throw new TypeError("Array expected, size parameter");
          }
          if (size2.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          size2 = size2.map(function(s3) {
            if (isBigNumber(s3)) {
              s3 = s3.toNumber();
            }
            if (!isNumber(s3) || !isInteger(s3) || s3 < 1) {
              throw new Error("Size values must be positive integers");
            }
            return s3;
          });
          if (k4) {
            if (isBigNumber(k4)) {
              k4 = k4.toNumber();
            }
            if (!isNumber(k4) || !isInteger(k4)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k4 = 0;
          }
          var kSuper = k4 > 0 ? k4 : 0;
          var kSub = k4 < 0 ? -k4 : 0;
          var rows = size2[0];
          var columns = size2[1];
          var n3 = Math.min(rows - kSub, columns - kSuper);
          var _value;
          if (isArray(value)) {
            if (value.length !== n3) {
              throw new Error("Invalid value array length");
            }
            _value = function _value2(i5) {
              return value[i5];
            };
          } else if (isMatrix(value)) {
            var ms = value.size();
            if (ms.length !== 1 || ms[0] !== n3) {
              throw new Error("Invalid matrix length");
            }
            _value = function _value2(i5) {
              return value.get([i5]);
            };
          } else {
            _value = function _value2() {
              return value;
            };
          }
          if (!defaultValue) {
            defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
          }
          var data = [];
          if (size2.length > 0) {
            data = resize(data, size2, defaultValue);
            for (var d3 = 0; d3 < n3; d3++) {
              data[d3 + kSub][d3 + kSuper] = _value(d3);
            }
          }
          return new DenseMatrix2({
            data,
            size: [rows, columns]
          });
        };
        DenseMatrix2.fromJSON = function(json) {
          return new DenseMatrix2(json);
        };
        DenseMatrix2.prototype.swapRows = function(i5, j4) {
          if (!isNumber(i5) || !isInteger(i5) || !isNumber(j4) || !isInteger(j4)) {
            throw new Error("Row index must be positive integers");
          }
          if (this._size.length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          validateIndex(i5, this._size[0]);
          validateIndex(j4, this._size[0]);
          DenseMatrix2._swapRows(i5, j4, this._data);
          return this;
        };
        DenseMatrix2._swapRows = function(i5, j4, data) {
          var vi = data[i5];
          data[i5] = data[j4];
          data[j4] = vi;
        };
        function preprocess(data) {
          if (isMatrix(data)) {
            return preprocess(data.valueOf());
          }
          if (isArray(data)) {
            return data.map(preprocess);
          }
          return data;
        }
        return DenseMatrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/clone.js
  var name8, dependencies9, createClone;
  var init_clone = __esm({
    "node_modules/mathjs/lib/esm/function/utils/clone.js"() {
      init_object();
      init_factory();
      name8 = "clone";
      dependencies9 = ["typed"];
      createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name8, {
          any: clone
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/switch.js
  function _switch(mat) {
    var I3 = mat.length;
    var J2 = mat[0].length;
    var i5, j4;
    var ret = [];
    for (j4 = 0; j4 < J2; j4++) {
      var tmp = [];
      for (i5 = 0; i5 < I3; i5++) {
        tmp.push(mat[i5][j4]);
      }
      ret.push(tmp);
    }
    return ret;
  }
  var init_switch = __esm({
    "node_modules/mathjs/lib/esm/utils/switch.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/utils/collection.js
  function containsCollections(array) {
    for (var i5 = 0; i5 < array.length; i5++) {
      if (isCollection(array[i5])) {
        return true;
      }
    }
    return false;
  }
  function deepForEach(array, callback) {
    if (isMatrix(array)) {
      array = array.valueOf();
    }
    for (var i5 = 0, ii = array.length; i5 < ii; i5++) {
      var value = array[i5];
      if (Array.isArray(value)) {
        deepForEach(value, callback);
      } else {
        callback(value);
      }
    }
  }
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x4) {
        return deepMap(x4, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }
  function reduce(mat, dim, callback) {
    var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    if (isMatrix(mat)) {
      return mat.create(_reduce(mat.valueOf(), dim, callback));
    } else {
      return _reduce(mat, dim, callback);
    }
  }
  function _reduce(mat, dim, callback) {
    var i5, ret, val, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        val = mat[0];
        for (i5 = 1; i5 < mat.length; i5++) {
          val = callback(val, mat[i5]);
        }
        return val;
      } else {
        tran = _switch(mat);
        ret = [];
        for (i5 = 0; i5 < tran.length; i5++) {
          ret[i5] = _reduce(tran[i5], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i5 = 0; i5 < mat.length; i5++) {
        ret[i5] = _reduce(mat[i5], dim - 1, callback);
      }
      return ret;
    }
  }
  function scatter(a3, j4, w4, x4, u3, mark, cindex, f3, inverse, update, value) {
    var avalues = a3._values;
    var aindex = a3._index;
    var aptr = a3._ptr;
    var k4, k0, k1, i5;
    if (x4) {
      for (k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
        i5 = aindex[k4];
        if (w4[i5] !== mark) {
          w4[i5] = mark;
          cindex.push(i5);
          if (update) {
            x4[i5] = inverse ? f3(avalues[k4], value) : f3(value, avalues[k4]);
            u3[i5] = mark;
          } else {
            x4[i5] = avalues[k4];
          }
        } else {
          x4[i5] = inverse ? f3(avalues[k4], x4[i5]) : f3(x4[i5], avalues[k4]);
          u3[i5] = mark;
        }
      }
    } else {
      for (k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
        i5 = aindex[k4];
        if (w4[i5] !== mark) {
          w4[i5] = mark;
          cindex.push(i5);
        } else {
          u3[i5] = mark;
        }
      }
    }
  }
  var init_collection = __esm({
    "node_modules/mathjs/lib/esm/utils/collection.js"() {
      init_is();
      init_IndexError();
      init_array();
      init_switch();
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isInteger.js
  var name9, dependencies10, createIsInteger;
  var init_isInteger = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isInteger.js"() {
      init_collection();
      init_number();
      init_factory();
      name9 = "isInteger";
      dependencies10 = ["typed"];
      createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name9, {
          number: isInteger,
          // TODO: what to do with isInteger(add(0.1, 0.2))  ?
          BigNumber: function BigNumber2(x4) {
            return x4.isInt();
          },
          Fraction: function Fraction3(x4) {
            return x4.d === 1 && isFinite(x4.n);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  function absNumber(a3) {
    return Math.abs(a3);
  }
  function addNumber(a3, b3) {
    return a3 + b3;
  }
  function subtractNumber(a3, b3) {
    return a3 - b3;
  }
  function multiplyNumber(a3, b3) {
    return a3 * b3;
  }
  function divideNumber(a3, b3) {
    return a3 / b3;
  }
  function unaryMinusNumber(x4) {
    return -x4;
  }
  function unaryPlusNumber(x4) {
    return x4;
  }
  function cbrtNumber(x4) {
    return cbrt(x4);
  }
  function cubeNumber(x4) {
    return x4 * x4 * x4;
  }
  function expNumber(x4) {
    return Math.exp(x4);
  }
  function expm1Number(x4) {
    return expm1(x4);
  }
  function gcdNumber(a3, b3) {
    if (!isInteger(a3) || !isInteger(b3)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r3;
    while (b3 !== 0) {
      r3 = a3 % b3;
      a3 = b3;
      b3 = r3;
    }
    return a3 < 0 ? -a3 : a3;
  }
  function lcmNumber(a3, b3) {
    if (!isInteger(a3) || !isInteger(b3)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a3 === 0 || b3 === 0) {
      return 0;
    }
    var t3;
    var prod2 = a3 * b3;
    while (b3 !== 0) {
      t3 = b3;
      b3 = a3 % t3;
      a3 = t3;
    }
    return Math.abs(prod2 / a3);
  }
  function logNumber(x4, y3) {
    if (y3) {
      return Math.log(x4) / Math.log(y3);
    }
    return Math.log(x4);
  }
  function log10Number(x4) {
    return log10(x4);
  }
  function log2Number(x4) {
    return log2(x4);
  }
  function log1pNumber(x4) {
    return log1p(x4);
  }
  function modNumber(x4, y3) {
    if (y3 > 0) {
      return x4 - y3 * Math.floor(x4 / y3);
    } else if (y3 === 0) {
      return x4;
    } else {
      throw new Error("Cannot calculate mod for a negative divisor");
    }
  }
  function nthRootNumber(a3) {
    var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var inv2 = root < 0;
    if (inv2) {
      root = -root;
    }
    if (root === 0) {
      throw new Error("Root must be non-zero");
    }
    if (a3 < 0 && Math.abs(root) % 2 !== 1) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a3 === 0) {
      return inv2 ? Infinity : 0;
    }
    if (!isFinite(a3)) {
      return inv2 ? 0 : a3;
    }
    var x4 = Math.pow(Math.abs(a3), 1 / root);
    x4 = a3 < 0 ? -x4 : x4;
    return inv2 ? 1 / x4 : x4;
  }
  function signNumber(x4) {
    return sign(x4);
  }
  function sqrtNumber(x4) {
    return Math.sqrt(x4);
  }
  function squareNumber(x4) {
    return x4 * x4;
  }
  function xgcdNumber(a3, b3) {
    var t3;
    var q4;
    var r3;
    var x4 = 0;
    var lastx = 1;
    var y3 = 1;
    var lasty = 0;
    if (!isInteger(a3) || !isInteger(b3)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b3) {
      q4 = Math.floor(a3 / b3);
      r3 = a3 - q4 * b3;
      t3 = x4;
      x4 = lastx - q4 * x4;
      lastx = t3;
      t3 = y3;
      y3 = lasty - q4 * y3;
      lasty = t3;
      a3 = b3;
      b3 = r3;
    }
    var res;
    if (a3 < 0) {
      res = [-a3, -lastx, -lasty];
    } else {
      res = [a3, a3 ? lastx : 0, lasty];
    }
    return res;
  }
  function powNumber(x4, y3) {
    if (x4 * x4 < 1 && y3 === Infinity || x4 * x4 > 1 && y3 === -Infinity) {
      return 0;
    }
    return Math.pow(x4, y3);
  }
  function roundNumber(value) {
    var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
      throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
    }
    return parseFloat(toFixed(value, decimals));
  }
  function normNumber(x4) {
    return Math.abs(x4);
  }
  var n1, n2;
  var init_arithmetic = __esm({
    "node_modules/mathjs/lib/esm/plain/number/arithmetic.js"() {
      init_number();
      n1 = "number";
      n2 = "number, number";
      absNumber.signature = n1;
      addNumber.signature = n2;
      subtractNumber.signature = n2;
      multiplyNumber.signature = n2;
      divideNumber.signature = n2;
      unaryMinusNumber.signature = n1;
      unaryPlusNumber.signature = n1;
      cbrtNumber.signature = n1;
      cubeNumber.signature = n1;
      expNumber.signature = n1;
      expm1Number.signature = n1;
      gcdNumber.signature = n2;
      lcmNumber.signature = n2;
      log10Number.signature = n1;
      log2Number.signature = n1;
      log1pNumber.signature = n1;
      modNumber.signature = n2;
      signNumber.signature = n1;
      sqrtNumber.signature = n1;
      squareNumber.signature = n1;
      xgcdNumber.signature = n2;
      powNumber.signature = n2;
      normNumber.signature = n1;
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/bitwise.js
  function bitAndNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function bitAnd");
    }
    return x4 & y3;
  }
  function bitNotNumber(x4) {
    if (!isInteger(x4)) {
      throw new Error("Integer expected in function bitNot");
    }
    return ~x4;
  }
  function bitOrNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function bitOr");
    }
    return x4 | y3;
  }
  function bitXorNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function bitXor");
    }
    return x4 ^ y3;
  }
  function leftShiftNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function leftShift");
    }
    return x4 << y3;
  }
  function rightArithShiftNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function rightArithShift");
    }
    return x4 >> y3;
  }
  function rightLogShiftNumber(x4, y3) {
    if (!isInteger(x4) || !isInteger(y3)) {
      throw new Error("Integers expected in function rightLogShift");
    }
    return x4 >>> y3;
  }
  var n12, n22;
  var init_bitwise = __esm({
    "node_modules/mathjs/lib/esm/plain/number/bitwise.js"() {
      init_number();
      n12 = "number";
      n22 = "number, number";
      bitAndNumber.signature = n22;
      bitNotNumber.signature = n12;
      bitOrNumber.signature = n22;
      bitXorNumber.signature = n22;
      leftShiftNumber.signature = n22;
      rightArithShiftNumber.signature = n22;
      rightLogShiftNumber.signature = n22;
    }
  });

  // node_modules/mathjs/lib/esm/utils/product.js
  function product2(i5, n3) {
    if (n3 < i5) {
      return 1;
    }
    if (n3 === i5) {
      return n3;
    }
    var half = n3 + i5 >> 1;
    return product2(i5, half) * product2(half + 1, n3);
  }
  var init_product = __esm({
    "node_modules/mathjs/lib/esm/utils/product.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/combinations.js
  function combinationsNumber(n3, k4) {
    if (!isInteger(n3) || n3 < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (!isInteger(k4) || k4 < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (k4 > n3) {
      throw new TypeError("k must be less than or equal to n");
    }
    var nMinusk = n3 - k4;
    var answer = 1;
    var firstnumerator = k4 < nMinusk ? nMinusk + 1 : k4 + 1;
    var nextdivisor = 2;
    var lastdivisor = k4 < nMinusk ? k4 : nMinusk;
    for (var nextnumerator = firstnumerator; nextnumerator <= n3; ++nextnumerator) {
      answer *= nextnumerator;
      while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
        answer /= nextdivisor;
        ++nextdivisor;
      }
    }
    if (nextdivisor <= lastdivisor) {
      answer /= product2(nextdivisor, lastdivisor);
    }
    return answer;
  }
  var init_combinations = __esm({
    "node_modules/mathjs/lib/esm/plain/number/combinations.js"() {
      init_number();
      init_product();
      combinationsNumber.signature = "number, number";
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/constants.js
  var pi, tau, e3, phi;
  var init_constants = __esm({
    "node_modules/mathjs/lib/esm/plain/number/constants.js"() {
      pi = Math.PI;
      tau = 2 * Math.PI;
      e3 = Math.E;
      phi = 1.618033988749895;
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/logical.js
  function notNumber(x4) {
    return !x4;
  }
  function orNumber(x4, y3) {
    return !!(x4 || y3);
  }
  function xorNumber(x4, y3) {
    return !!x4 !== !!y3;
  }
  function andNumber(x4, y3) {
    return !!(x4 && y3);
  }
  var n13, n23;
  var init_logical = __esm({
    "node_modules/mathjs/lib/esm/plain/number/logical.js"() {
      n13 = "number";
      n23 = "number, number";
      notNumber.signature = n13;
      orNumber.signature = n23;
      xorNumber.signature = n23;
      andNumber.signature = n23;
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/relational.js
  var init_relational = __esm({
    "node_modules/mathjs/lib/esm/plain/number/relational.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/probability.js
  function gammaNumber(n3) {
    var x4;
    if (isInteger(n3)) {
      if (n3 <= 0) {
        return isFinite(n3) ? Infinity : NaN;
      }
      if (n3 > 171) {
        return Infinity;
      }
      return product2(1, n3 - 1);
    }
    if (n3 < 0.5) {
      return Math.PI / (Math.sin(Math.PI * n3) * gammaNumber(1 - n3));
    }
    if (n3 >= 171.35) {
      return Infinity;
    }
    if (n3 > 85) {
      var twoN = n3 * n3;
      var threeN = twoN * n3;
      var fourN = threeN * n3;
      var fiveN = fourN * n3;
      return Math.sqrt(2 * Math.PI / n3) * Math.pow(n3 / Math.E, n3) * (1 + 1 / (12 * n3) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n3));
    }
    --n3;
    x4 = gammaP[0];
    for (var i5 = 1; i5 < gammaP.length; ++i5) {
      x4 += gammaP[i5] / (n3 + i5);
    }
    var t3 = n3 + gammaG + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t3, n3 + 0.5) * Math.exp(-t3) * x4;
  }
  function lgammaNumber(n3) {
    if (n3 < 0)
      return NaN;
    if (n3 === 0)
      return Infinity;
    if (!isFinite(n3))
      return n3;
    if (n3 < 0.5) {
      return Math.log(Math.PI / Math.sin(Math.PI * n3)) - lgammaNumber(1 - n3);
    }
    n3 = n3 - 1;
    var base = n3 + lgammaG + 0.5;
    var sum3 = lgammaSeries[0];
    for (var i5 = lgammaN - 1; i5 >= 1; i5--) {
      sum3 += lgammaSeries[i5] / (n3 + i5);
    }
    return lnSqrt2PI + (n3 + 0.5) * Math.log(base) - base + Math.log(sum3);
  }
  var gammaG, gammaP, lnSqrt2PI, lgammaG, lgammaN, lgammaSeries;
  var init_probability = __esm({
    "node_modules/mathjs/lib/esm/plain/number/probability.js"() {
      init_number();
      init_product();
      gammaNumber.signature = "number";
      gammaG = 4.7421875;
      gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
      lnSqrt2PI = 0.9189385332046728;
      lgammaG = 5;
      lgammaN = 7;
      lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
      lgammaNumber.signature = "number";
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/trigonometry.js
  function acosNumber(x4) {
    return Math.acos(x4);
  }
  function acoshNumber(x4) {
    return acosh(x4);
  }
  function acotNumber(x4) {
    return Math.atan(1 / x4);
  }
  function acothNumber(x4) {
    return isFinite(x4) ? (Math.log((x4 + 1) / x4) + Math.log(x4 / (x4 - 1))) / 2 : 0;
  }
  function acscNumber(x4) {
    return Math.asin(1 / x4);
  }
  function acschNumber(x4) {
    var xInv = 1 / x4;
    return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
  }
  function asecNumber(x4) {
    return Math.acos(1 / x4);
  }
  function asechNumber(x4) {
    var xInv = 1 / x4;
    var ret = Math.sqrt(xInv * xInv - 1);
    return Math.log(ret + xInv);
  }
  function asinNumber(x4) {
    return Math.asin(x4);
  }
  function asinhNumber(x4) {
    return asinh(x4);
  }
  function atanNumber(x4) {
    return Math.atan(x4);
  }
  function atan2Number(y3, x4) {
    return Math.atan2(y3, x4);
  }
  function atanhNumber(x4) {
    return atanh(x4);
  }
  function cosNumber(x4) {
    return Math.cos(x4);
  }
  function coshNumber(x4) {
    return cosh(x4);
  }
  function cotNumber(x4) {
    return 1 / Math.tan(x4);
  }
  function cothNumber(x4) {
    var e6 = Math.exp(2 * x4);
    return (e6 + 1) / (e6 - 1);
  }
  function cscNumber(x4) {
    return 1 / Math.sin(x4);
  }
  function cschNumber(x4) {
    if (x4 === 0) {
      return Number.POSITIVE_INFINITY;
    } else {
      return Math.abs(2 / (Math.exp(x4) - Math.exp(-x4))) * sign(x4);
    }
  }
  function secNumber(x4) {
    return 1 / Math.cos(x4);
  }
  function sechNumber(x4) {
    return 2 / (Math.exp(x4) + Math.exp(-x4));
  }
  function sinNumber(x4) {
    return Math.sin(x4);
  }
  function sinhNumber(x4) {
    return sinh(x4);
  }
  function tanNumber(x4) {
    return Math.tan(x4);
  }
  function tanhNumber(x4) {
    return tanh(x4);
  }
  var n14, n24;
  var init_trigonometry = __esm({
    "node_modules/mathjs/lib/esm/plain/number/trigonometry.js"() {
      init_number();
      n14 = "number";
      n24 = "number, number";
      acosNumber.signature = n14;
      acoshNumber.signature = n14;
      acotNumber.signature = n14;
      acothNumber.signature = n14;
      acscNumber.signature = n14;
      acschNumber.signature = n14;
      asecNumber.signature = n14;
      asechNumber.signature = n14;
      asinNumber.signature = n14;
      asinhNumber.signature = n14;
      atanNumber.signature = n14;
      atan2Number.signature = n24;
      atanhNumber.signature = n14;
      cosNumber.signature = n14;
      coshNumber.signature = n14;
      cotNumber.signature = n14;
      cothNumber.signature = n14;
      cscNumber.signature = n14;
      cschNumber.signature = n14;
      secNumber.signature = n14;
      sechNumber.signature = n14;
      sinNumber.signature = n14;
      sinhNumber.signature = n14;
      tanNumber.signature = n14;
      tanhNumber.signature = n14;
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/utils.js
  function isIntegerNumber(x4) {
    return isInteger(x4);
  }
  function isNegativeNumber(x4) {
    return x4 < 0;
  }
  function isPositiveNumber(x4) {
    return x4 > 0;
  }
  function isZeroNumber(x4) {
    return x4 === 0;
  }
  function isNaNNumber(x4) {
    return Number.isNaN(x4);
  }
  var n15;
  var init_utils = __esm({
    "node_modules/mathjs/lib/esm/plain/number/utils.js"() {
      init_number();
      n15 = "number";
      isIntegerNumber.signature = n15;
      isNegativeNumber.signature = n15;
      isPositiveNumber.signature = n15;
      isZeroNumber.signature = n15;
      isNaNNumber.signature = n15;
    }
  });

  // node_modules/mathjs/lib/esm/plain/number/index.js
  var init_number2 = __esm({
    "node_modules/mathjs/lib/esm/plain/number/index.js"() {
      init_arithmetic();
      init_bitwise();
      init_combinations();
      init_constants();
      init_logical();
      init_relational();
      init_probability();
      init_trigonometry();
      init_utils();
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isNegative.js
  var name10, dependencies11, createIsNegative;
  var init_isNegative = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isNegative.js"() {
      init_collection();
      init_factory();
      init_number2();
      name10 = "isNegative";
      dependencies11 = ["typed"];
      createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name10, {
          number: isNegativeNumber,
          BigNumber: function BigNumber2(x4) {
            return x4.isNeg() && !x4.isZero() && !x4.isNaN();
          },
          Fraction: function Fraction3(x4) {
            return x4.s < 0;
          },
          Unit: typed3.referToSelf((self2) => (x4) => typed3.find(self2, x4.valueType())(x4.value)),
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isNumeric.js
  var name11, dependencies12, createIsNumeric;
  var init_isNumeric = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isNumeric.js"() {
      init_collection();
      init_factory();
      name11 = "isNumeric";
      dependencies12 = ["typed"];
      createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name11, {
          "number | BigNumber | Fraction | boolean": () => true,
          "Complex | Unit | string | null | undefined | Node": () => false,
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
  var name12, dependencies13, createHasNumericValue;
  var init_hasNumericValue = __esm({
    "node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js"() {
      init_factory();
      name12 = "hasNumericValue";
      dependencies13 = ["typed", "isNumeric"];
      createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
        var {
          typed: typed3,
          isNumeric: isNumeric2
        } = _ref;
        return typed3(name12, {
          boolean: () => true,
          string: function string2(x4) {
            return x4.trim().length > 0 && !isNaN(Number(x4));
          },
          any: function any(x4) {
            return isNumeric2(x4);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isPositive.js
  var name13, dependencies14, createIsPositive;
  var init_isPositive = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isPositive.js"() {
      init_collection();
      init_factory();
      init_number2();
      name13 = "isPositive";
      dependencies14 = ["typed"];
      createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name13, {
          number: isPositiveNumber,
          BigNumber: function BigNumber2(x4) {
            return !x4.isNeg() && !x4.isZero() && !x4.isNaN();
          },
          Fraction: function Fraction3(x4) {
            return x4.s > 0 && x4.n > 0;
          },
          Unit: typed3.referToSelf((self2) => (x4) => typed3.find(self2, x4.valueType())(x4.value)),
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isZero.js
  var name14, dependencies15, createIsZero;
  var init_isZero = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isZero.js"() {
      init_collection();
      init_factory();
      init_number2();
      name14 = "isZero";
      dependencies15 = ["typed"];
      createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name14, {
          number: isZeroNumber,
          BigNumber: function BigNumber2(x4) {
            return x4.isZero();
          },
          Complex: function Complex3(x4) {
            return x4.re === 0 && x4.im === 0;
          },
          Fraction: function Fraction3(x4) {
            return x4.d === 1 && x4.n === 0;
          },
          Unit: typed3.referToSelf((self2) => (x4) => typed3.find(self2, x4.valueType())(x4.value)),
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isNaN.js
  var name15, dependencies16, createIsNaN;
  var init_isNaN = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isNaN.js"() {
      init_collection();
      init_factory();
      init_number2();
      name15 = "isNaN";
      dependencies16 = ["typed"];
      createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name15, {
          number: isNaNNumber,
          BigNumber: function BigNumber2(x4) {
            return x4.isNaN();
          },
          Fraction: function Fraction3(x4) {
            return false;
          },
          Complex: function Complex3(x4) {
            return x4.isNaN();
          },
          Unit: function Unit2(x4) {
            return Number.isNaN(x4.value);
          },
          "Array | Matrix": function ArrayMatrix(x4) {
            return deepMap(x4, Number.isNaN);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/typeOf.js
  var name16, dependencies17, createTypeOf;
  var init_typeOf = __esm({
    "node_modules/mathjs/lib/esm/function/utils/typeOf.js"() {
      init_factory();
      init_is();
      name16 = "typeOf";
      dependencies17 = ["typed"];
      createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name16, {
          any: typeOf
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x4, y3, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x4.eq(y3);
    }
    if (x4.eq(y3)) {
      return true;
    }
    if (x4.isNaN() || y3.isNaN()) {
      return false;
    }
    if (x4.isFinite() && y3.isFinite()) {
      var diff2 = x4.minus(y3).abs();
      if (diff2.isZero()) {
        return true;
      } else {
        var max3 = x4.constructor.max(x4.abs(), y3.abs());
        return diff2.lte(max3.times(epsilon));
      }
    }
    return false;
  }
  var init_nearlyEqual = __esm({
    "node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x4, y3, epsilon) {
    return nearlyEqual(x4.re, y3.re, epsilon) && nearlyEqual(x4.im, y3.im, epsilon);
  }
  var init_complex = __esm({
    "node_modules/mathjs/lib/esm/utils/complex.js"() {
      init_number();
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/compareUnits.js
  var createCompareUnits;
  var init_compareUnits = __esm({
    "node_modules/mathjs/lib/esm/function/relational/compareUnits.js"() {
      init_factory();
      createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return {
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => {
            if (!x4.equalBase(y3)) {
              throw new Error("Cannot compare units with different base");
            }
            return typed3.find(self2, [x4.valueType(), y3.valueType()])(x4.value, y3.value);
          })
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name17, dependencies18, createEqualScalar, createEqualScalarNumber;
  var init_equalScalar = __esm({
    "node_modules/mathjs/lib/esm/function/relational/equalScalar.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_complex();
      init_compareUnits();
      name17 = "equalScalar";
      dependencies18 = ["typed", "config"];
      createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
        var {
          typed: typed3,
          config: config4
        } = _ref;
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name17, {
          "boolean, boolean": function booleanBoolean(x4, y3) {
            return x4 === y3;
          },
          "number, number": function numberNumber(x4, y3) {
            return nearlyEqual(x4, y3, config4.epsilon);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.eq(y3) || nearlyEqual2(x4, y3, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            return x4.equals(y3);
          },
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return complexEquals(x4, y3, config4.epsilon);
          }
        }, compareUnits);
      });
      createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name17, {
          "number, number": function numberNumber(x4, y3) {
            return nearlyEqual(x4, y3, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name18, dependencies19, createSparseMatrixClass;
  var init_SparseMatrix = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js"() {
      init_is();
      init_number();
      init_string();
      init_object();
      init_array();
      init_factory();
      init_DimensionError();
      init_function();
      name18 = "SparseMatrix";
      dependencies19 = ["typed", "equalScalar", "Matrix"];
      createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2,
          Matrix: Matrix2
        } = _ref;
        function SparseMatrix2(data, datatype) {
          if (!(this instanceof SparseMatrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !isString(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if (isMatrix(data)) {
            _createFromMatrix(this, data, datatype);
          } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
            this._values = data.values;
            this._index = data.index;
            this._ptr = data.ptr;
            this._size = data.size;
            this._datatype = datatype || data.datatype;
          } else if (isArray(data)) {
            _createFromArray(this, data, datatype);
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
          } else {
            this._values = [];
            this._index = [];
            this._ptr = [0];
            this._size = [0, 0];
            this._datatype = datatype;
          }
        }
        function _createFromMatrix(matrix2, source, datatype) {
          if (source.type === "SparseMatrix") {
            matrix2._values = source._values ? clone(source._values) : void 0;
            matrix2._index = clone(source._index);
            matrix2._ptr = clone(source._ptr);
            matrix2._size = clone(source._size);
            matrix2._datatype = datatype || source._datatype;
          } else {
            _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
          }
        }
        function _createFromArray(matrix2, data, datatype) {
          matrix2._values = [];
          matrix2._index = [];
          matrix2._ptr = [];
          matrix2._datatype = datatype;
          var rows = data.length;
          var columns = 0;
          var eq = equalScalar2;
          var zero = 0;
          if (isString(datatype)) {
            eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
            zero = typed3.convert(0, datatype);
          }
          if (rows > 0) {
            var j4 = 0;
            do {
              matrix2._ptr.push(matrix2._index.length);
              for (var i5 = 0; i5 < rows; i5++) {
                var row2 = data[i5];
                if (isArray(row2)) {
                  if (j4 === 0 && columns < row2.length) {
                    columns = row2.length;
                  }
                  if (j4 < row2.length) {
                    var v3 = row2[j4];
                    if (!eq(v3, zero)) {
                      matrix2._values.push(v3);
                      matrix2._index.push(i5);
                    }
                  }
                } else {
                  if (j4 === 0 && columns < 1) {
                    columns = 1;
                  }
                  if (!eq(row2, zero)) {
                    matrix2._values.push(row2);
                    matrix2._index.push(i5);
                  }
                }
              }
              j4++;
            } while (j4 < columns);
          }
          matrix2._ptr.push(matrix2._index.length);
          matrix2._size = [rows, columns];
        }
        SparseMatrix2.prototype = new Matrix2();
        SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
          return new SparseMatrix2(data, datatype);
        };
        Object.defineProperty(SparseMatrix2, "name", {
          value: "SparseMatrix"
        });
        SparseMatrix2.prototype.constructor = SparseMatrix2;
        SparseMatrix2.prototype.type = "SparseMatrix";
        SparseMatrix2.prototype.isSparseMatrix = true;
        SparseMatrix2.prototype.getDataType = function() {
          return getArrayDataType(this._values, typeOf);
        };
        SparseMatrix2.prototype.storage = function() {
          return "sparse";
        };
        SparseMatrix2.prototype.datatype = function() {
          return this._datatype;
        };
        SparseMatrix2.prototype.create = function(data, datatype) {
          return new SparseMatrix2(data, datatype);
        };
        SparseMatrix2.prototype.density = function() {
          var rows = this._size[0];
          var columns = this._size[1];
          return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
        };
        SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
          if (!this._values) {
            throw new Error("Cannot invoke subset on a Pattern only matrix");
          }
          switch (arguments.length) {
            case 1:
              return _getsubset(this, index2);
            case 2:
            case 3:
              return _setsubset(this, index2, replacement, defaultValue);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        function _getsubset(matrix2, idx) {
          if (!isIndex(idx)) {
            throw new TypeError("Invalid index");
          }
          var isScalar = idx.isScalar();
          if (isScalar) {
            return matrix2.get(idx.min());
          }
          var size2 = idx.size();
          if (size2.length !== matrix2._size.length) {
            throw new DimensionError(size2.length, matrix2._size.length);
          }
          var i5, ii, k4, kk;
          var min3 = idx.min();
          var max3 = idx.max();
          for (i5 = 0, ii = matrix2._size.length; i5 < ii; i5++) {
            validateIndex(min3[i5], matrix2._size[i5]);
            validateIndex(max3[i5], matrix2._size[i5]);
          }
          var mvalues = matrix2._values;
          var mindex = matrix2._index;
          var mptr = matrix2._ptr;
          var rows = idx.dimension(0);
          var columns = idx.dimension(1);
          var w4 = [];
          var pv = [];
          rows.forEach(function(i6, r3) {
            pv[i6] = r3[0];
            w4[i6] = true;
          });
          var values = mvalues ? [] : void 0;
          var index2 = [];
          var ptr = [];
          columns.forEach(function(j4) {
            ptr.push(index2.length);
            for (k4 = mptr[j4], kk = mptr[j4 + 1]; k4 < kk; k4++) {
              i5 = mindex[k4];
              if (w4[i5] === true) {
                index2.push(pv[i5]);
                if (values) {
                  values.push(mvalues[k4]);
                }
              }
            }
          });
          ptr.push(index2.length);
          return new SparseMatrix2({
            values,
            index: index2,
            ptr,
            size: size2,
            datatype: matrix2._datatype
          });
        }
        function _setsubset(matrix2, index2, submatrix, defaultValue) {
          if (!index2 || index2.isIndex !== true) {
            throw new TypeError("Invalid index");
          }
          var iSize = index2.size();
          var isScalar = index2.isScalar();
          var sSize;
          if (isMatrix(submatrix)) {
            sSize = submatrix.size();
            submatrix = submatrix.toArray();
          } else {
            sSize = arraySize(submatrix);
          }
          if (isScalar) {
            if (sSize.length !== 0) {
              throw new TypeError("Scalar expected");
            }
            matrix2.set(index2.min(), submatrix, defaultValue);
          } else {
            if (iSize.length !== 1 && iSize.length !== 2) {
              throw new DimensionError(iSize.length, matrix2._size.length, "<");
            }
            if (sSize.length < iSize.length) {
              var i5 = 0;
              var outer = 0;
              while (iSize[i5] === 1 && sSize[i5] === 1) {
                i5++;
              }
              while (iSize[i5] === 1) {
                outer++;
                i5++;
              }
              submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
            }
            if (!deepStrictEqual(iSize, sSize)) {
              throw new DimensionError(iSize, sSize, ">");
            }
            if (iSize.length === 1) {
              var range2 = index2.dimension(0);
              range2.forEach(function(dataIndex, subIndex) {
                validateIndex(dataIndex);
                matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
              });
            } else {
              var firstDimensionRange = index2.dimension(0);
              var secondDimensionRange = index2.dimension(1);
              firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
                validateIndex(firstDataIndex);
                secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
                  validateIndex(secondDataIndex);
                  matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
                });
              });
            }
          }
          return matrix2;
        }
        SparseMatrix2.prototype.get = function(index2) {
          if (!isArray(index2)) {
            throw new TypeError("Array expected");
          }
          if (index2.length !== this._size.length) {
            throw new DimensionError(index2.length, this._size.length);
          }
          if (!this._values) {
            throw new Error("Cannot invoke get on a Pattern only matrix");
          }
          var i5 = index2[0];
          var j4 = index2[1];
          validateIndex(i5, this._size[0]);
          validateIndex(j4, this._size[1]);
          var k4 = _getValueIndex(i5, this._ptr[j4], this._ptr[j4 + 1], this._index);
          if (k4 < this._ptr[j4 + 1] && this._index[k4] === i5) {
            return this._values[k4];
          }
          return 0;
        };
        SparseMatrix2.prototype.set = function(index2, v3, defaultValue) {
          if (!isArray(index2)) {
            throw new TypeError("Array expected");
          }
          if (index2.length !== this._size.length) {
            throw new DimensionError(index2.length, this._size.length);
          }
          if (!this._values) {
            throw new Error("Cannot invoke set on a Pattern only matrix");
          }
          var i5 = index2[0];
          var j4 = index2[1];
          var rows = this._size[0];
          var columns = this._size[1];
          var eq = equalScalar2;
          var zero = 0;
          if (isString(this._datatype)) {
            eq = typed3.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
            zero = typed3.convert(0, this._datatype);
          }
          if (i5 > rows - 1 || j4 > columns - 1) {
            _resize2(this, Math.max(i5 + 1, rows), Math.max(j4 + 1, columns), defaultValue);
            rows = this._size[0];
            columns = this._size[1];
          }
          validateIndex(i5, rows);
          validateIndex(j4, columns);
          var k4 = _getValueIndex(i5, this._ptr[j4], this._ptr[j4 + 1], this._index);
          if (k4 < this._ptr[j4 + 1] && this._index[k4] === i5) {
            if (!eq(v3, zero)) {
              this._values[k4] = v3;
            } else {
              _remove(k4, j4, this._values, this._index, this._ptr);
            }
          } else {
            if (!eq(v3, zero)) {
              _insert(k4, i5, j4, v3, this._values, this._index, this._ptr);
            }
          }
          return this;
        };
        function _getValueIndex(i5, top, bottom, index2) {
          if (bottom - top === 0) {
            return bottom;
          }
          for (var r3 = top; r3 < bottom; r3++) {
            if (index2[r3] === i5) {
              return r3;
            }
          }
          return top;
        }
        function _remove(k4, j4, values, index2, ptr) {
          values.splice(k4, 1);
          index2.splice(k4, 1);
          for (var x4 = j4 + 1; x4 < ptr.length; x4++) {
            ptr[x4]--;
          }
        }
        function _insert(k4, i5, j4, v3, values, index2, ptr) {
          values.splice(k4, 0, v3);
          index2.splice(k4, 0, i5);
          for (var x4 = j4 + 1; x4 < ptr.length; x4++) {
            ptr[x4]++;
          }
        }
        SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
          if (!isCollection(size2)) {
            throw new TypeError("Array or Matrix expected");
          }
          var sizeArray = size2.valueOf().map((value) => {
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
          });
          if (sizeArray.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          sizeArray.forEach(function(value) {
            if (!isNumber(value) || !isInteger(value) || value < 0) {
              throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
            }
          });
          var m3 = copy ? this.clone() : this;
          return _resize2(m3, sizeArray[0], sizeArray[1], defaultValue);
        };
        function _resize2(matrix2, rows, columns, defaultValue) {
          var value = defaultValue || 0;
          var eq = equalScalar2;
          var zero = 0;
          if (isString(matrix2._datatype)) {
            eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
            zero = typed3.convert(0, matrix2._datatype);
            value = typed3.convert(value, matrix2._datatype);
          }
          var ins = !eq(value, zero);
          var r3 = matrix2._size[0];
          var c3 = matrix2._size[1];
          var i5, j4, k4;
          if (columns > c3) {
            for (j4 = c3; j4 < columns; j4++) {
              matrix2._ptr[j4] = matrix2._values.length;
              if (ins) {
                for (i5 = 0; i5 < r3; i5++) {
                  matrix2._values.push(value);
                  matrix2._index.push(i5);
                }
              }
            }
            matrix2._ptr[columns] = matrix2._values.length;
          } else if (columns < c3) {
            matrix2._ptr.splice(columns + 1, c3 - columns);
            matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
            matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
          }
          c3 = columns;
          if (rows > r3) {
            if (ins) {
              var n3 = 0;
              for (j4 = 0; j4 < c3; j4++) {
                matrix2._ptr[j4] = matrix2._ptr[j4] + n3;
                k4 = matrix2._ptr[j4 + 1] + n3;
                var p3 = 0;
                for (i5 = r3; i5 < rows; i5++, p3++) {
                  matrix2._values.splice(k4 + p3, 0, value);
                  matrix2._index.splice(k4 + p3, 0, i5);
                  n3++;
                }
              }
              matrix2._ptr[c3] = matrix2._values.length;
            }
          } else if (rows < r3) {
            var d3 = 0;
            for (j4 = 0; j4 < c3; j4++) {
              matrix2._ptr[j4] = matrix2._ptr[j4] - d3;
              var k0 = matrix2._ptr[j4];
              var k1 = matrix2._ptr[j4 + 1] - d3;
              for (k4 = k0; k4 < k1; k4++) {
                i5 = matrix2._index[k4];
                if (i5 > rows - 1) {
                  matrix2._values.splice(k4, 1);
                  matrix2._index.splice(k4, 1);
                  d3++;
                }
              }
            }
            matrix2._ptr[j4] = matrix2._values.length;
          }
          matrix2._size[0] = rows;
          matrix2._size[1] = columns;
          return matrix2;
        }
        SparseMatrix2.prototype.reshape = function(sizes, copy) {
          if (!isArray(sizes)) {
            throw new TypeError("Array expected");
          }
          if (sizes.length !== 2) {
            throw new Error("Sparse matrices can only be reshaped in two dimensions");
          }
          sizes.forEach(function(value) {
            if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
              throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
            }
          });
          var currentLength = this._size[0] * this._size[1];
          sizes = processSizesWildcard(sizes, currentLength);
          var newLength = sizes[0] * sizes[1];
          if (currentLength !== newLength) {
            throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
          }
          var m3 = copy ? this.clone() : this;
          if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
            return m3;
          }
          var colIndex = [];
          for (var i5 = 0; i5 < m3._ptr.length; i5++) {
            for (var j4 = 0; j4 < m3._ptr[i5 + 1] - m3._ptr[i5]; j4++) {
              colIndex.push(i5);
            }
          }
          var values = m3._values.slice();
          var rowIndex = m3._index.slice();
          for (var _i = 0; _i < m3._index.length; _i++) {
            var r1 = rowIndex[_i];
            var c1 = colIndex[_i];
            var flat = r1 * m3._size[1] + c1;
            colIndex[_i] = flat % sizes[1];
            rowIndex[_i] = Math.floor(flat / sizes[1]);
          }
          m3._values.length = 0;
          m3._index.length = 0;
          m3._ptr.length = sizes[1] + 1;
          m3._size = sizes.slice();
          for (var _i2 = 0; _i2 < m3._ptr.length; _i2++) {
            m3._ptr[_i2] = 0;
          }
          for (var h3 = 0; h3 < values.length; h3++) {
            var _i3 = rowIndex[h3];
            var _j = colIndex[h3];
            var v3 = values[h3];
            var k4 = _getValueIndex(_i3, m3._ptr[_j], m3._ptr[_j + 1], m3._index);
            _insert(k4, _i3, _j, v3, m3._values, m3._index, m3._ptr);
          }
          return m3;
        };
        SparseMatrix2.prototype.clone = function() {
          var m3 = new SparseMatrix2({
            values: this._values ? clone(this._values) : void 0,
            index: clone(this._index),
            ptr: clone(this._ptr),
            size: clone(this._size),
            datatype: this._datatype
          });
          return m3;
        };
        SparseMatrix2.prototype.size = function() {
          return this._size.slice(0);
        };
        SparseMatrix2.prototype.map = function(callback, skipZeros) {
          if (!this._values) {
            throw new Error("Cannot invoke map on a Pattern only matrix");
          }
          var me = this;
          var rows = this._size[0];
          var columns = this._size[1];
          var args = maxArgumentCount(callback);
          var invoke = function invoke2(v3, i5, j4) {
            if (args === 1)
              return callback(v3);
            if (args === 2)
              return callback(v3, [i5, j4]);
            return callback(v3, [i5, j4], me);
          };
          return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
        };
        function _map3(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
          var values = [];
          var index2 = [];
          var ptr = [];
          var eq = equalScalar2;
          var zero = 0;
          if (isString(matrix2._datatype)) {
            eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
            zero = typed3.convert(0, matrix2._datatype);
          }
          var invoke = function invoke2(v3, x4, y3) {
            v3 = callback(v3, x4, y3);
            if (!eq(v3, zero)) {
              values.push(v3);
              index2.push(x4);
            }
          };
          for (var j4 = minColumn; j4 <= maxColumn; j4++) {
            ptr.push(values.length);
            var k0 = matrix2._ptr[j4];
            var k1 = matrix2._ptr[j4 + 1];
            if (skipZeros) {
              for (var k4 = k0; k4 < k1; k4++) {
                var i5 = matrix2._index[k4];
                if (i5 >= minRow && i5 <= maxRow) {
                  invoke(matrix2._values[k4], i5 - minRow, j4 - minColumn);
                }
              }
            } else {
              var _values = {};
              for (var _k = k0; _k < k1; _k++) {
                var _i4 = matrix2._index[_k];
                _values[_i4] = matrix2._values[_k];
              }
              for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
                var value = _i5 in _values ? _values[_i5] : 0;
                invoke(value, _i5 - minRow, j4 - minColumn);
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index: index2,
            ptr,
            size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
          });
        }
        SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
          if (!this._values) {
            throw new Error("Cannot invoke forEach on a Pattern only matrix");
          }
          var me = this;
          var rows = this._size[0];
          var columns = this._size[1];
          for (var j4 = 0; j4 < columns; j4++) {
            var k0 = this._ptr[j4];
            var k1 = this._ptr[j4 + 1];
            if (skipZeros) {
              for (var k4 = k0; k4 < k1; k4++) {
                var i5 = this._index[k4];
                callback(this._values[k4], [i5, j4], me);
              }
            } else {
              var values = {};
              for (var _k2 = k0; _k2 < k1; _k2++) {
                var _i6 = this._index[_k2];
                values[_i6] = this._values[_k2];
              }
              for (var _i7 = 0; _i7 < rows; _i7++) {
                var value = _i7 in values ? values[_i7] : 0;
                callback(value, [_i7, j4], me);
              }
            }
          }
        };
        SparseMatrix2.prototype[Symbol.iterator] = function* () {
          if (!this._values) {
            throw new Error("Cannot iterate a Pattern only matrix");
          }
          var columns = this._size[1];
          for (var j4 = 0; j4 < columns; j4++) {
            var k0 = this._ptr[j4];
            var k1 = this._ptr[j4 + 1];
            for (var k4 = k0; k4 < k1; k4++) {
              var i5 = this._index[k4];
              yield {
                value: this._values[k4],
                index: [i5, j4]
              };
            }
          }
        };
        SparseMatrix2.prototype.toArray = function() {
          return _toArray(this._values, this._index, this._ptr, this._size, true);
        };
        SparseMatrix2.prototype.valueOf = function() {
          return _toArray(this._values, this._index, this._ptr, this._size, false);
        };
        function _toArray(values, index2, ptr, size2, copy) {
          var rows = size2[0];
          var columns = size2[1];
          var a3 = [];
          var i5, j4;
          for (i5 = 0; i5 < rows; i5++) {
            a3[i5] = [];
            for (j4 = 0; j4 < columns; j4++) {
              a3[i5][j4] = 0;
            }
          }
          for (j4 = 0; j4 < columns; j4++) {
            var k0 = ptr[j4];
            var k1 = ptr[j4 + 1];
            for (var k4 = k0; k4 < k1; k4++) {
              i5 = index2[k4];
              a3[i5][j4] = values ? copy ? clone(values[k4]) : values[k4] : 1;
            }
          }
          return a3;
        }
        SparseMatrix2.prototype.format = function(options) {
          var rows = this._size[0];
          var columns = this._size[1];
          var density = this.density();
          var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
          for (var j4 = 0; j4 < columns; j4++) {
            var k0 = this._ptr[j4];
            var k1 = this._ptr[j4 + 1];
            for (var k4 = k0; k4 < k1; k4++) {
              var i5 = this._index[k4];
              str += "\n    (" + format3(i5, options) + ", " + format3(j4, options) + ") ==> " + (this._values ? format3(this._values[k4], options) : "X");
            }
          }
          return str;
        };
        SparseMatrix2.prototype.toString = function() {
          return format3(this.toArray());
        };
        SparseMatrix2.prototype.toJSON = function() {
          return {
            mathjs: "SparseMatrix",
            values: this._values,
            index: this._index,
            ptr: this._ptr,
            size: this._size,
            datatype: this._datatype
          };
        };
        SparseMatrix2.prototype.diagonal = function(k4) {
          if (k4) {
            if (isBigNumber(k4)) {
              k4 = k4.toNumber();
            }
            if (!isNumber(k4) || !isInteger(k4)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k4 = 0;
          }
          var kSuper = k4 > 0 ? k4 : 0;
          var kSub = k4 < 0 ? -k4 : 0;
          var rows = this._size[0];
          var columns = this._size[1];
          var n3 = Math.min(rows - kSub, columns - kSuper);
          var values = [];
          var index2 = [];
          var ptr = [];
          ptr[0] = 0;
          for (var j4 = kSuper; j4 < columns && values.length < n3; j4++) {
            var k0 = this._ptr[j4];
            var k1 = this._ptr[j4 + 1];
            for (var x4 = k0; x4 < k1; x4++) {
              var i5 = this._index[x4];
              if (i5 === j4 - kSuper + kSub) {
                values.push(this._values[x4]);
                index2[values.length - 1] = i5 - kSub;
                break;
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index: index2,
            ptr,
            size: [n3, 1]
          });
        };
        SparseMatrix2.fromJSON = function(json) {
          return new SparseMatrix2(json);
        };
        SparseMatrix2.diagonal = function(size2, value, k4, defaultValue, datatype) {
          if (!isArray(size2)) {
            throw new TypeError("Array expected, size parameter");
          }
          if (size2.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          size2 = size2.map(function(s3) {
            if (isBigNumber(s3)) {
              s3 = s3.toNumber();
            }
            if (!isNumber(s3) || !isInteger(s3) || s3 < 1) {
              throw new Error("Size values must be positive integers");
            }
            return s3;
          });
          if (k4) {
            if (isBigNumber(k4)) {
              k4 = k4.toNumber();
            }
            if (!isNumber(k4) || !isInteger(k4)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k4 = 0;
          }
          var eq = equalScalar2;
          var zero = 0;
          if (isString(datatype)) {
            eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
            zero = typed3.convert(0, datatype);
          }
          var kSuper = k4 > 0 ? k4 : 0;
          var kSub = k4 < 0 ? -k4 : 0;
          var rows = size2[0];
          var columns = size2[1];
          var n3 = Math.min(rows - kSub, columns - kSuper);
          var _value;
          if (isArray(value)) {
            if (value.length !== n3) {
              throw new Error("Invalid value array length");
            }
            _value = function _value2(i6) {
              return value[i6];
            };
          } else if (isMatrix(value)) {
            var ms = value.size();
            if (ms.length !== 1 || ms[0] !== n3) {
              throw new Error("Invalid matrix length");
            }
            _value = function _value2(i6) {
              return value.get([i6]);
            };
          } else {
            _value = function _value2() {
              return value;
            };
          }
          var values = [];
          var index2 = [];
          var ptr = [];
          for (var j4 = 0; j4 < columns; j4++) {
            ptr.push(values.length);
            var i5 = j4 - kSuper;
            if (i5 >= 0 && i5 < n3) {
              var v3 = _value(i5);
              if (!eq(v3, zero)) {
                index2.push(i5 + kSub);
                values.push(v3);
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index: index2,
            ptr,
            size: [rows, columns]
          });
        };
        SparseMatrix2.prototype.swapRows = function(i5, j4) {
          if (!isNumber(i5) || !isInteger(i5) || !isNumber(j4) || !isInteger(j4)) {
            throw new Error("Row index must be positive integers");
          }
          if (this._size.length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          validateIndex(i5, this._size[0]);
          validateIndex(j4, this._size[0]);
          SparseMatrix2._swapRows(i5, j4, this._size[1], this._values, this._index, this._ptr);
          return this;
        };
        SparseMatrix2._forEachRow = function(j4, values, index2, ptr, callback) {
          var k0 = ptr[j4];
          var k1 = ptr[j4 + 1];
          for (var k4 = k0; k4 < k1; k4++) {
            callback(index2[k4], values[k4]);
          }
        };
        SparseMatrix2._swapRows = function(x4, y3, columns, values, index2, ptr) {
          for (var j4 = 0; j4 < columns; j4++) {
            var k0 = ptr[j4];
            var k1 = ptr[j4 + 1];
            var kx = _getValueIndex(x4, k0, k1, index2);
            var ky = _getValueIndex(y3, k0, k1, index2);
            if (kx < k1 && ky < k1 && index2[kx] === x4 && index2[ky] === y3) {
              if (values) {
                var v3 = values[kx];
                values[kx] = values[ky];
                values[ky] = v3;
              }
              continue;
            }
            if (kx < k1 && index2[kx] === x4 && (ky >= k1 || index2[ky] !== y3)) {
              var vx = values ? values[kx] : void 0;
              index2.splice(ky, 0, y3);
              if (values) {
                values.splice(ky, 0, vx);
              }
              index2.splice(ky <= kx ? kx + 1 : kx, 1);
              if (values) {
                values.splice(ky <= kx ? kx + 1 : kx, 1);
              }
              continue;
            }
            if (ky < k1 && index2[ky] === y3 && (kx >= k1 || index2[kx] !== x4)) {
              var vy = values ? values[ky] : void 0;
              index2.splice(kx, 0, x4);
              if (values) {
                values.splice(kx, 0, vy);
              }
              index2.splice(kx <= ky ? ky + 1 : ky, 1);
              if (values) {
                values.splice(kx <= ky ? ky + 1 : ky, 1);
              }
            }
          }
        };
        return SparseMatrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/number.js
  function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        "0b": 2,
        "0o": 8,
        "0x": 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  function makeNumberFromNonDecimalParts(parts) {
    var n3 = parseInt(parts.integerPart, parts.radix);
    var f3 = 0;
    for (var i5 = 0; i5 < parts.fractionalPart.length; i5++) {
      var digitValue = parseInt(parts.fractionalPart[i5], parts.radix);
      f3 += digitValue / Math.pow(parts.radix, i5 + 1);
    }
    var result = n3 + f3;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is no valid number');
    }
    return result;
  }
  var name19, dependencies20, createNumber;
  var init_number3 = __esm({
    "node_modules/mathjs/lib/esm/type/number.js"() {
      init_factory();
      init_collection();
      name19 = "number";
      dependencies20 = ["typed"];
      createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        var number2 = typed3("number", {
          "": function _3() {
            return 0;
          },
          number: function number3(x4) {
            return x4;
          },
          string: function string2(x4) {
            if (x4 === "NaN")
              return NaN;
            var nonDecimalNumberParts = getNonDecimalNumberParts(x4);
            if (nonDecimalNumberParts) {
              return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
            }
            var size2 = 0;
            var wordSizeSuffixMatch = x4.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
              size2 = Number(wordSizeSuffixMatch[2]);
              x4 = wordSizeSuffixMatch[1];
            }
            var num = Number(x4);
            if (isNaN(num)) {
              throw new SyntaxError('String "' + x4 + '" is no valid number');
            }
            if (wordSizeSuffixMatch) {
              if (num > 2 ** size2 - 1) {
                throw new SyntaxError('String "'.concat(x4, '" is out of range'));
              }
              if (num >= 2 ** (size2 - 1)) {
                num = num - 2 ** size2;
              }
            }
            return num;
          },
          BigNumber: function BigNumber2(x4) {
            return x4.toNumber();
          },
          Fraction: function Fraction3(x4) {
            return x4.valueOf();
          },
          Unit: typed3.referToSelf((self2) => (x4) => {
            var clone5 = x4.clone();
            clone5.value = self2(x4.value);
            return clone5;
          }),
          null: function _null2(x4) {
            return 0;
          },
          "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
            return unit2.toNumber(valuelessUnit);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
        number2.fromJSON = function(json) {
          return parseFloat(json.value);
        };
        return number2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/string.js
  var name20, dependencies21, createString;
  var init_string2 = __esm({
    "node_modules/mathjs/lib/esm/type/string.js"() {
      init_factory();
      init_collection();
      init_number();
      name20 = "string";
      dependencies21 = ["typed"];
      createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name20, {
          "": function _3() {
            return "";
          },
          number: format,
          null: function _null2(x4) {
            return "null";
          },
          boolean: function boolean2(x4) {
            return x4 + "";
          },
          string: function string2(x4) {
            return x4;
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2)),
          any: function any(x4) {
            return String(x4);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/boolean.js
  var name21, dependencies22, createBoolean;
  var init_boolean = __esm({
    "node_modules/mathjs/lib/esm/type/boolean.js"() {
      init_factory();
      init_collection();
      name21 = "boolean";
      dependencies22 = ["typed"];
      createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name21, {
          "": function _3() {
            return false;
          },
          boolean: function boolean2(x4) {
            return x4;
          },
          number: function number2(x4) {
            return !!x4;
          },
          null: function _null2(x4) {
            return false;
          },
          BigNumber: function BigNumber2(x4) {
            return !x4.isZero();
          },
          string: function string2(x4) {
            var lcase = x4.toLowerCase();
            if (lcase === "true") {
              return true;
            } else if (lcase === "false") {
              return false;
            }
            var num = Number(x4);
            if (x4 !== "" && !isNaN(num)) {
              return !!num;
            }
            throw new Error('Cannot convert "' + x4 + '" to a boolean');
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
  var name22, dependencies23, createBignumber;
  var init_bignumber = __esm({
    "node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js"() {
      init_factory();
      init_collection();
      name22 = "bignumber";
      dependencies23 = ["typed", "BigNumber"];
      createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
        var {
          typed: typed3,
          BigNumber: BigNumber2
        } = _ref;
        return typed3("bignumber", {
          "": function _3() {
            return new BigNumber2(0);
          },
          number: function number2(x4) {
            return new BigNumber2(x4 + "");
          },
          string: function string2(x4) {
            var wordSizeSuffixMatch = x4.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
              var size2 = wordSizeSuffixMatch[2];
              var n3 = BigNumber2(wordSizeSuffixMatch[1]);
              var twoPowSize = new BigNumber2(2).pow(Number(size2));
              if (n3.gt(twoPowSize.sub(1))) {
                throw new SyntaxError('String "'.concat(x4, '" is out of range'));
              }
              var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
              if (n3.gte(twoPowSizeSubOne)) {
                return n3.sub(twoPowSize);
              } else {
                return n3;
              }
            }
            return new BigNumber2(x4);
          },
          BigNumber: function BigNumber3(x4) {
            return x4;
          },
          Unit: typed3.referToSelf((self2) => (x4) => {
            var clone5 = x4.clone();
            clone5.value = self2(x4.value);
            return clone5;
          }),
          Fraction: function Fraction3(x4) {
            return new BigNumber2(x4.n).div(x4.d).times(x4.s);
          },
          null: function _null2(x4) {
            return new BigNumber2(0);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name23, dependencies24, createComplex;
  var init_complex2 = __esm({
    "node_modules/mathjs/lib/esm/type/complex/function/complex.js"() {
      init_factory();
      init_collection();
      name23 = "complex";
      dependencies24 = ["typed", "Complex"];
      createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
        var {
          typed: typed3,
          Complex: Complex3
        } = _ref;
        return typed3("complex", {
          "": function _3() {
            return Complex3.ZERO;
          },
          number: function number2(x4) {
            return new Complex3(x4, 0);
          },
          "number, number": function numberNumber(re2, im2) {
            return new Complex3(re2, im2);
          },
          // TODO: this signature should be redundant
          "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
            return new Complex3(re2.toNumber(), im2.toNumber());
          },
          Fraction: function Fraction3(x4) {
            return new Complex3(x4.valueOf(), 0);
          },
          Complex: function Complex4(x4) {
            return x4.clone();
          },
          string: function string2(x4) {
            return Complex3(x4);
          },
          null: function _null2(x4) {
            return Complex3(0);
          },
          Object: function Object2(x4) {
            if ("re" in x4 && "im" in x4) {
              return new Complex3(x4.re, x4.im);
            }
            if ("r" in x4 && "phi" in x4 || "abs" in x4 && "arg" in x4) {
              return new Complex3(x4);
            }
            throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
  var name24, dependencies25, createFraction;
  var init_fraction = __esm({
    "node_modules/mathjs/lib/esm/type/fraction/function/fraction.js"() {
      init_factory();
      init_collection();
      name24 = "fraction";
      dependencies25 = ["typed", "Fraction"];
      createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
        var {
          typed: typed3,
          Fraction: Fraction3
        } = _ref;
        return typed3("fraction", {
          number: function number2(x4) {
            if (!isFinite(x4) || isNaN(x4)) {
              throw new Error(x4 + " cannot be represented as a fraction");
            }
            return new Fraction3(x4);
          },
          string: function string2(x4) {
            return new Fraction3(x4);
          },
          "number, number": function numberNumber(numerator, denominator) {
            return new Fraction3(numerator, denominator);
          },
          null: function _null2(x4) {
            return new Fraction3(0);
          },
          BigNumber: function BigNumber2(x4) {
            return new Fraction3(x4.toString());
          },
          Fraction: function Fraction4(x4) {
            return x4;
          },
          Unit: typed3.referToSelf((self2) => (x4) => {
            var clone5 = x4.clone();
            clone5.value = self2(x4.value);
            return clone5;
          }),
          Object: function Object2(x4) {
            return new Fraction3(x4);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name25, dependencies26, createMatrix;
  var init_matrix = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/function/matrix.js"() {
      init_factory();
      name25 = "matrix";
      dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
      createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
        var {
          typed: typed3,
          Matrix: Matrix2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2
        } = _ref;
        return typed3(name25, {
          "": function _3() {
            return _create([]);
          },
          string: function string2(format5) {
            return _create([], format5);
          },
          "string, string": function stringString(format5, datatype) {
            return _create([], format5, datatype);
          },
          Array: function Array2(data) {
            return _create(data);
          },
          Matrix: function Matrix3(data) {
            return _create(data, data.storage());
          },
          "Array | Matrix, string": _create,
          "Array | Matrix, string, string": _create
        });
        function _create(data, format5, datatype) {
          if (format5 === "dense" || format5 === "default" || format5 === void 0) {
            return new DenseMatrix2(data, datatype);
          }
          if (format5 === "sparse") {
            return new SparseMatrix2(data, datatype);
          }
          throw new TypeError("Unknown matrix type " + JSON.stringify(format5) + ".");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
  var name26, dependencies27, createMatrixFromFunction;
  var init_matrixFromFunction = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"() {
      init_factory();
      name26 = "matrixFromFunction";
      dependencies27 = ["typed", "matrix", "isZero"];
      createMatrixFromFunction = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          isZero: isZero2
        } = _ref;
        return typed3(name26, {
          "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn2, format5, datatype) {
            return _create(size2, fn2, format5, datatype);
          },
          "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn2, format5) {
            return _create(size2, fn2, format5);
          },
          "Matrix, function": function MatrixFunction(size2, fn2) {
            return _create(size2, fn2, "dense");
          },
          "Array, function": function ArrayFunction(size2, fn2) {
            return _create(size2, fn2, "dense").toArray();
          },
          "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format5, fn2) {
            return _create(size2, fn2, format5);
          },
          "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format5, datatype, fn2) {
            return _create(size2, fn2, format5, datatype);
          }
        });
        function _create(size2, fn2, format5, datatype) {
          var m3;
          if (datatype !== void 0) {
            m3 = matrix2(format5, datatype);
          } else {
            m3 = matrix2(format5);
          }
          m3.resize(size2);
          m3.forEach(function(_3, index2) {
            var val = fn2(index2);
            if (isZero2(val))
              return;
            m3.set(index2, val);
          });
          return m3;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
  var name27, dependencies28, createMatrixFromRows;
  var init_matrixFromRows = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js"() {
      init_factory();
      name27 = "matrixFromRows";
      dependencies28 = ["typed", "matrix", "flatten", "size"];
      createMatrixFromRows = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          flatten: flatten3,
          size: size2
        } = _ref;
        return typed3(name27, {
          "...Array": function Array2(arr) {
            return _createArray(arr);
          },
          "...Matrix": function Matrix2(arr) {
            return matrix2(_createArray(arr.map((m3) => m3.toArray())));
          }
          // TODO implement this properly for SparseMatrix
        });
        function _createArray(arr) {
          if (arr.length === 0)
            throw new TypeError("At least one row is needed to construct a matrix.");
          var N3 = checkVectorTypeAndReturnLength(arr[0]);
          var result = [];
          for (var row2 of arr) {
            var rowLength = checkVectorTypeAndReturnLength(row2);
            if (rowLength !== N3) {
              throw new TypeError("The vectors had different length: " + (N3 | 0) + " \u2260 " + (rowLength | 0));
            }
            result.push(flatten3(row2));
          }
          return result;
        }
        function checkVectorTypeAndReturnLength(vec) {
          var s3 = size2(vec);
          if (s3.length === 1) {
            return s3[0];
          } else if (s3.length === 2) {
            if (s3[0] === 1) {
              return s3[1];
            } else if (s3[1] === 1) {
              return s3[0];
            } else {
              throw new TypeError("At least one of the arguments is not a vector.");
            }
          } else {
            throw new TypeError("Only one- or two-dimensional vectors are supported.");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
  var name28, dependencies29, createMatrixFromColumns;
  var init_matrixFromColumns = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js"() {
      init_factory();
      name28 = "matrixFromColumns";
      dependencies29 = ["typed", "matrix", "flatten", "size"];
      createMatrixFromColumns = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          flatten: flatten3,
          size: size2
        } = _ref;
        return typed3(name28, {
          "...Array": function Array2(arr) {
            return _createArray(arr);
          },
          "...Matrix": function Matrix2(arr) {
            return matrix2(_createArray(arr.map((m3) => m3.toArray())));
          }
          // TODO implement this properly for SparseMatrix
        });
        function _createArray(arr) {
          if (arr.length === 0)
            throw new TypeError("At least one column is needed to construct a matrix.");
          var N3 = checkVectorTypeAndReturnLength(arr[0]);
          var result = [];
          for (var i5 = 0; i5 < N3; i5++) {
            result[i5] = [];
          }
          for (var col of arr) {
            var colLength = checkVectorTypeAndReturnLength(col);
            if (colLength !== N3) {
              throw new TypeError("The vectors had different length: " + (N3 | 0) + " \u2260 " + (colLength | 0));
            }
            var f3 = flatten3(col);
            for (var _i = 0; _i < N3; _i++) {
              result[_i].push(f3[_i]);
            }
          }
          return result;
        }
        function checkVectorTypeAndReturnLength(vec) {
          var s3 = size2(vec);
          if (s3.length === 1) {
            return s3[0];
          } else if (s3.length === 2) {
            if (s3[0] === 1) {
              return s3[1];
            } else if (s3[1] === 1) {
              return s3[0];
            } else {
              throw new TypeError("At least one of the arguments is not a vector.");
            }
          } else {
            throw new TypeError("Only one- or two-dimensional vectors are supported.");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
  var name29, dependencies30, createSplitUnit;
  var init_splitUnit = __esm({
    "node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js"() {
      init_factory();
      name29 = "splitUnit";
      dependencies30 = ["typed"];
      createSplitUnit = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name29, {
          "Unit, Array": function UnitArray(unit2, parts) {
            return unit2.splitUnit(parts);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
  var name30, dependencies31, createUnaryMinus;
  var init_unaryMinus = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js"() {
      init_factory();
      init_collection();
      init_number2();
      name30 = "unaryMinus";
      dependencies31 = ["typed"];
      createUnaryMinus = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name30, {
          number: unaryMinusNumber,
          "Complex | BigNumber | Fraction": (x4) => x4.neg(),
          Unit: typed3.referToSelf((self2) => (x4) => {
            var res = x4.clone();
            res.value = typed3.find(self2, res.valueType())(x4.value);
            return res;
          }),
          // deep map collection, skip zeros since unaryMinus(0) = 0
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2, true))
          // TODO: add support for string
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
  var name31, dependencies32, createUnaryPlus;
  var init_unaryPlus = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js"() {
      init_factory();
      init_collection();
      init_number2();
      name31 = "unaryPlus";
      dependencies32 = ["typed", "config", "BigNumber"];
      createUnaryPlus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          BigNumber: BigNumber2
        } = _ref;
        return typed3(name31, {
          number: unaryPlusNumber,
          Complex: function Complex3(x4) {
            return x4;
          },
          BigNumber: function BigNumber3(x4) {
            return x4;
          },
          Fraction: function Fraction3(x4) {
            return x4;
          },
          Unit: function Unit2(x4) {
            return x4.clone();
          },
          // deep map collection, skip zeros since unaryPlus(0) = 0
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2, true)),
          "boolean | string": function booleanString(x4) {
            return config4.number === "BigNumber" ? new BigNumber2(+x4) : +x4;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/abs.js
  var name32, dependencies33, createAbs;
  var init_abs = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/abs.js"() {
      init_factory();
      init_collection();
      init_number2();
      name32 = "abs";
      dependencies33 = ["typed"];
      createAbs = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name32, {
          number: absNumber,
          "Complex | BigNumber | Fraction | Unit": (x4) => x4.abs(),
          // deep map collection, skip zeros since abs(0) = 0
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2, true))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/apply.js
  function _apply(mat, dim, callback) {
    var i5, ret, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        return callback(mat);
      } else {
        tran = _switch2(mat);
        ret = [];
        for (i5 = 0; i5 < tran.length; i5++) {
          ret[i5] = _apply(tran[i5], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i5 = 0; i5 < mat.length; i5++) {
        ret[i5] = _apply(mat[i5], dim - 1, callback);
      }
      return ret;
    }
  }
  function _switch2(mat) {
    var I3 = mat.length;
    var J2 = mat[0].length;
    var i5, j4;
    var ret = [];
    for (j4 = 0; j4 < J2; j4++) {
      var tmp = [];
      for (i5 = 0; i5 < I3; i5++) {
        tmp.push(mat[i5][j4]);
      }
      ret.push(tmp);
    }
    return ret;
  }
  var name33, dependencies34, createApply;
  var init_apply = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/apply.js"() {
      init_factory();
      init_array();
      init_is();
      init_IndexError();
      name33 = "apply";
      dependencies34 = ["typed", "isInteger"];
      createApply = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
        var {
          typed: typed3,
          isInteger: isInteger3
        } = _ref;
        return typed3(name33, {
          "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
            if (!isInteger3(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
            if (dim < 0 || dim >= size2.length) {
              throw new IndexError(dim, size2.length);
            }
            if (isMatrix(mat)) {
              return mat.create(_apply(mat.valueOf(), dim, callback));
            } else {
              return _apply(mat, dim, callback);
            }
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name34, dependencies35, createAddScalar;
  var init_addScalar = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js"() {
      init_factory();
      init_number2();
      name34 = "addScalar";
      dependencies35 = ["typed"];
      createAddScalar = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name34, {
          "number, number": addNumber,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return x4.add(y3);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.plus(y3);
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            return x4.add(y3);
          },
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => {
            if (x4.value === null || x4.value === void 0) {
              throw new Error("Parameter x contains a unit with undefined value");
            }
            if (y3.value === null || y3.value === void 0) {
              throw new Error("Parameter y contains a unit with undefined value");
            }
            if (!x4.equalBase(y3))
              throw new Error("Units do not match");
            var res = x4.clone();
            res.value = typed3.find(self2, [res.valueType(), y3.valueType()])(res.value, y3.value);
            res.fixPrefix = false;
            return res;
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
  var name35, dependencies36, createCbrt;
  var init_cbrt = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js"() {
      init_factory();
      init_is();
      init_number2();
      name35 = "cbrt";
      dependencies36 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
      createCbrt = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
        var {
          config: config4,
          typed: typed3,
          isNegative: isNegative2,
          unaryMinus: unaryMinus2,
          matrix: matrix2,
          Complex: Complex3,
          BigNumber: BigNumber2,
          Fraction: Fraction3
        } = _ref;
        return typed3(name35, {
          number: cbrtNumber,
          // note: signature 'number, boolean' is also supported,
          //       created by typed as it knows how to convert number to Complex
          Complex: _cbrtComplex,
          "Complex, boolean": _cbrtComplex,
          BigNumber: function BigNumber3(x4) {
            return x4.cbrt();
          },
          Unit: _cbrtUnit
        });
        function _cbrtComplex(x4, allRoots) {
          var arg3 = x4.arg() / 3;
          var abs3 = x4.abs();
          var principal = new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3).exp());
          if (allRoots) {
            var all = [principal, new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
            return config4.matrix === "Array" ? all : matrix2(all);
          } else {
            return principal;
          }
        }
        function _cbrtUnit(x4) {
          if (x4.value && isComplex(x4.value)) {
            var result = x4.clone();
            result.value = 1;
            result = result.pow(1 / 3);
            result.value = _cbrtComplex(x4.value);
            return result;
          } else {
            var negate = isNegative2(x4.value);
            if (negate) {
              x4.value = unaryMinus2(x4.value);
            }
            var third;
            if (isBigNumber(x4.value)) {
              third = new BigNumber2(1).div(3);
            } else if (isFraction(x4.value)) {
              third = new Fraction3(1, 3);
            } else {
              third = 1 / 3;
            }
            var _result = x4.pow(third);
            if (negate) {
              _result.value = unaryMinus2(_result.value);
            }
            return _result;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
  var name36, dependencies37, createMatAlgo11xS0s;
  var init_matAlgo11xS0s = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js"() {
      init_factory();
      name36 = "matAlgo11xS0s";
      dependencies37 = ["typed", "equalScalar"];
      createMatAlgo11xS0s = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo11xS0s(s3, b3, callback, inverse) {
          var avalues = s3._values;
          var aindex = s3._index;
          var aptr = s3._ptr;
          var asize = s3._size;
          var adt = s3._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            b3 = typed3.convert(b3, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          for (var j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            for (var k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var i5 = aindex[k4];
              var v3 = inverse ? cf(b3, avalues[k4]) : cf(avalues[k4], b3);
              if (!eq(v3, zero)) {
                cindex.push(i5);
                cvalues.push(v3);
              }
            }
          }
          cptr[columns] = cindex.length;
          return s3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
  var name37, dependencies38, createMatAlgo12xSfs;
  var init_matAlgo12xSfs = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js"() {
      init_factory();
      name37 = "matAlgo12xSfs";
      dependencies38 = ["typed", "DenseMatrix"];
      createMatAlgo12xSfs = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
        var {
          typed: typed3,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return function matAlgo12xSfs(s3, b3, callback, inverse) {
          var avalues = s3._values;
          var aindex = s3._index;
          var aptr = s3._ptr;
          var asize = s3._size;
          var adt = s3._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b3 = typed3.convert(b3, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cdata = [];
          var x4 = [];
          var w4 = [];
          for (var j4 = 0; j4 < columns; j4++) {
            var mark = j4 + 1;
            for (var k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var r3 = aindex[k4];
              x4[r3] = avalues[k4];
              w4[r3] = mark;
            }
            for (var i5 = 0; i5 < rows; i5++) {
              if (j4 === 0) {
                cdata[i5] = [];
              }
              if (w4[i5] === mark) {
                cdata[i5][j4] = inverse ? cf(b3, x4[i5]) : cf(x4[i5], b3);
              } else {
                cdata[i5][j4] = inverse ? cf(b3, 0) : cf(0, b3);
              }
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
  var name38, dependencies39, createMatAlgo14xDs;
  var init_matAlgo14xDs = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js"() {
      init_factory();
      init_object();
      name38 = "matAlgo14xDs";
      dependencies39 = ["typed"];
      createMatAlgo14xDs = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return function matAlgo14xDs(a3, b3, callback, inverse) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b3 = typed3.convert(b3, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b3, inverse) : [];
          return a3.createDenseMatrix({
            data: cdata,
            size: clone(asize),
            datatype: dt
          });
        };
        function _iterate(f3, level, s3, n3, av, bv, inverse) {
          var cv = [];
          if (level === s3.length - 1) {
            for (var i5 = 0; i5 < n3; i5++) {
              cv[i5] = inverse ? f3(bv, av[i5]) : f3(av[i5], bv);
            }
          } else {
            for (var j4 = 0; j4 < n3; j4++) {
              cv[j4] = _iterate(f3, level + 1, s3, s3[level + 1], av[j4], bv, inverse);
            }
          }
          return cv;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
  var name39, dependencies40, createCeilNumber, createCeil;
  var init_ceil = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/ceil.js"() {
      init_decimal();
      init_factory();
      init_collection();
      init_number();
      init_nearlyEqual();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matAlgo14xDs();
      name39 = "ceil";
      dependencies40 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
      createCeilNumber = /* @__PURE__ */ factory(name39, ["typed", "config", "round"], (_ref) => {
        var {
          typed: typed3,
          config: config4,
          round: round3
        } = _ref;
        return typed3(name39, {
          number: function number2(x4) {
            if (nearlyEqual(x4, round3(x4), config4.epsilon)) {
              return round3(x4);
            } else {
              return Math.ceil(x4);
            }
          },
          "number, number": function numberNumber(x4, n3) {
            if (nearlyEqual(x4, round3(x4, n3), config4.epsilon)) {
              return round3(x4, n3);
            } else {
              var [number2, exponent] = "".concat(x4, "e").split("e");
              var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n3)));
              [number2, exponent] = "".concat(result, "e").split("e");
              return Number("".concat(number2, "e").concat(Number(exponent) - n3));
            }
          }
        });
      });
      createCeil = /* @__PURE__ */ factory(name39, dependencies40, (_ref2) => {
        var {
          typed: typed3,
          config: config4,
          round: round3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2
        } = _ref2;
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var ceilNumber = createCeilNumber({
          typed: typed3,
          config: config4,
          round: round3
        });
        return typed3("ceil", {
          number: ceilNumber.signatures.number,
          "number,number": ceilNumber.signatures["number,number"],
          Complex: function Complex3(x4) {
            return x4.ceil();
          },
          "Complex, number": function ComplexNumber(x4, n3) {
            return x4.ceil(n3);
          },
          "Complex, BigNumber": function ComplexBigNumber(x4, n3) {
            return x4.ceil(n3.toNumber());
          },
          BigNumber: function BigNumber2(x4) {
            if (nearlyEqual2(x4, round3(x4), config4.epsilon)) {
              return round3(x4);
            } else {
              return x4.ceil();
            }
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, n3) {
            if (nearlyEqual2(x4, round3(x4, n3), config4.epsilon)) {
              return round3(x4, n3);
            } else {
              return x4.toDecimalPlaces(n3.toNumber(), decimal_default.ROUND_CEIL);
            }
          },
          Fraction: function Fraction3(x4) {
            return x4.ceil();
          },
          "Fraction, number": function FractionNumber(x4, n3) {
            return x4.ceil(n3);
          },
          "Fraction, BigNumber": function FractionBigNumber(x4, n3) {
            return x4.ceil(n3.toNumber());
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => {
            return deepMap(x4, self2, true);
          }),
          "Array, number | BigNumber": typed3.referToSelf((self2) => (x4, n3) => {
            return deepMap(x4, (i5) => self2(i5, n3), true);
          }),
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(matrix2(y3), x4, self2, true).valueOf();
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0))
              return zeros3(y3.size(), y3.storage());
            if (y3.storage() === "dense") {
              return matAlgo14xDs(y3, x4, self2, true);
            }
            return matAlgo12xSfs(y3, x4, self2, true);
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cube.js
  var name40, dependencies41, createCube;
  var init_cube = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/cube.js"() {
      init_factory();
      init_number2();
      name40 = "cube";
      dependencies41 = ["typed"];
      createCube = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name40, {
          number: cubeNumber,
          Complex: function Complex3(x4) {
            return x4.mul(x4).mul(x4);
          },
          BigNumber: function BigNumber2(x4) {
            return x4.times(x4).times(x4);
          },
          Fraction: function Fraction3(x4) {
            return x4.pow(3);
          },
          Unit: function Unit2(x4) {
            return x4.pow(3);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/exp.js
  var name41, dependencies42, createExp;
  var init_exp = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/exp.js"() {
      init_factory();
      init_number2();
      name41 = "exp";
      dependencies42 = ["typed"];
      createExp = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name41, {
          number: expNumber,
          Complex: function Complex3(x4) {
            return x4.exp();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.exp();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
  var name42, dependencies43, createExpm1;
  var init_expm1 = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/expm1.js"() {
      init_factory();
      init_number2();
      name42 = "expm1";
      dependencies43 = ["typed", "Complex"];
      createExpm1 = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
        var {
          typed: typed3,
          Complex: _Complex
        } = _ref;
        return typed3(name42, {
          number: expm1Number,
          Complex: function Complex3(x4) {
            var r3 = Math.exp(x4.re);
            return new _Complex(r3 * Math.cos(x4.im) - 1, r3 * Math.sin(x4.im));
          },
          BigNumber: function BigNumber2(x4) {
            return x4.exp().minus(1);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/fix.js
  var name43, dependencies44, createFixNumber, createFix;
  var init_fix = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/fix.js"() {
      init_factory();
      init_collection();
      init_matAlgo12xSfs();
      init_matAlgo14xDs();
      name43 = "fix";
      dependencies44 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
      createFixNumber = /* @__PURE__ */ factory(name43, ["typed", "ceil", "floor"], (_ref) => {
        var {
          typed: typed3,
          ceil: ceil3,
          floor: floor3
        } = _ref;
        return typed3(name43, {
          number: function number2(x4) {
            return x4 > 0 ? floor3(x4) : ceil3(x4);
          },
          "number, number": function numberNumber(x4, n3) {
            return x4 > 0 ? floor3(x4, n3) : ceil3(x4, n3);
          }
        });
      });
      createFix = /* @__PURE__ */ factory(name43, dependencies44, (_ref2) => {
        var {
          typed: typed3,
          Complex: _Complex,
          matrix: matrix2,
          ceil: ceil3,
          floor: floor3,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2
        } = _ref2;
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var fixNumber = createFixNumber({
          typed: typed3,
          ceil: ceil3,
          floor: floor3
        });
        return typed3("fix", {
          number: fixNumber.signatures.number,
          "number, number | BigNumber": fixNumber.signatures["number,number"],
          Complex: function Complex3(x4) {
            return new _Complex(x4.re > 0 ? Math.floor(x4.re) : Math.ceil(x4.re), x4.im > 0 ? Math.floor(x4.im) : Math.ceil(x4.im));
          },
          "Complex, number": function ComplexNumber(x4, n3) {
            return new _Complex(x4.re > 0 ? floor3(x4.re, n3) : ceil3(x4.re, n3), x4.im > 0 ? floor3(x4.im, n3) : ceil3(x4.im, n3));
          },
          "Complex, BigNumber": function ComplexBigNumber(x4, bn2) {
            var n3 = bn2.toNumber();
            return new _Complex(x4.re > 0 ? floor3(x4.re, n3) : ceil3(x4.re, n3), x4.im > 0 ? floor3(x4.im, n3) : ceil3(x4.im, n3));
          },
          BigNumber: function BigNumber2(x4) {
            return x4.isNegative() ? ceil3(x4) : floor3(x4);
          },
          "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x4, n3) {
            return x4.isNegative() ? ceil3(x4, n3) : floor3(x4, n3);
          },
          Fraction: function Fraction3(x4) {
            return x4.s < 0 ? x4.ceil() : x4.floor();
          },
          "Fraction, number | BigNumber": function FractionNumberBigNumber(x4, n3) {
            return x4.s < 0 ? ceil3(x4, n3) : floor3(x4, n3);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => {
            return deepMap(x4, self2, true);
          }),
          "Array | Matrix, number | BigNumber": typed3.referToSelf((self2) => (x4, n3) => {
            return deepMap(x4, (i5) => self2(i5, n3), true);
          }),
          "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(matrix2(y3), x4, self2, true).valueOf();
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0))
              return zeros3(y3.size(), y3.storage());
            if (y3.storage() === "dense") {
              return matAlgo14xDs(y3, x4, self2, true);
            }
            return matAlgo12xSfs(y3, x4, self2, true);
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/floor.js
  var name44, dependencies45, createFloorNumber, createFloor;
  var init_floor = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/floor.js"() {
      init_decimal();
      init_factory();
      init_collection();
      init_number();
      init_nearlyEqual();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matAlgo14xDs();
      name44 = "floor";
      dependencies45 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
      createFloorNumber = /* @__PURE__ */ factory(name44, ["typed", "config", "round"], (_ref) => {
        var {
          typed: typed3,
          config: config4,
          round: round3
        } = _ref;
        return typed3(name44, {
          number: function number2(x4) {
            if (nearlyEqual(x4, round3(x4), config4.epsilon)) {
              return round3(x4);
            } else {
              return Math.floor(x4);
            }
          },
          "number, number": function numberNumber(x4, n3) {
            if (nearlyEqual(x4, round3(x4, n3), config4.epsilon)) {
              return round3(x4, n3);
            } else {
              var [number2, exponent] = "".concat(x4, "e").split("e");
              var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n3)));
              [number2, exponent] = "".concat(result, "e").split("e");
              return Number("".concat(number2, "e").concat(Number(exponent) - n3));
            }
          }
        });
      });
      createFloor = /* @__PURE__ */ factory(name44, dependencies45, (_ref2) => {
        var {
          typed: typed3,
          config: config4,
          round: round3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2
        } = _ref2;
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var floorNumber = createFloorNumber({
          typed: typed3,
          config: config4,
          round: round3
        });
        return typed3("floor", {
          number: floorNumber.signatures.number,
          "number,number": floorNumber.signatures["number,number"],
          Complex: function Complex3(x4) {
            return x4.floor();
          },
          "Complex, number": function ComplexNumber(x4, n3) {
            return x4.floor(n3);
          },
          "Complex, BigNumber": function ComplexBigNumber(x4, n3) {
            return x4.floor(n3.toNumber());
          },
          BigNumber: function BigNumber2(x4) {
            if (nearlyEqual2(x4, round3(x4), config4.epsilon)) {
              return round3(x4);
            } else {
              return x4.floor();
            }
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, n3) {
            if (nearlyEqual2(x4, round3(x4, n3), config4.epsilon)) {
              return round3(x4, n3);
            } else {
              return x4.toDecimalPlaces(n3.toNumber(), decimal_default.ROUND_FLOOR);
            }
          },
          Fraction: function Fraction3(x4) {
            return x4.floor();
          },
          "Fraction, number": function FractionNumber(x4, n3) {
            return x4.floor(n3);
          },
          "Fraction, BigNumber": function FractionBigNumber(x4, n3) {
            return x4.floor(n3.toNumber());
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => {
            return deepMap(x4, self2, true);
          }),
          "Array, number | BigNumber": typed3.referToSelf((self2) => (x4, n3) => {
            return deepMap(x4, (i5) => self2(i5, n3), true);
          }),
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(matrix2(y3), x4, self2, true).valueOf();
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0))
              return zeros3(y3.size(), y3.storage());
            if (y3.storage() === "dense") {
              return matAlgo14xDs(y3, x4, self2, true);
            }
            return matAlgo12xSfs(y3, x4, self2, true);
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
  var name45, dependencies46, createMatAlgo01xDSid;
  var init_matAlgo01xDSid = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js"() {
      init_factory();
      init_DimensionError();
      name45 = "matAlgo01xDSid";
      dependencies46 = ["typed"];
      createMatAlgo01xDSid = /* @__PURE__ */ factory(name45, dependencies46, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype;
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
          var cf = dt ? typed3.find(callback, [dt, dt]) : callback;
          var i5, j4;
          var cdata = [];
          for (i5 = 0; i5 < rows; i5++) {
            cdata[i5] = [];
          }
          var x4 = [];
          var w4 = [];
          for (j4 = 0; j4 < columns; j4++) {
            var mark = j4 + 1;
            for (var k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = bindex[k4];
              x4[i5] = inverse ? cf(bvalues[k4], adata[i5][j4]) : cf(adata[i5][j4], bvalues[k4]);
              w4[i5] = mark;
            }
            for (i5 = 0; i5 < rows; i5++) {
              if (w4[i5] === mark) {
                cdata[i5][j4] = x4[i5];
              } else {
                cdata[i5][j4] = adata[i5][j4];
              }
            }
          }
          return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
  var name46, dependencies47, createMatAlgo04xSidSid;
  var init_matAlgo04xSidSid = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js"() {
      init_factory();
      init_DimensionError();
      name46 = "matAlgo04xSidSid";
      dependencies47 = ["typed", "equalScalar"];
      createMatAlgo04xSidSid = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo04xSidSid(a3, b3, callback) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var xa = avalues && bvalues ? [] : void 0;
          var xb = avalues && bvalues ? [] : void 0;
          var wa = [];
          var wb = [];
          var i5, j4, k4, k0, k1;
          for (j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            var mark = j4 + 1;
            for (k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = aindex[k4];
              cindex.push(i5);
              wa[i5] = mark;
              if (xa) {
                xa[i5] = avalues[k4];
              }
            }
            for (k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = bindex[k4];
              if (wa[i5] === mark) {
                if (xa) {
                  var v3 = cf(xa[i5], bvalues[k4]);
                  if (!eq(v3, zero)) {
                    xa[i5] = v3;
                  } else {
                    wa[i5] = null;
                  }
                }
              } else {
                cindex.push(i5);
                wb[i5] = mark;
                if (xb) {
                  xb[i5] = bvalues[k4];
                }
              }
            }
            if (xa && xb) {
              k4 = cptr[j4];
              while (k4 < cindex.length) {
                i5 = cindex[k4];
                if (wa[i5] === mark) {
                  cvalues[k4] = xa[i5];
                  k4++;
                } else if (wb[i5] === mark) {
                  cvalues[k4] = xb[i5];
                  k4++;
                } else {
                  cindex.splice(k4, 1);
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
  var name47, dependencies48, createMatAlgo10xSids;
  var init_matAlgo10xSids = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js"() {
      init_factory();
      name47 = "matAlgo10xSids";
      dependencies48 = ["typed", "DenseMatrix"];
      createMatAlgo10xSids = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
        var {
          typed: typed3,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return function matAlgo10xSids(s3, b3, callback, inverse) {
          var avalues = s3._values;
          var aindex = s3._index;
          var aptr = s3._ptr;
          var asize = s3._size;
          var adt = s3._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b3 = typed3.convert(b3, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cdata = [];
          var x4 = [];
          var w4 = [];
          for (var j4 = 0; j4 < columns; j4++) {
            var mark = j4 + 1;
            for (var k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var r3 = aindex[k4];
              x4[r3] = avalues[k4];
              w4[r3] = mark;
            }
            for (var i5 = 0; i5 < rows; i5++) {
              if (j4 === 0) {
                cdata[i5] = [];
              }
              if (w4[i5] === mark) {
                cdata[i5][j4] = inverse ? cf(b3, x4[i5]) : cf(x4[i5], b3);
              } else {
                cdata[i5][j4] = b3;
              }
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
  var name48, dependencies49, createMatAlgo13xDD;
  var init_matAlgo13xDD = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js"() {
      init_factory();
      init_DimensionError();
      name48 = "matAlgo13xDD";
      dependencies49 = ["typed"];
      createMatAlgo13xDD = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return function matAlgo13xDD(a3, b3, callback) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var bdata = b3._data;
          var bsize = b3._size;
          var bdt = b3._datatype;
          var csize = [];
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          for (var s3 = 0; s3 < asize.length; s3++) {
            if (asize[s3] !== bsize[s3]) {
              throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
            }
            csize[s3] = asize[s3];
          }
          var dt;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            cf = typed3.find(callback, [dt, dt]);
          }
          var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
          return a3.createDenseMatrix({
            data: cdata,
            size: csize,
            datatype: dt
          });
        };
        function _iterate(f3, level, s3, n3, av, bv) {
          var cv = [];
          if (level === s3.length - 1) {
            for (var i5 = 0; i5 < n3; i5++) {
              cv[i5] = f3(av[i5], bv[i5]);
            }
          } else {
            for (var j4 = 0; j4 < n3; j4++) {
              cv[j4] = _iterate(f3, level + 1, s3, s3[level + 1], av[j4], bv[j4]);
            }
          }
          return cv;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
  var name49, dependancies, createBroadcast;
  var init_broadcast = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"() {
      init_array();
      init_factory();
      name49 = "broadcast";
      dependancies = ["concat"];
      createBroadcast = /* @__PURE__ */ factory(name49, dependancies, (_ref) => {
        var {
          concat: concat3
        } = _ref;
        return function(A4, B4) {
          var N3 = Math.max(A4._size.length, B4._size.length);
          if (A4._size.length === B4._size.length) {
            if (A4._size.every((dim2, i5) => dim2 === B4._size[i5])) {
              return [A4, B4];
            }
          }
          var sizeA = _padLeft(A4._size, N3, 0);
          var sizeB = _padLeft(B4._size, N3, 0);
          var sizeMax = [];
          for (var dim = 0; dim < N3; dim++) {
            sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
          }
          checkBroadcastingRules(sizeA, sizeMax);
          checkBroadcastingRules(sizeB, sizeMax);
          var AA = A4.clone();
          var BB = B4.clone();
          if (AA._size.length < N3) {
            AA.reshape(_padLeft(AA._size, N3, 1));
          } else if (BB._size.length < N3) {
            BB.reshape(_padLeft(BB._size, N3, 1));
          }
          for (var _dim = 0; _dim < N3; _dim++) {
            if (AA._size[_dim] < sizeMax[_dim]) {
              AA = _stretch(AA, sizeMax[_dim], _dim);
            }
            if (BB._size[_dim] < sizeMax[_dim]) {
              BB = _stretch(BB, sizeMax[_dim], _dim);
            }
          }
          return [AA, BB];
        };
        function _padLeft(shape, N3, filler) {
          return [...Array(N3 - shape.length).fill(filler), ...shape];
        }
        function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
          return concat3(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
  var name50, dependencies50, createMatrixAlgorithmSuite;
  var init_matrixAlgorithmSuite = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js"() {
      init_factory();
      init_object();
      init_matAlgo13xDD();
      init_matAlgo14xDs();
      init_broadcast();
      name50 = "matrixAlgorithmSuite";
      dependencies50 = ["typed", "matrix", "concat"];
      createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name50, dependencies50, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        } = _ref;
        var matAlgo13xDD = createMatAlgo13xDD({
          typed: typed3
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var broadcast = createBroadcast({
          concat: concat3
        });
        return function matrixAlgorithmSuite(options) {
          var elop = options.elop;
          var SD = options.SD || options.DS;
          var matrixSignatures;
          if (elop) {
            matrixSignatures = {
              "DenseMatrix, DenseMatrix": (x4, y3) => matAlgo13xDD(...broadcast(x4, y3), elop),
              "Array, Array": (x4, y3) => matAlgo13xDD(...broadcast(matrix2(x4), matrix2(y3)), elop).valueOf(),
              "Array, DenseMatrix": (x4, y3) => matAlgo13xDD(...broadcast(matrix2(x4), y3), elop),
              "DenseMatrix, Array": (x4, y3) => matAlgo13xDD(...broadcast(x4, matrix2(y3)), elop)
            };
            if (options.SS) {
              matrixSignatures["SparseMatrix, SparseMatrix"] = (x4, y3) => options.SS(...broadcast(x4, y3), elop, false);
            }
            if (options.DS) {
              matrixSignatures["DenseMatrix, SparseMatrix"] = (x4, y3) => options.DS(...broadcast(x4, y3), elop, false);
              matrixSignatures["Array, SparseMatrix"] = (x4, y3) => options.DS(...broadcast(matrix2(x4), y3), elop, false);
            }
            if (SD) {
              matrixSignatures["SparseMatrix, DenseMatrix"] = (x4, y3) => SD(...broadcast(y3, x4), elop, true);
              matrixSignatures["SparseMatrix, Array"] = (x4, y3) => SD(...broadcast(matrix2(y3), x4), elop, true);
            }
          } else {
            matrixSignatures = {
              "DenseMatrix, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo13xDD(...broadcast(x4, y3), self2);
              }),
              "Array, Array": typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo13xDD(...broadcast(matrix2(x4), matrix2(y3)), self2).valueOf();
              }),
              "Array, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo13xDD(...broadcast(matrix2(x4), y3), self2);
              }),
              "DenseMatrix, Array": typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo13xDD(...broadcast(x4, matrix2(y3)), self2);
              })
            };
            if (options.SS) {
              matrixSignatures["SparseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return options.SS(...broadcast(x4, y3), self2, false);
              });
            }
            if (options.DS) {
              matrixSignatures["DenseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return options.DS(...broadcast(x4, y3), self2, false);
              });
              matrixSignatures["Array, SparseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return options.DS(...broadcast(matrix2(x4), y3), self2, false);
              });
            }
            if (SD) {
              matrixSignatures["SparseMatrix, DenseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return SD(...broadcast(y3, x4), self2, true);
              });
              matrixSignatures["SparseMatrix, Array"] = typed3.referToSelf((self2) => (x4, y3) => {
                return SD(...broadcast(matrix2(y3), x4), self2, true);
              });
            }
          }
          var scalar = options.scalar || "any";
          var Ds = options.Ds || options.Ss;
          if (Ds) {
            if (elop) {
              matrixSignatures["DenseMatrix," + scalar] = (x4, y3) => matAlgo14xDs(x4, y3, elop, false);
              matrixSignatures[scalar + ", DenseMatrix"] = (x4, y3) => matAlgo14xDs(y3, x4, elop, true);
              matrixSignatures["Array," + scalar] = (x4, y3) => matAlgo14xDs(matrix2(x4), y3, elop, false).valueOf();
              matrixSignatures[scalar + ", Array"] = (x4, y3) => matAlgo14xDs(matrix2(y3), x4, elop, true).valueOf();
            } else {
              matrixSignatures["DenseMatrix," + scalar] = typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo14xDs(x4, y3, self2, false);
              });
              matrixSignatures[scalar + ", DenseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo14xDs(y3, x4, self2, true);
              });
              matrixSignatures["Array," + scalar] = typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo14xDs(matrix2(x4), y3, self2, false).valueOf();
              });
              matrixSignatures[scalar + ", Array"] = typed3.referToSelf((self2) => (x4, y3) => {
                return matAlgo14xDs(matrix2(y3), x4, self2, true).valueOf();
              });
            }
          }
          var sS = options.sS !== void 0 ? options.sS : options.Ss;
          if (elop) {
            if (options.Ss) {
              matrixSignatures["SparseMatrix," + scalar] = (x4, y3) => options.Ss(x4, y3, elop, false);
            }
            if (sS) {
              matrixSignatures[scalar + ", SparseMatrix"] = (x4, y3) => sS(y3, x4, elop, true);
            }
          } else {
            if (options.Ss) {
              matrixSignatures["SparseMatrix," + scalar] = typed3.referToSelf((self2) => (x4, y3) => {
                return options.Ss(x4, y3, self2, false);
              });
            }
            if (sS) {
              matrixSignatures[scalar + ", SparseMatrix"] = typed3.referToSelf((self2) => (x4, y3) => {
                return sS(y3, x4, self2, true);
              });
            }
          }
          if (elop && elop.signatures) {
            extend(matrixSignatures, elop.signatures);
          }
          return matrixSignatures;
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/error/ArgumentsError.js
  function ArgumentsError(fn2, count2, min3, max3) {
    if (!(this instanceof ArgumentsError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.fn = fn2;
    this.count = count2;
    this.min = min3;
    this.max = max3;
    this.message = "Wrong number of arguments in function " + fn2 + " (" + count2 + " provided, " + min3 + (max3 !== void 0 && max3 !== null ? "-" + max3 : "") + " expected)";
    this.stack = new Error().stack;
  }
  var init_ArgumentsError = __esm({
    "node_modules/mathjs/lib/esm/error/ArgumentsError.js"() {
      ArgumentsError.prototype = new Error();
      ArgumentsError.prototype.constructor = Error;
      ArgumentsError.prototype.name = "ArgumentsError";
      ArgumentsError.prototype.isArgumentsError = true;
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
  function is1d(array) {
    return !array.some((element) => Array.isArray(element));
  }
  var name51, dependencies51, gcdTypes, gcdManyTypesSignature, createGcd;
  var init_gcd = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/gcd.js"() {
      init_factory();
      init_matAlgo01xDSid();
      init_matAlgo04xSidSid();
      init_matAlgo10xSids();
      init_matrixAlgorithmSuite();
      init_number2();
      init_ArgumentsError();
      name51 = "gcd";
      dependencies51 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
      gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
      gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
      createGcd = /* @__PURE__ */ factory(name51, dependencies51, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          BigNumber: BigNumber2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo04xSidSid = createMatAlgo04xSidSid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name51, {
          "number, number": gcdNumber,
          "BigNumber, BigNumber": _gcdBigNumber,
          "Fraction, Fraction": (x4, y3) => x4.gcd(y3)
        }, matrixAlgorithmSuite({
          SS: matAlgo04xSidSid,
          DS: matAlgo01xDSid,
          Ss: matAlgo10xSids
        }), {
          [gcdManyTypesSignature]: typed3.referToSelf((self2) => (a3, b3, args) => {
            var res = self2(a3, b3);
            for (var i5 = 0; i5 < args.length; i5++) {
              res = self2(res, args[i5]);
            }
            return res;
          }),
          Array: typed3.referToSelf((self2) => (array) => {
            if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
              return self2(...array[0]);
            }
            if (is1d(array)) {
              return self2(...array);
            }
            throw new ArgumentsError("gcd() supports only 1d matrices!");
          }),
          Matrix: typed3.referToSelf((self2) => (matrix3) => {
            return self2(matrix3.toArray());
          })
        });
        function _gcdBigNumber(a3, b3) {
          if (!a3.isInt() || !b3.isInt()) {
            throw new Error("Parameters in function gcd must be integer numbers");
          }
          var zero = new BigNumber2(0);
          while (!b3.isZero()) {
            var r3 = a3.mod(b3);
            a3 = b3;
            b3 = r3;
          }
          return a3.lt(zero) ? a3.neg() : a3;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
  var name52, dependencies52, createMatAlgo02xDS0;
  var init_matAlgo02xDS0 = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js"() {
      init_factory();
      init_DimensionError();
      name52 = "matAlgo02xDS0";
      dependencies52 = ["typed", "equalScalar"];
      createMatAlgo02xDS0 = /* @__PURE__ */ factory(name52, dependencies52, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype;
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          for (var j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            for (var k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var i5 = bindex[k4];
              var cij = inverse ? cf(bvalues[k4], adata[i5][j4]) : cf(adata[i5][j4], bvalues[k4]);
              if (!eq(cij, zero)) {
                cindex.push(i5);
                cvalues.push(cij);
              }
            }
          }
          cptr[columns] = cindex.length;
          return sparseMatrix.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
  var name53, dependencies53, createMatAlgo06xS0S0;
  var init_matAlgo06xS0S0 = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js"() {
      init_factory();
      init_DimensionError();
      init_collection();
      name53 = "matAlgo06xS0S0";
      dependencies53 = ["typed", "equalScalar"];
      createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name53, dependencies53, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo06xS0S0(a3, b3, callback) {
          var avalues = a3._values;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var x4 = cvalues ? [] : void 0;
          var w4 = [];
          var u3 = [];
          for (var j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            var mark = j4 + 1;
            scatter(a3, j4, w4, x4, u3, mark, cindex, cf);
            scatter(b3, j4, w4, x4, u3, mark, cindex, cf);
            if (x4) {
              var k4 = cptr[j4];
              while (k4 < cindex.length) {
                var i5 = cindex[k4];
                if (u3[i5] === mark) {
                  var v3 = x4[i5];
                  if (!eq(v3, zero)) {
                    cvalues.push(v3);
                    k4++;
                  } else {
                    cindex.splice(k4, 1);
                  }
                } else {
                  cindex.splice(k4, 1);
                }
              }
            } else {
              var p3 = cptr[j4];
              while (p3 < cindex.length) {
                var r3 = cindex[p3];
                if (u3[r3] !== mark) {
                  cindex.splice(p3, 1);
                } else {
                  p3++;
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
  var name54, dependencies54, createLcm;
  var init_lcm = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/lcm.js"() {
      init_factory();
      init_matAlgo02xDS0();
      init_matAlgo06xS0S0();
      init_matAlgo11xS0s();
      init_matrixAlgorithmSuite();
      init_number2();
      name54 = "lcm";
      dependencies54 = ["typed", "matrix", "equalScalar", "concat"];
      createLcm = /* @__PURE__ */ factory(name54, dependencies54, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = createMatAlgo06xS0S0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
        var lcmManySignature = {};
        lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed3.referToSelf((self2) => (a3, b3, args) => {
          var res = self2(a3, b3);
          for (var i5 = 0; i5 < args.length; i5++) {
            res = self2(res, args[i5]);
          }
          return res;
        });
        return typed3(name54, {
          "number, number": lcmNumber,
          "BigNumber, BigNumber": _lcmBigNumber,
          "Fraction, Fraction": (x4, y3) => x4.lcm(y3)
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }), lcmManySignature);
        function _lcmBigNumber(a3, b3) {
          if (!a3.isInt() || !b3.isInt()) {
            throw new Error("Parameters in function lcm must be integer numbers");
          }
          if (a3.isZero()) {
            return a3;
          }
          if (b3.isZero()) {
            return b3;
          }
          var prod2 = a3.times(b3);
          while (!b3.isZero()) {
            var t3 = b3;
            b3 = a3.mod(t3);
            a3 = t3;
          }
          return prod2.div(a3).abs();
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log10.js
  var name55, dependencies55, createLog10;
  var init_log10 = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/log10.js"() {
      init_factory();
      init_collection();
      init_number2();
      name55 = "log10";
      dependencies55 = ["typed", "config", "Complex"];
      createLog10 = /* @__PURE__ */ factory(name55, dependencies55, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: _Complex
        } = _ref;
        return typed3(name55, {
          number: function number2(x4) {
            if (x4 >= 0 || config4.predictable) {
              return log10Number(x4);
            } else {
              return new _Complex(x4, 0).log().div(Math.LN10);
            }
          },
          Complex: function Complex3(x4) {
            return new _Complex(x4).log().div(Math.LN10);
          },
          BigNumber: function BigNumber2(x4) {
            if (!x4.isNegative() || config4.predictable) {
              return x4.log();
            } else {
              return new _Complex(x4.toNumber(), 0).log().div(Math.LN10);
            }
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log2.js
  var name56, dependencies56, createLog2;
  var init_log2 = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/log2.js"() {
      init_factory();
      init_collection();
      init_number2();
      name56 = "log2";
      dependencies56 = ["typed", "config", "Complex"];
      createLog2 = /* @__PURE__ */ factory(name56, dependencies56, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3
        } = _ref;
        return typed3(name56, {
          number: function number2(x4) {
            if (x4 >= 0 || config4.predictable) {
              return log2Number(x4);
            } else {
              return _log2Complex(new Complex3(x4, 0));
            }
          },
          Complex: _log2Complex,
          BigNumber: function BigNumber2(x4) {
            if (!x4.isNegative() || config4.predictable) {
              return x4.log(2);
            } else {
              return _log2Complex(new Complex3(x4.toNumber(), 0));
            }
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
        function _log2Complex(x4) {
          var newX = Math.sqrt(x4.re * x4.re + x4.im * x4.im);
          return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x4.im, x4.re) / Math.LN2);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
  var name57, dependencies57, createMatAlgo03xDSf;
  var init_matAlgo03xDSf = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js"() {
      init_factory();
      init_DimensionError();
      name57 = "matAlgo03xDSf";
      dependencies57 = ["typed"];
      createMatAlgo03xDSf = /* @__PURE__ */ factory(name57, dependencies57, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype;
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cdata = [];
          for (var z5 = 0; z5 < rows; z5++) {
            cdata[z5] = [];
          }
          var x4 = [];
          var w4 = [];
          for (var j4 = 0; j4 < columns; j4++) {
            var mark = j4 + 1;
            for (var k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var i5 = bindex[k4];
              x4[i5] = inverse ? cf(bvalues[k4], adata[i5][j4]) : cf(adata[i5][j4], bvalues[k4]);
              w4[i5] = mark;
            }
            for (var y3 = 0; y3 < rows; y3++) {
              if (w4[y3] === mark) {
                cdata[y3][j4] = x4[y3];
              } else {
                cdata[y3][j4] = inverse ? cf(zero, adata[y3][j4]) : cf(adata[y3][j4], zero);
              }
            }
          }
          return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
  var name58, dependencies58, createMatAlgo05xSfSf;
  var init_matAlgo05xSfSf = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js"() {
      init_factory();
      init_DimensionError();
      name58 = "matAlgo05xSfSf";
      dependencies58 = ["typed", "equalScalar"];
      createMatAlgo05xSfSf = /* @__PURE__ */ factory(name58, dependencies58, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo05xSfSf(a3, b3, callback) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var xa = cvalues ? [] : void 0;
          var xb = cvalues ? [] : void 0;
          var wa = [];
          var wb = [];
          var i5, j4, k4, k1;
          for (j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            var mark = j4 + 1;
            for (k4 = aptr[j4], k1 = aptr[j4 + 1]; k4 < k1; k4++) {
              i5 = aindex[k4];
              cindex.push(i5);
              wa[i5] = mark;
              if (xa) {
                xa[i5] = avalues[k4];
              }
            }
            for (k4 = bptr[j4], k1 = bptr[j4 + 1]; k4 < k1; k4++) {
              i5 = bindex[k4];
              if (wa[i5] !== mark) {
                cindex.push(i5);
              }
              wb[i5] = mark;
              if (xb) {
                xb[i5] = bvalues[k4];
              }
            }
            if (cvalues) {
              k4 = cptr[j4];
              while (k4 < cindex.length) {
                i5 = cindex[k4];
                var wai = wa[i5];
                var wbi = wb[i5];
                if (wai === mark || wbi === mark) {
                  var va = wai === mark ? xa[i5] : zero;
                  var vb = wbi === mark ? xb[i5] : zero;
                  var vc = cf(va, vb);
                  if (!eq(vc, zero)) {
                    cvalues.push(vc);
                    k4++;
                  } else {
                    cindex.splice(k4, 1);
                  }
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/mod.js
  var name59, dependencies59, createMod;
  var init_mod = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/mod.js"() {
      init_factory();
      init_matAlgo02xDS0();
      init_matAlgo03xDSf();
      init_matAlgo05xSfSf();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_number2();
      init_matrixAlgorithmSuite();
      name59 = "mod";
      dependencies59 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      createMod = /* @__PURE__ */ factory(name59, dependencies59, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo05xSfSf = createMatAlgo05xSfSf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name59, {
          "number, number": modNumber,
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            if (y3.isNeg()) {
              throw new Error("Cannot calculate mod for a negative divisor");
            }
            return y3.isZero() ? x4 : x4.mod(y3);
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            if (y3.compare(0) < 0) {
              throw new Error("Cannot calculate mod for a negative divisor");
            }
            return x4.compare(0) >= 0 ? x4.mod(y3) : x4.mod(y3).add(y3).mod(y3);
          }
        }, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name60, dependencies60, createMultiplyScalar;
  var init_multiplyScalar = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js"() {
      init_factory();
      init_number2();
      name60 = "multiplyScalar";
      dependencies60 = ["typed"];
      createMultiplyScalar = /* @__PURE__ */ factory(name60, dependencies60, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("multiplyScalar", {
          "number, number": multiplyNumber,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return x4.mul(y3);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.times(y3);
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            return x4.mul(y3);
          },
          "number | Fraction | BigNumber | Complex, Unit": (x4, y3) => y3.multiply(x4),
          "Unit, number | Fraction | BigNumber | Complex | Unit": (x4, y3) => x4.multiply(y3)
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name61, dependencies61, createMultiply;
  var init_multiply = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/multiply.js"() {
      init_factory();
      init_is();
      init_array();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      name61 = "multiply";
      dependencies61 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
      createMultiply = /* @__PURE__ */ factory(name61, dependencies61, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          addScalar: addScalar2,
          multiplyScalar: multiplyScalar2,
          equalScalar: equalScalar2,
          dot: dot2
        } = _ref;
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        function _validateMatrixDimensions(size1, size2) {
          switch (size1.length) {
            case 1:
              switch (size2.length) {
                case 1:
                  if (size1[0] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
                  }
                  break;
                case 2:
                  if (size1[0] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
                  }
                  break;
                default:
                  throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
              }
              break;
            case 2:
              switch (size2.length) {
                case 1:
                  if (size1[1] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
                  }
                  break;
                case 2:
                  if (size1[1] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
                  }
                  break;
                default:
                  throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
          }
        }
        function _multiplyVectorVector(a3, b3, n3) {
          if (n3 === 0) {
            throw new Error("Cannot multiply two empty vectors");
          }
          return dot2(a3, b3);
        }
        function _multiplyVectorMatrix(a3, b3) {
          if (b3.storage() !== "dense") {
            throw new Error("Support for SparseMatrix not implemented");
          }
          return _multiplyVectorDenseMatrix(a3, b3);
        }
        function _multiplyVectorDenseMatrix(a3, b3) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var bdata = b3._data;
          var bsize = b3._size;
          var bdt = b3._datatype;
          var alength = asize[0];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
          }
          var c3 = [];
          for (var j4 = 0; j4 < bcolumns; j4++) {
            var sum3 = mf(adata[0], bdata[0][j4]);
            for (var i5 = 1; i5 < alength; i5++) {
              sum3 = af(sum3, mf(adata[i5], bdata[i5][j4]));
            }
            c3[j4] = sum3;
          }
          return a3.createDenseMatrix({
            data: c3,
            size: [bcolumns],
            datatype: dt
          });
        }
        var _multiplyMatrixVector = typed3("_multiplyMatrixVector", {
          "DenseMatrix, any": _multiplyDenseMatrixVector,
          "SparseMatrix, any": _multiplySparseMatrixVector
        });
        var _multiplyMatrixMatrix = typed3("_multiplyMatrixMatrix", {
          "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
          "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
          "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
          "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
        });
        function _multiplyDenseMatrixVector(a3, b3) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var bdata = b3._data;
          var bdt = b3._datatype;
          var arows = asize[0];
          var acolumns = asize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
          }
          var c3 = [];
          for (var i5 = 0; i5 < arows; i5++) {
            var row2 = adata[i5];
            var sum3 = mf(row2[0], bdata[0]);
            for (var j4 = 1; j4 < acolumns; j4++) {
              sum3 = af(sum3, mf(row2[j4], bdata[j4]));
            }
            c3[i5] = sum3;
          }
          return a3.createDenseMatrix({
            data: c3,
            size: [arows],
            datatype: dt
          });
        }
        function _multiplyDenseMatrixDenseMatrix(a3, b3) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var bdata = b3._data;
          var bsize = b3._size;
          var bdt = b3._datatype;
          var arows = asize[0];
          var acolumns = asize[1];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
          }
          var c3 = [];
          for (var i5 = 0; i5 < arows; i5++) {
            var row2 = adata[i5];
            c3[i5] = [];
            for (var j4 = 0; j4 < bcolumns; j4++) {
              var sum3 = mf(row2[0], bdata[0][j4]);
              for (var x4 = 1; x4 < acolumns; x4++) {
                sum3 = af(sum3, mf(row2[x4], bdata[x4][j4]));
              }
              c3[i5][j4] = sum3;
            }
          }
          return a3.createDenseMatrix({
            data: c3,
            size: [arows, bcolumns],
            datatype: dt
          });
        }
        function _multiplyDenseMatrixSparseMatrix(a3, b3) {
          var adata = a3._data;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (!bvalues) {
            throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
          }
          var arows = asize[0];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var c3 = b3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: dt
          });
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var kb0 = bptr[jb];
            var kb1 = bptr[jb + 1];
            if (kb1 > kb0) {
              var last = 0;
              for (var i5 = 0; i5 < arows; i5++) {
                var mark = i5 + 1;
                var cij = void 0;
                for (var kb = kb0; kb < kb1; kb++) {
                  var ib = bindex[kb];
                  if (last !== mark) {
                    cij = mf(adata[i5][ib], bvalues[kb]);
                    last = mark;
                  } else {
                    cij = af(cij, mf(adata[i5][ib], bvalues[kb]));
                  }
                }
                if (last === mark && !eq(cij, zero)) {
                  cindex.push(i5);
                  cvalues.push(cij);
                }
              }
            }
          }
          cptr[bcolumns] = cindex.length;
          return c3;
        }
        function _multiplySparseMatrixVector(a3, b3) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var adt = a3._datatype;
          if (!avalues) {
            throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
          }
          var bdata = b3._data;
          var bdt = b3._datatype;
          var arows = a3._size[0];
          var brows = b3._size[0];
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
          }
          var x4 = [];
          var w4 = [];
          cptr[0] = 0;
          for (var ib = 0; ib < brows; ib++) {
            var vbi = bdata[ib];
            if (!eq(vbi, zero)) {
              for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                var ia = aindex[ka];
                if (!w4[ia]) {
                  w4[ia] = true;
                  cindex.push(ia);
                  x4[ia] = mf(vbi, avalues[ka]);
                } else {
                  x4[ia] = af(x4[ia], mf(vbi, avalues[ka]));
                }
              }
            }
          }
          for (var p1 = cindex.length, p3 = 0; p3 < p1; p3++) {
            var ic = cindex[p3];
            cvalues[p3] = x4[ic];
          }
          cptr[1] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, 1],
            datatype: dt
          });
        }
        function _multiplySparseMatrixDenseMatrix(a3, b3) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var adt = a3._datatype;
          if (!avalues) {
            throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
          }
          var bdata = b3._data;
          var bdt = b3._datatype;
          var arows = a3._size[0];
          var brows = b3._size[0];
          var bcolumns = b3._size[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var c3 = a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: dt
          });
          var x4 = [];
          var w4 = [];
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var mark = jb + 1;
            for (var ib = 0; ib < brows; ib++) {
              var vbij = bdata[ib][jb];
              if (!eq(vbij, zero)) {
                for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  var ia = aindex[ka];
                  if (w4[ia] !== mark) {
                    w4[ia] = mark;
                    cindex.push(ia);
                    x4[ia] = mf(vbij, avalues[ka]);
                  } else {
                    x4[ia] = af(x4[ia], mf(vbij, avalues[ka]));
                  }
                }
              }
            }
            for (var p0 = cptr[jb], p1 = cindex.length, p3 = p0; p3 < p1; p3++) {
              var ic = cindex[p3];
              cvalues[p3] = x4[ic];
            }
          }
          cptr[bcolumns] = cindex.length;
          return c3;
        }
        function _multiplySparseMatrixSparseMatrix(a3, b3) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bdt = b3._datatype;
          var arows = a3._size[0];
          var bcolumns = b3._size[1];
          var values = avalues && bvalues;
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            dt = adt;
            af = typed3.find(addScalar2, [dt, dt]);
            mf = typed3.find(multiplyScalar2, [dt, dt]);
          }
          var cvalues = values ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var c3 = a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: dt
          });
          var x4 = values ? [] : void 0;
          var w4 = [];
          var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var mark = jb + 1;
            for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
              ib = bindex[kb];
              if (values) {
                for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  ia = aindex[ka];
                  if (w4[ia] !== mark) {
                    w4[ia] = mark;
                    cindex.push(ia);
                    x4[ia] = mf(bvalues[kb], avalues[ka]);
                  } else {
                    x4[ia] = af(x4[ia], mf(bvalues[kb], avalues[ka]));
                  }
                }
              } else {
                for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  ia = aindex[ka];
                  if (w4[ia] !== mark) {
                    w4[ia] = mark;
                    cindex.push(ia);
                  }
                }
              }
            }
            if (values) {
              for (var p0 = cptr[jb], p1 = cindex.length, p3 = p0; p3 < p1; p3++) {
                var ic = cindex[p3];
                cvalues[p3] = x4[ic];
              }
            }
          }
          cptr[bcolumns] = cindex.length;
          return c3;
        }
        return typed3(name61, multiplyScalar2, {
          // we extend the signatures of multiplyScalar with signatures dealing with matrices
          "Array, Array": typed3.referTo("Matrix, Matrix", (selfMM) => (x4, y3) => {
            _validateMatrixDimensions(arraySize(x4), arraySize(y3));
            var m3 = selfMM(matrix2(x4), matrix2(y3));
            return isMatrix(m3) ? m3.valueOf() : m3;
          }),
          "Matrix, Matrix": function MatrixMatrix(x4, y3) {
            var xsize = x4.size();
            var ysize = y3.size();
            _validateMatrixDimensions(xsize, ysize);
            if (xsize.length === 1) {
              if (ysize.length === 1) {
                return _multiplyVectorVector(x4, y3, xsize[0]);
              }
              return _multiplyVectorMatrix(x4, y3);
            }
            if (ysize.length === 1) {
              return _multiplyMatrixVector(x4, y3);
            }
            return _multiplyMatrixMatrix(x4, y3);
          },
          "Matrix, Array": typed3.referTo("Matrix,Matrix", (selfMM) => (x4, y3) => selfMM(x4, matrix2(y3))),
          "Array, Matrix": typed3.referToSelf((self2) => (x4, y3) => {
            return self2(matrix2(x4, y3.storage()), y3);
          }),
          "SparseMatrix, any": function SparseMatrixAny(x4, y3) {
            return matAlgo11xS0s(x4, y3, multiplyScalar2, false);
          },
          "DenseMatrix, any": function DenseMatrixAny(x4, y3) {
            return matAlgo14xDs(x4, y3, multiplyScalar2, false);
          },
          "any, SparseMatrix": function anySparseMatrix(x4, y3) {
            return matAlgo11xS0s(y3, x4, multiplyScalar2, true);
          },
          "any, DenseMatrix": function anyDenseMatrix(x4, y3) {
            return matAlgo14xDs(y3, x4, multiplyScalar2, true);
          },
          "Array, any": function ArrayAny(x4, y3) {
            return matAlgo14xDs(matrix2(x4), y3, multiplyScalar2, false).valueOf();
          },
          "any, Array": function anyArray(x4, y3) {
            return matAlgo14xDs(matrix2(y3), x4, multiplyScalar2, true).valueOf();
          },
          "any, any": multiplyScalar2,
          "any, any, ...any": typed3.referToSelf((self2) => (x4, y3, rest) => {
            var result = self2(x4, y3);
            for (var i5 = 0; i5 < rest.length; i5++) {
              result = self2(result, rest[i5]);
            }
            return result;
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
  var name62, dependencies62, createNthRoot;
  var init_nthRoot = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js"() {
      init_factory();
      init_matAlgo01xDSid();
      init_matAlgo02xDS0();
      init_matAlgo06xS0S0();
      init_matAlgo11xS0s();
      init_matrixAlgorithmSuite();
      init_number2();
      name62 = "nthRoot";
      dependencies62 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
      createNthRoot = /* @__PURE__ */ factory(name62, dependencies62, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          BigNumber: _BigNumber,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = createMatAlgo06xS0S0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        function complexErr() {
          throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
        }
        return typed3(name62, {
          number: nthRootNumber,
          "number, number": nthRootNumber,
          BigNumber: (x4) => _bigNthRoot(x4, new _BigNumber(2)),
          "BigNumber, BigNumber": _bigNthRoot,
          Complex: complexErr,
          "Complex, number": complexErr,
          Array: typed3.referTo("DenseMatrix,number", (selfDn) => (x4) => selfDn(matrix2(x4), 2).valueOf()),
          DenseMatrix: typed3.referTo("DenseMatrix,number", (selfDn) => (x4) => selfDn(x4, 2)),
          SparseMatrix: typed3.referTo("SparseMatrix,number", (selfSn) => (x4) => selfSn(x4, 2)),
          "SparseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (y3.density() === 1) {
              return matAlgo06xS0S0(x4, y3, self2);
            } else {
              throw new Error("Root must be non-zero");
            }
          }),
          "DenseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (y3.density() === 1) {
              return matAlgo01xDSid(x4, y3, self2, false);
            } else {
              throw new Error("Root must be non-zero");
            }
          }),
          "Array, SparseMatrix": typed3.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x4, y3) => selfDS(matrix2(x4), y3)),
          "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (y3.density() === 1) {
              return matAlgo11xS0s(y3, x4, self2, true);
            } else {
              throw new Error("Root must be non-zero");
            }
          })
        }, matrixAlgorithmSuite({
          scalar: "number | BigNumber",
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: false
        }));
        function _bigNthRoot(a3, root) {
          var precision = _BigNumber.precision;
          var Big = _BigNumber.clone({
            precision: precision + 2
          });
          var zero = new _BigNumber(0);
          var one = new Big(1);
          var inv2 = root.isNegative();
          if (inv2) {
            root = root.neg();
          }
          if (root.isZero()) {
            throw new Error("Root must be non-zero");
          }
          if (a3.isNegative() && !root.abs().mod(2).equals(1)) {
            throw new Error("Root must be odd when a is negative.");
          }
          if (a3.isZero()) {
            return inv2 ? new Big(Infinity) : 0;
          }
          if (!a3.isFinite()) {
            return inv2 ? zero : a3;
          }
          var x4 = a3.abs().pow(one.div(root));
          x4 = a3.isNeg() ? x4.neg() : x4;
          return new _BigNumber((inv2 ? one.div(x4) : x4).toPrecision(precision));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sign.js
  var name63, dependencies63, createSign;
  var init_sign = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/sign.js"() {
      init_factory();
      init_collection();
      init_number2();
      name63 = "sign";
      dependencies63 = ["typed", "BigNumber", "Fraction", "complex"];
      createSign = /* @__PURE__ */ factory(name63, dependencies63, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber,
          complex: complex2,
          Fraction: _Fraction
        } = _ref;
        return typed3(name63, {
          number: signNumber,
          Complex: function Complex3(x4) {
            return x4.im === 0 ? complex2(signNumber(x4.re)) : x4.sign();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(x4.cmp(0));
          },
          Fraction: function Fraction3(x4) {
            return new _Fraction(x4.s, 1);
          },
          // deep map collection, skip zeros since sign(0) = 0
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2, true)),
          Unit: typed3.referToSelf((self2) => (x4) => {
            if (!x4._isDerived() && x4.units[0].unit.offset !== 0) {
              throw new TypeError("sign is ambiguous for units with offset");
            }
            return typed3.find(self2, x4.valueType())(x4.value);
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
  var name64, dependencies64, createSqrt;
  var init_sqrt = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js"() {
      init_factory();
      name64 = "sqrt";
      dependencies64 = ["config", "typed", "Complex"];
      createSqrt = /* @__PURE__ */ factory(name64, dependencies64, (_ref) => {
        var {
          config: config4,
          typed: typed3,
          Complex: Complex3
        } = _ref;
        return typed3("sqrt", {
          number: _sqrtNumber,
          Complex: function Complex4(x4) {
            return x4.sqrt();
          },
          BigNumber: function BigNumber2(x4) {
            if (!x4.isNegative() || config4.predictable) {
              return x4.sqrt();
            } else {
              return _sqrtNumber(x4.toNumber());
            }
          },
          Unit: function Unit2(x4) {
            return x4.pow(0.5);
          }
        });
        function _sqrtNumber(x4) {
          if (isNaN(x4)) {
            return NaN;
          } else if (x4 >= 0 || config4.predictable) {
            return Math.sqrt(x4);
          } else {
            return new Complex3(x4, 0).sqrt();
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/square.js
  var name65, dependencies65, createSquare;
  var init_square = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/square.js"() {
      init_factory();
      init_number2();
      name65 = "square";
      dependencies65 = ["typed"];
      createSquare = /* @__PURE__ */ factory(name65, dependencies65, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name65, {
          number: squareNumber,
          Complex: function Complex3(x4) {
            return x4.mul(x4);
          },
          BigNumber: function BigNumber2(x4) {
            return x4.times(x4);
          },
          Fraction: function Fraction3(x4) {
            return x4.mul(x4);
          },
          Unit: function Unit2(x4) {
            return x4.pow(2);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
  var name66, dependencies66, createSubtract;
  var init_subtract = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/subtract.js"() {
      init_factory();
      init_matAlgo01xDSid();
      init_matAlgo03xDSf();
      init_matAlgo05xSfSf();
      init_matAlgo10xSids();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name66 = "subtract";
      dependencies66 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix", "concat"];
      createSubtract = /* @__PURE__ */ factory(name66, dependencies66, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          addScalar: addScalar2,
          unaryMinus: unaryMinus2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo05xSfSf = createMatAlgo05xSfSf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name66, {
          "number, number": (x4, y3) => x4 - y3,
          "Complex, Complex": (x4, y3) => x4.sub(y3),
          "BigNumber, BigNumber": (x4, y3) => x4.minus(y3),
          "Fraction, Fraction": (x4, y3) => x4.sub(y3),
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => {
            if (x4.value === null) {
              throw new Error("Parameter x contains a unit with undefined value");
            }
            if (y3.value === null) {
              throw new Error("Parameter y contains a unit with undefined value");
            }
            if (!x4.equalBase(y3)) {
              throw new Error("Units do not match");
            }
            var res = x4.clone();
            res.value = typed3.find(self2, [res.valueType(), y3.valueType()])(res.value, y3.value);
            res.fixPrefix = false;
            return res;
          })
        }, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo01xDSid,
          SD: matAlgo03xDSf,
          Ss: matAlgo12xSfs,
          sS: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
  var name67, dependencies67, createXgcd;
  var init_xgcd = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js"() {
      init_factory();
      init_number2();
      name67 = "xgcd";
      dependencies67 = ["typed", "config", "matrix", "BigNumber"];
      createXgcd = /* @__PURE__ */ factory(name67, dependencies67, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          BigNumber: BigNumber2
        } = _ref;
        return typed3(name67, {
          "number, number": function numberNumber(a3, b3) {
            var res = xgcdNumber(a3, b3);
            return config4.matrix === "Array" ? res : matrix2(res);
          },
          "BigNumber, BigNumber": _xgcdBigNumber
          // TODO: implement support for Fraction
        });
        function _xgcdBigNumber(a3, b3) {
          var t3;
          var q4;
          var r3;
          var zero = new BigNumber2(0);
          var one = new BigNumber2(1);
          var x4 = zero;
          var lastx = one;
          var y3 = one;
          var lasty = zero;
          if (!a3.isInt() || !b3.isInt()) {
            throw new Error("Parameters in function xgcd must be integer numbers");
          }
          while (!b3.isZero()) {
            q4 = a3.div(b3).floor();
            r3 = a3.mod(b3);
            t3 = x4;
            x4 = lastx.minus(q4.times(x4));
            lastx = t3;
            t3 = y3;
            y3 = lasty.minus(q4.times(y3));
            lasty = t3;
            a3 = b3;
            b3 = r3;
          }
          var res;
          if (a3.lt(zero)) {
            res = [a3.neg(), lastx.neg(), lasty.neg()];
          } else {
            res = [a3, !a3.isZero() ? lastx : 0, lasty];
          }
          return config4.matrix === "Array" ? res : matrix2(res);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
  var name68, dependencies68, createInvmod;
  var init_invmod = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/invmod.js"() {
      init_factory();
      name68 = "invmod";
      dependencies68 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
      createInvmod = /* @__PURE__ */ factory(name68, dependencies68, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          BigNumber: BigNumber2,
          xgcd: xgcd2,
          equal: equal2,
          smaller: smaller2,
          mod: mod3,
          add: add3,
          isInteger: isInteger3
        } = _ref;
        return typed3(name68, {
          "number, number": invmod2,
          "BigNumber, BigNumber": invmod2
        });
        function invmod2(a3, b3) {
          if (!isInteger3(a3) || !isInteger3(b3))
            throw new Error("Parameters in function invmod must be integer numbers");
          a3 = mod3(a3, b3);
          if (equal2(b3, 0))
            throw new Error("Divisor must be non zero");
          var res = xgcd2(a3, b3);
          res = res.valueOf();
          var [gcd2, inv2] = res;
          if (!equal2(gcd2, BigNumber2(1)))
            return NaN;
          inv2 = mod3(inv2, b3);
          if (smaller2(inv2, BigNumber2(0)))
            inv2 = add3(inv2, b3);
          return inv2;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
  var name69, dependencies69, createMatAlgo09xS0Sf;
  var init_matAlgo09xS0Sf = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js"() {
      init_factory();
      init_DimensionError();
      name69 = "matAlgo09xS0Sf";
      dependencies69 = ["typed", "equalScalar"];
      createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name69, dependencies69, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo09xS0Sf(a3, b3, callback) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var x4 = cvalues ? [] : void 0;
          var w4 = [];
          var i5, j4, k4, k0, k1;
          for (j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            var mark = j4 + 1;
            if (x4) {
              for (k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
                i5 = bindex[k4];
                w4[i5] = mark;
                x4[i5] = bvalues[k4];
              }
            }
            for (k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = aindex[k4];
              if (x4) {
                var vb = w4[i5] === mark ? x4[i5] : zero;
                var vc = cf(avalues[k4], vb);
                if (!eq(vc, zero)) {
                  cindex.push(i5);
                  cvalues.push(vc);
                }
              } else {
                cindex.push(i5);
              }
            }
          }
          cptr[columns] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
  var name70, dependencies70, createDotMultiply;
  var init_dotMultiply = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js"() {
      init_factory();
      init_matAlgo02xDS0();
      init_matAlgo09xS0Sf();
      init_matAlgo11xS0s();
      init_matrixAlgorithmSuite();
      name70 = "dotMultiply";
      dependencies70 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
      createDotMultiply = /* @__PURE__ */ factory(name70, dependencies70, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          multiplyScalar: multiplyScalar2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name70, matrixAlgorithmSuite({
          elop: multiplyScalar2,
          SS: matAlgo09xS0Sf,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
  function bitAndBigNumber(x4, y3) {
    if (x4.isFinite() && !x4.isInteger() || y3.isFinite() && !y3.isInteger()) {
      throw new Error("Integers expected in function bitAnd");
    }
    var BigNumber2 = x4.constructor;
    if (x4.isNaN() || y3.isNaN()) {
      return new BigNumber2(NaN);
    }
    if (x4.isZero() || y3.eq(-1) || x4.eq(y3)) {
      return x4;
    }
    if (y3.isZero() || x4.eq(-1)) {
      return y3;
    }
    if (!x4.isFinite() || !y3.isFinite()) {
      if (!x4.isFinite() && !y3.isFinite()) {
        if (x4.isNegative() === y3.isNegative()) {
          return x4;
        }
        return new BigNumber2(0);
      }
      if (!x4.isFinite()) {
        if (y3.isNegative()) {
          return x4;
        }
        if (x4.isNegative()) {
          return new BigNumber2(0);
        }
        return y3;
      }
      if (!y3.isFinite()) {
        if (x4.isNegative()) {
          return y3;
        }
        if (y3.isNegative()) {
          return new BigNumber2(0);
        }
        return x4;
      }
    }
    return bitwise(x4, y3, function(a3, b3) {
      return a3 & b3;
    });
  }
  function bitNotBigNumber(x4) {
    if (x4.isFinite() && !x4.isInteger()) {
      throw new Error("Integer expected in function bitNot");
    }
    var BigNumber2 = x4.constructor;
    var prevPrec = BigNumber2.precision;
    BigNumber2.config({
      precision: 1e9
    });
    var result = x4.plus(new BigNumber2(1));
    result.s = -result.s || null;
    BigNumber2.config({
      precision: prevPrec
    });
    return result;
  }
  function bitOrBigNumber(x4, y3) {
    if (x4.isFinite() && !x4.isInteger() || y3.isFinite() && !y3.isInteger()) {
      throw new Error("Integers expected in function bitOr");
    }
    var BigNumber2 = x4.constructor;
    if (x4.isNaN() || y3.isNaN()) {
      return new BigNumber2(NaN);
    }
    var negOne = new BigNumber2(-1);
    if (x4.isZero() || y3.eq(negOne) || x4.eq(y3)) {
      return y3;
    }
    if (y3.isZero() || x4.eq(negOne)) {
      return x4;
    }
    if (!x4.isFinite() || !y3.isFinite()) {
      if (!x4.isFinite() && !x4.isNegative() && y3.isNegative() || x4.isNegative() && !y3.isNegative() && !y3.isFinite()) {
        return negOne;
      }
      if (x4.isNegative() && y3.isNegative()) {
        return x4.isFinite() ? x4 : y3;
      }
      return x4.isFinite() ? y3 : x4;
    }
    return bitwise(x4, y3, function(a3, b3) {
      return a3 | b3;
    });
  }
  function bitwise(x4, y3, func) {
    var BigNumber2 = x4.constructor;
    var xBits, yBits;
    var xSign = +(x4.s < 0);
    var ySign = +(y3.s < 0);
    if (xSign) {
      xBits = decCoefficientToBinaryString(bitNotBigNumber(x4));
      for (var i5 = 0; i5 < xBits.length; ++i5) {
        xBits[i5] ^= 1;
      }
    } else {
      xBits = decCoefficientToBinaryString(x4);
    }
    if (ySign) {
      yBits = decCoefficientToBinaryString(bitNotBigNumber(y3));
      for (var _i = 0; _i < yBits.length; ++_i) {
        yBits[_i] ^= 1;
      }
    } else {
      yBits = decCoefficientToBinaryString(y3);
    }
    var minBits, maxBits, minSign;
    if (xBits.length <= yBits.length) {
      minBits = xBits;
      maxBits = yBits;
      minSign = xSign;
    } else {
      minBits = yBits;
      maxBits = xBits;
      minSign = ySign;
    }
    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber2(expFuncVal ^ 1);
    var twoPower = new BigNumber2(1);
    var two = new BigNumber2(2);
    var prevPrec = BigNumber2.precision;
    BigNumber2.config({
      precision: 1e9
    });
    while (shortLen > 0) {
      if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    while (longLen > 0) {
      if (func(minSign, maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    BigNumber2.config({
      precision: prevPrec
    });
    if (expFuncVal === 0) {
      outVal.s = -outVal.s;
    }
    return outVal;
  }
  function decCoefficientToBinaryString(x4) {
    var a3 = x4.d;
    var r3 = a3[0] + "";
    for (var i5 = 1; i5 < a3.length; ++i5) {
      var s3 = a3[i5] + "";
      for (var z5 = 7 - s3.length; z5--; ) {
        s3 = "0" + s3;
      }
      r3 += s3;
    }
    var j4 = r3.length;
    while (r3.charAt(j4) === "0") {
      j4--;
    }
    var xe = x4.e;
    var str = r3.slice(0, j4 + 1 || 1);
    var strL = str.length;
    if (xe > 0) {
      if (++xe > strL) {
        xe -= strL;
        while (xe--) {
          str += "0";
        }
      } else if (xe < strL) {
        str = str.slice(0, xe) + "." + str.slice(xe);
      }
    }
    var arr = [0];
    for (var _i2 = 0; _i2 < str.length; ) {
      var arrL = arr.length;
      while (arrL--) {
        arr[arrL] *= 10;
      }
      arr[0] += parseInt(str.charAt(_i2++));
      for (var _j = 0; _j < arr.length; ++_j) {
        if (arr[_j] > 1) {
          if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
            arr[_j + 1] = 0;
          }
          arr[_j + 1] += arr[_j] >> 1;
          arr[_j] &= 1;
        }
      }
    }
    return arr.reverse();
  }
  function bitXor(x4, y3) {
    if (x4.isFinite() && !x4.isInteger() || y3.isFinite() && !y3.isInteger()) {
      throw new Error("Integers expected in function bitXor");
    }
    var BigNumber2 = x4.constructor;
    if (x4.isNaN() || y3.isNaN()) {
      return new BigNumber2(NaN);
    }
    if (x4.isZero()) {
      return y3;
    }
    if (y3.isZero()) {
      return x4;
    }
    if (x4.eq(y3)) {
      return new BigNumber2(0);
    }
    var negOne = new BigNumber2(-1);
    if (x4.eq(negOne)) {
      return bitNotBigNumber(y3);
    }
    if (y3.eq(negOne)) {
      return bitNotBigNumber(x4);
    }
    if (!x4.isFinite() || !y3.isFinite()) {
      if (!x4.isFinite() && !y3.isFinite()) {
        return negOne;
      }
      return new BigNumber2(x4.isNegative() === y3.isNegative() ? Infinity : -Infinity);
    }
    return bitwise(x4, y3, function(a3, b3) {
      return a3 ^ b3;
    });
  }
  function leftShiftBigNumber(x4, y3) {
    if (x4.isFinite() && !x4.isInteger() || y3.isFinite() && !y3.isInteger()) {
      throw new Error("Integers expected in function leftShift");
    }
    var BigNumber2 = x4.constructor;
    if (x4.isNaN() || y3.isNaN() || y3.isNegative() && !y3.isZero()) {
      return new BigNumber2(NaN);
    }
    if (x4.isZero() || y3.isZero()) {
      return x4;
    }
    if (!x4.isFinite() && !y3.isFinite()) {
      return new BigNumber2(NaN);
    }
    if (y3.lt(55)) {
      return x4.times(Math.pow(2, y3.toNumber()) + "");
    }
    return x4.times(new BigNumber2(2).pow(y3));
  }
  function rightArithShiftBigNumber(x4, y3) {
    if (x4.isFinite() && !x4.isInteger() || y3.isFinite() && !y3.isInteger()) {
      throw new Error("Integers expected in function rightArithShift");
    }
    var BigNumber2 = x4.constructor;
    if (x4.isNaN() || y3.isNaN() || y3.isNegative() && !y3.isZero()) {
      return new BigNumber2(NaN);
    }
    if (x4.isZero() || y3.isZero()) {
      return x4;
    }
    if (!y3.isFinite()) {
      if (x4.isNegative()) {
        return new BigNumber2(-1);
      }
      if (!x4.isFinite()) {
        return new BigNumber2(NaN);
      }
      return new BigNumber2(0);
    }
    if (y3.lt(55)) {
      return x4.div(Math.pow(2, y3.toNumber()) + "").floor();
    }
    return x4.div(new BigNumber2(2).pow(y3)).floor();
  }
  var init_bitwise2 = __esm({
    "node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
  var name71, dependencies71, createBitAnd;
  var init_bitAnd = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js"() {
      init_bitwise2();
      init_matAlgo02xDS0();
      init_matAlgo11xS0s();
      init_matAlgo06xS0S0();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      name71 = "bitAnd";
      dependencies71 = ["typed", "matrix", "equalScalar", "concat"];
      createBitAnd = /* @__PURE__ */ factory(name71, dependencies71, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = createMatAlgo06xS0S0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name71, {
          "number, number": bitAndNumber,
          "BigNumber, BigNumber": bitAndBigNumber
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
  var name72, dependencies72, createBitNot;
  var init_bitNot = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/bitNot.js"() {
      init_bitwise2();
      init_collection();
      init_factory();
      init_number2();
      name72 = "bitNot";
      dependencies72 = ["typed"];
      createBitNot = /* @__PURE__ */ factory(name72, dependencies72, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name72, {
          number: bitNotNumber,
          BigNumber: bitNotBigNumber,
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
  var name73, dependencies73, createBitOr;
  var init_bitOr = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/bitOr.js"() {
      init_bitwise2();
      init_factory();
      init_matAlgo10xSids();
      init_matAlgo04xSidSid();
      init_matAlgo01xDSid();
      init_matrixAlgorithmSuite();
      init_number2();
      name73 = "bitOr";
      dependencies73 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      createBitOr = /* @__PURE__ */ factory(name73, dependencies73, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo04xSidSid = createMatAlgo04xSidSid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name73, {
          "number, number": bitOrNumber,
          "BigNumber, BigNumber": bitOrBigNumber
        }, matrixAlgorithmSuite({
          SS: matAlgo04xSidSid,
          DS: matAlgo01xDSid,
          Ss: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
  var name74, dependencies74, createMatAlgo07xSSf;
  var init_matAlgo07xSSf = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js"() {
      init_factory();
      init_DimensionError();
      name74 = "matAlgo07xSSf";
      dependencies74 = ["typed", "DenseMatrix"];
      createMatAlgo07xSSf = /* @__PURE__ */ factory(name74, dependencies74, (_ref) => {
        var {
          typed: typed3,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return function matAlgo07xSSf(a3, b3, callback) {
          var asize = a3._size;
          var adt = a3._datatype;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var i5, j4;
          var cdata = [];
          for (i5 = 0; i5 < rows; i5++) {
            cdata[i5] = [];
          }
          var xa = [];
          var xb = [];
          var wa = [];
          var wb = [];
          for (j4 = 0; j4 < columns; j4++) {
            var mark = j4 + 1;
            _scatter(a3, j4, wa, xa, mark);
            _scatter(b3, j4, wb, xb, mark);
            for (i5 = 0; i5 < rows; i5++) {
              var va = wa[i5] === mark ? xa[i5] : zero;
              var vb = wb[i5] === mark ? xb[i5] : zero;
              cdata[i5][j4] = cf(va, vb);
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
        function _scatter(m3, j4, w4, x4, mark) {
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          for (var k4 = ptr[j4], k1 = ptr[j4 + 1]; k4 < k1; k4++) {
            var i5 = index2[k4];
            w4[i5] = mark;
            x4[i5] = values[k4];
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
  var name75, dependencies75, createBitXor;
  var init_bitXor = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/bitXor.js"() {
      init_bitwise2();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      name75 = "bitXor";
      dependencies75 = ["typed", "matrix", "DenseMatrix", "concat"];
      createBitXor = /* @__PURE__ */ factory(name75, dependencies75, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name75, {
          "number, number": bitXorNumber,
          "BigNumber, BigNumber": bitXor
        }, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/complex/arg.js
  var name76, dependencies76, createArg;
  var init_arg = __esm({
    "node_modules/mathjs/lib/esm/function/complex/arg.js"() {
      init_factory();
      init_collection();
      name76 = "arg";
      dependencies76 = ["typed"];
      createArg = /* @__PURE__ */ factory(name76, dependencies76, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name76, {
          number: function number2(x4) {
            return Math.atan2(0, x4);
          },
          BigNumber: function BigNumber2(x4) {
            return x4.constructor.atan2(0, x4);
          },
          Complex: function Complex3(x4) {
            return x4.arg();
          },
          // TODO: implement BigNumber support for function arg
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/complex/conj.js
  var name77, dependencies77, createConj;
  var init_conj = __esm({
    "node_modules/mathjs/lib/esm/function/complex/conj.js"() {
      init_factory();
      init_collection();
      name77 = "conj";
      dependencies77 = ["typed"];
      createConj = /* @__PURE__ */ factory(name77, dependencies77, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name77, {
          "number | BigNumber | Fraction": (x4) => x4,
          Complex: (x4) => x4.conjugate(),
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/complex/im.js
  var name78, dependencies78, createIm;
  var init_im = __esm({
    "node_modules/mathjs/lib/esm/function/complex/im.js"() {
      init_factory();
      init_collection();
      name78 = "im";
      dependencies78 = ["typed"];
      createIm = /* @__PURE__ */ factory(name78, dependencies78, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name78, {
          number: () => 0,
          "BigNumber | Fraction": (x4) => x4.mul(0),
          Complex: (x4) => x4.im,
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/complex/re.js
  var name79, dependencies79, createRe;
  var init_re = __esm({
    "node_modules/mathjs/lib/esm/function/complex/re.js"() {
      init_factory();
      init_collection();
      name79 = "re";
      dependencies79 = ["typed"];
      createRe = /* @__PURE__ */ factory(name79, dependencies79, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name79, {
          "number | BigNumber | Fraction": (x4) => x4,
          Complex: (x4) => x4.re,
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/logical/not.js
  var name80, dependencies80, createNot;
  var init_not = __esm({
    "node_modules/mathjs/lib/esm/function/logical/not.js"() {
      init_collection();
      init_factory();
      init_number2();
      name80 = "not";
      dependencies80 = ["typed"];
      createNot = /* @__PURE__ */ factory(name80, dependencies80, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name80, {
          "null | undefined": () => true,
          number: notNumber,
          Complex: function Complex3(x4) {
            return x4.re === 0 && x4.im === 0;
          },
          BigNumber: function BigNumber2(x4) {
            return x4.isZero() || x4.isNaN();
          },
          Unit: typed3.referToSelf((self2) => (x4) => typed3.find(self2, x4.valueType())(x4.value)),
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/logical/or.js
  var name81, dependencies81, createOr;
  var init_or = __esm({
    "node_modules/mathjs/lib/esm/function/logical/or.js"() {
      init_matAlgo03xDSf();
      init_matAlgo12xSfs();
      init_matAlgo05xSfSf();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      name81 = "or";
      dependencies81 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      createOr = /* @__PURE__ */ factory(name81, dependencies81, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo05xSfSf = createMatAlgo05xSfSf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name81, {
          "number, number": orNumber,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return x4.re !== 0 || x4.im !== 0 || y3.re !== 0 || y3.im !== 0;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return !x4.isZero() && !x4.isNaN() || !y3.isZero() && !y3.isNaN();
          },
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => self2(x4.value || 0, y3.value || 0))
        }, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/logical/xor.js
  var name82, dependencies82, createXor;
  var init_xor = __esm({
    "node_modules/mathjs/lib/esm/function/logical/xor.js"() {
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      name82 = "xor";
      dependencies82 = ["typed", "matrix", "DenseMatrix", "concat"];
      createXor = /* @__PURE__ */ factory(name82, dependencies82, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name82, {
          "number, number": xorNumber,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return (x4.re !== 0 || x4.im !== 0) !== (y3.re !== 0 || y3.im !== 0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return (!x4.isZero() && !x4.isNaN()) !== (!y3.isZero() && !y3.isNaN());
          },
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => self2(x4.value || 0, y3.value || 0))
        }, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/concat.js
  var name83, dependencies83, createConcat;
  var init_concat = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/concat.js"() {
      init_is();
      init_object();
      init_array();
      init_IndexError();
      init_DimensionError();
      init_factory();
      name83 = "concat";
      dependencies83 = ["typed", "matrix", "isInteger"];
      createConcat = /* @__PURE__ */ factory(name83, dependencies83, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          isInteger: isInteger3
        } = _ref;
        return typed3(name83, {
          // TODO: change signature to '...Array | Matrix, dim?' when supported
          "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
            var i5;
            var len = args.length;
            var dim = -1;
            var prevDim;
            var asMatrix = false;
            var matrices = [];
            for (i5 = 0; i5 < len; i5++) {
              var arg2 = args[i5];
              if (isMatrix(arg2)) {
                asMatrix = true;
              }
              if (isNumber(arg2) || isBigNumber(arg2)) {
                if (i5 !== len - 1) {
                  throw new Error("Dimension must be specified as last argument");
                }
                prevDim = dim;
                dim = arg2.valueOf();
                if (!isInteger3(dim)) {
                  throw new TypeError("Integer number expected for dimension");
                }
                if (dim < 0 || i5 > 0 && dim > prevDim) {
                  throw new IndexError(dim, prevDim + 1);
                }
              } else {
                var m3 = clone(arg2).valueOf();
                var size2 = arraySize(m3);
                matrices[i5] = m3;
                prevDim = dim;
                dim = size2.length - 1;
                if (i5 > 0 && dim !== prevDim) {
                  throw new DimensionError(prevDim + 1, dim + 1);
                }
              }
            }
            if (matrices.length === 0) {
              throw new SyntaxError("At least one matrix expected");
            }
            var res = matrices.shift();
            while (matrices.length) {
              res = concat(res, matrices.shift(), dim);
            }
            return asMatrix ? matrix2(res) : res;
          },
          "...string": function string2(args) {
            return args.join("");
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/column.js
  var name84, dependencies84, createColumn;
  var init_column = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/column.js"() {
      init_factory();
      init_is();
      init_object();
      init_array();
      name84 = "column";
      dependencies84 = ["typed", "Index", "matrix", "range"];
      createColumn = /* @__PURE__ */ factory(name84, dependencies84, (_ref) => {
        var {
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        } = _ref;
        return typed3(name84, {
          "Matrix, number": _column,
          "Array, number": function ArrayNumber(value, column2) {
            return _column(matrix2(clone(value)), column2).valueOf();
          }
        });
        function _column(value, column2) {
          if (value.size().length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          validateIndex(column2, value.size()[1]);
          var rowRange = range2(0, value.size()[0]);
          var index2 = new Index2(rowRange, column2);
          var result = value.subset(index2);
          return isMatrix(result) ? result : matrix2([[result]]);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/count.js
  var name85, dependencies85, createCount;
  var init_count = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/count.js"() {
      init_factory();
      name85 = "count";
      dependencies85 = ["typed", "size", "prod"];
      createCount = /* @__PURE__ */ factory(name85, dependencies85, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          prod: prod2
        } = _ref;
        return typed3(name85, {
          string: function string2(x4) {
            return x4.length;
          },
          "Matrix | Array": function MatrixArray(x4) {
            return prod2(size2(x4));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/cross.js
  var name86, dependencies86, createCross;
  var init_cross = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/cross.js"() {
      init_array();
      init_factory();
      name86 = "cross";
      dependencies86 = ["typed", "matrix", "subtract", "multiply"];
      createCross = /* @__PURE__ */ factory(name86, dependencies86, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          subtract: subtract2,
          multiply: multiply2
        } = _ref;
        return typed3(name86, {
          "Matrix, Matrix": function MatrixMatrix(x4, y3) {
            return matrix2(_cross(x4.toArray(), y3.toArray()));
          },
          "Matrix, Array": function MatrixArray(x4, y3) {
            return matrix2(_cross(x4.toArray(), y3));
          },
          "Array, Matrix": function ArrayMatrix(x4, y3) {
            return matrix2(_cross(x4, y3.toArray()));
          },
          "Array, Array": _cross
        });
        function _cross(x4, y3) {
          var highestDimension = Math.max(arraySize(x4).length, arraySize(y3).length);
          x4 = squeeze(x4);
          y3 = squeeze(y3);
          var xSize = arraySize(x4);
          var ySize = arraySize(y3);
          if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
            throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
          }
          var product3 = [subtract2(multiply2(x4[1], y3[2]), multiply2(x4[2], y3[1])), subtract2(multiply2(x4[2], y3[0]), multiply2(x4[0], y3[2])), subtract2(multiply2(x4[0], y3[1]), multiply2(x4[1], y3[0]))];
          if (highestDimension > 1) {
            return [product3];
          } else {
            return product3;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/diag.js
  var name87, dependencies87, createDiag;
  var init_diag = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/diag.js"() {
      init_is();
      init_array();
      init_number();
      init_factory();
      name87 = "diag";
      dependencies87 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
      createDiag = /* @__PURE__ */ factory(name87, dependencies87, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2
        } = _ref;
        return typed3(name87, {
          // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
          Array: function Array2(x4) {
            return _diag(x4, 0, arraySize(x4), null);
          },
          "Array, number": function ArrayNumber(x4, k4) {
            return _diag(x4, k4, arraySize(x4), null);
          },
          "Array, BigNumber": function ArrayBigNumber(x4, k4) {
            return _diag(x4, k4.toNumber(), arraySize(x4), null);
          },
          "Array, string": function ArrayString(x4, format5) {
            return _diag(x4, 0, arraySize(x4), format5);
          },
          "Array, number, string": function ArrayNumberString(x4, k4, format5) {
            return _diag(x4, k4, arraySize(x4), format5);
          },
          "Array, BigNumber, string": function ArrayBigNumberString(x4, k4, format5) {
            return _diag(x4, k4.toNumber(), arraySize(x4), format5);
          },
          Matrix: function Matrix2(x4) {
            return _diag(x4, 0, x4.size(), x4.storage());
          },
          "Matrix, number": function MatrixNumber(x4, k4) {
            return _diag(x4, k4, x4.size(), x4.storage());
          },
          "Matrix, BigNumber": function MatrixBigNumber(x4, k4) {
            return _diag(x4, k4.toNumber(), x4.size(), x4.storage());
          },
          "Matrix, string": function MatrixString(x4, format5) {
            return _diag(x4, 0, x4.size(), format5);
          },
          "Matrix, number, string": function MatrixNumberString(x4, k4, format5) {
            return _diag(x4, k4, x4.size(), format5);
          },
          "Matrix, BigNumber, string": function MatrixBigNumberString(x4, k4, format5) {
            return _diag(x4, k4.toNumber(), x4.size(), format5);
          }
        });
        function _diag(x4, k4, size2, format5) {
          if (!isInteger(k4)) {
            throw new TypeError("Second parameter in function diag must be an integer");
          }
          var kSuper = k4 > 0 ? k4 : 0;
          var kSub = k4 < 0 ? -k4 : 0;
          switch (size2.length) {
            case 1:
              return _createDiagonalMatrix(x4, k4, format5, size2[0], kSub, kSuper);
            case 2:
              return _getDiagonal(x4, k4, format5, size2, kSub, kSuper);
          }
          throw new RangeError("Matrix for function diag must be 2 dimensional");
        }
        function _createDiagonalMatrix(x4, k4, format5, l3, kSub, kSuper) {
          var ms = [l3 + kSub, l3 + kSuper];
          if (format5 && format5 !== "sparse" && format5 !== "dense") {
            throw new TypeError("Unknown matrix type ".concat(format5, '"'));
          }
          var m3 = format5 === "sparse" ? SparseMatrix2.diagonal(ms, x4, k4) : DenseMatrix2.diagonal(ms, x4, k4);
          return format5 !== null ? m3 : m3.valueOf();
        }
        function _getDiagonal(x4, k4, format5, s3, kSub, kSuper) {
          if (isMatrix(x4)) {
            var dm = x4.diagonal(k4);
            if (format5 !== null) {
              if (format5 !== dm.storage()) {
                return matrix2(dm, format5);
              }
              return dm;
            }
            return dm.valueOf();
          }
          var n3 = Math.min(s3[0] - kSub, s3[1] - kSuper);
          var vector = [];
          for (var i5 = 0; i5 < n3; i5++) {
            vector[i5] = x4[i5 + kSub][i5 + kSuper];
          }
          return format5 !== null ? matrix2(vector) : vector;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/applyCallback.js
  function applyCallback(callback, value, index2, array, mappingFnName) {
    if (import_typed_function2.default.isTypedFunction(callback)) {
      var args3 = [value, index2, array];
      var signature3 = import_typed_function2.default.resolve(callback, args3);
      if (signature3) {
        return tryWithArgs(signature3.implementation, args3);
      }
      var args2 = [value, index2];
      var signature2 = import_typed_function2.default.resolve(callback, args2);
      if (signature2) {
        return tryWithArgs(signature2.implementation, args2);
      }
      var args1 = [value];
      var signature1 = import_typed_function2.default.resolve(callback, args1);
      if (signature1) {
        return tryWithArgs(signature1.implementation, args1);
      }
      return tryWithArgs(callback, args3);
    } else {
      return callback(value, index2, array);
    }
    function tryWithArgs(signature, args) {
      try {
        return signature.apply(signature, args);
      } catch (err) {
        var _err$data;
        if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
          var argsDesc = [];
          argsDesc.push("value: ".concat(typeOf(value)));
          if (args.length >= 2) {
            argsDesc.push("index: ".concat(typeOf(index2)));
          }
          if (args.length >= 3) {
            argsDesc.push("array: ".concat(typeOf(array)));
          }
          throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index2)));
        } else {
          throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
        }
      }
    }
  }
  var import_typed_function2;
  var init_applyCallback = __esm({
    "node_modules/mathjs/lib/esm/utils/applyCallback.js"() {
      import_typed_function2 = __toESM(require_typed_function(), 1);
      init_is();
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/filter.js
  function _filterCallback(x4, callback) {
    return filter(x4, function(value, index2, array) {
      return applyCallback(callback, value, [index2], array, "filter");
    });
  }
  var name88, dependencies88, createFilter;
  var init_filter = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/filter.js"() {
      init_applyCallback();
      init_array();
      init_factory();
      name88 = "filter";
      dependencies88 = ["typed"];
      createFilter = /* @__PURE__ */ factory(name88, dependencies88, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("filter", {
          "Array, function": _filterCallback,
          "Matrix, function": function MatrixFunction(x4, test) {
            return x4.create(_filterCallback(x4.toArray(), test));
          },
          "Array, RegExp": filterRegExp,
          "Matrix, RegExp": function MatrixRegExp(x4, test) {
            return x4.create(filterRegExp(x4.toArray(), test));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/flatten.js
  var name89, dependencies89, createFlatten;
  var init_flatten = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/flatten.js"() {
      init_array();
      init_factory();
      name89 = "flatten";
      dependencies89 = ["typed", "matrix"];
      createFlatten = /* @__PURE__ */ factory(name89, dependencies89, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2
        } = _ref;
        return typed3(name89, {
          Array: function Array2(x4) {
            return flatten(x4);
          },
          Matrix: function Matrix2(x4) {
            var flat = flatten(x4.toArray());
            return matrix2(flat);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/forEach.js
  function _forEach(array, callback) {
    var recurse = function recurse2(value, index2) {
      if (Array.isArray(value)) {
        forEach(value, function(child, i5) {
          recurse2(child, index2.concat(i5));
        });
      } else {
        return applyCallback(callback, value, index2, array, "forEach");
      }
    };
    recurse(array, []);
  }
  var name90, dependencies90, createForEach;
  var init_forEach = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/forEach.js"() {
      init_applyCallback();
      init_array();
      init_factory();
      name90 = "forEach";
      dependencies90 = ["typed"];
      createForEach = /* @__PURE__ */ factory(name90, dependencies90, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name90, {
          "Array, function": _forEach,
          "Matrix, function": function MatrixFunction(x4, callback) {
            x4.forEach(callback);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
  var name91, dependencies91, createGetMatrixDataType;
  var init_getMatrixDataType = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js"() {
      init_factory();
      init_array();
      init_is();
      name91 = "getMatrixDataType";
      dependencies91 = ["typed"];
      createGetMatrixDataType = /* @__PURE__ */ factory(name91, dependencies91, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name91, {
          Array: function Array2(x4) {
            return getArrayDataType(x4, typeOf);
          },
          Matrix: function Matrix2(x4) {
            return x4.getDataType();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/identity.js
  var name92, dependencies92, createIdentity;
  var init_identity = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/identity.js"() {
      init_is();
      init_array();
      init_number();
      init_factory();
      name92 = "identity";
      dependencies92 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
      createIdentity = /* @__PURE__ */ factory(name92, dependencies92, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          BigNumber: BigNumber2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2
        } = _ref;
        return typed3(name92, {
          "": function _3() {
            return config4.matrix === "Matrix" ? matrix2([]) : [];
          },
          string: function string2(format5) {
            return matrix2(format5);
          },
          "number | BigNumber": function numberBigNumber(rows) {
            return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber, string": function numberBigNumberString(rows, format5) {
            return _identity(rows, rows, format5);
          },
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
            return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format5) {
            return _identity(rows, cols, format5);
          },
          Array: function Array2(size2) {
            return _identityVector(size2);
          },
          "Array, string": function ArrayString(size2, format5) {
            return _identityVector(size2, format5);
          },
          Matrix: function Matrix2(size2) {
            return _identityVector(size2.valueOf(), size2.storage());
          },
          "Matrix, string": function MatrixString(size2, format5) {
            return _identityVector(size2.valueOf(), format5);
          }
        });
        function _identityVector(size2, format5) {
          switch (size2.length) {
            case 0:
              return format5 ? matrix2(format5) : [];
            case 1:
              return _identity(size2[0], size2[0], format5);
            case 2:
              return _identity(size2[0], size2[1], format5);
            default:
              throw new Error("Vector containing two values expected");
          }
        }
        function _identity(rows, cols, format5) {
          var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
          if (isBigNumber(rows))
            rows = rows.toNumber();
          if (isBigNumber(cols))
            cols = cols.toNumber();
          if (!isInteger(rows) || rows < 1) {
            throw new Error("Parameters in function identity must be positive integers");
          }
          if (!isInteger(cols) || cols < 1) {
            throw new Error("Parameters in function identity must be positive integers");
          }
          var one = Big ? new BigNumber2(1) : 1;
          var defaultValue = Big ? new Big(0) : 0;
          var size2 = [rows, cols];
          if (format5) {
            if (format5 === "sparse") {
              return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
            }
            if (format5 === "dense") {
              return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
            }
            throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
          }
          var res = resize([], size2, defaultValue);
          var minimum = rows < cols ? rows : cols;
          for (var d3 = 0; d3 < minimum; d3++) {
            res[d3][d3] = one;
          }
          return res;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/kron.js
  var name93, dependencies93, createKron;
  var init_kron = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/kron.js"() {
      init_array();
      init_factory();
      name93 = "kron";
      dependencies93 = ["typed", "matrix", "multiplyScalar"];
      createKron = /* @__PURE__ */ factory(name93, dependencies93, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          multiplyScalar: multiplyScalar2
        } = _ref;
        return typed3(name93, {
          "Matrix, Matrix": function MatrixMatrix(x4, y3) {
            return matrix2(_kron(x4.toArray(), y3.toArray()));
          },
          "Matrix, Array": function MatrixArray(x4, y3) {
            return matrix2(_kron(x4.toArray(), y3));
          },
          "Array, Matrix": function ArrayMatrix(x4, y3) {
            return matrix2(_kron(x4, y3.toArray()));
          },
          "Array, Array": _kron
        });
        function _kron(a3, b3) {
          if (arraySize(a3).length === 1) {
            a3 = [a3];
          }
          if (arraySize(b3).length === 1) {
            b3 = [b3];
          }
          if (arraySize(a3).length > 2 || arraySize(b3).length > 2) {
            throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a3.length) + ", y = " + JSON.stringify(b3.length) + ")");
          }
          var t3 = [];
          var r3 = [];
          return a3.map(function(a4) {
            return b3.map(function(b4) {
              r3 = [];
              t3.push(r3);
              return a4.map(function(y3) {
                return b4.map(function(x4) {
                  return r3.push(multiplyScalar2(y3, x4));
                });
              });
            });
          }) && t3;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/map.js
  function _map(array, callback) {
    var recurse = function recurse2(value, index2) {
      if (Array.isArray(value)) {
        return value.map(function(child, i5) {
          return recurse2(child, index2.concat(i5));
        });
      } else {
        return applyCallback(callback, value, index2, array, "map");
      }
    };
    return recurse(array, []);
  }
  var name94, dependencies94, createMap2;
  var init_map2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/map.js"() {
      init_applyCallback();
      init_factory();
      name94 = "map";
      dependencies94 = ["typed"];
      createMap2 = /* @__PURE__ */ factory(name94, dependencies94, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name94, {
          "Array, function": _map,
          "Matrix, function": function MatrixFunction(x4, callback) {
            return x4.map(callback);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/diff.js
  var name95, dependencies95, createDiff;
  var init_diff = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/diff.js"() {
      init_factory();
      init_number();
      init_is();
      name95 = "diff";
      dependencies95 = ["typed", "matrix", "subtract", "number"];
      createDiff = /* @__PURE__ */ factory(name95, dependencies95, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          subtract: subtract2,
          number: number2
        } = _ref;
        return typed3(name95, {
          "Array | Matrix": function ArrayMatrix(arr) {
            if (isMatrix(arr)) {
              return matrix2(_diff(arr.toArray()));
            } else {
              return _diff(arr);
            }
          },
          "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
            if (!isInteger(dim))
              throw new RangeError("Dimension must be a whole number");
            if (isMatrix(arr)) {
              return matrix2(_recursive(arr.toArray(), dim));
            } else {
              return _recursive(arr, dim);
            }
          },
          "Array, BigNumber": typed3.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
          "Matrix, BigNumber": typed3.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
        });
        function _recursive(arr, dim) {
          if (isMatrix(arr)) {
            arr = arr.toArray();
          }
          if (!Array.isArray(arr)) {
            throw RangeError("Array/Matrix does not have that many dimensions");
          }
          if (dim > 0) {
            var result = [];
            arr.forEach((element) => {
              result.push(_recursive(element, dim - 1));
            });
            return result;
          } else if (dim === 0) {
            return _diff(arr);
          } else {
            throw RangeError("Cannot have negative dimension");
          }
        }
        function _diff(arr) {
          var result = [];
          var size2 = arr.length;
          for (var i5 = 1; i5 < size2; i5++) {
            result.push(_ElementDiff(arr[i5 - 1], arr[i5]));
          }
          return result;
        }
        function _ElementDiff(obj1, obj2) {
          if (isMatrix(obj1))
            obj1 = obj1.toArray();
          if (isMatrix(obj2))
            obj2 = obj2.toArray();
          var obj1IsArray = Array.isArray(obj1);
          var obj2IsArray = Array.isArray(obj2);
          if (obj1IsArray && obj2IsArray) {
            return _ArrayDiff(obj1, obj2);
          }
          if (!obj1IsArray && !obj2IsArray) {
            return subtract2(obj2, obj1);
          }
          throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
        }
        function _ArrayDiff(arr1, arr2) {
          if (arr1.length !== arr2.length) {
            throw RangeError("Not all sub-arrays have the same length");
          }
          var result = [];
          var size2 = arr1.length;
          for (var i5 = 0; i5 < size2; i5++) {
            result.push(_ElementDiff(arr1[i5], arr2[i5]));
          }
          return result;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ones.js
  var name96, dependencies96, createOnes;
  var init_ones = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/ones.js"() {
      init_is();
      init_number();
      init_array();
      init_factory();
      name96 = "ones";
      dependencies96 = ["typed", "config", "matrix", "BigNumber"];
      createOnes = /* @__PURE__ */ factory(name96, dependencies96, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          BigNumber: BigNumber2
        } = _ref;
        return typed3("ones", {
          "": function _3() {
            return config4.matrix === "Array" ? _ones([]) : _ones([], "default");
          },
          // math.ones(m, n, p, ..., format)
          // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
          "...number | BigNumber | string": function numberBigNumberString(size2) {
            var last = size2[size2.length - 1];
            if (typeof last === "string") {
              var format5 = size2.pop();
              return _ones(size2, format5);
            } else if (config4.matrix === "Array") {
              return _ones(size2);
            } else {
              return _ones(size2, "default");
            }
          },
          Array: _ones,
          Matrix: function Matrix2(size2) {
            var format5 = size2.storage();
            return _ones(size2.valueOf(), format5);
          },
          "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
            return _ones(size2.valueOf(), format5);
          }
        });
        function _ones(size2, format5) {
          var hasBigNumbers = _normalize(size2);
          var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
          _validate2(size2);
          if (format5) {
            var m3 = matrix2(format5);
            if (size2.length > 0) {
              return m3.resize(size2, defaultValue);
            }
            return m3;
          } else {
            var arr = [];
            if (size2.length > 0) {
              return resize(arr, size2, defaultValue);
            }
            return arr;
          }
        }
        function _normalize(size2) {
          var hasBigNumbers = false;
          size2.forEach(function(value, index2, arr) {
            if (isBigNumber(value)) {
              hasBigNumbers = true;
              arr[index2] = value.toNumber();
            }
          });
          return hasBigNumbers;
        }
        function _validate2(size2) {
          size2.forEach(function(value) {
            if (typeof value !== "number" || !isInteger(value) || value < 0) {
              throw new Error("Parameters in function ones must be positive integers");
            }
          });
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/noop.js
  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }
  var init_noop = __esm({
    "node_modules/mathjs/lib/esm/utils/noop.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/range.js
  var name97, dependencies97, createRange;
  var init_range = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/range.js"() {
      init_factory();
      init_noop();
      name97 = "range";
      dependencies97 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
      createRange = /* @__PURE__ */ factory(name97, dependencies97, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          bignumber: bignumber2,
          smaller: smaller2,
          smallerEq: smallerEq2,
          larger: larger2,
          largerEq: largerEq2,
          add: add3,
          isPositive: isPositive2
        } = _ref;
        return typed3(name97, {
          // TODO: simplify signatures when typed-function supports default values and optional arguments
          // TODO: a number or boolean should not be converted to string here
          string: _strRange,
          "string, boolean": _strRange,
          "number, number": function numberNumber(start, end) {
            return _out(_range(start, end, 1, false));
          },
          "number, number, number": function numberNumberNumber(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
            return _out(_range(start, end, 1, includeEnd));
          },
          "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
            var BigNumber2 = start.constructor;
            return _out(_range(start, end, new BigNumber2(1), false));
          },
          "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
            var BigNumber2 = start.constructor;
            return _out(_range(start, end, new BigNumber2(1), includeEnd));
          },
          "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          },
          "Unit, Unit, Unit": function UnitUnitUnit(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          }
        });
        function _out(arr) {
          if (config4.matrix === "Matrix") {
            return matrix2 ? matrix2(arr) : noMatrix();
          }
          return arr;
        }
        function _strRange(str, includeEnd) {
          var r3 = _parse(str);
          if (!r3) {
            throw new SyntaxError('String "' + str + '" is no valid range');
          }
          if (config4.number === "BigNumber") {
            if (bignumber2 === void 0) {
              noBignumber();
            }
            return _out(_range(bignumber2(r3.start), bignumber2(r3.end), bignumber2(r3.step)), includeEnd);
          } else {
            return _out(_range(r3.start, r3.end, r3.step, includeEnd));
          }
        }
        function _range(start, end, step, includeEnd) {
          var array = [];
          var ongoing = isPositive2(step) ? includeEnd ? smallerEq2 : smaller2 : includeEnd ? largerEq2 : larger2;
          var x4 = start;
          while (ongoing(x4, end)) {
            array.push(x4);
            x4 = add3(x4, step);
          }
          return array;
        }
        function _parse(str) {
          var args = str.split(":");
          var nums = args.map(function(arg2) {
            return Number(arg2);
          });
          var invalid = nums.some(function(num) {
            return isNaN(num);
          });
          if (invalid) {
            return null;
          }
          switch (nums.length) {
            case 2:
              return {
                start: nums[0],
                end: nums[1],
                step: 1
              };
            case 3:
              return {
                start: nums[0],
                end: nums[2],
                step: nums[1]
              };
            default:
              return null;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/reshape.js
  var name98, dependencies98, createReshape;
  var init_reshape = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/reshape.js"() {
      init_array();
      init_factory();
      name98 = "reshape";
      dependencies98 = ["typed", "isInteger", "matrix"];
      createReshape = /* @__PURE__ */ factory(name98, dependencies98, (_ref) => {
        var {
          typed: typed3,
          isInteger: isInteger3
        } = _ref;
        return typed3(name98, {
          "Matrix, Array": function MatrixArray(x4, sizes) {
            return x4.reshape(sizes, true);
          },
          "Array, Array": function ArrayArray(x4, sizes) {
            sizes.forEach(function(size2) {
              if (!isInteger3(size2)) {
                throw new TypeError("Invalid size for dimension: " + size2);
              }
            });
            return reshape(x4, sizes);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/resize.js
  var name99, dependencies99, createResize;
  var init_resize = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/resize.js"() {
      init_is();
      init_DimensionError();
      init_ArgumentsError();
      init_number();
      init_string();
      init_object();
      init_array();
      init_factory();
      name99 = "resize";
      dependencies99 = ["config", "matrix"];
      createResize = /* @__PURE__ */ factory(name99, dependencies99, (_ref) => {
        var {
          config: config4,
          matrix: matrix2
        } = _ref;
        return function resize3(x4, size2, defaultValue) {
          if (arguments.length !== 2 && arguments.length !== 3) {
            throw new ArgumentsError("resize", arguments.length, 2, 3);
          }
          if (isMatrix(size2)) {
            size2 = size2.valueOf();
          }
          if (isBigNumber(size2[0])) {
            size2 = size2.map(function(value) {
              return !isBigNumber(value) ? value : value.toNumber();
            });
          }
          if (isMatrix(x4)) {
            return x4.resize(size2, defaultValue, true);
          }
          if (typeof x4 === "string") {
            return _resizeString(x4, size2, defaultValue);
          }
          var asMatrix = Array.isArray(x4) ? false : config4.matrix !== "Array";
          if (size2.length === 0) {
            while (Array.isArray(x4)) {
              x4 = x4[0];
            }
            return clone(x4);
          } else {
            if (!Array.isArray(x4)) {
              x4 = [x4];
            }
            x4 = clone(x4);
            var res = resize(x4, size2, defaultValue);
            return asMatrix ? matrix2(res) : res;
          }
        };
        function _resizeString(str, size2, defaultChar) {
          if (defaultChar !== void 0) {
            if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
              throw new TypeError("Single character expected as defaultValue");
            }
          } else {
            defaultChar = " ";
          }
          if (size2.length !== 1) {
            throw new DimensionError(size2.length, 1);
          }
          var len = size2[0];
          if (typeof len !== "number" || !isInteger(len)) {
            throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
          }
          if (str.length > len) {
            return str.substring(0, len);
          } else if (str.length < len) {
            var res = str;
            for (var i5 = 0, ii = len - str.length; i5 < ii; i5++) {
              res += defaultChar;
            }
            return res;
          } else {
            return str;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotate.js
  var name100, dependencies100, createRotate;
  var init_rotate = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/rotate.js"() {
      init_factory();
      init_array();
      name100 = "rotate";
      dependencies100 = ["typed", "multiply", "rotationMatrix"];
      createRotate = /* @__PURE__ */ factory(name100, dependencies100, (_ref) => {
        var {
          typed: typed3,
          multiply: multiply2,
          rotationMatrix: rotationMatrix2
        } = _ref;
        return typed3(name100, {
          "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w4, theta) {
            _validateSize(w4, 2);
            var matrixRes = multiply2(rotationMatrix2(theta), w4);
            return matrixRes.toArray();
          },
          "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w4, theta) {
            _validateSize(w4, 2);
            return multiply2(rotationMatrix2(theta), w4);
          },
          "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w4, theta, v3) {
            _validateSize(w4, 3);
            var matrixRes = multiply2(rotationMatrix2(theta, v3), w4);
            return matrixRes;
          },
          "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w4, theta, v3) {
            _validateSize(w4, 3);
            return multiply2(rotationMatrix2(theta, v3), w4);
          }
        });
        function _validateSize(v3, expectedSize) {
          var actualSize = Array.isArray(v3) ? arraySize(v3) : v3.size();
          if (actualSize.length > 2) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
          if (actualSize.length === 2 && actualSize[1] !== 1) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
          if (actualSize[0] !== expectedSize) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
  var name101, dependencies101, createRotationMatrix;
  var init_rotationMatrix = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js"() {
      init_is();
      init_factory();
      name101 = "rotationMatrix";
      dependencies101 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
      createRotationMatrix = /* @__PURE__ */ factory(name101, dependencies101, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          multiplyScalar: multiplyScalar2,
          addScalar: addScalar2,
          unaryMinus: unaryMinus2,
          norm: norm2,
          BigNumber: BigNumber2,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2,
          cos: cos3,
          sin: sin3
        } = _ref;
        return typed3(name101, {
          "": function _3() {
            return config4.matrix === "Matrix" ? matrix2([]) : [];
          },
          string: function string2(format5) {
            return matrix2(format5);
          },
          "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
            return _rotationMatrix2x2(theta, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format5) {
            return _rotationMatrix2x2(theta, format5);
          },
          "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v3) {
            var matrixV = matrix2(v3);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, void 0);
          },
          "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v3) {
            _validateVector(v3);
            var storageType = v3.storage() || (config4.matrix === "Matrix" ? "dense" : void 0);
            return _rotationMatrix3x3(theta, v3, storageType);
          },
          "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v3, format5) {
            var matrixV = matrix2(v3);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, format5);
          },
          "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v3, format5) {
            _validateVector(v3);
            return _rotationMatrix3x3(theta, v3, format5);
          }
        });
        function _rotationMatrix2x2(theta, format5) {
          var Big = isBigNumber(theta);
          var minusOne = Big ? new BigNumber2(-1) : -1;
          var cosTheta = cos3(theta);
          var sinTheta = sin3(theta);
          var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
          return _convertToFormat(data, format5);
        }
        function _validateVector(v3) {
          var size2 = v3.size();
          if (size2.length < 1 || size2[0] !== 3) {
            throw new RangeError("Vector must be of dimensions 1x3");
          }
        }
        function _mul(array) {
          return array.reduce((p3, curr) => multiplyScalar2(p3, curr));
        }
        function _convertToFormat(data, format5) {
          if (format5) {
            if (format5 === "sparse") {
              return new SparseMatrix2(data);
            }
            if (format5 === "dense") {
              return new DenseMatrix2(data);
            }
            throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
          }
          return data;
        }
        function _rotationMatrix3x3(theta, v3, format5) {
          var normV = norm2(v3);
          if (normV === 0) {
            throw new RangeError("Rotation around zero vector");
          }
          var Big = isBigNumber(theta) ? BigNumber2 : null;
          var one = Big ? new Big(1) : 1;
          var minusOne = Big ? new Big(-1) : -1;
          var vx = Big ? new Big(v3.get([0]) / normV) : v3.get([0]) / normV;
          var vy = Big ? new Big(v3.get([1]) / normV) : v3.get([1]) / normV;
          var vz = Big ? new Big(v3.get([2]) / normV) : v3.get([2]) / normV;
          var c3 = cos3(theta);
          var oneMinusC = addScalar2(one, unaryMinus2(c3));
          var s3 = sin3(theta);
          var r11 = addScalar2(c3, _mul([vx, vx, oneMinusC]));
          var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s3]));
          var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s3]));
          var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s3]));
          var r22 = addScalar2(c3, _mul([vy, vy, oneMinusC]));
          var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s3]));
          var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s3]));
          var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s3]));
          var r33 = addScalar2(c3, _mul([vz, vz, oneMinusC]));
          var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
          return _convertToFormat(data, format5);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/row.js
  var name102, dependencies102, createRow;
  var init_row = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/row.js"() {
      init_factory();
      init_is();
      init_object();
      init_array();
      name102 = "row";
      dependencies102 = ["typed", "Index", "matrix", "range"];
      createRow = /* @__PURE__ */ factory(name102, dependencies102, (_ref) => {
        var {
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        } = _ref;
        return typed3(name102, {
          "Matrix, number": _row,
          "Array, number": function ArrayNumber(value, row2) {
            return _row(matrix2(clone(value)), row2).valueOf();
          }
        });
        function _row(value, row2) {
          if (value.size().length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          validateIndex(row2, value.size()[0]);
          var columnRange = range2(0, value.size()[1]);
          var index2 = new Index2(row2, columnRange);
          var result = value.subset(index2);
          return isMatrix(result) ? result : matrix2([[result]]);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/size.js
  var name103, dependencies103, createSize;
  var init_size = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/size.js"() {
      init_array();
      init_factory();
      init_noop();
      name103 = "size";
      dependencies103 = ["typed", "config", "?matrix"];
      createSize = /* @__PURE__ */ factory(name103, dependencies103, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2
        } = _ref;
        return typed3(name103, {
          Matrix: function Matrix2(x4) {
            return x4.create(x4.size());
          },
          Array: arraySize,
          string: function string2(x4) {
            return config4.matrix === "Array" ? [x4.length] : matrix2([x4.length]);
          },
          "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x4) {
            return config4.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/squeeze.js
  var name104, dependencies104, createSqueeze;
  var init_squeeze = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/squeeze.js"() {
      init_object();
      init_array();
      init_factory();
      name104 = "squeeze";
      dependencies104 = ["typed", "matrix"];
      createSqueeze = /* @__PURE__ */ factory(name104, dependencies104, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2
        } = _ref;
        return typed3(name104, {
          Array: function Array2(x4) {
            return squeeze(clone(x4));
          },
          Matrix: function Matrix2(x4) {
            var res = squeeze(x4.toArray());
            return Array.isArray(res) ? matrix2(res) : res;
          },
          any: function any(x4) {
            return clone(x4);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/subset.js
  function _getSubstring(str, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Index expected");
    }
    if (isEmptyIndex(index2)) {
      return "";
    }
    validateIndexSourceSize(Array.from(str), index2);
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size().length, 1);
    }
    var strLen = str.length;
    validateIndex(index2.min()[0], strLen);
    validateIndex(index2.max()[0], strLen);
    var range2 = index2.dimension(0);
    var substr = "";
    range2.forEach(function(v3) {
      substr += str.charAt(v3);
    });
    return substr;
  }
  function _setSubstring(str, index2, replacement, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Index expected");
    }
    if (isEmptyIndex(index2)) {
      return str;
    }
    validateIndexSourceSize(Array.from(str), index2);
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size().length, 1);
    }
    if (defaultValue !== void 0) {
      if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultValue = " ";
    }
    var range2 = index2.dimension(0);
    var len = range2.size()[0];
    if (len !== replacement.length) {
      throw new DimensionError(range2.size()[0], replacement.length);
    }
    var strLen = str.length;
    validateIndex(index2.min()[0]);
    validateIndex(index2.max()[0]);
    var chars = [];
    for (var i5 = 0; i5 < strLen; i5++) {
      chars[i5] = str.charAt(i5);
    }
    range2.forEach(function(v3, i6) {
      chars[v3] = replacement.charAt(i6[0]);
    });
    if (chars.length > strLen) {
      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
        if (!chars[_i]) {
          chars[_i] = defaultValue;
        }
      }
    }
    return chars.join("");
  }
  function _getObjectProperty(object, index2) {
    if (isEmptyIndex(index2)) {
      return void 0;
    }
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size(), 1);
    }
    var key = index2.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    return getSafeProperty(object, key);
  }
  function _setObjectProperty(object, index2, replacement) {
    if (isEmptyIndex(index2)) {
      return object;
    }
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size(), 1);
    }
    var key = index2.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    var updated = clone(object);
    setSafeProperty(updated, key, replacement);
    return updated;
  }
  var name105, dependencies105, createSubset;
  var init_subset = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/subset.js"() {
      init_is();
      init_object();
      init_array();
      init_customs();
      init_DimensionError();
      init_factory();
      name105 = "subset";
      dependencies105 = ["typed", "matrix", "zeros", "add"];
      createSubset = /* @__PURE__ */ factory(name105, dependencies105, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          zeros: zeros3,
          add: add3
        } = _ref;
        return typed3(name105, {
          // get subset
          "Matrix, Index": function MatrixIndex(value, index2) {
            if (isEmptyIndex(index2)) {
              return matrix2();
            }
            validateIndexSourceSize(value, index2);
            return value.subset(index2);
          },
          "Array, Index": typed3.referTo("Matrix, Index", function(subsetRef) {
            return function(value, index2) {
              var subsetResult = subsetRef(matrix2(value), index2);
              return index2.isScalar() ? subsetResult : subsetResult.valueOf();
            };
          }),
          "Object, Index": _getObjectProperty,
          "string, Index": _getSubstring,
          // set subset
          "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
            if (isEmptyIndex(index2)) {
              return value;
            }
            validateIndexSourceSize(value, index2);
            return value.clone().subset(index2, _broadcastReplacement(replacement, index2), defaultValue);
          },
          "Array, Index, any, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index2, replacement, defaultValue) {
              var subsetResult = subsetRef(matrix2(value), index2, replacement, defaultValue);
              return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
            };
          }),
          "Array, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index2, replacement) {
              return subsetRef(matrix2(value), index2, replacement, void 0).valueOf();
            };
          }),
          "Matrix, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index2, replacement) {
              return subsetRef(value, index2, replacement, void 0);
            };
          }),
          "string, Index, string": _setSubstring,
          "string, Index, string, string": _setSubstring,
          "Object, Index, any": _setObjectProperty
        });
        function _broadcastReplacement(replacement, index2) {
          if (typeof replacement === "string") {
            throw new Error("can't boradcast a string");
          }
          if (index2._isScalar) {
            return replacement;
          }
          var indexSize = index2.size();
          if (indexSize.every((d3) => d3 > 0)) {
            try {
              return add3(replacement, zeros3(indexSize));
            } catch (error) {
              return replacement;
            }
          } else {
            return replacement;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/transpose.js
  var name106, dependencies106, createTranspose;
  var init_transpose = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/transpose.js"() {
      init_object();
      init_string();
      init_factory();
      name106 = "transpose";
      dependencies106 = ["typed", "matrix"];
      createTranspose = /* @__PURE__ */ factory(name106, dependencies106, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2
        } = _ref;
        return typed3(name106, {
          Array: (x4) => transposeMatrix(matrix2(x4)).valueOf(),
          Matrix: transposeMatrix,
          any: clone
          // scalars
        });
        function transposeMatrix(x4) {
          var size2 = x4.size();
          var c3;
          switch (size2.length) {
            case 1:
              c3 = x4.clone();
              break;
            case 2:
              {
                var rows = size2[0];
                var columns = size2[1];
                if (columns === 0) {
                  throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size2) + ")");
                }
                switch (x4.storage()) {
                  case "dense":
                    c3 = _denseTranspose(x4, rows, columns);
                    break;
                  case "sparse":
                    c3 = _sparseTranspose(x4, rows, columns);
                    break;
                }
              }
              break;
            default:
              throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size2) + ")");
          }
          return c3;
        }
        function _denseTranspose(m3, rows, columns) {
          var data = m3._data;
          var transposed = [];
          var transposedRow;
          for (var j4 = 0; j4 < columns; j4++) {
            transposedRow = transposed[j4] = [];
            for (var i5 = 0; i5 < rows; i5++) {
              transposedRow[i5] = clone(data[i5][j4]);
            }
          }
          return m3.createDenseMatrix({
            data: transposed,
            size: [columns, rows],
            datatype: m3._datatype
          });
        }
        function _sparseTranspose(m3, rows, columns) {
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          var cvalues = values ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var w4 = [];
          for (var x4 = 0; x4 < rows; x4++) {
            w4[x4] = 0;
          }
          var p3, l3, j4;
          for (p3 = 0, l3 = index2.length; p3 < l3; p3++) {
            w4[index2[p3]]++;
          }
          var sum3 = 0;
          for (var i5 = 0; i5 < rows; i5++) {
            cptr.push(sum3);
            sum3 += w4[i5];
            w4[i5] = cptr[i5];
          }
          cptr.push(sum3);
          for (j4 = 0; j4 < columns; j4++) {
            for (var k0 = ptr[j4], k1 = ptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              var q4 = w4[index2[k4]]++;
              cindex[q4] = j4;
              if (values) {
                cvalues[q4] = clone(values[k4]);
              }
            }
          }
          return m3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [columns, rows],
            datatype: m3._datatype
          });
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
  var name107, dependencies107, createCtranspose;
  var init_ctranspose = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/ctranspose.js"() {
      init_factory();
      name107 = "ctranspose";
      dependencies107 = ["typed", "transpose", "conj"];
      createCtranspose = /* @__PURE__ */ factory(name107, dependencies107, (_ref) => {
        var {
          typed: typed3,
          transpose: transpose2,
          conj: conj2
        } = _ref;
        return typed3(name107, {
          any: function any(x4) {
            return conj2(transpose2(x4));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/zeros.js
  var name108, dependencies108, createZeros;
  var init_zeros = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/zeros.js"() {
      init_is();
      init_number();
      init_array();
      init_factory();
      name108 = "zeros";
      dependencies108 = ["typed", "config", "matrix", "BigNumber"];
      createZeros = /* @__PURE__ */ factory(name108, dependencies108, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          BigNumber: BigNumber2
        } = _ref;
        return typed3(name108, {
          "": function _3() {
            return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
          },
          // math.zeros(m, n, p, ..., format)
          // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
          "...number | BigNumber | string": function numberBigNumberString(size2) {
            var last = size2[size2.length - 1];
            if (typeof last === "string") {
              var format5 = size2.pop();
              return _zeros(size2, format5);
            } else if (config4.matrix === "Array") {
              return _zeros(size2);
            } else {
              return _zeros(size2, "default");
            }
          },
          Array: _zeros,
          Matrix: function Matrix2(size2) {
            var format5 = size2.storage();
            return _zeros(size2.valueOf(), format5);
          },
          "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
            return _zeros(size2.valueOf(), format5);
          }
        });
        function _zeros(size2, format5) {
          var hasBigNumbers = _normalize(size2);
          var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
          _validate2(size2);
          if (format5) {
            var m3 = matrix2(format5);
            if (size2.length > 0) {
              return m3.resize(size2, defaultValue);
            }
            return m3;
          } else {
            var arr = [];
            if (size2.length > 0) {
              return resize(arr, size2, defaultValue);
            }
            return arr;
          }
        }
        function _normalize(size2) {
          var hasBigNumbers = false;
          size2.forEach(function(value, index2, arr) {
            if (isBigNumber(value)) {
              hasBigNumbers = true;
              arr[index2] = value.toNumber();
            }
          });
          return hasBigNumbers;
        }
        function _validate2(size2) {
          size2.forEach(function(value) {
            if (typeof value !== "number" || !isInteger(value) || value < 0) {
              throw new Error("Parameters in function zeros must be positive integers");
            }
          });
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/fft.js
  var name109, dependencies109, createFft;
  var init_fft = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/fft.js"() {
      init_array();
      init_factory();
      name109 = "fft";
      dependencies109 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
      createFft = /* @__PURE__ */ factory(name109, dependencies109, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          addScalar: addScalar2,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          exp: exp3,
          tau: tau3,
          i: I3,
          dotDivide: dotDivide2,
          conj: conj2,
          pow: pow3,
          ceil: ceil3,
          log2: log25
        } = _ref;
        return typed3(name109, {
          Array: _ndFft,
          Matrix: function Matrix2(matrix3) {
            return matrix3.create(_ndFft(matrix3.toArray()));
          }
        });
        function _ndFft(arr) {
          var size2 = arraySize(arr);
          if (size2.length === 1)
            return _fft(arr, size2[0]);
          return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
        }
        function _1dFft(arr, dim) {
          var size2 = arraySize(arr);
          if (dim !== 0)
            return new Array(size2[0]).fill(0).map((_3, i5) => _1dFft(arr[i5], dim - 1));
          if (size2.length === 1)
            return _fft(arr);
          function _transpose(arr2) {
            var size3 = arraySize(arr2);
            return new Array(size3[1]).fill(0).map((_3, j4) => new Array(size3[0]).fill(0).map((_4, i5) => arr2[i5][j4]));
          }
          return _transpose(_1dFft(_transpose(arr), 1));
        }
        function _czt(arr) {
          var n3 = arr.length;
          var w4 = exp3(divideScalar2(multiplyScalar2(-1, multiplyScalar2(I3, tau3)), n3));
          var chirp = [];
          for (var i5 = 1 - n3; i5 < n3; i5++) {
            chirp.push(pow3(w4, divideScalar2(pow3(i5, 2), 2)));
          }
          var N22 = pow3(2, ceil3(log25(n3 + n3 - 1)));
          var xp = [...new Array(n3).fill(0).map((_3, i6) => multiplyScalar2(arr[i6], chirp[n3 - 1 + i6])), ...new Array(N22 - n3).fill(0)];
          var ichirp = [...new Array(n3 + n3 - 1).fill(0).map((_3, i6) => divideScalar2(1, chirp[i6])), ...new Array(N22 - (n3 + n3 - 1)).fill(0)];
          var fftXp = _fft(xp);
          var fftIchirp = _fft(ichirp);
          var fftProduct = new Array(N22).fill(0).map((_3, i6) => multiplyScalar2(fftXp[i6], fftIchirp[i6]));
          var ifftProduct = dotDivide2(conj2(_ndFft(conj2(fftProduct))), N22);
          var ret = [];
          for (var _i = n3 - 1; _i < n3 + n3 - 1; _i++) {
            ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
          }
          return ret;
        }
        function _fft(arr) {
          var len = arr.length;
          if (len === 1)
            return [arr[0]];
          if (len % 2 === 0) {
            var ret = [..._fft(arr.filter((_3, i5) => i5 % 2 === 0), len / 2), ..._fft(arr.filter((_3, i5) => i5 % 2 === 1), len / 2)];
            for (var k4 = 0; k4 < len / 2; k4++) {
              var p3 = ret[k4];
              var q4 = multiplyScalar2(ret[k4 + len / 2], exp3(multiplyScalar2(multiplyScalar2(tau3, I3), divideScalar2(-k4, len))));
              ret[k4] = addScalar2(p3, q4);
              ret[k4 + len / 2] = addScalar2(p3, multiplyScalar2(-1, q4));
            }
            return ret;
          } else {
            return _czt(arr);
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ifft.js
  var name110, dependencies110, createIfft;
  var init_ifft = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/ifft.js"() {
      init_array();
      init_factory();
      init_is();
      name110 = "ifft";
      dependencies110 = ["typed", "fft", "dotDivide", "conj"];
      createIfft = /* @__PURE__ */ factory(name110, dependencies110, (_ref) => {
        var {
          typed: typed3,
          fft: fft2,
          dotDivide: dotDivide2,
          conj: conj2
        } = _ref;
        return typed3(name110, {
          "Array | Matrix": function ArrayMatrix(arr) {
            var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
            return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
          }
        });
      });
    }
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  var init_typeof = __esm({
    "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var init_toPrimitive = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
      init_typeof();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function _toPropertyKey(arg2) {
    var key = _toPrimitive(arg2, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  var init_toPropertyKey = __esm({
    "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
      init_typeof();
      init_toPrimitive();
    }
  });

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var init_defineProperty = __esm({
    "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
      init_toPropertyKey();
    }
  });

  // node_modules/mathjs/lib/esm/function/numeric/solveODE.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = null != arguments[i5] ? arguments[i5] : {};
      i5 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var name111, dependencies111, createSolveODE;
  var init_solveODE = __esm({
    "node_modules/mathjs/lib/esm/function/numeric/solveODE.js"() {
      init_defineProperty();
      init_is();
      init_factory();
      name111 = "solveODE";
      dependencies111 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
      createSolveODE = /* @__PURE__ */ factory(name111, dependencies111, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          max: max3,
          map: map3,
          abs: abs3,
          isPositive: isPositive2,
          isNegative: isNegative2,
          larger: larger2,
          smaller: smaller2,
          matrix: matrix2,
          bignumber: bignumber2,
          unaryMinus: unaryMinus2
        } = _ref;
        function _rk(butcherTableau) {
          return function(f3, tspan, y0, options) {
            var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
            if (wrongTSpan) {
              throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
            }
            var t0 = tspan[0];
            var tf = tspan[1];
            var isForwards = larger2(tf, t0);
            var firstStep = options.firstStep;
            if (firstStep !== void 0 && !isPositive2(firstStep)) {
              throw new Error('"firstStep" must be positive');
            }
            var maxStep = options.maxStep;
            if (maxStep !== void 0 && !isPositive2(maxStep)) {
              throw new Error('"maxStep" must be positive');
            }
            var minStep = options.minStep;
            if (minStep && isNegative2(minStep)) {
              throw new Error('"minStep" must be positive or zero');
            }
            var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x4) => x4 !== void 0);
            if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
              throw new Error('Inconsistent type of "t" dependant variables');
            }
            var steps = 1;
            var tol = options.tol ? options.tol : 1e-4;
            var minDelta = options.minDelta ? options.minDelta : 0.2;
            var maxDelta = options.maxDelta ? options.maxDelta : 5;
            var maxIter = options.maxIter ? options.maxIter : 1e4;
            var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
            var [a3, c3, b3, bp] = hasBigNumbers ? [bignumber2(butcherTableau.a), bignumber2(butcherTableau.c), bignumber2(butcherTableau.b), bignumber2(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
            var h3 = firstStep ? isForwards ? firstStep : unaryMinus2(firstStep) : divide3(subtract2(tf, t0), steps);
            var t3 = [t0];
            var y3 = [y0];
            var deltaB = subtract2(b3, bp);
            var n3 = 0;
            var iter = 0;
            var ongoing = _createOngoing(isForwards);
            var trimStep = _createTrimStep(isForwards);
            while (ongoing(t3[n3], tf)) {
              var k4 = [];
              h3 = trimStep(t3[n3], tf, h3);
              k4.push(f3(t3[n3], y3[n3]));
              for (var i5 = 1; i5 < c3.length; ++i5) {
                k4.push(f3(add3(t3[n3], multiply2(c3[i5], h3)), add3(y3[n3], multiply2(h3, a3[i5], k4))));
              }
              var TE = max3(abs3(map3(multiply2(deltaB, k4), (X2) => isUnit(X2) ? X2.value : X2)));
              if (TE < tol && tol / TE > 1 / 4) {
                t3.push(add3(t3[n3], h3));
                y3.push(add3(y3[n3], multiply2(h3, b3, k4)));
                n3++;
              }
              var delta = 0.84 * (tol / TE) ** (1 / 5);
              if (smaller2(delta, minDelta)) {
                delta = minDelta;
              } else if (larger2(delta, maxDelta)) {
                delta = maxDelta;
              }
              delta = hasBigNumbers ? bignumber2(delta) : delta;
              h3 = multiply2(h3, delta);
              if (maxStep && larger2(abs3(h3), maxStep)) {
                h3 = isForwards ? maxStep : unaryMinus2(maxStep);
              } else if (minStep && smaller2(abs3(h3), minStep)) {
                h3 = isForwards ? minStep : unaryMinus2(minStep);
              }
              iter++;
              if (iter > maxIter) {
                throw new Error("Maximum number of iterations reached, try changing options");
              }
            }
            return {
              t: t3,
              y: y3
            };
          };
        }
        function _rk23(f3, tspan, y0, options) {
          var a3 = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
          var c3 = [null, 1 / 2, 3 / 4, 1];
          var b3 = [2 / 9, 1 / 3, 4 / 9, 0];
          var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
          var butcherTableau = {
            a: a3,
            c: c3,
            b: b3,
            bp
          };
          return _rk(butcherTableau)(f3, tspan, y0, options);
        }
        function _rk45(f3, tspan, y0, options) {
          var a3 = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
          var c3 = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
          var b3 = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
          var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
          var butcherTableau = {
            a: a3,
            c: c3,
            b: b3,
            bp
          };
          return _rk(butcherTableau)(f3, tspan, y0, options);
        }
        function _solveODE(f3, tspan, y0, opt) {
          var method = opt.method ? opt.method : "RK45";
          var methods = {
            RK23: _rk23,
            RK45: _rk45
          };
          if (method.toUpperCase() in methods) {
            var methodOptions = _objectSpread({}, opt);
            delete methodOptions.method;
            return methods[method.toUpperCase()](f3, tspan, y0, methodOptions);
          } else {
            var methodsWithQuotes = Object.keys(methods).map((x4) => '"'.concat(x4, '"'));
            var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
            throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
          }
        }
        function _createOngoing(isForwards) {
          return isForwards ? smaller2 : larger2;
        }
        function _createTrimStep(isForwards) {
          var outOfBounds = isForwards ? larger2 : smaller2;
          return function(t3, tf, h3) {
            var next = add3(t3, h3);
            return outOfBounds(next, tf) ? subtract2(tf, t3) : h3;
          };
        }
        function isNumOrBig(x4) {
          return isBigNumber(x4) || isNumber(x4);
        }
        function _matrixSolveODE(f3, T4, y0, options) {
          var sol = _solveODE(f3, T4.toArray(), y0.toArray(), options);
          return {
            t: matrix2(sol.t),
            y: matrix2(sol.y)
          };
        }
        return typed3("solveODE", {
          "function, Array, Array, Object": _solveODE,
          "function, Matrix, Matrix, Object": _matrixSolveODE,
          "function, Array, Array": (f3, T4, y0) => _solveODE(f3, T4, y0, {}),
          "function, Matrix, Matrix": (f3, T4, y0) => _matrixSolveODE(f3, T4, y0, {}),
          "function, Array, number | BigNumber | Unit": (f3, T4, y0) => {
            var sol = _solveODE(f3, T4, [y0], {});
            return {
              t: sol.t,
              y: sol.y.map((Y2) => Y2[0])
            };
          },
          "function, Matrix, number | BigNumber | Unit": (f3, T4, y0) => {
            var sol = _solveODE(f3, T4.toArray(), [y0], {});
            return {
              t: matrix2(sol.t),
              y: matrix2(sol.y.map((Y2) => Y2[0]))
            };
          },
          "function, Array, number | BigNumber | Unit, Object": (f3, T4, y0, options) => {
            var sol = _solveODE(f3, T4, [y0], options);
            return {
              t: sol.t,
              y: sol.y.map((Y2) => Y2[0])
            };
          },
          "function, Matrix, number | BigNumber | Unit, Object": (f3, T4, y0, options) => {
            var sol = _solveODE(f3, T4.toArray(), [y0], options);
            return {
              t: matrix2(sol.t),
              y: matrix2(sol.y.map((Y2) => Y2[0]))
            };
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/special/erf.js
  var name112, dependencies112, createErf, THRESH, SQRPI, P5, Q2, MAX_NUM;
  var init_erf = __esm({
    "node_modules/mathjs/lib/esm/function/special/erf.js"() {
      init_collection();
      init_number();
      init_factory();
      name112 = "erf";
      dependencies112 = ["typed"];
      createErf = /* @__PURE__ */ factory(name112, dependencies112, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("name", {
          number: function number2(x4) {
            var y3 = Math.abs(x4);
            if (y3 >= MAX_NUM) {
              return sign(x4);
            }
            if (y3 <= THRESH) {
              return sign(x4) * erf1(y3);
            }
            if (y3 <= 4) {
              return sign(x4) * (1 - erfc2(y3));
            }
            return sign(x4) * (1 - erfc3(y3));
          },
          "Array | Matrix": typed3.referToSelf((self2) => (n3) => deepMap(n3, self2))
          // TODO: For complex numbers, use the approximation for the Faddeeva function
          //  from "More Efficient Computation of the Complex Error Function" (AMS)
        });
        function erf1(y3) {
          var ysq = y3 * y3;
          var xnum = P5[0][4] * ysq;
          var xden = ysq;
          var i5;
          for (i5 = 0; i5 < 3; i5 += 1) {
            xnum = (xnum + P5[0][i5]) * ysq;
            xden = (xden + Q2[0][i5]) * ysq;
          }
          return y3 * (xnum + P5[0][3]) / (xden + Q2[0][3]);
        }
        function erfc2(y3) {
          var xnum = P5[1][8] * y3;
          var xden = y3;
          var i5;
          for (i5 = 0; i5 < 7; i5 += 1) {
            xnum = (xnum + P5[1][i5]) * y3;
            xden = (xden + Q2[1][i5]) * y3;
          }
          var result = (xnum + P5[1][7]) / (xden + Q2[1][7]);
          var ysq = parseInt(y3 * 16) / 16;
          var del = (y3 - ysq) * (y3 + ysq);
          return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
        }
        function erfc3(y3) {
          var ysq = 1 / (y3 * y3);
          var xnum = P5[2][5] * ysq;
          var xden = ysq;
          var i5;
          for (i5 = 0; i5 < 4; i5 += 1) {
            xnum = (xnum + P5[2][i5]) * ysq;
            xden = (xden + Q2[2][i5]) * ysq;
          }
          var result = ysq * (xnum + P5[2][4]) / (xden + Q2[2][4]);
          result = (SQRPI - result) / y3;
          ysq = parseInt(y3 * 16) / 16;
          var del = (y3 - ysq) * (y3 + ysq);
          return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
        }
      });
      THRESH = 0.46875;
      SQRPI = 0.5641895835477563;
      P5 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
      Q2 = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
      MAX_NUM = Math.pow(2, 53);
    }
  });

  // node_modules/mathjs/lib/esm/function/special/zeta.js
  var name113, dependencies113, createZeta;
  var init_zeta = __esm({
    "node_modules/mathjs/lib/esm/function/special/zeta.js"() {
      init_factory();
      name113 = "zeta";
      dependencies113 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
      createZeta = /* @__PURE__ */ factory(name113, dependencies113, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          multiply: multiply2,
          pow: pow3,
          divide: divide3,
          factorial: factorial2,
          equal: equal2,
          smallerEq: smallerEq2,
          isNegative: isNegative2,
          gamma: gamma2,
          sin: sin3,
          subtract: subtract2,
          add: add3,
          Complex: Complex3,
          BigNumber: _BigNumber,
          pi: pi3
        } = _ref;
        return typed3(name113, {
          number: (s3) => zetaNumeric(s3, (value) => value, () => 20),
          BigNumber: (s3) => zetaNumeric(s3, (value) => new _BigNumber(value), () => {
            return Math.abs(Math.log10(config4.epsilon));
          }),
          Complex: zetaComplex
        });
        function zetaNumeric(s3, createValue, determineDigits) {
          if (equal2(s3, 0)) {
            return createValue(-0.5);
          }
          if (equal2(s3, 1)) {
            return createValue(NaN);
          }
          if (!isFinite(s3)) {
            return isNegative2(s3) ? createValue(NaN) : createValue(1);
          }
          return zeta2(s3, createValue, determineDigits, (s4) => s4);
        }
        function zetaComplex(s3) {
          if (s3.re === 0 && s3.im === 0) {
            return new Complex3(-0.5);
          }
          if (s3.re === 1) {
            return new Complex3(NaN, NaN);
          }
          if (s3.re === Infinity && s3.im === 0) {
            return new Complex3(1);
          }
          if (s3.im === Infinity || s3.re === -Infinity) {
            return new Complex3(NaN, NaN);
          }
          return zeta2(s3, (value) => value, (s4) => Math.round(1.3 * 15 + 0.9 * Math.abs(s4.im)), (s4) => s4.re);
        }
        function zeta2(s3, createValue, determineDigits, getRe) {
          var n3 = determineDigits(s3);
          if (getRe(s3) > -(n3 - 1) / 2) {
            return f3(s3, createValue(n3), createValue);
          } else {
            var c3 = multiply2(pow3(2, s3), pow3(createValue(pi3), subtract2(s3, 1)));
            c3 = multiply2(c3, sin3(multiply2(divide3(createValue(pi3), 2), s3)));
            c3 = multiply2(c3, gamma2(subtract2(1, s3)));
            return multiply2(c3, zeta2(subtract2(1, s3), createValue, determineDigits, getRe));
          }
        }
        function d3(k4, n3) {
          var S2 = k4;
          for (var j4 = k4; smallerEq2(j4, n3); j4 = add3(j4, 1)) {
            var factor = divide3(multiply2(factorial2(add3(n3, subtract2(j4, 1))), pow3(4, j4)), multiply2(factorial2(subtract2(n3, j4)), factorial2(multiply2(2, j4))));
            S2 = add3(S2, factor);
          }
          return multiply2(n3, S2);
        }
        function f3(s3, n3, createValue) {
          var c3 = divide3(1, multiply2(d3(createValue(0), n3), subtract2(1, pow3(2, subtract2(1, s3)))));
          var S2 = createValue(0);
          for (var k4 = createValue(1); smallerEq2(k4, n3); k4 = add3(k4, 1)) {
            S2 = add3(S2, divide3(multiply2((-1) ** (k4 - 1), d3(k4, n3)), pow3(k4, s3)));
          }
          return multiply2(c3, S2);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mode.js
  var name114, dependencies114, createMode;
  var init_mode = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/mode.js"() {
      init_array();
      init_factory();
      name114 = "mode";
      dependencies114 = ["typed", "isNaN", "isNumeric"];
      createMode = /* @__PURE__ */ factory(name114, dependencies114, (_ref) => {
        var {
          typed: typed3,
          isNaN: isNaN3,
          isNumeric: isNumeric2
        } = _ref;
        return typed3(name114, {
          "Array | Matrix": _mode,
          "...": function _3(args) {
            return _mode(args);
          }
        });
        function _mode(values) {
          values = flatten(values.valueOf());
          var num = values.length;
          if (num === 0) {
            throw new Error("Cannot calculate mode of an empty array");
          }
          var count2 = {};
          var mode2 = [];
          var max3 = 0;
          for (var i5 = 0; i5 < values.length; i5++) {
            var value = values[i5];
            if (isNumeric2(value) && isNaN3(value)) {
              throw new Error("Cannot calculate mode of an array containing NaN values");
            }
            if (!(value in count2)) {
              count2[value] = 0;
            }
            count2[value]++;
            if (count2[value] === max3) {
              mode2.push(value);
            } else if (count2[value] > max3) {
              max3 = count2[value];
              mode2 = [value];
            }
          }
          return mode2;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
  function improveErrorMessage(err, fnName, value) {
    var details;
    if (String(err).indexOf("Unexpected type") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
      return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
    }
    if (String(err).indexOf("complex numbers") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
      return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
    }
    return err;
  }
  var init_improveErrorMessage = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js"() {
      init_is();
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/prod.js
  var name115, dependencies115, createProd;
  var init_prod = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/prod.js"() {
      init_collection();
      init_factory();
      init_improveErrorMessage();
      name115 = "prod";
      dependencies115 = ["typed", "config", "multiplyScalar", "numeric"];
      createProd = /* @__PURE__ */ factory(name115, dependencies115, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          multiplyScalar: multiplyScalar2,
          numeric: numeric3
        } = _ref;
        return typed3(name115, {
          // prod([a, b, c, d, ...])
          "Array | Matrix": _prod,
          // prod([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            throw new Error("prod(A, dim) is not yet supported");
          },
          // prod(a, b, c, d, ...)
          "...": function _3(args) {
            return _prod(args);
          }
        });
        function _prod(array) {
          var prod2;
          deepForEach(array, function(value) {
            try {
              prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
            } catch (err) {
              throw improveErrorMessage(err, "prod", value);
            }
          });
          if (typeof prod2 === "string") {
            prod2 = numeric3(prod2, config4.number);
          }
          if (prod2 === void 0) {
            throw new Error("Cannot calculate prod of an empty array");
          }
          return prod2;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/string/format.js
  var name116, dependencies116, createFormat;
  var init_format = __esm({
    "node_modules/mathjs/lib/esm/function/string/format.js"() {
      init_string();
      init_factory();
      name116 = "format";
      dependencies116 = ["typed"];
      createFormat = /* @__PURE__ */ factory(name116, dependencies116, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name116, {
          any: format3,
          "any, Object | function | number": format3
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/string/bin.js
  var name117, dependencies117, createBin;
  var init_bin = __esm({
    "node_modules/mathjs/lib/esm/function/string/bin.js"() {
      init_factory();
      name117 = "bin";
      dependencies117 = ["typed", "format"];
      createBin = factory(name117, dependencies117, (_ref) => {
        var {
          typed: typed3,
          format: format5
        } = _ref;
        return typed3(name117, {
          "number | BigNumber": function numberBigNumber(n3) {
            return format5(n3, {
              notation: "bin"
            });
          },
          "number | BigNumber, number": function numberBigNumberNumber(n3, wordSize) {
            return format5(n3, {
              notation: "bin",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/string/oct.js
  var name118, dependencies118, createOct;
  var init_oct = __esm({
    "node_modules/mathjs/lib/esm/function/string/oct.js"() {
      init_factory();
      name118 = "oct";
      dependencies118 = ["typed", "format"];
      createOct = factory(name118, dependencies118, (_ref) => {
        var {
          typed: typed3,
          format: format5
        } = _ref;
        return typed3(name118, {
          "number | BigNumber": function numberBigNumber(n3) {
            return format5(n3, {
              notation: "oct"
            });
          },
          "number | BigNumber, number": function numberBigNumberNumber(n3, wordSize) {
            return format5(n3, {
              notation: "oct",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/string/hex.js
  var name119, dependencies119, createHex;
  var init_hex = __esm({
    "node_modules/mathjs/lib/esm/function/string/hex.js"() {
      init_factory();
      name119 = "hex";
      dependencies119 = ["typed", "format"];
      createHex = factory(name119, dependencies119, (_ref) => {
        var {
          typed: typed3,
          format: format5
        } = _ref;
        return typed3(name119, {
          "number | BigNumber": function numberBigNumber(n3) {
            return format5(n3, {
              notation: "hex"
            });
          },
          "number | BigNumber, number": function numberBigNumberNumber(n3, wordSize) {
            return format5(n3, {
              notation: "hex",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/string/print.js
  function _print(template, values, options) {
    return template.replace(/\$([\w.]+)/g, function(original, key) {
      var keys = key.split(".");
      var value = values[keys.shift()];
      while (keys.length && value !== void 0) {
        var k4 = keys.shift();
        value = k4 ? value[k4] : value + ".";
      }
      if (value !== void 0) {
        if (!isString(value)) {
          return format3(value, options);
        } else {
          return value;
        }
      }
      return original;
    });
  }
  var name120, dependencies120, createPrint;
  var init_print = __esm({
    "node_modules/mathjs/lib/esm/function/string/print.js"() {
      init_string();
      init_is();
      init_factory();
      name120 = "print";
      dependencies120 = ["typed"];
      createPrint = /* @__PURE__ */ factory(name120, dependencies120, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name120, {
          // note: Matrix will be converted automatically to an Array
          "string, Object | Array": _print,
          "string, Object | Array, number | Object": _print
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/unit/to.js
  var name121, dependencies121, createTo;
  var init_to = __esm({
    "node_modules/mathjs/lib/esm/function/unit/to.js"() {
      init_factory();
      init_matrixAlgorithmSuite();
      name121 = "to";
      dependencies121 = ["typed", "matrix", "concat"];
      createTo = /* @__PURE__ */ factory(name121, dependencies121, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        } = _ref;
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name121, {
          "Unit, Unit | string": (x4, unit2) => x4.to(unit2)
        }, matrixAlgorithmSuite({
          Ds: true
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/isPrime.js
  var name122, dependencies122, createIsPrime;
  var init_isPrime = __esm({
    "node_modules/mathjs/lib/esm/function/utils/isPrime.js"() {
      init_collection();
      init_factory();
      name122 = "isPrime";
      dependencies122 = ["typed"];
      createIsPrime = /* @__PURE__ */ factory(name122, dependencies122, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name122, {
          number: function number2(x4) {
            if (x4 * 0 !== 0) {
              return false;
            }
            if (x4 <= 3) {
              return x4 > 1;
            }
            if (x4 % 2 === 0 || x4 % 3 === 0) {
              return false;
            }
            for (var i5 = 5; i5 * i5 <= x4; i5 += 6) {
              if (x4 % i5 === 0 || x4 % (i5 + 2) === 0) {
                return false;
              }
            }
            return true;
          },
          BigNumber: function BigNumber2(n3) {
            if (n3.toNumber() * 0 !== 0) {
              return false;
            }
            if (n3.lte(3))
              return n3.gt(1);
            if (n3.mod(2).eq(0) || n3.mod(3).eq(0))
              return false;
            if (n3.lt(Math.pow(2, 32))) {
              var x4 = n3.toNumber();
              for (var i5 = 5; i5 * i5 <= x4; i5 += 6) {
                if (x4 % i5 === 0 || x4 % (i5 + 2) === 0) {
                  return false;
                }
              }
              return true;
            }
            function modPow(base, exponent, modulus) {
              var accumulator = 1;
              while (!exponent.eq(0)) {
                if (exponent.mod(2).eq(0)) {
                  exponent = exponent.div(2);
                  base = base.mul(base).mod(modulus);
                } else {
                  exponent = exponent.sub(1);
                  accumulator = base.mul(accumulator).mod(modulus);
                }
              }
              return accumulator;
            }
            var Decimal2 = n3.constructor.clone({
              precision: n3.toFixed(0).length * 2
            });
            n3 = new Decimal2(n3);
            var r3 = 0;
            var d3 = n3.sub(1);
            while (d3.mod(2).eq(0)) {
              d3 = d3.div(2);
              r3 += 1;
            }
            var bases = null;
            if (n3.lt("3317044064679887385961981")) {
              bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x5) => x5 < n3);
            } else {
              var max3 = Math.min(n3.toNumber() - 2, Math.floor(2 * Math.pow(n3.toFixed(0).length * Math.log(10), 2)));
              bases = [];
              for (var _i = 2; _i <= max3; _i += 1) {
                bases.push(max3);
              }
            }
            for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
              var a3 = bases[_i2];
              var adn = modPow(n3.sub(n3).add(a3), d3, n3);
              if (!adn.eq(1)) {
                for (var _i3 = 0, _x = adn; !_x.eq(n3.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n3)) {
                  if (_i3 === r3 - 1) {
                    return false;
                  }
                }
              }
            }
            return true;
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/utils/numeric.js
  var name123, dependencies123, createNumeric;
  var init_numeric = __esm({
    "node_modules/mathjs/lib/esm/function/utils/numeric.js"() {
      init_is();
      init_factory();
      init_noop();
      name123 = "numeric";
      dependencies123 = ["number", "?bignumber", "?fraction"];
      createNumeric = /* @__PURE__ */ factory(name123, dependencies123, (_ref) => {
        var {
          number: _number,
          bignumber: bignumber2,
          fraction: fraction2
        } = _ref;
        var validInputTypes = {
          string: true,
          number: true,
          BigNumber: true,
          Fraction: true
        };
        var validOutputTypes = {
          number: (x4) => _number(x4),
          BigNumber: bignumber2 ? (x4) => bignumber2(x4) : noBignumber,
          Fraction: fraction2 ? (x4) => fraction2(x4) : noFraction
        };
        return function numeric3(value) {
          var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
          var check = arguments.length > 2 ? arguments[2] : void 0;
          if (check !== void 0) {
            throw new SyntaxError("numeric() takes one or two arguments");
          }
          var inputType = typeOf(value);
          if (!(inputType in validInputTypes)) {
            throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
          }
          if (!(outputType in validOutputTypes)) {
            throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
          }
          if (outputType === inputType) {
            return value;
          } else {
            return validOutputTypes[outputType](value);
          }
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
  var name124, dependencies124, createDivideScalar;
  var init_divideScalar = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js"() {
      init_factory();
      name124 = "divideScalar";
      dependencies124 = ["typed", "numeric"];
      createDivideScalar = /* @__PURE__ */ factory(name124, dependencies124, (_ref) => {
        var {
          typed: typed3,
          numeric: numeric3
        } = _ref;
        return typed3(name124, {
          "number, number": function numberNumber(x4, y3) {
            return x4 / y3;
          },
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return x4.div(y3);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.div(y3);
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            return x4.div(y3);
          },
          "Unit, number | Complex | Fraction | BigNumber | Unit": (x4, y3) => x4.divide(y3),
          "number | Fraction | Complex | BigNumber, Unit": (x4, y3) => y3.divideInto(x4)
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/pow.js
  var name125, dependencies125, createPow;
  var init_pow = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/pow.js"() {
      init_factory();
      init_number();
      init_array();
      init_number2();
      name125 = "pow";
      dependencies125 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
      createPow = /* @__PURE__ */ factory(name125, dependencies125, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          identity: identity2,
          multiply: multiply2,
          matrix: matrix2,
          inv: inv2,
          number: number2,
          fraction: fraction2,
          Complex: Complex3
        } = _ref;
        return typed3(name125, {
          "number, number": _pow,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return x4.pow(y3);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            if (y3.isInteger() || x4 >= 0 || config4.predictable) {
              return x4.pow(y3);
            } else {
              return new Complex3(x4.toNumber(), 0).pow(y3.toNumber(), 0);
            }
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            var result = x4.pow(y3);
            if (result != null) {
              return result;
            }
            if (config4.predictable) {
              throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
            } else {
              return _pow(x4.valueOf(), y3.valueOf());
            }
          },
          "Array, number": _powArray,
          "Array, BigNumber": function ArrayBigNumber(x4, y3) {
            return _powArray(x4, y3.toNumber());
          },
          "Matrix, number": _powMatrix,
          "Matrix, BigNumber": function MatrixBigNumber(x4, y3) {
            return _powMatrix(x4, y3.toNumber());
          },
          "Unit, number | BigNumber": function UnitNumberBigNumber(x4, y3) {
            return x4.pow(y3);
          }
        });
        function _pow(x4, y3) {
          if (config4.predictable && !isInteger(y3) && x4 < 0) {
            try {
              var yFrac = fraction2(y3);
              var yNum = number2(yFrac);
              if (y3 === yNum || Math.abs((y3 - yNum) / y3) < 1e-14) {
                if (yFrac.d % 2 === 1) {
                  return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x4, y3);
                }
              }
            } catch (ex) {
            }
          }
          if (config4.predictable && (x4 < -1 && y3 === Infinity || x4 > -1 && x4 < 0 && y3 === -Infinity)) {
            return NaN;
          }
          if (isInteger(y3) || x4 >= 0 || config4.predictable) {
            return powNumber(x4, y3);
          } else {
            if (x4 * x4 < 1 && y3 === Infinity || x4 * x4 > 1 && y3 === -Infinity) {
              return 0;
            }
            return new Complex3(x4, 0).pow(y3, 0);
          }
        }
        function _powArray(x4, y3) {
          if (!isInteger(y3)) {
            throw new TypeError("For A^b, b must be an integer (value is " + y3 + ")");
          }
          var s3 = arraySize(x4);
          if (s3.length !== 2) {
            throw new Error("For A^b, A must be 2 dimensional (A has " + s3.length + " dimensions)");
          }
          if (s3[0] !== s3[1]) {
            throw new Error("For A^b, A must be square (size is " + s3[0] + "x" + s3[1] + ")");
          }
          if (y3 < 0) {
            try {
              return _powArray(inv2(x4), -y3);
            } catch (error) {
              if (error.message === "Cannot calculate inverse, determinant is zero") {
                throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y3 + ")");
              }
              throw error;
            }
          }
          var res = identity2(s3[0]).valueOf();
          var px = x4;
          while (y3 >= 1) {
            if ((y3 & 1) === 1) {
              res = multiply2(px, res);
            }
            y3 >>= 1;
            px = multiply2(px, px);
          }
          return res;
        }
        function _powMatrix(x4, y3) {
          return matrix2(_powArray(x4.valueOf(), y3));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/round.js
  var NO_INT, name126, dependencies126, createRound;
  var init_round = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/round.js"() {
      init_factory();
      init_collection();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matAlgo14xDs();
      init_number2();
      NO_INT = "Number of decimals in function round must be an integer";
      name126 = "round";
      dependencies126 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
      createRound = /* @__PURE__ */ factory(name126, dependencies126, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          BigNumber: BigNumber2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        return typed3(name126, {
          number: roundNumber,
          "number, number": roundNumber,
          "number, BigNumber": function numberBigNumber(x4, n3) {
            if (!n3.isInteger()) {
              throw new TypeError(NO_INT);
            }
            return new BigNumber2(x4).toDecimalPlaces(n3.toNumber());
          },
          Complex: function Complex3(x4) {
            return x4.round();
          },
          "Complex, number": function ComplexNumber(x4, n3) {
            if (n3 % 1) {
              throw new TypeError(NO_INT);
            }
            return x4.round(n3);
          },
          "Complex, BigNumber": function ComplexBigNumber(x4, n3) {
            if (!n3.isInteger()) {
              throw new TypeError(NO_INT);
            }
            var _n2 = n3.toNumber();
            return x4.round(_n2);
          },
          BigNumber: function BigNumber3(x4) {
            return x4.toDecimalPlaces(0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, n3) {
            if (!n3.isInteger()) {
              throw new TypeError(NO_INT);
            }
            return x4.toDecimalPlaces(n3.toNumber());
          },
          Fraction: function Fraction3(x4) {
            return x4.round();
          },
          "Fraction, number": function FractionNumber(x4, n3) {
            if (n3 % 1) {
              throw new TypeError(NO_INT);
            }
            return x4.round(n3);
          },
          "Fraction, BigNumber": function FractionBigNumber(x4, n3) {
            if (!n3.isInteger()) {
              throw new TypeError(NO_INT);
            }
            return x4.round(n3.toNumber());
          },
          // deep map collection, skip zeros since round(0) = 0
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2, true)),
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "Array, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(matrix2(x4), y3, self2, false).valueOf();
          }),
          "number | Complex | BigNumber | Fraction, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo12xSfs(y3, x4, self2, true);
          }),
          "number | Complex | BigNumber | Fraction, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo14xDs(y3, x4, self2, true);
          }),
          "number | Complex | BigNumber | Fraction, Array": typed3.referToSelf((self2) => (x4, y3) => {
            return matAlgo14xDs(matrix2(y3), x4, self2, true).valueOf();
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log.js
  var name127, dependencies127, createLog;
  var init_log = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/log.js"() {
      init_factory();
      init_number2();
      name127 = "log";
      dependencies127 = ["config", "typed", "divideScalar", "Complex"];
      createLog = /* @__PURE__ */ factory(name127, dependencies127, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          divideScalar: divideScalar2,
          Complex: Complex3
        } = _ref;
        return typed3(name127, {
          number: function number2(x4) {
            if (x4 >= 0 || config4.predictable) {
              return logNumber(x4);
            } else {
              return new Complex3(x4, 0).log();
            }
          },
          Complex: function Complex4(x4) {
            return x4.log();
          },
          BigNumber: function BigNumber2(x4) {
            if (!x4.isNegative() || config4.predictable) {
              return x4.ln();
            } else {
              return new Complex3(x4.toNumber(), 0).log();
            }
          },
          "any, any": typed3.referToSelf((self2) => (x4, base) => {
            return divideScalar2(self2(x4), self2(base));
          })
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
  var name128, dependencies128, createLog1p;
  var init_log1p = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/log1p.js"() {
      init_factory();
      init_collection();
      init_number();
      name128 = "log1p";
      dependencies128 = ["typed", "config", "divideScalar", "log", "Complex"];
      createLog1p = /* @__PURE__ */ factory(name128, dependencies128, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          divideScalar: divideScalar2,
          log: log4,
          Complex: Complex3
        } = _ref;
        return typed3(name128, {
          number: function number2(x4) {
            if (x4 >= -1 || config4.predictable) {
              return log1p(x4);
            } else {
              return _log1pComplex(new Complex3(x4, 0));
            }
          },
          Complex: _log1pComplex,
          BigNumber: function BigNumber2(x4) {
            var y3 = x4.plus(1);
            if (!y3.isNegative() || config4.predictable) {
              return y3.ln();
            } else {
              return _log1pComplex(new Complex3(x4.toNumber(), 0));
            }
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2)),
          "any, any": typed3.referToSelf((self2) => (x4, base) => {
            return divideScalar2(self2(x4), log4(base));
          })
        });
        function _log1pComplex(x4) {
          var xRe1p = x4.re + 1;
          return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x4.im * x4.im)), Math.atan2(x4.im, xRe1p));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
  var name129, dependencies129, createNthRoots;
  var init_nthRoots = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js"() {
      init_factory();
      name129 = "nthRoots";
      dependencies129 = ["config", "typed", "divideScalar", "Complex"];
      createNthRoots = /* @__PURE__ */ factory(name129, dependencies129, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          divideScalar: divideScalar2,
          Complex: Complex3
        } = _ref;
        var _calculateExactResult = [function realPos(val) {
          return new Complex3(val, 0);
        }, function imagPos(val) {
          return new Complex3(0, val);
        }, function realNeg(val) {
          return new Complex3(-val, 0);
        }, function imagNeg(val) {
          return new Complex3(0, -val);
        }];
        function _nthComplexRoots(a3, root) {
          if (root < 0)
            throw new Error("Root must be greater than zero");
          if (root === 0)
            throw new Error("Root must be non-zero");
          if (root % 1 !== 0)
            throw new Error("Root must be an integer");
          if (a3 === 0 || a3.abs() === 0)
            return [new Complex3(0, 0)];
          var aIsNumeric = typeof a3 === "number";
          var offset;
          if (aIsNumeric || a3.re === 0 || a3.im === 0) {
            if (aIsNumeric) {
              offset = 2 * +(a3 < 0);
            } else if (a3.im === 0) {
              offset = 2 * +(a3.re < 0);
            } else {
              offset = 2 * +(a3.im < 0) + 1;
            }
          }
          var arg2 = a3.arg();
          var abs3 = a3.abs();
          var roots = [];
          var r3 = Math.pow(abs3, 1 / root);
          for (var k4 = 0; k4 < root; k4++) {
            var halfPiFactor = (offset + 4 * k4) / root;
            if (halfPiFactor === Math.round(halfPiFactor)) {
              roots.push(_calculateExactResult[halfPiFactor % 4](r3));
              continue;
            }
            roots.push(new Complex3({
              r: r3,
              phi: (arg2 + 2 * Math.PI * k4) / root
            }));
          }
          return roots;
        }
        return typed3(name129, {
          Complex: function Complex4(x4) {
            return _nthComplexRoots(x4, 2);
          },
          "Complex, number": _nthComplexRoots
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
  var name130, dependencies130, createDotPow;
  var init_dotPow = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js"() {
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name130 = "dotPow";
      dependencies130 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
      createDotPow = /* @__PURE__ */ factory(name130, dependencies130, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2,
          matrix: matrix2,
          pow: pow3,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var powScalarSignatures = {};
        for (var signature in pow3.signatures) {
          if (Object.prototype.hasOwnProperty.call(pow3.signatures, signature)) {
            if (!signature.includes("Matrix") && !signature.includes("Array")) {
              powScalarSignatures[signature] = pow3.signatures[signature];
            }
          }
        }
        var powScalar = typed3(powScalarSignatures);
        return typed3(name130, matrixAlgorithmSuite({
          elop: powScalar,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
  var name131, dependencies131, createDotDivide;
  var init_dotDivide = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js"() {
      init_factory();
      init_matAlgo02xDS0();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name131 = "dotDivide";
      dependencies131 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
      createDotDivide = /* @__PURE__ */ factory(name131, dependencies131, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          divideScalar: divideScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name131, matrixAlgorithmSuite({
          elop: divideScalar2,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
  function createSolveValidation(_ref) {
    var {
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function solveValidation(m3, b3, copy) {
      var mSize = m3.size();
      if (mSize.length !== 2) {
        throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
      }
      var data = [];
      if (isMatrix(b3)) {
        var bSize = b3.size();
        var bdata = b3._data;
        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var i5 = 0; i5 < rows; i5++) {
            data[i5] = [bdata[i5]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b3._datatype
          });
        }
        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          if (isDenseMatrix(b3)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1],
                datatype: b3._datatype
              });
            }
            return b3;
          }
          if (isSparseMatrix(b3)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values = b3._values;
            var index2 = b3._index;
            var ptr = b3._ptr;
            for (var k1 = ptr[1], k4 = ptr[0]; k4 < k1; k4++) {
              var _i3 = index2[k4];
              data[_i3][0] = values[k4];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b3._datatype
            });
          }
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
      if (isArray(b3)) {
        var bsize = arraySize(b3);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b3[_i4]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b3[_i5][0]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
    };
  }
  var init_solveValidation = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js"() {
      init_is();
      init_array();
      init_string();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
  var name132, dependencies132, createLsolve;
  var init_lsolve = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js"() {
      init_factory();
      init_solveValidation();
      name132 = "lsolve";
      dependencies132 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
      createLsolve = /* @__PURE__ */ factory(name132, dependencies132, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var solveValidation = createSolveValidation({
          DenseMatrix: DenseMatrix2
        });
        return typed3(name132, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m3, b3) {
            return _sparseForwardSubstitution(m3, b3);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m3, b3) {
            return _denseForwardSubstitution(m3, b3);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a3, b3) {
            var m3 = matrix2(a3);
            var r3 = _denseForwardSubstitution(m3, b3);
            return r3.valueOf();
          }
        });
        function _denseForwardSubstitution(m3, b3) {
          b3 = solveValidation(m3, b3, true);
          var bdata = b3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          var x4 = [];
          var mdata = m3._data;
          for (var j4 = 0; j4 < columns; j4++) {
            var bj = bdata[j4][0] || 0;
            var xj = void 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = mdata[j4][j4];
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              xj = divideScalar2(bj, vjj);
              for (var i5 = j4 + 1; i5 < rows; i5++) {
                bdata[i5] = [subtract2(bdata[i5][0] || 0, multiplyScalar2(xj, mdata[i5][j4]))];
              }
            } else {
              xj = 0;
            }
            x4[j4] = [xj];
          }
          return new DenseMatrix2({
            data: x4,
            size: [rows, 1]
          });
        }
        function _sparseForwardSubstitution(m3, b3) {
          b3 = solveValidation(m3, b3, true);
          var bdata = b3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          var x4 = [];
          for (var j4 = 0; j4 < columns; j4++) {
            var bj = bdata[j4][0] || 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = 0;
              var jValues = [];
              var jIndices = [];
              var firstIndex = ptr[j4];
              var lastIndex = ptr[j4 + 1];
              for (var k4 = firstIndex; k4 < lastIndex; k4++) {
                var i5 = index2[k4];
                if (i5 === j4) {
                  vjj = values[k4];
                } else if (i5 > j4) {
                  jValues.push(values[k4]);
                  jIndices.push(i5);
                }
              }
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              var xj = divideScalar2(bj, vjj);
              for (var _k = 0, l3 = jIndices.length; _k < l3; _k++) {
                var _i = jIndices[_k];
                bdata[_i] = [subtract2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
              }
              x4[j4] = [xj];
            } else {
              x4[j4] = [0];
            }
          }
          return new DenseMatrix2({
            data: x4,
            size: [rows, 1]
          });
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
  var name133, dependencies133, createUsolve;
  var init_usolve = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js"() {
      init_factory();
      init_solveValidation();
      name133 = "usolve";
      dependencies133 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
      createUsolve = /* @__PURE__ */ factory(name133, dependencies133, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var solveValidation = createSolveValidation({
          DenseMatrix: DenseMatrix2
        });
        return typed3(name133, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m3, b3) {
            return _sparseBackwardSubstitution(m3, b3);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m3, b3) {
            return _denseBackwardSubstitution(m3, b3);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a3, b3) {
            var m3 = matrix2(a3);
            var r3 = _denseBackwardSubstitution(m3, b3);
            return r3.valueOf();
          }
        });
        function _denseBackwardSubstitution(m3, b3) {
          b3 = solveValidation(m3, b3, true);
          var bdata = b3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          var x4 = [];
          var mdata = m3._data;
          for (var j4 = columns - 1; j4 >= 0; j4--) {
            var bj = bdata[j4][0] || 0;
            var xj = void 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = mdata[j4][j4];
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              xj = divideScalar2(bj, vjj);
              for (var i5 = j4 - 1; i5 >= 0; i5--) {
                bdata[i5] = [subtract2(bdata[i5][0] || 0, multiplyScalar2(xj, mdata[i5][j4]))];
              }
            } else {
              xj = 0;
            }
            x4[j4] = [xj];
          }
          return new DenseMatrix2({
            data: x4,
            size: [rows, 1]
          });
        }
        function _sparseBackwardSubstitution(m3, b3) {
          b3 = solveValidation(m3, b3, true);
          var bdata = b3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          var x4 = [];
          for (var j4 = columns - 1; j4 >= 0; j4--) {
            var bj = bdata[j4][0] || 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = 0;
              var jValues = [];
              var jIndices = [];
              var firstIndex = ptr[j4];
              var lastIndex = ptr[j4 + 1];
              for (var k4 = lastIndex - 1; k4 >= firstIndex; k4--) {
                var i5 = index2[k4];
                if (i5 === j4) {
                  vjj = values[k4];
                } else if (i5 < j4) {
                  jValues.push(values[k4]);
                  jIndices.push(i5);
                }
              }
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              var xj = divideScalar2(bj, vjj);
              for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
                var _i = jIndices[_k];
                bdata[_i] = [subtract2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
              }
              x4[j4] = [xj];
            } else {
              x4[j4] = [0];
            }
          }
          return new DenseMatrix2({
            data: x4,
            size: [rows, 1]
          });
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
  var name134, dependencies134, createLsolveAll;
  var init_lsolveAll = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js"() {
      init_factory();
      init_solveValidation();
      name134 = "lsolveAll";
      dependencies134 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
      createLsolveAll = /* @__PURE__ */ factory(name134, dependencies134, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var solveValidation = createSolveValidation({
          DenseMatrix: DenseMatrix2
        });
        return typed3(name134, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m3, b3) {
            return _sparseForwardSubstitution(m3, b3);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m3, b3) {
            return _denseForwardSubstitution(m3, b3);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a3, b3) {
            var m3 = matrix2(a3);
            var R2 = _denseForwardSubstitution(m3, b3);
            return R2.map((r3) => r3.valueOf());
          }
        });
        function _denseForwardSubstitution(m3, b_) {
          var B4 = [solveValidation(m3, b_, true)._data.map((e6) => e6[0])];
          var M3 = m3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          for (var i5 = 0; i5 < columns; i5++) {
            var L3 = B4.length;
            for (var k4 = 0; k4 < L3; k4++) {
              var b3 = B4[k4];
              if (!equalScalar2(M3[i5][i5], 0)) {
                b3[i5] = divideScalar2(b3[i5], M3[i5][i5]);
                for (var j4 = i5 + 1; j4 < columns; j4++) {
                  b3[j4] = subtract2(b3[j4], multiplyScalar2(b3[i5], M3[j4][i5]));
                }
              } else if (!equalScalar2(b3[i5], 0)) {
                if (k4 === 0) {
                  return [];
                } else {
                  B4.splice(k4, 1);
                  k4 -= 1;
                  L3 -= 1;
                }
              } else if (k4 === 0) {
                var bNew = [...b3];
                bNew[i5] = 1;
                for (var _j = i5 + 1; _j < columns; _j++) {
                  bNew[_j] = subtract2(bNew[_j], M3[_j][i5]);
                }
                B4.push(bNew);
              }
            }
          }
          return B4.map((x4) => new DenseMatrix2({
            data: x4.map((e6) => [e6]),
            size: [rows, 1]
          }));
        }
        function _sparseForwardSubstitution(m3, b_) {
          var B4 = [solveValidation(m3, b_, true)._data.map((e6) => e6[0])];
          var rows = m3._size[0];
          var columns = m3._size[1];
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          for (var i5 = 0; i5 < columns; i5++) {
            var L3 = B4.length;
            for (var k4 = 0; k4 < L3; k4++) {
              var b3 = B4[k4];
              var iValues = [];
              var iIndices = [];
              var firstIndex = ptr[i5];
              var lastIndex = ptr[i5 + 1];
              var Mii = 0;
              for (var j4 = firstIndex; j4 < lastIndex; j4++) {
                var J2 = index2[j4];
                if (J2 === i5) {
                  Mii = values[j4];
                } else if (J2 > i5) {
                  iValues.push(values[j4]);
                  iIndices.push(J2);
                }
              }
              if (!equalScalar2(Mii, 0)) {
                b3[i5] = divideScalar2(b3[i5], Mii);
                for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                  var _J = iIndices[_j2];
                  b3[_J] = subtract2(b3[_J], multiplyScalar2(b3[i5], iValues[_j2]));
                }
              } else if (!equalScalar2(b3[i5], 0)) {
                if (k4 === 0) {
                  return [];
                } else {
                  B4.splice(k4, 1);
                  k4 -= 1;
                  L3 -= 1;
                }
              } else if (k4 === 0) {
                var bNew = [...b3];
                bNew[i5] = 1;
                for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                  var _J2 = iIndices[_j3];
                  bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
                }
                B4.push(bNew);
              }
            }
          }
          return B4.map((x4) => new DenseMatrix2({
            data: x4.map((e6) => [e6]),
            size: [rows, 1]
          }));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
  var name135, dependencies135, createUsolveAll;
  var init_usolveAll = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js"() {
      init_factory();
      init_solveValidation();
      name135 = "usolveAll";
      dependencies135 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
      createUsolveAll = /* @__PURE__ */ factory(name135, dependencies135, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var solveValidation = createSolveValidation({
          DenseMatrix: DenseMatrix2
        });
        return typed3(name135, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m3, b3) {
            return _sparseBackwardSubstitution(m3, b3);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m3, b3) {
            return _denseBackwardSubstitution(m3, b3);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a3, b3) {
            var m3 = matrix2(a3);
            var R2 = _denseBackwardSubstitution(m3, b3);
            return R2.map((r3) => r3.valueOf());
          }
        });
        function _denseBackwardSubstitution(m3, b_) {
          var B4 = [solveValidation(m3, b_, true)._data.map((e6) => e6[0])];
          var M3 = m3._data;
          var rows = m3._size[0];
          var columns = m3._size[1];
          for (var i5 = columns - 1; i5 >= 0; i5--) {
            var L3 = B4.length;
            for (var k4 = 0; k4 < L3; k4++) {
              var b3 = B4[k4];
              if (!equalScalar2(M3[i5][i5], 0)) {
                b3[i5] = divideScalar2(b3[i5], M3[i5][i5]);
                for (var j4 = i5 - 1; j4 >= 0; j4--) {
                  b3[j4] = subtract2(b3[j4], multiplyScalar2(b3[i5], M3[j4][i5]));
                }
              } else if (!equalScalar2(b3[i5], 0)) {
                if (k4 === 0) {
                  return [];
                } else {
                  B4.splice(k4, 1);
                  k4 -= 1;
                  L3 -= 1;
                }
              } else if (k4 === 0) {
                var bNew = [...b3];
                bNew[i5] = 1;
                for (var _j = i5 - 1; _j >= 0; _j--) {
                  bNew[_j] = subtract2(bNew[_j], M3[_j][i5]);
                }
                B4.push(bNew);
              }
            }
          }
          return B4.map((x4) => new DenseMatrix2({
            data: x4.map((e6) => [e6]),
            size: [rows, 1]
          }));
        }
        function _sparseBackwardSubstitution(m3, b_) {
          var B4 = [solveValidation(m3, b_, true)._data.map((e6) => e6[0])];
          var rows = m3._size[0];
          var columns = m3._size[1];
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          for (var i5 = columns - 1; i5 >= 0; i5--) {
            var L3 = B4.length;
            for (var k4 = 0; k4 < L3; k4++) {
              var b3 = B4[k4];
              var iValues = [];
              var iIndices = [];
              var firstIndex = ptr[i5];
              var lastIndex = ptr[i5 + 1];
              var Mii = 0;
              for (var j4 = lastIndex - 1; j4 >= firstIndex; j4--) {
                var J2 = index2[j4];
                if (J2 === i5) {
                  Mii = values[j4];
                } else if (J2 < i5) {
                  iValues.push(values[j4]);
                  iIndices.push(J2);
                }
              }
              if (!equalScalar2(Mii, 0)) {
                b3[i5] = divideScalar2(b3[i5], Mii);
                for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                  var _J = iIndices[_j2];
                  b3[_J] = subtract2(b3[_J], multiplyScalar2(b3[i5], iValues[_j2]));
                }
              } else if (!equalScalar2(b3[i5], 0)) {
                if (k4 === 0) {
                  return [];
                } else {
                  B4.splice(k4, 1);
                  k4 -= 1;
                  L3 -= 1;
                }
              } else if (k4 === 0) {
                var bNew = [...b3];
                bNew[i5] = 1;
                for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                  var _J2 = iIndices[_j3];
                  bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
                }
                B4.push(bNew);
              }
            }
          }
          return B4.map((x4) => new DenseMatrix2({
            data: x4.map((e6) => [e6]),
            size: [rows, 1]
          }));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
  var name136, dependencies136, createMatAlgo08xS0Sid;
  var init_matAlgo08xS0Sid = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js"() {
      init_factory();
      init_DimensionError();
      name136 = "matAlgo08xS0Sid";
      dependencies136 = ["typed", "equalScalar"];
      createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name136, dependencies136, (_ref) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref;
        return function matAlgo08xS0Sid(a3, b3, callback) {
          var avalues = a3._values;
          var aindex = a3._index;
          var aptr = a3._ptr;
          var asize = a3._size;
          var adt = a3._datatype;
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var bsize = b3._size;
          var bdt = b3._datatype;
          if (asize.length !== bsize.length) {
            throw new DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!avalues || !bvalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrices");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            eq = typed3.find(equalScalar2, [dt, dt]);
            zero = typed3.convert(0, dt);
            cf = typed3.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var x4 = [];
          var w4 = [];
          var k4, k0, k1, i5;
          for (var j4 = 0; j4 < columns; j4++) {
            cptr[j4] = cindex.length;
            var mark = j4 + 1;
            for (k0 = aptr[j4], k1 = aptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = aindex[k4];
              w4[i5] = mark;
              x4[i5] = avalues[k4];
              cindex.push(i5);
            }
            for (k0 = bptr[j4], k1 = bptr[j4 + 1], k4 = k0; k4 < k1; k4++) {
              i5 = bindex[k4];
              if (w4[i5] === mark) {
                x4[i5] = cf(x4[i5], bvalues[k4]);
              }
            }
            k4 = cptr[j4];
            while (k4 < cindex.length) {
              i5 = cindex[k4];
              var v3 = x4[i5];
              if (!eq(v3, zero)) {
                cvalues.push(v3);
                k4++;
              } else {
                cindex.splice(k4, 1);
              }
            }
          }
          cptr[columns] = cindex.length;
          return a3.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
  var createUseMatrixForArrayScalar;
  var init_useMatrixForArrayScalar = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js"() {
      init_factory();
      createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2
        } = _ref;
        return {
          "Array, number": typed3.referTo("DenseMatrix, number", (selfDn) => (x4, y3) => selfDn(matrix2(x4), y3).valueOf()),
          "Array, BigNumber": typed3.referTo("DenseMatrix, BigNumber", (selfDB) => (x4, y3) => selfDB(matrix2(x4), y3).valueOf()),
          "number, Array": typed3.referTo("number, DenseMatrix", (selfnD) => (x4, y3) => selfnD(x4, matrix2(y3)).valueOf()),
          "BigNumber, Array": typed3.referTo("BigNumber, DenseMatrix", (selfBD) => (x4, y3) => selfBD(x4, matrix2(y3)).valueOf())
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
  var name137, dependencies137, createLeftShift;
  var init_leftShift = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/leftShift.js"() {
      init_matAlgo02xDS0();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      init_matAlgo01xDSid();
      init_matAlgo10xSids();
      init_matAlgo08xS0Sid();
      init_factory();
      init_matrixAlgorithmSuite();
      init_useMatrixForArrayScalar();
      init_number2();
      init_bitwise2();
      name137 = "leftShift";
      dependencies137 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      createLeftShift = /* @__PURE__ */ factory(name137, dependencies137, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
          typed: typed3,
          matrix: matrix2
        });
        return typed3(name137, {
          "number, number": leftShiftNumber,
          "BigNumber, BigNumber": leftShiftBigNumber,
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo10xSids(y3, x4, self2, true);
          }),
          "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo14xDs(y3, x4, self2, true);
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
  var name138, dependencies138, createRightArithShift;
  var init_rightArithShift = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js"() {
      init_bitwise2();
      init_matAlgo02xDS0();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      init_matAlgo01xDSid();
      init_matAlgo10xSids();
      init_matAlgo08xS0Sid();
      init_factory();
      init_matrixAlgorithmSuite();
      init_useMatrixForArrayScalar();
      init_number2();
      name138 = "rightArithShift";
      dependencies138 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      createRightArithShift = /* @__PURE__ */ factory(name138, dependencies138, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
          typed: typed3,
          matrix: matrix2
        });
        return typed3(name138, {
          "number, number": rightArithShiftNumber,
          "BigNumber, BigNumber": rightArithShiftBigNumber,
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo10xSids(y3, x4, self2, true);
          }),
          "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo14xDs(y3, x4, self2, true);
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
  var name139, dependencies139, createRightLogShift;
  var init_rightLogShift = __esm({
    "node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js"() {
      init_matAlgo02xDS0();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      init_matAlgo01xDSid();
      init_matAlgo10xSids();
      init_matAlgo08xS0Sid();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      init_useMatrixForArrayScalar();
      name139 = "rightLogShift";
      dependencies139 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      createRightLogShift = /* @__PURE__ */ factory(name139, dependencies139, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
          typed: typed3,
          matrix: matrix2
        });
        return typed3(name139, {
          "number, number": rightLogShiftNumber,
          // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
          "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(y3, 0)) {
              return x4.clone();
            }
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo10xSids(y3, x4, self2, true);
          }),
          "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (equalScalar2(x4, 0)) {
              return zeros3(y3.size(), y3.storage());
            }
            return matAlgo14xDs(y3, x4, self2, true);
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/logical/and.js
  var name140, dependencies140, createAnd;
  var init_and = __esm({
    "node_modules/mathjs/lib/esm/function/logical/and.js"() {
      init_matAlgo02xDS0();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      init_matAlgo06xS0S0();
      init_factory();
      init_matrixAlgorithmSuite();
      init_number2();
      name140 = "and";
      dependencies140 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
      createAnd = /* @__PURE__ */ factory(name140, dependencies140, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros3,
          not: not2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = createMatAlgo06xS0S0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name140, {
          "number, number": andNumber,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            return (x4.re !== 0 || x4.im !== 0) && (y3.re !== 0 || y3.im !== 0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return !x4.isZero() && !y3.isZero() && !x4.isNaN() && !y3.isNaN();
          },
          "Unit, Unit": typed3.referToSelf((self2) => (x4, y3) => self2(x4.value || 0, y3.value || 0)),
          "SparseMatrix, any": typed3.referToSelf((self2) => (x4, y3) => {
            if (not2(y3)) {
              return zeros3(x4.size(), x4.storage());
            }
            return matAlgo11xS0s(x4, y3, self2, false);
          }),
          "DenseMatrix, any": typed3.referToSelf((self2) => (x4, y3) => {
            if (not2(y3)) {
              return zeros3(x4.size(), x4.storage());
            }
            return matAlgo14xDs(x4, y3, self2, false);
          }),
          "any, SparseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (not2(x4)) {
              return zeros3(x4.size(), x4.storage());
            }
            return matAlgo11xS0s(y3, x4, self2, true);
          }),
          "any, DenseMatrix": typed3.referToSelf((self2) => (x4, y3) => {
            if (not2(x4)) {
              return zeros3(x4.size(), x4.storage());
            }
            return matAlgo14xDs(y3, x4, self2, true);
          }),
          "Array, any": typed3.referToSelf((self2) => (x4, y3) => {
            return self2(matrix2(x4), y3).valueOf();
          }),
          "any, Array": typed3.referToSelf((self2) => (x4, y3) => {
            return self2(x4, matrix2(y3)).valueOf();
          })
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/compare.js
  var name141, dependencies141, createCompare, createCompareNumber;
  var init_compare = __esm({
    "node_modules/mathjs/lib/esm/function/relational/compare.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo12xSfs();
      init_matAlgo05xSfSf();
      init_matrixAlgorithmSuite();
      init_compareUnits();
      name141 = "compare";
      dependencies141 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
      createCompare = /* @__PURE__ */ factory(name141, dependencies141, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          equalScalar: equalScalar2,
          matrix: matrix2,
          BigNumber: BigNumber2,
          Fraction: Fraction3,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo05xSfSf = createMatAlgo05xSfSf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name141, createCompareNumber({
          typed: typed3,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x4, y3) {
            return x4 === y3 ? 0 : x4 > y3 ? 1 : -1;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return nearlyEqual2(x4, y3, config4.epsilon) ? new BigNumber2(0) : new BigNumber2(x4.cmp(y3));
          },
          "Fraction, Fraction": function FractionFraction(x4, y3) {
            return new Fraction3(x4.compare(y3));
          },
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createCompareNumber = /* @__PURE__ */ factory(name141, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name141, {
          "number, number": function numberNumber(x4, y3) {
            return nearlyEqual(x4, y3, config4.epsilon) ? 0 : x4 > y3 ? 1 : -1;
          }
        });
      });
    }
  });

  // node_modules/javascript-natural-sort/naturalSort.js
  var require_naturalSort = __commonJS({
    "node_modules/javascript-natural-sort/naturalSort.js"(exports, module) {
      module.exports = function naturalSort2(a3, b3) {
        "use strict";
        var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i5 = function(s3) {
          return naturalSort2.insensitive && ("" + s3).toLowerCase() || "" + s3;
        }, x4 = i5(a3).replace(sre, "") || "", y3 = i5(b3).replace(sre, "") || "", xN = x4.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y3.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x4.match(hre), 16) || xN.length !== 1 && x4.match(dre) && Date.parse(x4), yD = parseInt(y3.match(hre), 16) || xD && y3.match(dre) && Date.parse(y3) || null, oFxNcL, oFyNcL;
        if (yD) {
          if (xD < yD) {
            return -1;
          } else if (xD > yD) {
            return 1;
          }
        }
        for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
          oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
          oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
          if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
            return isNaN(oFxNcL) ? 1 : -1;
          } else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += "";
            oFyNcL += "";
          }
          if (oFxNcL < oFyNcL) {
            return -1;
          }
          if (oFxNcL > oFyNcL) {
            return 1;
          }
        }
        return 0;
      };
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/compareNatural.js
  function compareComplexNumbers(x4, y3) {
    if (x4.re > y3.re) {
      return 1;
    }
    if (x4.re < y3.re) {
      return -1;
    }
    if (x4.im > y3.im) {
      return 1;
    }
    if (x4.im < y3.im) {
      return -1;
    }
    return 0;
  }
  var import_javascript_natural_sort, name142, dependencies142, createCompareNatural;
  var init_compareNatural = __esm({
    "node_modules/mathjs/lib/esm/function/relational/compareNatural.js"() {
      import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
      init_is();
      init_factory();
      name142 = "compareNatural";
      dependencies142 = ["typed", "compare"];
      createCompareNatural = /* @__PURE__ */ factory(name142, dependencies142, (_ref) => {
        var {
          typed: typed3,
          compare: compare3
        } = _ref;
        var compareBooleans = compare3.signatures["boolean,boolean"];
        return typed3(name142, {
          "any, any": _compareNatural
        });
        function _compareNatural(x4, y3) {
          var typeX = typeOf(x4);
          var typeY = typeOf(y3);
          var c3;
          if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
            c3 = compare3(x4, y3);
            if (c3.toString() !== "0") {
              return c3 > 0 ? 1 : -1;
            } else {
              return (0, import_javascript_natural_sort.default)(typeX, typeY);
            }
          }
          var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
          if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
            c3 = compareMatricesAndArrays(_compareNatural, x4, y3);
            if (c3 !== 0) {
              return c3;
            } else {
              return (0, import_javascript_natural_sort.default)(typeX, typeY);
            }
          }
          if (typeX !== typeY) {
            return (0, import_javascript_natural_sort.default)(typeX, typeY);
          }
          if (typeX === "Complex") {
            return compareComplexNumbers(x4, y3);
          }
          if (typeX === "Unit") {
            if (x4.equalBase(y3)) {
              return _compareNatural(x4.value, y3.value);
            }
            return compareArrays(_compareNatural, x4.formatUnits(), y3.formatUnits());
          }
          if (typeX === "boolean") {
            return compareBooleans(x4, y3);
          }
          if (typeX === "string") {
            return (0, import_javascript_natural_sort.default)(x4, y3);
          }
          if (typeX === "Object") {
            return compareObjects(_compareNatural, x4, y3);
          }
          if (typeX === "null") {
            return 0;
          }
          if (typeX === "undefined") {
            return 0;
          }
          throw new TypeError('Unsupported type of value "' + typeX + '"');
        }
        function compareMatricesAndArrays(compareNatural2, x4, y3) {
          if (isSparseMatrix(x4) && isSparseMatrix(y3)) {
            return compareArrays(compareNatural2, x4.toJSON().values, y3.toJSON().values);
          }
          if (isSparseMatrix(x4)) {
            return compareMatricesAndArrays(compareNatural2, x4.toArray(), y3);
          }
          if (isSparseMatrix(y3)) {
            return compareMatricesAndArrays(compareNatural2, x4, y3.toArray());
          }
          if (isDenseMatrix(x4)) {
            return compareMatricesAndArrays(compareNatural2, x4.toJSON().data, y3);
          }
          if (isDenseMatrix(y3)) {
            return compareMatricesAndArrays(compareNatural2, x4, y3.toJSON().data);
          }
          if (!Array.isArray(x4)) {
            return compareMatricesAndArrays(compareNatural2, [x4], y3);
          }
          if (!Array.isArray(y3)) {
            return compareMatricesAndArrays(compareNatural2, x4, [y3]);
          }
          return compareArrays(compareNatural2, x4, y3);
        }
        function compareArrays(compareNatural2, x4, y3) {
          for (var i5 = 0, ii = Math.min(x4.length, y3.length); i5 < ii; i5++) {
            var v3 = compareNatural2(x4[i5], y3[i5]);
            if (v3 !== 0) {
              return v3;
            }
          }
          if (x4.length > y3.length) {
            return 1;
          }
          if (x4.length < y3.length) {
            return -1;
          }
          return 0;
        }
        function compareObjects(compareNatural2, x4, y3) {
          var keysX = Object.keys(x4);
          var keysY = Object.keys(y3);
          keysX.sort(import_javascript_natural_sort.default);
          keysY.sort(import_javascript_natural_sort.default);
          var c3 = compareArrays(compareNatural2, keysX, keysY);
          if (c3 !== 0) {
            return c3;
          }
          for (var i5 = 0; i5 < keysX.length; i5++) {
            var v3 = compareNatural2(x4[keysX[i5]], y3[keysY[i5]]);
            if (v3 !== 0) {
              return v3;
            }
          }
          return 0;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/compareText.js
  var name143, dependencies143, createCompareText;
  var init_compareText = __esm({
    "node_modules/mathjs/lib/esm/function/relational/compareText.js"() {
      init_string();
      init_factory();
      init_matrixAlgorithmSuite();
      name143 = "compareText";
      dependencies143 = ["typed", "matrix", "concat"];
      compareText.signature = "any, any";
      createCompareText = /* @__PURE__ */ factory(name143, dependencies143, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        } = _ref;
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name143, compareText, matrixAlgorithmSuite({
          elop: compareText,
          Ds: true
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/equal.js
  var name144, dependencies144, createEqual, createEqualNumber;
  var init_equal = __esm({
    "node_modules/mathjs/lib/esm/function/relational/equal.js"() {
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name144 = "equal";
      dependencies144 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      createEqual = /* @__PURE__ */ factory(name144, dependencies144, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name144, createEqualNumber({
          typed: typed3,
          equalScalar: equalScalar2
        }), matrixAlgorithmSuite({
          elop: equalScalar2,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createEqualNumber = factory(name144, ["typed", "equalScalar"], (_ref2) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref2;
        return typed3(name144, {
          "any, any": function anyAny(x4, y3) {
            if (x4 === null) {
              return y3 === null;
            }
            if (y3 === null) {
              return x4 === null;
            }
            if (x4 === void 0) {
              return y3 === void 0;
            }
            if (y3 === void 0) {
              return x4 === void 0;
            }
            return equalScalar2(x4, y3);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/equalText.js
  var name145, dependencies145, createEqualText;
  var init_equalText = __esm({
    "node_modules/mathjs/lib/esm/function/relational/equalText.js"() {
      init_factory();
      name145 = "equalText";
      dependencies145 = ["typed", "compareText", "isZero"];
      createEqualText = /* @__PURE__ */ factory(name145, dependencies145, (_ref) => {
        var {
          typed: typed3,
          compareText: compareText3,
          isZero: isZero2
        } = _ref;
        return typed3(name145, {
          "any, any": function anyAny(x4, y3) {
            return isZero2(compareText3(x4, y3));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/smaller.js
  var name146, dependencies146, createSmaller, createSmallerNumber;
  var init_smaller = __esm({
    "node_modules/mathjs/lib/esm/function/relational/smaller.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      init_compareUnits();
      name146 = "smaller";
      dependencies146 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      createSmaller = /* @__PURE__ */ factory(name146, dependencies146, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name146, createSmallerNumber({
          typed: typed3,
          config: config4
        }), {
          "boolean, boolean": (x4, y3) => x4 < y3,
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.lt(y3) && !nearlyEqual2(x4, y3, config4.epsilon);
          },
          "Fraction, Fraction": (x4, y3) => x4.compare(y3) === -1,
          "Complex, Complex": function ComplexComplex(x4, y3) {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createSmallerNumber = /* @__PURE__ */ factory(name146, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name146, {
          "number, number": function numberNumber(x4, y3) {
            return x4 < y3 && !nearlyEqual(x4, y3, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/smallerEq.js
  var name147, dependencies147, createSmallerEq, createSmallerEqNumber;
  var init_smallerEq = __esm({
    "node_modules/mathjs/lib/esm/function/relational/smallerEq.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      init_compareUnits();
      name147 = "smallerEq";
      dependencies147 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      createSmallerEq = /* @__PURE__ */ factory(name147, dependencies147, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name147, createSmallerEqNumber({
          typed: typed3,
          config: config4
        }), {
          "boolean, boolean": (x4, y3) => x4 <= y3,
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.lte(y3) || nearlyEqual2(x4, y3, config4.epsilon);
          },
          "Fraction, Fraction": (x4, y3) => x4.compare(y3) !== 1,
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createSmallerEqNumber = /* @__PURE__ */ factory(name147, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name147, {
          "number, number": function numberNumber(x4, y3) {
            return x4 <= y3 || nearlyEqual(x4, y3, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/larger.js
  var name148, dependencies148, createLarger, createLargerNumber;
  var init_larger = __esm({
    "node_modules/mathjs/lib/esm/function/relational/larger.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      init_compareUnits();
      name148 = "larger";
      dependencies148 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      createLarger = /* @__PURE__ */ factory(name148, dependencies148, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name148, createLargerNumber({
          typed: typed3,
          config: config4
        }), {
          "boolean, boolean": (x4, y3) => x4 > y3,
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.gt(y3) && !nearlyEqual2(x4, y3, config4.epsilon);
          },
          "Fraction, Fraction": (x4, y3) => x4.compare(y3) === 1,
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createLargerNumber = /* @__PURE__ */ factory(name148, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name148, {
          "number, number": function numberNumber(x4, y3) {
            return x4 > y3 && !nearlyEqual(x4, y3, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/largerEq.js
  var name149, dependencies149, createLargerEq, createLargerEqNumber;
  var init_largerEq = __esm({
    "node_modules/mathjs/lib/esm/function/relational/largerEq.js"() {
      init_nearlyEqual();
      init_number();
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      init_compareUnits();
      name149 = "largerEq";
      dependencies149 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      createLargerEq = /* @__PURE__ */ factory(name149, dependencies149, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        var compareUnits = createCompareUnits({
          typed: typed3
        });
        return typed3(name149, createLargerEqNumber({
          typed: typed3,
          config: config4
        }), {
          "boolean, boolean": (x4, y3) => x4 >= y3,
          "BigNumber, BigNumber": function BigNumberBigNumber(x4, y3) {
            return x4.gte(y3) || nearlyEqual2(x4, y3, config4.epsilon);
          },
          "Fraction, Fraction": (x4, y3) => x4.compare(y3) !== -1,
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      createLargerEqNumber = /* @__PURE__ */ factory(name149, ["typed", "config"], (_ref2) => {
        var {
          typed: typed3,
          config: config4
        } = _ref2;
        return typed3(name149, {
          "number, number": function numberNumber(x4, y3) {
            return x4 >= y3 || nearlyEqual(x4, y3, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/deepEqual.js
  var name150, dependencies150, createDeepEqual;
  var init_deepEqual = __esm({
    "node_modules/mathjs/lib/esm/function/relational/deepEqual.js"() {
      init_factory();
      name150 = "deepEqual";
      dependencies150 = ["typed", "equal"];
      createDeepEqual = /* @__PURE__ */ factory(name150, dependencies150, (_ref) => {
        var {
          typed: typed3,
          equal: equal2
        } = _ref;
        return typed3(name150, {
          "any, any": function anyAny(x4, y3) {
            return _deepEqual(x4.valueOf(), y3.valueOf());
          }
        });
        function _deepEqual(x4, y3) {
          if (Array.isArray(x4)) {
            if (Array.isArray(y3)) {
              var len = x4.length;
              if (len !== y3.length) {
                return false;
              }
              for (var i5 = 0; i5 < len; i5++) {
                if (!_deepEqual(x4[i5], y3[i5])) {
                  return false;
                }
              }
              return true;
            } else {
              return false;
            }
          } else {
            if (Array.isArray(y3)) {
              return false;
            } else {
              return equal2(x4, y3);
            }
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/unequal.js
  var name151, dependencies151, createUnequal, createUnequalNumber;
  var init_unequal = __esm({
    "node_modules/mathjs/lib/esm/function/relational/unequal.js"() {
      init_factory();
      init_matAlgo03xDSf();
      init_matAlgo07xSSf();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name151 = "unequal";
      dependencies151 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
      createUnequal = /* @__PURE__ */ factory(name151, dependencies151, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          equalScalar: equalScalar2,
          matrix: matrix2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo07xSSf = createMatAlgo07xSSf({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name151, createUnequalNumber({
          typed: typed3,
          equalScalar: equalScalar2
        }), matrixAlgorithmSuite({
          elop: _unequal,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
        function _unequal(x4, y3) {
          return !equalScalar2(x4, y3);
        }
      });
      createUnequalNumber = factory(name151, ["typed", "equalScalar"], (_ref2) => {
        var {
          typed: typed3,
          equalScalar: equalScalar2
        } = _ref2;
        return typed3(name151, {
          "any, any": function anyAny(x4, y3) {
            if (x4 === null) {
              return y3 !== null;
            }
            if (y3 === null) {
              return x4 !== null;
            }
            if (x4 === void 0) {
              return y3 !== void 0;
            }
            if (y3 === void 0) {
              return x4 !== void 0;
            }
            return !equalScalar2(x4, y3);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
  var name152, dependencies152, createPartitionSelect;
  var init_partitionSelect = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js"() {
      init_is();
      init_number();
      init_factory();
      name152 = "partitionSelect";
      dependencies152 = ["typed", "isNumeric", "isNaN", "compare"];
      createPartitionSelect = /* @__PURE__ */ factory(name152, dependencies152, (_ref) => {
        var {
          typed: typed3,
          isNumeric: isNumeric2,
          isNaN: isNaN3,
          compare: compare3
        } = _ref;
        var asc = compare3;
        var desc = (a3, b3) => -compare3(a3, b3);
        return typed3(name152, {
          "Array | Matrix, number": function ArrayMatrixNumber(x4, k4) {
            return _partitionSelect(x4, k4, asc);
          },
          "Array | Matrix, number, string": function ArrayMatrixNumberString(x4, k4, compare4) {
            if (compare4 === "asc") {
              return _partitionSelect(x4, k4, asc);
            } else if (compare4 === "desc") {
              return _partitionSelect(x4, k4, desc);
            } else {
              throw new Error('Compare string must be "asc" or "desc"');
            }
          },
          "Array | Matrix, number, function": _partitionSelect
        });
        function _partitionSelect(x4, k4, compare4) {
          if (!isInteger(k4) || k4 < 0) {
            throw new Error("k must be a non-negative integer");
          }
          if (isMatrix(x4)) {
            var size2 = x4.size();
            if (size2.length > 1) {
              throw new Error("Only one dimensional matrices supported");
            }
            return quickSelect(x4.valueOf(), k4, compare4);
          }
          if (Array.isArray(x4)) {
            return quickSelect(x4, k4, compare4);
          }
        }
        function quickSelect(arr, k4, compare4) {
          if (k4 >= arr.length) {
            throw new Error("k out of bounds");
          }
          for (var i5 = 0; i5 < arr.length; i5++) {
            if (isNumeric2(arr[i5]) && isNaN3(arr[i5])) {
              return arr[i5];
            }
          }
          var from = 0;
          var to2 = arr.length - 1;
          while (from < to2) {
            var r3 = from;
            var w4 = to2;
            var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
            while (r3 < w4) {
              if (compare4(arr[r3], pivot) >= 0) {
                var tmp = arr[w4];
                arr[w4] = arr[r3];
                arr[r3] = tmp;
                --w4;
              } else {
                ++r3;
              }
            }
            if (compare4(arr[r3], pivot) > 0) {
              --r3;
            }
            if (k4 <= r3) {
              to2 = r3;
            } else {
              from = r3 + 1;
            }
          }
          return arr[k4];
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sort.js
  var name153, dependencies153, createSort;
  var init_sort = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/sort.js"() {
      init_array();
      init_factory();
      name153 = "sort";
      dependencies153 = ["typed", "matrix", "compare", "compareNatural"];
      createSort = /* @__PURE__ */ factory(name153, dependencies153, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          compare: compare3,
          compareNatural: compareNatural2
        } = _ref;
        var compareAsc = compare3;
        var compareDesc = (a3, b3) => -compare3(a3, b3);
        return typed3(name153, {
          Array: function Array2(x4) {
            _arrayIsVector(x4);
            return x4.sort(compareAsc);
          },
          Matrix: function Matrix2(x4) {
            _matrixIsVector(x4);
            return matrix2(x4.toArray().sort(compareAsc), x4.storage());
          },
          "Array, function": function ArrayFunction(x4, _comparator2) {
            _arrayIsVector(x4);
            return x4.sort(_comparator2);
          },
          "Matrix, function": function MatrixFunction(x4, _comparator2) {
            _matrixIsVector(x4);
            return matrix2(x4.toArray().sort(_comparator2), x4.storage());
          },
          "Array, string": function ArrayString(x4, order) {
            _arrayIsVector(x4);
            return x4.sort(_comparator(order));
          },
          "Matrix, string": function MatrixString(x4, order) {
            _matrixIsVector(x4);
            return matrix2(x4.toArray().sort(_comparator(order)), x4.storage());
          }
        });
        function _comparator(order) {
          if (order === "asc") {
            return compareAsc;
          } else if (order === "desc") {
            return compareDesc;
          } else if (order === "natural") {
            return compareNatural2;
          } else {
            throw new Error('String "asc", "desc", or "natural" expected');
          }
        }
        function _arrayIsVector(array) {
          if (arraySize(array).length !== 1) {
            throw new Error("One dimensional array expected");
          }
        }
        function _matrixIsVector(matrix3) {
          if (matrix3.size().length !== 1) {
            throw new Error("One dimensional matrix expected");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/max.js
  var name154, dependencies154, createMax;
  var init_max = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/max.js"() {
      init_collection();
      init_factory();
      init_improveErrorMessage();
      name154 = "max";
      dependencies154 = ["typed", "config", "numeric", "larger"];
      createMax = /* @__PURE__ */ factory(name154, dependencies154, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          numeric: numeric3,
          larger: larger2
        } = _ref;
        return typed3(name154, {
          // max([a, b, c, d, ...])
          "Array | Matrix": _max,
          // max([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return reduce(array, dim.valueOf(), _largest);
          },
          // max(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("Scalar values expected in function max");
            }
            return _max(args);
          }
        });
        function _largest(x4, y3) {
          try {
            return larger2(x4, y3) ? x4 : y3;
          } catch (err) {
            throw improveErrorMessage(err, "max", y3);
          }
        }
        function _max(array) {
          var res;
          deepForEach(array, function(value) {
            try {
              if (isNaN(value) && typeof value === "number") {
                res = NaN;
              } else if (res === void 0 || larger2(value, res)) {
                res = value;
              }
            } catch (err) {
              throw improveErrorMessage(err, "max", value);
            }
          });
          if (res === void 0) {
            throw new Error("Cannot calculate max of an empty array");
          }
          if (typeof res === "string") {
            res = numeric3(res, config4.number);
          }
          return res;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/min.js
  var name155, dependencies155, createMin;
  var init_min = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/min.js"() {
      init_collection();
      init_factory();
      init_improveErrorMessage();
      name155 = "min";
      dependencies155 = ["typed", "config", "numeric", "smaller"];
      createMin = /* @__PURE__ */ factory(name155, dependencies155, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          numeric: numeric3,
          smaller: smaller2
        } = _ref;
        return typed3(name155, {
          // min([a, b, c, d, ...])
          "Array | Matrix": _min,
          // min([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return reduce(array, dim.valueOf(), _smallest);
          },
          // min(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("Scalar values expected in function min");
            }
            return _min(args);
          }
        });
        function _smallest(x4, y3) {
          try {
            return smaller2(x4, y3) ? x4 : y3;
          } catch (err) {
            throw improveErrorMessage(err, "min", y3);
          }
        }
        function _min(array) {
          var min3;
          deepForEach(array, function(value) {
            try {
              if (isNaN(value) && typeof value === "number") {
                min3 = NaN;
              } else if (min3 === void 0 || smaller2(value, min3)) {
                min3 = value;
              }
            } catch (err) {
              throw improveErrorMessage(err, "min", value);
            }
          });
          if (min3 === void 0) {
            throw new Error("Cannot calculate min of an empty array");
          }
          if (typeof min3 === "string") {
            min3 = numeric3(min3, config4.number);
          }
          return min3;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
  var name156, dependencies156, createImmutableDenseMatrixClass;
  var init_ImmutableDenseMatrix = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js"() {
      init_is();
      init_object();
      init_factory();
      name156 = "ImmutableDenseMatrix";
      dependencies156 = ["smaller", "DenseMatrix"];
      createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name156, dependencies156, (_ref) => {
        var {
          smaller: smaller2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        function ImmutableDenseMatrix2(data, datatype) {
          if (!(this instanceof ImmutableDenseMatrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !isString(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if (isMatrix(data) || isArray(data)) {
            var matrix2 = new DenseMatrix2(data, datatype);
            this._data = matrix2._data;
            this._size = matrix2._size;
            this._datatype = matrix2._datatype;
            this._min = null;
            this._max = null;
          } else if (data && isArray(data.data) && isArray(data.size)) {
            this._data = data.data;
            this._size = data.size;
            this._datatype = data.datatype;
            this._min = typeof data.min !== "undefined" ? data.min : null;
            this._max = typeof data.max !== "undefined" ? data.max : null;
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
          } else {
            this._data = [];
            this._size = [0];
            this._datatype = datatype;
            this._min = null;
            this._max = null;
          }
        }
        ImmutableDenseMatrix2.prototype = new DenseMatrix2();
        ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
        ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
        ImmutableDenseMatrix2.prototype.subset = function(index2) {
          switch (arguments.length) {
            case 1: {
              var m3 = DenseMatrix2.prototype.subset.call(this, index2);
              if (isMatrix(m3)) {
                return new ImmutableDenseMatrix2({
                  data: m3._data,
                  size: m3._size,
                  datatype: m3._datatype
                });
              }
              return m3;
            }
            case 2:
            case 3:
              throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        ImmutableDenseMatrix2.prototype.set = function() {
          throw new Error("Cannot invoke set on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix2.prototype.resize = function() {
          throw new Error("Cannot invoke resize on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix2.prototype.reshape = function() {
          throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix2.prototype.clone = function() {
          return new ImmutableDenseMatrix2({
            data: clone(this._data),
            size: clone(this._size),
            datatype: this._datatype
          });
        };
        ImmutableDenseMatrix2.prototype.toJSON = function() {
          return {
            mathjs: "ImmutableDenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype
          };
        };
        ImmutableDenseMatrix2.fromJSON = function(json) {
          return new ImmutableDenseMatrix2(json);
        };
        ImmutableDenseMatrix2.prototype.swapRows = function() {
          throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix2.prototype.min = function() {
          if (this._min === null) {
            var m3 = null;
            this.forEach(function(v3) {
              if (m3 === null || smaller2(v3, m3)) {
                m3 = v3;
              }
            });
            this._min = m3 !== null ? m3 : void 0;
          }
          return this._min;
        };
        ImmutableDenseMatrix2.prototype.max = function() {
          if (this._max === null) {
            var m3 = null;
            this.forEach(function(v3) {
              if (m3 === null || smaller2(m3, v3)) {
                m3 = v3;
              }
            });
            this._max = m3 !== null ? m3 : void 0;
          }
          return this._max;
        };
        return ImmutableDenseMatrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
  function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
    var indexOfNumbers = [];
    booleanArrayIndex.forEach((bool, idx) => {
      if (bool) {
        indexOfNumbers.push(idx);
      }
    });
    return indexOfNumbers;
  }
  var name157, dependencies157, createIndexClass;
  var init_MatrixIndex = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js"() {
      init_is();
      init_object();
      init_number();
      init_factory();
      name157 = "Index";
      dependencies157 = ["ImmutableDenseMatrix", "getMatrixDataType"];
      createIndexClass = /* @__PURE__ */ factory(name157, dependencies157, (_ref) => {
        var {
          ImmutableDenseMatrix: ImmutableDenseMatrix2,
          getMatrixDataType: getMatrixDataType2
        } = _ref;
        function Index2(ranges) {
          if (!(this instanceof Index2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._dimensions = [];
          this._sourceSize = [];
          this._isScalar = true;
          for (var i5 = 0, ii = arguments.length; i5 < ii; i5++) {
            var arg2 = arguments[i5];
            var argIsArray = isArray(arg2);
            var argIsMatrix = isMatrix(arg2);
            var sourceSize = null;
            if (isRange(arg2)) {
              this._dimensions.push(arg2);
              this._isScalar = false;
            } else if (argIsArray || argIsMatrix) {
              var m3 = void 0;
              if (getMatrixDataType2(arg2) === "boolean") {
                if (argIsArray)
                  m3 = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2).valueOf());
                if (argIsMatrix)
                  m3 = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2._data).valueOf());
                sourceSize = arg2.valueOf().length;
              } else {
                m3 = _createImmutableMatrix(arg2.valueOf());
              }
              this._dimensions.push(m3);
              var size2 = m3.size();
              if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
                this._isScalar = false;
              }
            } else if (typeof arg2 === "number") {
              this._dimensions.push(_createImmutableMatrix([arg2]));
            } else if (typeof arg2 === "string") {
              this._dimensions.push(arg2);
            } else {
              throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
            }
            this._sourceSize.push(sourceSize);
          }
        }
        Index2.prototype.type = "Index";
        Index2.prototype.isIndex = true;
        function _createImmutableMatrix(arg2) {
          for (var i5 = 0, l3 = arg2.length; i5 < l3; i5++) {
            if (typeof arg2[i5] !== "number" || !isInteger(arg2[i5])) {
              throw new TypeError("Index parameters must be positive integer numbers");
            }
          }
          return new ImmutableDenseMatrix2(arg2);
        }
        Index2.prototype.clone = function() {
          var index2 = new Index2();
          index2._dimensions = clone(this._dimensions);
          index2._isScalar = this._isScalar;
          index2._sourceSize = this._sourceSize;
          return index2;
        };
        Index2.create = function(ranges) {
          var index2 = new Index2();
          Index2.apply(index2, ranges);
          return index2;
        };
        Index2.prototype.size = function() {
          var size2 = [];
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            var d3 = this._dimensions[i5];
            size2[i5] = typeof d3 === "string" ? 1 : d3.size()[0];
          }
          return size2;
        };
        Index2.prototype.max = function() {
          var values = [];
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            var range2 = this._dimensions[i5];
            values[i5] = typeof range2 === "string" ? range2 : range2.max();
          }
          return values;
        };
        Index2.prototype.min = function() {
          var values = [];
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            var range2 = this._dimensions[i5];
            values[i5] = typeof range2 === "string" ? range2 : range2.min();
          }
          return values;
        };
        Index2.prototype.forEach = function(callback) {
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            callback(this._dimensions[i5], i5, this);
          }
        };
        Index2.prototype.dimension = function(dim) {
          return this._dimensions[dim] || null;
        };
        Index2.prototype.isObjectProperty = function() {
          return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
        };
        Index2.prototype.getObjectProperty = function() {
          return this.isObjectProperty() ? this._dimensions[0] : null;
        };
        Index2.prototype.isScalar = function() {
          return this._isScalar;
        };
        Index2.prototype.toArray = function() {
          var array = [];
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            var dimension = this._dimensions[i5];
            array.push(typeof dimension === "string" ? dimension : dimension.toArray());
          }
          return array;
        };
        Index2.prototype.valueOf = Index2.prototype.toArray;
        Index2.prototype.toString = function() {
          var strings = [];
          for (var i5 = 0, ii = this._dimensions.length; i5 < ii; i5++) {
            var dimension = this._dimensions[i5];
            if (typeof dimension === "string") {
              strings.push(JSON.stringify(dimension));
            } else {
              strings.push(dimension.toString());
            }
          }
          return "[" + strings.join(", ") + "]";
        };
        Index2.prototype.toJSON = function() {
          return {
            mathjs: "Index",
            dimensions: this._dimensions
          };
        };
        Index2.fromJSON = function(json) {
          return Index2.create(json.dimensions);
        };
        return Index2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
  var name158, dependencies158, createFibonacciHeapClass;
  var init_FibonacciHeap = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js"() {
      init_factory();
      name158 = "FibonacciHeap";
      dependencies158 = ["smaller", "larger"];
      createFibonacciHeapClass = /* @__PURE__ */ factory(name158, dependencies158, (_ref) => {
        var {
          smaller: smaller2,
          larger: larger2
        } = _ref;
        var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
        function FibonacciHeap2() {
          if (!(this instanceof FibonacciHeap2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._minimum = null;
          this._size = 0;
        }
        FibonacciHeap2.prototype.type = "FibonacciHeap";
        FibonacciHeap2.prototype.isFibonacciHeap = true;
        FibonacciHeap2.prototype.insert = function(key, value) {
          var node = {
            key,
            value,
            degree: 0
          };
          if (this._minimum) {
            var minimum = this._minimum;
            node.left = minimum;
            node.right = minimum.right;
            minimum.right = node;
            node.right.left = node;
            if (smaller2(key, minimum.key)) {
              this._minimum = node;
            }
          } else {
            node.left = node;
            node.right = node;
            this._minimum = node;
          }
          this._size++;
          return node;
        };
        FibonacciHeap2.prototype.size = function() {
          return this._size;
        };
        FibonacciHeap2.prototype.clear = function() {
          this._minimum = null;
          this._size = 0;
        };
        FibonacciHeap2.prototype.isEmpty = function() {
          return this._size === 0;
        };
        FibonacciHeap2.prototype.extractMinimum = function() {
          var node = this._minimum;
          if (node === null) {
            return node;
          }
          var minimum = this._minimum;
          var numberOfChildren = node.degree;
          var x4 = node.child;
          while (numberOfChildren > 0) {
            var tempRight = x4.right;
            x4.left.right = x4.right;
            x4.right.left = x4.left;
            x4.left = minimum;
            x4.right = minimum.right;
            minimum.right = x4;
            x4.right.left = x4;
            x4.parent = null;
            x4 = tempRight;
            numberOfChildren--;
          }
          node.left.right = node.right;
          node.right.left = node.left;
          if (node === node.right) {
            minimum = null;
          } else {
            minimum = node.right;
            minimum = _findMinimumNode(minimum, this._size);
          }
          this._size--;
          this._minimum = minimum;
          return node;
        };
        FibonacciHeap2.prototype.remove = function(node) {
          this._minimum = _decreaseKey(this._minimum, node, -1);
          this.extractMinimum();
        };
        function _decreaseKey(minimum, node, key) {
          node.key = key;
          var parent = node.parent;
          if (parent && smaller2(node.key, parent.key)) {
            _cut(minimum, node, parent);
            _cascadingCut(minimum, parent);
          }
          if (smaller2(node.key, minimum.key)) {
            minimum = node;
          }
          return minimum;
        }
        function _cut(minimum, node, parent) {
          node.left.right = node.right;
          node.right.left = node.left;
          parent.degree--;
          if (parent.child === node) {
            parent.child = node.right;
          }
          if (parent.degree === 0) {
            parent.child = null;
          }
          node.left = minimum;
          node.right = minimum.right;
          minimum.right = node;
          node.right.left = node;
          node.parent = null;
          node.mark = false;
        }
        function _cascadingCut(minimum, node) {
          var parent = node.parent;
          if (!parent) {
            return;
          }
          if (!node.mark) {
            node.mark = true;
          } else {
            _cut(minimum, node, parent);
            _cascadingCut(parent);
          }
        }
        var _linkNodes = function _linkNodes2(node, parent) {
          node.left.right = node.right;
          node.right.left = node.left;
          node.parent = parent;
          if (!parent.child) {
            parent.child = node;
            node.right = node;
            node.left = node;
          } else {
            node.left = parent.child;
            node.right = parent.child.right;
            parent.child.right = node;
            node.right.left = node;
          }
          parent.degree++;
          node.mark = false;
        };
        function _findMinimumNode(minimum, size2) {
          var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
          var array = new Array(arraySize2);
          var numRoots = 0;
          var x4 = minimum;
          if (x4) {
            numRoots++;
            x4 = x4.right;
            while (x4 !== minimum) {
              numRoots++;
              x4 = x4.right;
            }
          }
          var y3;
          while (numRoots > 0) {
            var d3 = x4.degree;
            var next = x4.right;
            while (true) {
              y3 = array[d3];
              if (!y3) {
                break;
              }
              if (larger2(x4.key, y3.key)) {
                var temp = y3;
                y3 = x4;
                x4 = temp;
              }
              _linkNodes(y3, x4);
              array[d3] = null;
              d3++;
            }
            array[d3] = x4;
            x4 = next;
            numRoots--;
          }
          minimum = null;
          for (var i5 = 0; i5 < arraySize2; i5++) {
            y3 = array[i5];
            if (!y3) {
              continue;
            }
            if (minimum) {
              y3.left.right = y3.right;
              y3.right.left = y3.left;
              y3.left = minimum;
              y3.right = minimum.right;
              minimum.right = y3;
              y3.right.left = y3;
              if (smaller2(y3.key, minimum.key)) {
                minimum = y3;
              }
            } else {
              minimum = y3;
            }
          }
          return minimum;
        }
        return FibonacciHeap2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/Spa.js
  var name159, dependencies159, createSpaClass;
  var init_Spa = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/Spa.js"() {
      init_factory();
      name159 = "Spa";
      dependencies159 = ["addScalar", "equalScalar", "FibonacciHeap"];
      createSpaClass = /* @__PURE__ */ factory(name159, dependencies159, (_ref) => {
        var {
          addScalar: addScalar2,
          equalScalar: equalScalar2,
          FibonacciHeap: FibonacciHeap2
        } = _ref;
        function Spa2() {
          if (!(this instanceof Spa2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._values = [];
          this._heap = new FibonacciHeap2();
        }
        Spa2.prototype.type = "Spa";
        Spa2.prototype.isSpa = true;
        Spa2.prototype.set = function(i5, v3) {
          if (!this._values[i5]) {
            var node = this._heap.insert(i5, v3);
            this._values[i5] = node;
          } else {
            this._values[i5].value = v3;
          }
        };
        Spa2.prototype.get = function(i5) {
          var node = this._values[i5];
          if (node) {
            return node.value;
          }
          return 0;
        };
        Spa2.prototype.accumulate = function(i5, v3) {
          var node = this._values[i5];
          if (!node) {
            node = this._heap.insert(i5, v3);
            this._values[i5] = node;
          } else {
            node.value = addScalar2(node.value, v3);
          }
        };
        Spa2.prototype.forEach = function(from, to2, callback) {
          var heap = this._heap;
          var values = this._values;
          var nodes = [];
          var node = heap.extractMinimum();
          if (node) {
            nodes.push(node);
          }
          while (node && node.key <= to2) {
            if (node.key >= from) {
              if (!equalScalar2(node.value, 0)) {
                callback(node.key, node.value, this);
              }
            }
            node = heap.extractMinimum();
            if (node) {
              nodes.push(node);
            }
          }
          for (var i5 = 0; i5 < nodes.length; i5++) {
            var n3 = nodes[i5];
            node = heap.insert(n3.key, n3.value);
            values[node.key] = node;
          }
        };
        Spa2.prototype.swap = function(i5, j4) {
          var nodei = this._values[i5];
          var nodej = this._values[j4];
          if (!nodei && nodej) {
            nodei = this._heap.insert(i5, nodej.value);
            this._heap.remove(nodej);
            this._values[i5] = nodei;
            this._values[j4] = void 0;
          } else if (nodei && !nodej) {
            nodej = this._heap.insert(j4, nodei.value);
            this._heap.remove(nodei);
            this._values[j4] = nodej;
            this._values[i5] = void 0;
          } else if (nodei && nodej) {
            var v3 = nodei.value;
            nodei.value = nodej.value;
            nodej.value = v3;
          }
        };
        return Spa2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/constants.js
  function hasher(args) {
    return args[0].precision;
  }
  var createBigNumberE, createBigNumberPhi, createBigNumberPi, createBigNumberTau;
  var init_constants2 = __esm({
    "node_modules/mathjs/lib/esm/utils/bignumber/constants.js"() {
      init_function();
      createBigNumberE = memoize(function(BigNumber2) {
        return new BigNumber2(1).exp();
      }, {
        hasher
      });
      createBigNumberPhi = memoize(function(BigNumber2) {
        return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
      }, {
        hasher
      });
      createBigNumberPi = memoize(function(BigNumber2) {
        return BigNumber2.acos(-1);
      }, {
        hasher
      });
      createBigNumberTau = memoize(function(BigNumber2) {
        return createBigNumberPi(BigNumber2).times(2);
      }, {
        hasher
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/Unit.js
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = null != arguments[i5] ? arguments[i5] : {};
      i5 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var name160, dependencies160, createUnitClass;
  var init_Unit = __esm({
    "node_modules/mathjs/lib/esm/type/unit/Unit.js"() {
      init_defineProperty();
      init_extends();
      init_is();
      init_factory();
      init_function();
      init_string();
      init_object();
      init_constants2();
      name160 = "Unit";
      dependencies160 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
      createUnitClass = /* @__PURE__ */ factory(name160, dependencies160, (_ref) => {
        var {
          on: on2,
          config: config4,
          addScalar: addScalar2,
          subtract: subtract2,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          pow: pow3,
          abs: abs3,
          fix: fix2,
          round: round3,
          equal: equal2,
          isNumeric: isNumeric2,
          format: format5,
          number: _number,
          Complex: Complex3,
          BigNumber: _BigNumber,
          Fraction: _Fraction
        } = _ref;
        var toNumber = _number;
        function Unit2(value, valuelessUnit) {
          if (!(this instanceof Unit2)) {
            throw new Error("Constructor must be called with the new operator");
          }
          if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
            throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
          }
          this.fixPrefix = false;
          this.skipAutomaticSimplification = true;
          if (valuelessUnit === void 0) {
            this.units = [];
            this.dimensions = BASE_DIMENSIONS.map((x4) => 0);
          } else if (typeof valuelessUnit === "string") {
            var u3 = Unit2.parse(valuelessUnit);
            this.units = u3.units;
            this.dimensions = u3.dimensions;
          } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
            this.fixPrefix = valuelessUnit.fixPrefix;
            this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
            this.dimensions = valuelessUnit.dimensions.slice(0);
            this.units = valuelessUnit.units.map((u4) => _extends({}, u4));
          } else {
            throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
          }
          this.value = this._normalize(value);
        }
        Object.defineProperty(Unit2, "name", {
          value: "Unit"
        });
        Unit2.prototype.constructor = Unit2;
        Unit2.prototype.type = "Unit";
        Unit2.prototype.isUnit = true;
        var text, index2, c3;
        function skipWhitespace() {
          while (c3 === " " || c3 === "	") {
            next();
          }
        }
        function isDigitDot(c4) {
          return c4 >= "0" && c4 <= "9" || c4 === ".";
        }
        function isDigit(c4) {
          return c4 >= "0" && c4 <= "9";
        }
        function next() {
          index2++;
          c3 = text.charAt(index2);
        }
        function revert(oldIndex) {
          index2 = oldIndex;
          c3 = text.charAt(index2);
        }
        function parseNumber() {
          var number2 = "";
          var oldIndex = index2;
          if (c3 === "+") {
            next();
          } else if (c3 === "-") {
            number2 += c3;
            next();
          }
          if (!isDigitDot(c3)) {
            revert(oldIndex);
            return null;
          }
          if (c3 === ".") {
            number2 += c3;
            next();
            if (!isDigit(c3)) {
              revert(oldIndex);
              return null;
            }
          } else {
            while (isDigit(c3)) {
              number2 += c3;
              next();
            }
            if (c3 === ".") {
              number2 += c3;
              next();
            }
          }
          while (isDigit(c3)) {
            number2 += c3;
            next();
          }
          if (c3 === "E" || c3 === "e") {
            var tentativeNumber = "";
            var tentativeIndex = index2;
            tentativeNumber += c3;
            next();
            if (c3 === "+" || c3 === "-") {
              tentativeNumber += c3;
              next();
            }
            if (!isDigit(c3)) {
              revert(tentativeIndex);
              return number2;
            }
            number2 = number2 + tentativeNumber;
            while (isDigit(c3)) {
              number2 += c3;
              next();
            }
          }
          return number2;
        }
        function parseUnit() {
          var unitName = "";
          while (isDigit(c3) || Unit2.isValidAlpha(c3)) {
            unitName += c3;
            next();
          }
          var firstC = unitName.charAt(0);
          if (Unit2.isValidAlpha(firstC)) {
            return unitName;
          } else {
            return null;
          }
        }
        function parseCharacter(toFind) {
          if (c3 === toFind) {
            next();
            return toFind;
          } else {
            return null;
          }
        }
        Unit2.parse = function(str, options) {
          options = options || {};
          text = str;
          index2 = -1;
          c3 = "";
          if (typeof text !== "string") {
            throw new TypeError("Invalid argument in Unit.parse, string expected");
          }
          var unit3 = new Unit2();
          unit3.units = [];
          var powerMultiplierCurrent = 1;
          var expectingUnit = false;
          next();
          skipWhitespace();
          var valueStr = parseNumber();
          var value = null;
          if (valueStr) {
            if (config4.number === "BigNumber") {
              value = new _BigNumber(valueStr);
            } else if (config4.number === "Fraction") {
              try {
                value = new _Fraction(valueStr);
              } catch (err) {
                value = parseFloat(valueStr);
              }
            } else {
              value = parseFloat(valueStr);
            }
            skipWhitespace();
            if (parseCharacter("*")) {
              powerMultiplierCurrent = 1;
              expectingUnit = true;
            } else if (parseCharacter("/")) {
              powerMultiplierCurrent = -1;
              expectingUnit = true;
            }
          }
          var powerMultiplierStack = [];
          var powerMultiplierStackProduct = 1;
          while (true) {
            skipWhitespace();
            while (c3 === "(") {
              powerMultiplierStack.push(powerMultiplierCurrent);
              powerMultiplierStackProduct *= powerMultiplierCurrent;
              powerMultiplierCurrent = 1;
              next();
              skipWhitespace();
            }
            var uStr = void 0;
            if (c3) {
              var oldC = c3;
              uStr = parseUnit();
              if (uStr === null) {
                throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
              }
            } else {
              break;
            }
            var res = _findUnit(uStr);
            if (res === null) {
              throw new SyntaxError('Unit "' + uStr + '" not found.');
            }
            var power = powerMultiplierCurrent * powerMultiplierStackProduct;
            skipWhitespace();
            if (parseCharacter("^")) {
              skipWhitespace();
              var p3 = parseNumber();
              if (p3 === null) {
                throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
              }
              power *= p3;
            }
            unit3.units.push({
              unit: res.unit,
              prefix: res.prefix,
              power
            });
            for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
              unit3.dimensions[i5] += (res.unit.dimensions[i5] || 0) * power;
            }
            skipWhitespace();
            while (c3 === ")") {
              if (powerMultiplierStack.length === 0) {
                throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
              }
              powerMultiplierStackProduct /= powerMultiplierStack.pop();
              next();
              skipWhitespace();
            }
            expectingUnit = false;
            if (parseCharacter("*")) {
              powerMultiplierCurrent = 1;
              expectingUnit = true;
            } else if (parseCharacter("/")) {
              powerMultiplierCurrent = -1;
              expectingUnit = true;
            } else {
              powerMultiplierCurrent = 1;
            }
            if (res.unit.base) {
              var baseDim = res.unit.base.key;
              UNIT_SYSTEMS.auto[baseDim] = {
                unit: res.unit,
                prefix: res.prefix
              };
            }
          }
          skipWhitespace();
          if (c3) {
            throw new SyntaxError('Could not parse: "' + str + '"');
          }
          if (expectingUnit) {
            throw new SyntaxError('Trailing characters: "' + str + '"');
          }
          if (powerMultiplierStack.length !== 0) {
            throw new SyntaxError('Unmatched "(" in "' + text + '"');
          }
          if (unit3.units.length === 0 && !options.allowNoUnits) {
            throw new SyntaxError('"' + str + '" contains no units');
          }
          unit3.value = value !== void 0 ? unit3._normalize(value) : null;
          return unit3;
        };
        Unit2.prototype.clone = function() {
          var unit3 = new Unit2();
          unit3.fixPrefix = this.fixPrefix;
          unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
          unit3.value = clone(this.value);
          unit3.dimensions = this.dimensions.slice(0);
          unit3.units = [];
          for (var i5 = 0; i5 < this.units.length; i5++) {
            unit3.units[i5] = {};
            for (var p3 in this.units[i5]) {
              if (hasOwnProperty2(this.units[i5], p3)) {
                unit3.units[i5][p3] = this.units[i5][p3];
              }
            }
          }
          return unit3;
        };
        Unit2.prototype.valueType = function() {
          return typeOf(this.value);
        };
        Unit2.prototype._isDerived = function() {
          if (this.units.length === 0) {
            return false;
          }
          return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
        };
        Unit2.prototype._normalize = function(value) {
          if (value === null || value === void 0 || this.units.length === 0) {
            return value;
          }
          var res = value;
          var convert = Unit2._getNumberConverter(typeOf(value));
          for (var i5 = 0; i5 < this.units.length; i5++) {
            var unitValue = convert(this.units[i5].unit.value);
            var unitPrefixValue = convert(this.units[i5].prefix.value);
            var unitPower = convert(this.units[i5].power);
            res = multiplyScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
          }
          return res;
        };
        Unit2.prototype._denormalize = function(value, prefixValue) {
          if (value === null || value === void 0 || this.units.length === 0) {
            return value;
          }
          var res = value;
          var convert = Unit2._getNumberConverter(typeOf(value));
          for (var i5 = 0; i5 < this.units.length; i5++) {
            var unitValue = convert(this.units[i5].unit.value);
            var unitPrefixValue = convert(this.units[i5].prefix.value);
            var unitPower = convert(this.units[i5].power);
            res = divideScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
          }
          return res;
        };
        var _findUnit = memoize((str) => {
          if (hasOwnProperty2(UNITS, str)) {
            var unit3 = UNITS[str];
            var prefix = unit3.prefixes[""];
            return {
              unit: unit3,
              prefix
            };
          }
          for (var _name in UNITS) {
            if (hasOwnProperty2(UNITS, _name)) {
              if (endsWith(str, _name)) {
                var _unit = UNITS[_name];
                var prefixLen = str.length - _name.length;
                var prefixName = str.substring(0, prefixLen);
                var _prefix = hasOwnProperty2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
                if (_prefix !== void 0) {
                  return {
                    unit: _unit,
                    prefix: _prefix
                  };
                }
              }
            }
          }
          return null;
        }, {
          hasher: (args) => args[0],
          limit: 100
        });
        Unit2.isValuelessUnit = function(name307) {
          return _findUnit(name307) !== null;
        };
        Unit2.prototype.hasBase = function(base) {
          if (typeof base === "string") {
            base = BASE_UNITS[base];
          }
          if (!base) {
            return false;
          }
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            if (Math.abs((this.dimensions[i5] || 0) - (base.dimensions[i5] || 0)) > 1e-12) {
              return false;
            }
          }
          return true;
        };
        Unit2.prototype.equalBase = function(other) {
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            if (Math.abs((this.dimensions[i5] || 0) - (other.dimensions[i5] || 0)) > 1e-12) {
              return false;
            }
          }
          return true;
        };
        Unit2.prototype.equals = function(other) {
          return this.equalBase(other) && equal2(this.value, other.value);
        };
        Unit2.prototype.multiply = function(_other) {
          var res = this.clone();
          var other = isUnit(_other) ? _other : new Unit2(_other);
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            res.dimensions[i5] = (this.dimensions[i5] || 0) + (other.dimensions[i5] || 0);
          }
          for (var _i = 0; _i < other.units.length; _i++) {
            var inverted = _objectSpread2({}, other.units[_i]);
            res.units.push(inverted);
          }
          if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(1) : this.value;
            var valOther = other.value === null ? other._normalize(1) : other.value;
            res.value = multiplyScalar2(valThis, valOther);
          } else {
            res.value = null;
          }
          if (isUnit(_other)) {
            res.skipAutomaticSimplification = false;
          }
          return getNumericIfUnitless(res);
        };
        Unit2.prototype.divideInto = function(numerator) {
          return new Unit2(numerator).divide(this);
        };
        Unit2.prototype.divide = function(_other) {
          var res = this.clone();
          var other = isUnit(_other) ? _other : new Unit2(_other);
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            res.dimensions[i5] = (this.dimensions[i5] || 0) - (other.dimensions[i5] || 0);
          }
          for (var _i2 = 0; _i2 < other.units.length; _i2++) {
            var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
              power: -other.units[_i2].power
            });
            res.units.push(inverted);
          }
          if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(1) : this.value;
            var valOther = other.value === null ? other._normalize(1) : other.value;
            res.value = divideScalar2(valThis, valOther);
          } else {
            res.value = null;
          }
          if (isUnit(_other)) {
            res.skipAutomaticSimplification = false;
          }
          return getNumericIfUnitless(res);
        };
        Unit2.prototype.pow = function(p3) {
          var res = this.clone();
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            res.dimensions[i5] = (this.dimensions[i5] || 0) * p3;
          }
          for (var _i3 = 0; _i3 < res.units.length; _i3++) {
            res.units[_i3].power *= p3;
          }
          if (res.value !== null) {
            res.value = pow3(res.value, p3);
          } else {
            res.value = null;
          }
          res.skipAutomaticSimplification = false;
          return getNumericIfUnitless(res);
        };
        function getNumericIfUnitless(unit3) {
          if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config4.predictable) {
            return unit3.value;
          } else {
            return unit3;
          }
        }
        Unit2.prototype.abs = function() {
          var ret = this.clone();
          if (ret.value !== null) {
            if (ret._isDerived() || ret.units[0].unit.offset === 0) {
              ret.value = abs3(ret.value);
            } else {
              var convert = ret._numberConverter();
              var unitValue = convert(ret.units[0].unit.value);
              var nominalOffset = convert(ret.units[0].unit.offset);
              var unitOffset = multiplyScalar2(unitValue, nominalOffset);
              ret.value = subtract2(abs3(addScalar2(ret.value, unitOffset)), unitOffset);
            }
          }
          for (var i5 in ret.units) {
            if (ret.units[i5].unit.name === "VA" || ret.units[i5].unit.name === "VAR") {
              ret.units[i5].unit = UNITS.W;
            }
          }
          return ret;
        };
        Unit2.prototype.to = function(valuelessUnit) {
          var value = this.value === null ? this._normalize(1) : this.value;
          var other;
          if (typeof valuelessUnit === "string") {
            other = Unit2.parse(valuelessUnit);
          } else if (isUnit(valuelessUnit)) {
            other = valuelessUnit.clone();
          } else {
            throw new Error("String or Unit expected as parameter");
          }
          if (!this.equalBase(other)) {
            throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
          }
          if (other.value !== null) {
            throw new Error("Cannot convert to a unit with a value");
          }
          if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
            other.value = clone(value);
          } else {
            var convert = Unit2._getNumberConverter(typeOf(value));
            var thisUnitValue = this.units[0].unit.value;
            var thisNominalOffset = this.units[0].unit.offset;
            var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
            var otherUnitValue = other.units[0].unit.value;
            var otherNominalOffset = other.units[0].unit.offset;
            var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
            other.value = addScalar2(value, convert(subtract2(thisUnitOffset, otherUnitOffset)));
          }
          other.fixPrefix = true;
          other.skipAutomaticSimplification = true;
          return other;
        };
        Unit2.prototype.toNumber = function(valuelessUnit) {
          return toNumber(this.toNumeric(valuelessUnit));
        };
        Unit2.prototype.toNumeric = function(valuelessUnit) {
          var other;
          if (valuelessUnit) {
            other = this.to(valuelessUnit);
          } else {
            other = this.clone();
          }
          if (other._isDerived() || other.units.length === 0) {
            return other._denormalize(other.value);
          } else {
            return other._denormalize(other.value, other.units[0].prefix.value);
          }
        };
        Unit2.prototype.toString = function() {
          return this.format();
        };
        Unit2.prototype.toJSON = function() {
          return {
            mathjs: "Unit",
            value: this._denormalize(this.value),
            unit: this.formatUnits(),
            fixPrefix: this.fixPrefix
          };
        };
        Unit2.fromJSON = function(json) {
          var unit3 = new Unit2(json.value, json.unit);
          unit3.fixPrefix = json.fixPrefix || false;
          return unit3;
        };
        Unit2.prototype.valueOf = Unit2.prototype.toString;
        Unit2.prototype.simplify = function() {
          var ret = this.clone();
          var proposedUnitList = [];
          var matchingBase;
          for (var key2 in currentUnitSystem) {
            if (hasOwnProperty2(currentUnitSystem, key2)) {
              if (ret.hasBase(BASE_UNITS[key2])) {
                matchingBase = key2;
                break;
              }
            }
          }
          if (matchingBase === "NONE") {
            ret.units = [];
          } else {
            var matchingUnit;
            if (matchingBase) {
              if (hasOwnProperty2(currentUnitSystem, matchingBase)) {
                matchingUnit = currentUnitSystem[matchingBase];
              }
            }
            if (matchingUnit) {
              ret.units = [{
                unit: matchingUnit.unit,
                prefix: matchingUnit.prefix,
                power: 1
              }];
            } else {
              var missingBaseDim = false;
              for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
                var baseDim = BASE_DIMENSIONS[i5];
                if (Math.abs(ret.dimensions[i5] || 0) > 1e-12) {
                  if (hasOwnProperty2(currentUnitSystem, baseDim)) {
                    proposedUnitList.push({
                      unit: currentUnitSystem[baseDim].unit,
                      prefix: currentUnitSystem[baseDim].prefix,
                      power: ret.dimensions[i5] || 0
                    });
                  } else {
                    missingBaseDim = true;
                  }
                }
              }
              if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
                ret.units = proposedUnitList;
              }
            }
          }
          return ret;
        };
        Unit2.prototype.toSI = function() {
          var ret = this.clone();
          var proposedUnitList = [];
          for (var i5 = 0; i5 < BASE_DIMENSIONS.length; i5++) {
            var baseDim = BASE_DIMENSIONS[i5];
            if (Math.abs(ret.dimensions[i5] || 0) > 1e-12) {
              if (hasOwnProperty2(UNIT_SYSTEMS.si, baseDim)) {
                proposedUnitList.push({
                  unit: UNIT_SYSTEMS.si[baseDim].unit,
                  prefix: UNIT_SYSTEMS.si[baseDim].prefix,
                  power: ret.dimensions[i5] || 0
                });
              } else {
                throw new Error("Cannot express custom unit " + baseDim + " in SI units");
              }
            }
          }
          ret.units = proposedUnitList;
          ret.fixPrefix = true;
          ret.skipAutomaticSimplification = true;
          return ret;
        };
        Unit2.prototype.formatUnits = function() {
          var strNum = "";
          var strDen = "";
          var nNum = 0;
          var nDen = 0;
          for (var i5 = 0; i5 < this.units.length; i5++) {
            if (this.units[i5].power > 0) {
              nNum++;
              strNum += " " + this.units[i5].prefix.name + this.units[i5].unit.name;
              if (Math.abs(this.units[i5].power - 1) > 1e-15) {
                strNum += "^" + this.units[i5].power;
              }
            } else if (this.units[i5].power < 0) {
              nDen++;
            }
          }
          if (nDen > 0) {
            for (var _i4 = 0; _i4 < this.units.length; _i4++) {
              if (this.units[_i4].power < 0) {
                if (nNum > 0) {
                  strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                  if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                    strDen += "^" + -this.units[_i4].power;
                  }
                } else {
                  strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                  strDen += "^" + this.units[_i4].power;
                }
              }
            }
          }
          strNum = strNum.substr(1);
          strDen = strDen.substr(1);
          if (nNum > 1 && nDen > 0) {
            strNum = "(" + strNum + ")";
          }
          if (nDen > 1 && nNum > 0) {
            strDen = "(" + strDen + ")";
          }
          var str = strNum;
          if (nNum > 0 && nDen > 0) {
            str += " / ";
          }
          str += strDen;
          return str;
        };
        Unit2.prototype.format = function(options) {
          var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
          var isImaginary = false;
          if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
            isImaginary = Math.abs(simp.value.re) < 1e-14;
          }
          for (var i5 in simp.units) {
            if (hasOwnProperty2(simp.units, i5)) {
              if (simp.units[i5].unit) {
                if (simp.units[i5].unit.name === "VA" && isImaginary) {
                  simp.units[i5].unit = UNITS.VAR;
                } else if (simp.units[i5].unit.name === "VAR" && !isImaginary) {
                  simp.units[i5].unit = UNITS.VA;
                }
              }
            }
          }
          if (simp.units.length === 1 && !simp.fixPrefix) {
            if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
              simp.units[0].prefix = simp._bestPrefix();
            }
          }
          var value = simp._denormalize(simp.value);
          var str = simp.value !== null ? format5(value, options || {}) : "";
          var unitStr = simp.formatUnits();
          if (simp.value && isComplex(simp.value)) {
            str = "(" + str + ")";
          }
          if (unitStr.length > 0 && str.length > 0) {
            str += " ";
          }
          str += unitStr;
          return str;
        };
        Unit2.prototype._bestPrefix = function() {
          if (this.units.length !== 1) {
            throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
          }
          if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
            throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
          }
          var absValue = this.value !== null ? abs3(this.value) : 0;
          var absUnitValue = abs3(this.units[0].unit.value);
          var bestPrefix = this.units[0].prefix;
          if (absValue === 0) {
            return bestPrefix;
          }
          var power = this.units[0].power;
          var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
          if (bestDiff > -2.200001 && bestDiff < 1.800001)
            return bestPrefix;
          bestDiff = Math.abs(bestDiff);
          var prefixes = this.units[0].unit.prefixes;
          for (var p3 in prefixes) {
            if (hasOwnProperty2(prefixes, p3)) {
              var prefix = prefixes[p3];
              if (prefix.scientific) {
                var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
                if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
                  bestPrefix = prefix;
                  bestDiff = diff2;
                }
              }
            }
          }
          return bestPrefix;
        };
        Unit2.prototype.splitUnit = function(parts) {
          var x4 = this.clone();
          var ret = [];
          for (var i5 = 0; i5 < parts.length; i5++) {
            x4 = x4.to(parts[i5]);
            if (i5 === parts.length - 1)
              break;
            var xNumeric = x4.toNumeric();
            var xRounded = round3(xNumeric);
            var xFixed = void 0;
            var isNearlyEqual = equal2(xRounded, xNumeric);
            if (isNearlyEqual) {
              xFixed = xRounded;
            } else {
              xFixed = fix2(x4.toNumeric());
            }
            var y3 = new Unit2(xFixed, parts[i5].toString());
            ret.push(y3);
            x4 = subtract2(x4, y3);
          }
          var testSum = 0;
          for (var _i5 = 0; _i5 < ret.length; _i5++) {
            testSum = addScalar2(testSum, ret[_i5].value);
          }
          if (equal2(testSum, this.value)) {
            x4.value = 0;
          }
          ret.push(x4);
          return ret;
        };
        var PREFIXES = {
          NONE: {
            "": {
              name: "",
              value: 1,
              scientific: true
            }
          },
          SHORT: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 10,
              scientific: false
            },
            h: {
              name: "h",
              value: 100,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e3,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e6,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e9,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e12,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e15,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e18,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e21,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e24,
              scientific: true
            },
            d: {
              name: "d",
              value: 0.1,
              scientific: false
            },
            c: {
              name: "c",
              value: 0.01,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-3,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-6,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-9,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-12,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-15,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-18,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-21,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-24,
              scientific: true
            }
          },
          LONG: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            deca: {
              name: "deca",
              value: 10,
              scientific: false
            },
            hecto: {
              name: "hecto",
              value: 100,
              scientific: false
            },
            kilo: {
              name: "kilo",
              value: 1e3,
              scientific: true
            },
            mega: {
              name: "mega",
              value: 1e6,
              scientific: true
            },
            giga: {
              name: "giga",
              value: 1e9,
              scientific: true
            },
            tera: {
              name: "tera",
              value: 1e12,
              scientific: true
            },
            peta: {
              name: "peta",
              value: 1e15,
              scientific: true
            },
            exa: {
              name: "exa",
              value: 1e18,
              scientific: true
            },
            zetta: {
              name: "zetta",
              value: 1e21,
              scientific: true
            },
            yotta: {
              name: "yotta",
              value: 1e24,
              scientific: true
            },
            deci: {
              name: "deci",
              value: 0.1,
              scientific: false
            },
            centi: {
              name: "centi",
              value: 0.01,
              scientific: false
            },
            milli: {
              name: "milli",
              value: 1e-3,
              scientific: true
            },
            micro: {
              name: "micro",
              value: 1e-6,
              scientific: true
            },
            nano: {
              name: "nano",
              value: 1e-9,
              scientific: true
            },
            pico: {
              name: "pico",
              value: 1e-12,
              scientific: true
            },
            femto: {
              name: "femto",
              value: 1e-15,
              scientific: true
            },
            atto: {
              name: "atto",
              value: 1e-18,
              scientific: true
            },
            zepto: {
              name: "zepto",
              value: 1e-21,
              scientific: true
            },
            yocto: {
              name: "yocto",
              value: 1e-24,
              scientific: true
            }
          },
          SQUARED: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 100,
              scientific: false
            },
            h: {
              name: "h",
              value: 1e4,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e6,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e12,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e18,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e24,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e30,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e36,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e42,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e48,
              scientific: true
            },
            d: {
              name: "d",
              value: 0.01,
              scientific: false
            },
            c: {
              name: "c",
              value: 1e-4,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-6,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-12,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-18,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-24,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-30,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-36,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-42,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-48,
              scientific: true
            }
          },
          CUBIC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 1e3,
              scientific: false
            },
            h: {
              name: "h",
              value: 1e6,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e9,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e18,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e27,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e36,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e45,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e54,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e63,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e72,
              scientific: true
            },
            d: {
              name: "d",
              value: 1e-3,
              scientific: false
            },
            c: {
              name: "c",
              value: 1e-6,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-9,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-18,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-27,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-36,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-45,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-54,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-63,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-72,
              scientific: true
            }
          },
          BINARY_SHORT_SI: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            k: {
              name: "k",
              value: 1e3,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e6,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e9,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e12,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e15,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e18,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e21,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e24,
              scientific: true
            }
          },
          BINARY_SHORT_IEC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            Ki: {
              name: "Ki",
              value: 1024,
              scientific: true
            },
            Mi: {
              name: "Mi",
              value: Math.pow(1024, 2),
              scientific: true
            },
            Gi: {
              name: "Gi",
              value: Math.pow(1024, 3),
              scientific: true
            },
            Ti: {
              name: "Ti",
              value: Math.pow(1024, 4),
              scientific: true
            },
            Pi: {
              name: "Pi",
              value: Math.pow(1024, 5),
              scientific: true
            },
            Ei: {
              name: "Ei",
              value: Math.pow(1024, 6),
              scientific: true
            },
            Zi: {
              name: "Zi",
              value: Math.pow(1024, 7),
              scientific: true
            },
            Yi: {
              name: "Yi",
              value: Math.pow(1024, 8),
              scientific: true
            }
          },
          BINARY_LONG_SI: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            kilo: {
              name: "kilo",
              value: 1e3,
              scientific: true
            },
            mega: {
              name: "mega",
              value: 1e6,
              scientific: true
            },
            giga: {
              name: "giga",
              value: 1e9,
              scientific: true
            },
            tera: {
              name: "tera",
              value: 1e12,
              scientific: true
            },
            peta: {
              name: "peta",
              value: 1e15,
              scientific: true
            },
            exa: {
              name: "exa",
              value: 1e18,
              scientific: true
            },
            zetta: {
              name: "zetta",
              value: 1e21,
              scientific: true
            },
            yotta: {
              name: "yotta",
              value: 1e24,
              scientific: true
            }
          },
          BINARY_LONG_IEC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            kibi: {
              name: "kibi",
              value: 1024,
              scientific: true
            },
            mebi: {
              name: "mebi",
              value: Math.pow(1024, 2),
              scientific: true
            },
            gibi: {
              name: "gibi",
              value: Math.pow(1024, 3),
              scientific: true
            },
            tebi: {
              name: "tebi",
              value: Math.pow(1024, 4),
              scientific: true
            },
            pebi: {
              name: "pebi",
              value: Math.pow(1024, 5),
              scientific: true
            },
            exi: {
              name: "exi",
              value: Math.pow(1024, 6),
              scientific: true
            },
            zebi: {
              name: "zebi",
              value: Math.pow(1024, 7),
              scientific: true
            },
            yobi: {
              name: "yobi",
              value: Math.pow(1024, 8),
              scientific: true
            }
          },
          BTU: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            MM: {
              name: "MM",
              value: 1e6,
              scientific: true
            }
          }
        };
        PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
        PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
        PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
        var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
        var BASE_UNITS = {
          NONE: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          MASS: {
            dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          LENGTH: {
            dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
          },
          TIME: {
            dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
          },
          CURRENT: {
            dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
          },
          TEMPERATURE: {
            dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
          },
          LUMINOUS_INTENSITY: {
            dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
          },
          AMOUNT_OF_SUBSTANCE: {
            dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
          },
          FORCE: {
            dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
          },
          SURFACE: {
            dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
          },
          VOLUME: {
            dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
          },
          ENERGY: {
            dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
          },
          POWER: {
            dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
          },
          PRESSURE: {
            dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CHARGE: {
            dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CAPACITANCE: {
            dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_POTENTIAL: {
            dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
          },
          ELECTRIC_RESISTANCE: {
            dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_INDUCTANCE: {
            dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CONDUCTANCE: {
            dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
          },
          MAGNETIC_FLUX: {
            dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
          },
          MAGNETIC_FLUX_DENSITY: {
            dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
          },
          FREQUENCY: {
            dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
          },
          ANGLE: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
          },
          BIT: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
          }
        };
        for (var key in BASE_UNITS) {
          if (hasOwnProperty2(BASE_UNITS, key)) {
            BASE_UNITS[key].key = key;
          }
        }
        var BASE_UNIT_NONE = {};
        var UNIT_NONE = {
          name: "",
          base: BASE_UNIT_NONE,
          value: 1,
          offset: 0,
          dimensions: BASE_DIMENSIONS.map((x4) => 0)
        };
        var UNITS = {
          // length
          meter: {
            name: "meter",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          inch: {
            name: "inch",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
          },
          foot: {
            name: "foot",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
          },
          yard: {
            name: "yard",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
          },
          mile: {
            name: "mile",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
          },
          link: {
            name: "link",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
          },
          rod: {
            name: "rod",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.0292,
            offset: 0
          },
          chain: {
            name: "chain",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
          },
          angstrom: {
            name: "angstrom",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1e-10,
            offset: 0
          },
          m: {
            name: "m",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          in: {
            name: "in",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
          },
          ft: {
            name: "ft",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
          },
          yd: {
            name: "yd",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
          },
          mi: {
            name: "mi",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
          },
          li: {
            name: "li",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
          },
          rd: {
            name: "rd",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.02921,
            offset: 0
          },
          ch: {
            name: "ch",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
          },
          mil: {
            name: "mil",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 254e-7,
            offset: 0
          },
          // 1/1000 inch
          // Surface
          m2: {
            name: "m2",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.SQUARED,
            value: 1,
            offset: 0
          },
          sqin: {
            name: "sqin",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 64516e-8,
            offset: 0
          },
          // 645.16 mm2
          sqft: {
            name: "sqft",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.09290304,
            offset: 0
          },
          // 0.09290304 m2
          sqyd: {
            name: "sqyd",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.83612736,
            offset: 0
          },
          // 0.83612736 m2
          sqmi: {
            name: "sqmi",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 2589988110336e-6,
            offset: 0
          },
          // 2.589988110336 km2
          sqrd: {
            name: "sqrd",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 25.29295,
            offset: 0
          },
          // 25.29295 m2
          sqch: {
            name: "sqch",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 404.6873,
            offset: 0
          },
          // 404.6873 m2
          sqmil: {
            name: "sqmil",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 64516e-14,
            offset: 0
          },
          // 6.4516 * 10^-10 m2
          acre: {
            name: "acre",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 4046.86,
            offset: 0
          },
          // 4046.86 m2
          hectare: {
            name: "hectare",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 1e4,
            offset: 0
          },
          // 10000 m2
          // Volume
          m3: {
            name: "m3",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.CUBIC,
            value: 1,
            offset: 0
          },
          L: {
            name: "L",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          // litre
          l: {
            name: "l",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          // litre
          litre: {
            name: "litre",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.LONG,
            value: 1e-3,
            offset: 0
          },
          cuin: {
            name: "cuin",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 16387064e-12,
            offset: 0
          },
          // 1.6387064e-5 m3
          cuft: {
            name: "cuft",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.028316846592,
            offset: 0
          },
          // 28.316 846 592 L
          cuyd: {
            name: "cuyd",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.764554857984,
            offset: 0
          },
          // 764.554 857 984 L
          teaspoon: {
            name: "teaspoon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-6,
            offset: 0
          },
          // 5 mL
          tablespoon: {
            name: "tablespoon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 15e-6,
            offset: 0
          },
          // 15 mL
          // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
          drop: {
            name: "drop",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
          },
          // 0.05 mL = 5e-8 m3
          gtt: {
            name: "gtt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
          },
          // 0.05 mL = 5e-8 m3
          // Liquid volume
          minim: {
            name: "minim",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 6161152e-14,
            offset: 0
          },
          // 0.06161152 mL
          fluiddram: {
            name: "fluiddram",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 36966911e-13,
            offset: 0
          },
          // 3.696691 mL
          fluidounce: {
            name: "fluidounce",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2957353e-11,
            offset: 0
          },
          // 29.57353 mL
          gill: {
            name: "gill",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1182941e-10,
            offset: 0
          },
          // 118.2941 mL
          cc: {
            name: "cc",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1e-6,
            offset: 0
          },
          // 1e-6 L
          cup: {
            name: "cup",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2365882e-10,
            offset: 0
          },
          // 236.5882 mL
          pint: {
            name: "pint",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 4731765e-10,
            offset: 0
          },
          // 473.1765 mL
          quart: {
            name: "quart",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 9463529e-10,
            offset: 0
          },
          // 946.3529 mL
          gallon: {
            name: "gallon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 3785412e-9,
            offset: 0
          },
          // 3.785412 L
          beerbarrel: {
            name: "beerbarrel",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1173478,
            offset: 0
          },
          // 117.3478 L
          oilbarrel: {
            name: "oilbarrel",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1589873,
            offset: 0
          },
          // 158.9873 L
          hogshead: {
            name: "hogshead",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.238481,
            offset: 0
          },
          // 238.4810 L
          // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
          fldr: {
            name: "fldr",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 36966911e-13,
            offset: 0
          },
          // 3.696691 mL
          floz: {
            name: "floz",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2957353e-11,
            offset: 0
          },
          // 29.57353 mL
          gi: {
            name: "gi",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1182941e-10,
            offset: 0
          },
          // 118.2941 mL
          cp: {
            name: "cp",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2365882e-10,
            offset: 0
          },
          // 236.5882 mL
          pt: {
            name: "pt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 4731765e-10,
            offset: 0
          },
          // 473.1765 mL
          qt: {
            name: "qt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 9463529e-10,
            offset: 0
          },
          // 946.3529 mL
          gal: {
            name: "gal",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 3785412e-9,
            offset: 0
          },
          // 3.785412 L
          bbl: {
            name: "bbl",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1173478,
            offset: 0
          },
          // 117.3478 L
          obl: {
            name: "obl",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1589873,
            offset: 0
          },
          // 158.9873 L
          // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
          // Mass
          g: {
            name: "g",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          gram: {
            name: "gram",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 1e-3,
            offset: 0
          },
          ton: {
            name: "ton",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 907.18474,
            offset: 0
          },
          t: {
            name: "t",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 1e3,
            offset: 0
          },
          tonne: {
            name: "tonne",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 1e3,
            offset: 0
          },
          grain: {
            name: "grain",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6479891e-11,
            offset: 0
          },
          dram: {
            name: "dram",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.0017718451953125,
            offset: 0
          },
          ounce: {
            name: "ounce",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.028349523125,
            offset: 0
          },
          poundmass: {
            name: "poundmass",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.45359237,
            offset: 0
          },
          hundredweight: {
            name: "hundredweight",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
          },
          stick: {
            name: "stick",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.115,
            offset: 0
          },
          stone: {
            name: "stone",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6.35029318,
            offset: 0
          },
          gr: {
            name: "gr",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6479891e-11,
            offset: 0
          },
          dr: {
            name: "dr",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.0017718451953125,
            offset: 0
          },
          oz: {
            name: "oz",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.028349523125,
            offset: 0
          },
          lbm: {
            name: "lbm",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.45359237,
            offset: 0
          },
          cwt: {
            name: "cwt",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
          },
          // Time
          s: {
            name: "s",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          min: {
            name: "min",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
          },
          h: {
            name: "h",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
          },
          second: {
            name: "second",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          sec: {
            name: "sec",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          minute: {
            name: "minute",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
          },
          hour: {
            name: "hour",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
          },
          day: {
            name: "day",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 86400,
            offset: 0
          },
          week: {
            name: "week",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 7 * 86400,
            offset: 0
          },
          month: {
            name: "month",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 2629800,
            // 1/12th of Julian year
            offset: 0
          },
          year: {
            name: "year",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 31557600,
            // Julian year
            offset: 0
          },
          decade: {
            name: "decade",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e3,
            // Julian decade
            offset: 0
          },
          century: {
            name: "century",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e4,
            // Julian century
            offset: 0
          },
          millennium: {
            name: "millennium",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e5,
            // Julian millennium
            offset: 0
          },
          // Frequency
          hertz: {
            name: "Hertz",
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0,
            reciprocal: true
          },
          Hz: {
            name: "Hz",
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0,
            reciprocal: true
          },
          // Angle
          rad: {
            name: "rad",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          radian: {
            name: "radian",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
          deg: {
            name: "deg",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          degree: {
            name: "degree",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
          grad: {
            name: "grad",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          gradian: {
            name: "gradian",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
          cycle: {
            name: "cycle",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
          arcsec: {
            name: "arcsec",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
          arcmin: {
            name: "arcmin",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // Electric current
          A: {
            name: "A",
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          ampere: {
            name: "ampere",
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // Temperature
          // K(C) = C + 273.15
          // K(F) = (F + 459.67) * (5 / 9)
          // K(R) = R * (5 / 9)
          K: {
            name: "K",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          degC: {
            name: "degC",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 273.15
          },
          degF: {
            name: "degF",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 459.67
          },
          degR: {
            name: "degR",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 0
          },
          kelvin: {
            name: "kelvin",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          celsius: {
            name: "celsius",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 273.15
          },
          fahrenheit: {
            name: "fahrenheit",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 459.67
          },
          rankine: {
            name: "rankine",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 0
          },
          // amount of substance
          mol: {
            name: "mol",
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          mole: {
            name: "mole",
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // luminous intensity
          cd: {
            name: "cd",
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          candela: {
            name: "candela",
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // TODO: units STERADIAN
          // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
          // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
          // Force
          N: {
            name: "N",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          newton: {
            name: "newton",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          dyn: {
            name: "dyn",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 1e-5,
            offset: 0
          },
          dyne: {
            name: "dyne",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 1e-5,
            offset: 0
          },
          lbf: {
            name: "lbf",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
          },
          poundforce: {
            name: "poundforce",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
          },
          kip: {
            name: "kip",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 4448.2216,
            offset: 0
          },
          kilogramforce: {
            name: "kilogramforce",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
          },
          // Energy
          J: {
            name: "J",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          joule: {
            name: "joule",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          erg: {
            name: "erg",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.NONE,
            value: 1e-7,
            offset: 0
          },
          Wh: {
            name: "Wh",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 3600,
            offset: 0
          },
          BTU: {
            name: "BTU",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.BTU,
            value: 1055.05585262,
            offset: 0
          },
          eV: {
            name: "eV",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1602176565e-28,
            offset: 0
          },
          electronvolt: {
            name: "electronvolt",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.LONG,
            value: 1602176565e-28,
            offset: 0
          },
          // Power
          W: {
            name: "W",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          watt: {
            name: "watt",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          hp: {
            name: "hp",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.NONE,
            value: 745.6998715386,
            offset: 0
          },
          // Electrical power units
          VAR: {
            name: "VAR",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: Complex3.I,
            offset: 0
          },
          VA: {
            name: "VA",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Pressure
          Pa: {
            name: "Pa",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          psi: {
            name: "psi",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 6894.75729276459,
            offset: 0
          },
          atm: {
            name: "atm",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 101325,
            offset: 0
          },
          bar: {
            name: "bar",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORTLONG,
            value: 1e5,
            offset: 0
          },
          torr: {
            name: "torr",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
          },
          mmHg: {
            name: "mmHg",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
          },
          mmH2O: {
            name: "mmH2O",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
          },
          cmH2O: {
            name: "cmH2O",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 98.0665,
            offset: 0
          },
          // Electric charge
          coulomb: {
            name: "coulomb",
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          C: {
            name: "C",
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric capacitance
          farad: {
            name: "farad",
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          F: {
            name: "F",
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric potential
          volt: {
            name: "volt",
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          V: {
            name: "V",
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric resistance
          ohm: {
            name: "ohm",
            base: BASE_UNITS.ELECTRIC_RESISTANCE,
            prefixes: PREFIXES.SHORTLONG,
            // Both Mohm and megaohm are acceptable
            value: 1,
            offset: 0
          },
          /*
           * Unicode breaks in browsers if charset is not specified
          : {
            name: '',
            base: BASE_UNITS.ELECTRIC_RESISTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          */
          // Electric inductance
          henry: {
            name: "henry",
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          H: {
            name: "H",
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric conductance
          siemens: {
            name: "siemens",
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          S: {
            name: "S",
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Magnetic flux
          weber: {
            name: "weber",
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          Wb: {
            name: "Wb",
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Magnetic flux density
          tesla: {
            name: "tesla",
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          T: {
            name: "T",
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Binary
          b: {
            name: "b",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 1,
            offset: 0
          },
          bits: {
            name: "bits",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 1,
            offset: 0
          },
          B: {
            name: "B",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 8,
            offset: 0
          },
          bytes: {
            name: "bytes",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 8,
            offset: 0
          }
        };
        var ALIASES = {
          meters: "meter",
          inches: "inch",
          feet: "foot",
          yards: "yard",
          miles: "mile",
          links: "link",
          rods: "rod",
          chains: "chain",
          angstroms: "angstrom",
          lt: "l",
          litres: "litre",
          liter: "litre",
          liters: "litre",
          teaspoons: "teaspoon",
          tablespoons: "tablespoon",
          minims: "minim",
          fluiddrams: "fluiddram",
          fluidounces: "fluidounce",
          gills: "gill",
          cups: "cup",
          pints: "pint",
          quarts: "quart",
          gallons: "gallon",
          beerbarrels: "beerbarrel",
          oilbarrels: "oilbarrel",
          hogsheads: "hogshead",
          gtts: "gtt",
          grams: "gram",
          tons: "ton",
          tonnes: "tonne",
          grains: "grain",
          drams: "dram",
          ounces: "ounce",
          poundmasses: "poundmass",
          hundredweights: "hundredweight",
          sticks: "stick",
          lb: "lbm",
          lbs: "lbm",
          kips: "kip",
          kgf: "kilogramforce",
          acres: "acre",
          hectares: "hectare",
          sqfeet: "sqft",
          sqyard: "sqyd",
          sqmile: "sqmi",
          sqmiles: "sqmi",
          mmhg: "mmHg",
          mmh2o: "mmH2O",
          cmh2o: "cmH2O",
          seconds: "second",
          secs: "second",
          minutes: "minute",
          mins: "minute",
          hours: "hour",
          hr: "hour",
          hrs: "hour",
          days: "day",
          weeks: "week",
          months: "month",
          years: "year",
          decades: "decade",
          centuries: "century",
          millennia: "millennium",
          hertz: "hertz",
          radians: "radian",
          degrees: "degree",
          gradians: "gradian",
          cycles: "cycle",
          arcsecond: "arcsec",
          arcseconds: "arcsec",
          arcminute: "arcmin",
          arcminutes: "arcmin",
          BTUs: "BTU",
          watts: "watt",
          joules: "joule",
          amperes: "ampere",
          amps: "ampere",
          amp: "ampere",
          coulombs: "coulomb",
          volts: "volt",
          ohms: "ohm",
          farads: "farad",
          webers: "weber",
          teslas: "tesla",
          electronvolts: "electronvolt",
          moles: "mole",
          bit: "bits",
          byte: "bytes"
        };
        function calculateAngleValues(config5) {
          if (config5.number === "BigNumber") {
            var pi3 = createBigNumberPi(_BigNumber);
            UNITS.rad.value = new _BigNumber(1);
            UNITS.deg.value = pi3.div(180);
            UNITS.grad.value = pi3.div(200);
            UNITS.cycle.value = pi3.times(2);
            UNITS.arcsec.value = pi3.div(648e3);
            UNITS.arcmin.value = pi3.div(10800);
          } else {
            UNITS.rad.value = 1;
            UNITS.deg.value = Math.PI / 180;
            UNITS.grad.value = Math.PI / 200;
            UNITS.cycle.value = Math.PI * 2;
            UNITS.arcsec.value = Math.PI / 648e3;
            UNITS.arcmin.value = Math.PI / 10800;
          }
          UNITS.radian.value = UNITS.rad.value;
          UNITS.degree.value = UNITS.deg.value;
          UNITS.gradian.value = UNITS.grad.value;
        }
        calculateAngleValues(config4);
        if (on2) {
          on2("config", function(curr, prev) {
            if (curr.number !== prev.number) {
              calculateAngleValues(curr);
            }
          });
        }
        var UNIT_SYSTEMS = {
          si: {
            // Base units
            NONE: {
              unit: UNIT_NONE,
              prefix: PREFIXES.NONE[""]
            },
            LENGTH: {
              unit: UNITS.m,
              prefix: PREFIXES.SHORT[""]
            },
            MASS: {
              unit: UNITS.g,
              prefix: PREFIXES.SHORT.k
            },
            TIME: {
              unit: UNITS.s,
              prefix: PREFIXES.SHORT[""]
            },
            CURRENT: {
              unit: UNITS.A,
              prefix: PREFIXES.SHORT[""]
            },
            TEMPERATURE: {
              unit: UNITS.K,
              prefix: PREFIXES.SHORT[""]
            },
            LUMINOUS_INTENSITY: {
              unit: UNITS.cd,
              prefix: PREFIXES.SHORT[""]
            },
            AMOUNT_OF_SUBSTANCE: {
              unit: UNITS.mol,
              prefix: PREFIXES.SHORT[""]
            },
            ANGLE: {
              unit: UNITS.rad,
              prefix: PREFIXES.SHORT[""]
            },
            BIT: {
              unit: UNITS.bits,
              prefix: PREFIXES.SHORT[""]
            },
            // Derived units
            FORCE: {
              unit: UNITS.N,
              prefix: PREFIXES.SHORT[""]
            },
            ENERGY: {
              unit: UNITS.J,
              prefix: PREFIXES.SHORT[""]
            },
            POWER: {
              unit: UNITS.W,
              prefix: PREFIXES.SHORT[""]
            },
            PRESSURE: {
              unit: UNITS.Pa,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CHARGE: {
              unit: UNITS.C,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CAPACITANCE: {
              unit: UNITS.F,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_POTENTIAL: {
              unit: UNITS.V,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_RESISTANCE: {
              unit: UNITS.ohm,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_INDUCTANCE: {
              unit: UNITS.H,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CONDUCTANCE: {
              unit: UNITS.S,
              prefix: PREFIXES.SHORT[""]
            },
            MAGNETIC_FLUX: {
              unit: UNITS.Wb,
              prefix: PREFIXES.SHORT[""]
            },
            MAGNETIC_FLUX_DENSITY: {
              unit: UNITS.T,
              prefix: PREFIXES.SHORT[""]
            },
            FREQUENCY: {
              unit: UNITS.Hz,
              prefix: PREFIXES.SHORT[""]
            }
          }
        };
        UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        UNIT_SYSTEMS.cgs.LENGTH = {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT.c
        };
        UNIT_SYSTEMS.cgs.MASS = {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT[""]
        };
        UNIT_SYSTEMS.cgs.FORCE = {
          unit: UNITS.dyn,
          prefix: PREFIXES.SHORT[""]
        };
        UNIT_SYSTEMS.cgs.ENERGY = {
          unit: UNITS.erg,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        UNIT_SYSTEMS.us.LENGTH = {
          unit: UNITS.ft,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.MASS = {
          unit: UNITS.lbm,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.TEMPERATURE = {
          unit: UNITS.degF,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.FORCE = {
          unit: UNITS.lbf,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.ENERGY = {
          unit: UNITS.BTU,
          prefix: PREFIXES.BTU[""]
        };
        UNIT_SYSTEMS.us.POWER = {
          unit: UNITS.hp,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.PRESSURE = {
          unit: UNITS.psi,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        var currentUnitSystem = UNIT_SYSTEMS.auto;
        Unit2.setUnitSystem = function(name307) {
          if (hasOwnProperty2(UNIT_SYSTEMS, name307)) {
            currentUnitSystem = UNIT_SYSTEMS[name307];
          } else {
            throw new Error("Unit system " + name307 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
          }
        };
        Unit2.getUnitSystem = function() {
          for (var _key in UNIT_SYSTEMS) {
            if (hasOwnProperty2(UNIT_SYSTEMS, _key)) {
              if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
                return _key;
              }
            }
          }
        };
        Unit2.typeConverters = {
          BigNumber: function BigNumber2(x4) {
            if (x4 !== null && x4 !== void 0 && x4.isFraction)
              return new _BigNumber(x4.n).div(x4.d).times(x4.s);
            return new _BigNumber(x4 + "");
          },
          Fraction: function Fraction3(x4) {
            return new _Fraction(x4);
          },
          Complex: function Complex4(x4) {
            return x4;
          },
          number: function number2(x4) {
            if (x4 !== null && x4 !== void 0 && x4.isFraction)
              return _number(x4);
            return x4;
          }
        };
        Unit2.prototype._numberConverter = function() {
          var convert = Unit2.typeConverters[this.valueType()];
          if (convert) {
            return convert;
          }
          throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
        };
        Unit2._getNumberConverter = function(type) {
          if (!Unit2.typeConverters[type]) {
            throw new TypeError('Unsupported type "' + type + '"');
          }
          return Unit2.typeConverters[type];
        };
        for (var _key2 in UNITS) {
          if (hasOwnProperty2(UNITS, _key2)) {
            var unit2 = UNITS[_key2];
            unit2.dimensions = unit2.base.dimensions;
          }
        }
        for (var _name2 in ALIASES) {
          if (hasOwnProperty2(ALIASES, _name2)) {
            var _unit2 = UNITS[ALIASES[_name2]];
            var alias = {};
            for (var _key3 in _unit2) {
              if (hasOwnProperty2(_unit2, _key3)) {
                alias[_key3] = _unit2[_key3];
              }
            }
            alias.name = _name2;
            UNITS[_name2] = alias;
          }
        }
        Unit2.isValidAlpha = function isValidAlpha(c4) {
          return /^[a-zA-Z]$/.test(c4);
        };
        function assertUnitNameIsValid(name307) {
          for (var i5 = 0; i5 < name307.length; i5++) {
            c3 = name307.charAt(i5);
            if (i5 === 0 && !Unit2.isValidAlpha(c3)) {
              throw new Error('Invalid unit name (must begin with alpha character): "' + name307 + '"');
            }
            if (i5 > 0 && !(Unit2.isValidAlpha(c3) || isDigit(c3))) {
              throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name307 + '"');
            }
          }
        }
        Unit2.createUnit = function(obj, options) {
          if (typeof obj !== "object") {
            throw new TypeError("createUnit expects first parameter to be of type 'Object'");
          }
          if (options && options.override) {
            for (var _key4 in obj) {
              if (hasOwnProperty2(obj, _key4)) {
                Unit2.deleteUnit(_key4);
              }
              if (obj[_key4].aliases) {
                for (var i5 = 0; i5 < obj[_key4].aliases.length; i5++) {
                  Unit2.deleteUnit(obj[_key4].aliases[i5]);
                }
              }
            }
          }
          var lastUnit;
          for (var _key5 in obj) {
            if (hasOwnProperty2(obj, _key5)) {
              lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
            }
          }
          return lastUnit;
        };
        Unit2.createUnitSingle = function(name307, obj) {
          if (typeof obj === "undefined" || obj === null) {
            obj = {};
          }
          if (typeof name307 !== "string") {
            throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
          }
          if (hasOwnProperty2(UNITS, name307)) {
            throw new Error('Cannot create unit "' + name307 + '": a unit with that name already exists');
          }
          assertUnitNameIsValid(name307);
          var defUnit = null;
          var aliases = [];
          var offset = 0;
          var definition;
          var prefixes;
          var baseName;
          if (obj && obj.type === "Unit") {
            defUnit = obj.clone();
          } else if (typeof obj === "string") {
            if (obj !== "") {
              definition = obj;
            }
          } else if (typeof obj === "object") {
            definition = obj.definition;
            prefixes = obj.prefixes;
            offset = obj.offset;
            baseName = obj.baseName;
            if (obj.aliases) {
              aliases = obj.aliases.valueOf();
            }
          } else {
            throw new TypeError('Cannot create unit "' + name307 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
          }
          if (aliases) {
            for (var i5 = 0; i5 < aliases.length; i5++) {
              if (hasOwnProperty2(UNITS, aliases[i5])) {
                throw new Error('Cannot create alias "' + aliases[i5] + '": a unit with that name already exists');
              }
            }
          }
          if (definition && typeof definition === "string" && !defUnit) {
            try {
              defUnit = Unit2.parse(definition, {
                allowNoUnits: true
              });
            } catch (ex) {
              ex.message = 'Could not create unit "' + name307 + '" from "' + definition + '": ' + ex.message;
              throw ex;
            }
          } else if (definition && definition.type === "Unit") {
            defUnit = definition.clone();
          }
          aliases = aliases || [];
          offset = offset || 0;
          if (prefixes && prefixes.toUpperCase) {
            prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
          } else {
            prefixes = PREFIXES.NONE;
          }
          var newUnit = {};
          if (!defUnit) {
            baseName = baseName || name307 + "_STUFF";
            if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
              throw new Error('Cannot create new base unit "' + name307 + '": a base unit with that name already exists (and cannot be overridden)');
            }
            BASE_DIMENSIONS.push(baseName);
            for (var b3 in BASE_UNITS) {
              if (hasOwnProperty2(BASE_UNITS, b3)) {
                BASE_UNITS[b3].dimensions[BASE_DIMENSIONS.length - 1] = 0;
              }
            }
            var newBaseUnit = {
              dimensions: []
            };
            for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
              newBaseUnit.dimensions[_i6] = 0;
            }
            newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
            newBaseUnit.key = baseName;
            BASE_UNITS[baseName] = newBaseUnit;
            newUnit = {
              name: name307,
              value: 1,
              dimensions: BASE_UNITS[baseName].dimensions.slice(0),
              prefixes,
              offset,
              base: BASE_UNITS[baseName]
            };
            currentUnitSystem[baseName] = {
              unit: newUnit,
              prefix: PREFIXES.NONE[""]
            };
          } else {
            newUnit = {
              name: name307,
              value: defUnit.value,
              dimensions: defUnit.dimensions.slice(0),
              prefixes,
              offset
            };
            var anyMatch = false;
            for (var _i7 in BASE_UNITS) {
              if (hasOwnProperty2(BASE_UNITS, _i7)) {
                var match = true;
                for (var j4 = 0; j4 < BASE_DIMENSIONS.length; j4++) {
                  if (Math.abs((newUnit.dimensions[j4] || 0) - (BASE_UNITS[_i7].dimensions[j4] || 0)) > 1e-12) {
                    match = false;
                    break;
                  }
                }
                if (match) {
                  anyMatch = true;
                  newUnit.base = BASE_UNITS[_i7];
                  break;
                }
              }
            }
            if (!anyMatch) {
              baseName = baseName || name307 + "_STUFF";
              var _newBaseUnit = {
                dimensions: defUnit.dimensions.slice(0)
              };
              _newBaseUnit.key = baseName;
              BASE_UNITS[baseName] = _newBaseUnit;
              currentUnitSystem[baseName] = {
                unit: newUnit,
                prefix: PREFIXES.NONE[""]
              };
              newUnit.base = BASE_UNITS[baseName];
            }
          }
          Unit2.UNITS[name307] = newUnit;
          for (var _i8 = 0; _i8 < aliases.length; _i8++) {
            var aliasName = aliases[_i8];
            var _alias = {};
            for (var _key6 in newUnit) {
              if (hasOwnProperty2(newUnit, _key6)) {
                _alias[_key6] = newUnit[_key6];
              }
            }
            _alias.name = aliasName;
            Unit2.UNITS[aliasName] = _alias;
          }
          delete _findUnit.cache;
          return new Unit2(null, name307);
        };
        Unit2.deleteUnit = function(name307) {
          delete Unit2.UNITS[name307];
        };
        Unit2.PREFIXES = PREFIXES;
        Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
        Unit2.BASE_UNITS = BASE_UNITS;
        Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
        Unit2.UNITS = UNITS;
        return Unit2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/unit.js
  var name161, dependencies161, createUnitFunction;
  var init_unit = __esm({
    "node_modules/mathjs/lib/esm/type/unit/function/unit.js"() {
      init_factory();
      init_collection();
      name161 = "unit";
      dependencies161 = ["typed", "Unit"];
      createUnitFunction = /* @__PURE__ */ factory(name161, dependencies161, (_ref) => {
        var {
          typed: typed3,
          Unit: Unit2
        } = _ref;
        return typed3(name161, {
          Unit: function Unit3(x4) {
            return x4.clone();
          },
          string: function string2(x4) {
            if (Unit2.isValuelessUnit(x4)) {
              return new Unit2(null, x4);
            }
            return Unit2.parse(x4, {
              allowNoUnits: true
            });
          },
          "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
            return new Unit2(value, unit2);
          },
          "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
            return new Unit2(value);
          },
          "Array | Matrix": typed3.referToSelf((self2) => (x4) => deepMap(x4, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
  var name162, dependencies162, createSparse;
  var init_sparse = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/function/sparse.js"() {
      init_factory();
      name162 = "sparse";
      dependencies162 = ["typed", "SparseMatrix"];
      createSparse = /* @__PURE__ */ factory(name162, dependencies162, (_ref) => {
        var {
          typed: typed3,
          SparseMatrix: SparseMatrix2
        } = _ref;
        return typed3(name162, {
          "": function _3() {
            return new SparseMatrix2([]);
          },
          string: function string2(datatype) {
            return new SparseMatrix2([], datatype);
          },
          "Array | Matrix": function ArrayMatrix(data) {
            return new SparseMatrix2(data);
          },
          "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
            return new SparseMatrix2(data, datatype);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
  var name163, dependencies163, createCreateUnit;
  var init_createUnit = __esm({
    "node_modules/mathjs/lib/esm/type/unit/function/createUnit.js"() {
      init_factory();
      name163 = "createUnit";
      dependencies163 = ["typed", "Unit"];
      createCreateUnit = /* @__PURE__ */ factory(name163, dependencies163, (_ref) => {
        var {
          typed: typed3,
          Unit: Unit2
        } = _ref;
        return typed3(name163, {
          // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
          "Object, Object": function ObjectObject(obj, options) {
            return Unit2.createUnit(obj, options);
          },
          // Same as above but without the options.
          Object: function Object2(obj) {
            return Unit2.createUnit(obj, {});
          },
          // Shortcut method for creating one unit.
          "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name307, def, options) {
            var obj = {};
            obj[name307] = def;
            return Unit2.createUnit(obj, options);
          },
          // Same as above but without the options.
          "string, Unit | string | Object": function stringUnitStringObject(name307, def) {
            var obj = {};
            obj[name307] = def;
            return Unit2.createUnit(obj, {});
          },
          // Without a definition, creates a base unit.
          string: function string2(name307) {
            var obj = {};
            obj[name307] = {};
            return Unit2.createUnit(obj, {});
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acos.js
  var name164, dependencies164, createAcos;
  var init_acos = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acos.js"() {
      init_factory();
      name164 = "acos";
      dependencies164 = ["typed", "config", "Complex"];
      createAcos = /* @__PURE__ */ factory(name164, dependencies164, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3
        } = _ref;
        return typed3(name164, {
          number: function number2(x4) {
            if (x4 >= -1 && x4 <= 1 || config4.predictable) {
              return Math.acos(x4);
            } else {
              return new Complex3(x4, 0).acos();
            }
          },
          Complex: function Complex4(x4) {
            return x4.acos();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.acos();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
  var name165, dependencies165, createAcosh;
  var init_acosh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acosh.js"() {
      init_factory();
      init_number2();
      name165 = "acosh";
      dependencies165 = ["typed", "config", "Complex"];
      createAcosh = /* @__PURE__ */ factory(name165, dependencies165, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3
        } = _ref;
        return typed3(name165, {
          number: function number2(x4) {
            if (x4 >= 1 || config4.predictable) {
              return acoshNumber(x4);
            }
            if (x4 <= -1) {
              return new Complex3(Math.log(Math.sqrt(x4 * x4 - 1) - x4), Math.PI);
            }
            return new Complex3(x4, 0).acosh();
          },
          Complex: function Complex4(x4) {
            return x4.acosh();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.acosh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acot.js
  var name166, dependencies166, createAcot;
  var init_acot = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acot.js"() {
      init_factory();
      init_number2();
      name166 = "acot";
      dependencies166 = ["typed", "BigNumber"];
      createAcot = /* @__PURE__ */ factory(name166, dependencies166, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name166, {
          number: acotNumber,
          Complex: function Complex3(x4) {
            return x4.acot();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).atan();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
  var name167, dependencies167, createAcoth;
  var init_acoth = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acoth.js"() {
      init_factory();
      init_number2();
      name167 = "acoth";
      dependencies167 = ["typed", "config", "Complex", "BigNumber"];
      createAcoth = /* @__PURE__ */ factory(name167, dependencies167, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name167, {
          number: function number2(x4) {
            if (x4 >= 1 || x4 <= -1 || config4.predictable) {
              return acothNumber(x4);
            }
            return new Complex3(x4, 0).acoth();
          },
          Complex: function Complex4(x4) {
            return x4.acoth();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).atanh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
  var name168, dependencies168, createAcsc;
  var init_acsc = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acsc.js"() {
      init_factory();
      init_number2();
      name168 = "acsc";
      dependencies168 = ["typed", "config", "Complex", "BigNumber"];
      createAcsc = /* @__PURE__ */ factory(name168, dependencies168, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name168, {
          number: function number2(x4) {
            if (x4 <= -1 || x4 >= 1 || config4.predictable) {
              return acscNumber(x4);
            }
            return new Complex3(x4, 0).acsc();
          },
          Complex: function Complex4(x4) {
            return x4.acsc();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).asin();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
  var name169, dependencies169, createAcsch;
  var init_acsch = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/acsch.js"() {
      init_factory();
      init_number2();
      name169 = "acsch";
      dependencies169 = ["typed", "BigNumber"];
      createAcsch = /* @__PURE__ */ factory(name169, dependencies169, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name169, {
          number: acschNumber,
          Complex: function Complex3(x4) {
            return x4.acsch();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).asinh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asec.js
  var name170, dependencies170, createAsec;
  var init_asec = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/asec.js"() {
      init_factory();
      init_number2();
      name170 = "asec";
      dependencies170 = ["typed", "config", "Complex", "BigNumber"];
      createAsec = /* @__PURE__ */ factory(name170, dependencies170, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name170, {
          number: function number2(x4) {
            if (x4 <= -1 || x4 >= 1 || config4.predictable) {
              return asecNumber(x4);
            }
            return new Complex3(x4, 0).asec();
          },
          Complex: function Complex4(x4) {
            return x4.asec();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).acos();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asech.js
  var name171, dependencies171, createAsech;
  var init_asech = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/asech.js"() {
      init_factory();
      init_number2();
      name171 = "asech";
      dependencies171 = ["typed", "config", "Complex", "BigNumber"];
      createAsech = /* @__PURE__ */ factory(name171, dependencies171, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name171, {
          number: function number2(x4) {
            if (x4 <= 1 && x4 >= -1 || config4.predictable) {
              var xInv = 1 / x4;
              if (xInv > 0 || config4.predictable) {
                return asechNumber(x4);
              }
              var ret = Math.sqrt(xInv * xInv - 1);
              return new Complex3(Math.log(ret - xInv), Math.PI);
            }
            return new Complex3(x4, 0).asech();
          },
          Complex: function Complex4(x4) {
            return x4.asech();
          },
          BigNumber: function BigNumber2(x4) {
            return new _BigNumber(1).div(x4).acosh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asin.js
  var name172, dependencies172, createAsin;
  var init_asin = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/asin.js"() {
      init_factory();
      name172 = "asin";
      dependencies172 = ["typed", "config", "Complex"];
      createAsin = /* @__PURE__ */ factory(name172, dependencies172, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3
        } = _ref;
        return typed3(name172, {
          number: function number2(x4) {
            if (x4 >= -1 && x4 <= 1 || config4.predictable) {
              return Math.asin(x4);
            } else {
              return new Complex3(x4, 0).asin();
            }
          },
          Complex: function Complex4(x4) {
            return x4.asin();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.asin();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
  var name173, dependencies173, createAsinh;
  var init_asinh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/asinh.js"() {
      init_factory();
      init_number2();
      name173 = "asinh";
      dependencies173 = ["typed"];
      createAsinh = /* @__PURE__ */ factory(name173, dependencies173, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("asinh", {
          number: asinhNumber,
          Complex: function Complex3(x4) {
            return x4.asinh();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.asinh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan.js
  var name174, dependencies174, createAtan;
  var init_atan = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/atan.js"() {
      init_factory();
      name174 = "atan";
      dependencies174 = ["typed"];
      createAtan = /* @__PURE__ */ factory(name174, dependencies174, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("atan", {
          number: function number2(x4) {
            return Math.atan(x4);
          },
          Complex: function Complex3(x4) {
            return x4.atan();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.atan();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
  var name175, dependencies175, createAtan2;
  var init_atan2 = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/atan2.js"() {
      init_factory();
      init_matAlgo02xDS0();
      init_matAlgo03xDSf();
      init_matAlgo09xS0Sf();
      init_matAlgo11xS0s();
      init_matAlgo12xSfs();
      init_matrixAlgorithmSuite();
      name175 = "atan2";
      dependencies175 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
      createAtan2 = /* @__PURE__ */ factory(name175, dependencies175, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          equalScalar: equalScalar2,
          BigNumber: BigNumber2,
          DenseMatrix: DenseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo02xDS0 = createMatAlgo02xDS0({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = createMatAlgo03xDSf({
          typed: typed3
        });
        var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = createMatAlgo12xSfs({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name175, {
          "number, number": Math.atan2,
          // Complex numbers doesn't seem to have a reasonable implementation of
          // atan2(). Even Matlab removed the support, after they only calculated
          // the atan only on base of the real part of the numbers and ignored
          // the imaginary.
          "BigNumber, BigNumber": (y3, x4) => BigNumber2.atan2(y3, x4)
        }, matrixAlgorithmSuite({
          scalar: "number | BigNumber",
          SS: matAlgo09xS0Sf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
  var name176, dependencies176, createAtanh;
  var init_atanh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/atanh.js"() {
      init_factory();
      init_number2();
      name176 = "atanh";
      dependencies176 = ["typed", "config", "Complex"];
      createAtanh = /* @__PURE__ */ factory(name176, dependencies176, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          Complex: Complex3
        } = _ref;
        return typed3(name176, {
          number: function number2(x4) {
            if (x4 <= 1 && x4 >= -1 || config4.predictable) {
              return atanhNumber(x4);
            }
            return new Complex3(x4, 0).atanh();
          },
          Complex: function Complex4(x4) {
            return x4.atanh();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.atanh();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
  var createTrigUnit;
  var init_trigUnit = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js"() {
      init_factory();
      createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return {
          Unit: typed3.referToSelf((self2) => (x4) => {
            if (!x4.hasBase(x4.constructor.BASE_UNITS.ANGLE)) {
              throw new TypeError("Unit in function cot is no angle");
            }
            return typed3.find(self2, x4.valueType())(x4.value);
          })
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cos.js
  var name177, dependencies177, createCos;
  var init_cos = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/cos.js"() {
      init_factory();
      init_trigUnit();
      name177 = "cos";
      dependencies177 = ["typed"];
      createCos = /* @__PURE__ */ factory(name177, dependencies177, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name177, {
          number: Math.cos,
          "Complex | BigNumber": (x4) => x4.cos()
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
  var name178, dependencies178, createCosh;
  var init_cosh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/cosh.js"() {
      init_factory();
      init_number();
      name178 = "cosh";
      dependencies178 = ["typed"];
      createCosh = /* @__PURE__ */ factory(name178, dependencies178, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name178, {
          number: cosh,
          "Complex | BigNumber": (x4) => x4.cosh()
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cot.js
  var name179, dependencies179, createCot;
  var init_cot = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/cot.js"() {
      init_factory();
      init_number2();
      init_trigUnit();
      name179 = "cot";
      dependencies179 = ["typed", "BigNumber"];
      createCot = /* @__PURE__ */ factory(name179, dependencies179, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name179, {
          number: cotNumber,
          Complex: (x4) => x4.cot(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.tan())
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/coth.js
  var name180, dependencies180, createCoth;
  var init_coth = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/coth.js"() {
      init_factory();
      init_number2();
      name180 = "coth";
      dependencies180 = ["typed", "BigNumber"];
      createCoth = /* @__PURE__ */ factory(name180, dependencies180, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name180, {
          number: cothNumber,
          Complex: (x4) => x4.coth(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.tanh())
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csc.js
  var name181, dependencies181, createCsc;
  var init_csc = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/csc.js"() {
      init_factory();
      init_number2();
      init_trigUnit();
      name181 = "csc";
      dependencies181 = ["typed", "BigNumber"];
      createCsc = /* @__PURE__ */ factory(name181, dependencies181, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name181, {
          number: cscNumber,
          Complex: (x4) => x4.csc(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.sin())
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csch.js
  var name182, dependencies182, createCsch;
  var init_csch = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/csch.js"() {
      init_factory();
      init_number2();
      name182 = "csch";
      dependencies182 = ["typed", "BigNumber"];
      createCsch = /* @__PURE__ */ factory(name182, dependencies182, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name182, {
          number: cschNumber,
          Complex: (x4) => x4.csch(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.sinh())
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sec.js
  var name183, dependencies183, createSec;
  var init_sec = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/sec.js"() {
      init_factory();
      init_number2();
      init_trigUnit();
      name183 = "sec";
      dependencies183 = ["typed", "BigNumber"];
      createSec = /* @__PURE__ */ factory(name183, dependencies183, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name183, {
          number: secNumber,
          Complex: (x4) => x4.sec(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.cos())
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sech.js
  var name184, dependencies184, createSech;
  var init_sech = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/sech.js"() {
      init_factory();
      init_number2();
      name184 = "sech";
      dependencies184 = ["typed", "BigNumber"];
      createSech = /* @__PURE__ */ factory(name184, dependencies184, (_ref) => {
        var {
          typed: typed3,
          BigNumber: _BigNumber
        } = _ref;
        return typed3(name184, {
          number: sechNumber,
          Complex: (x4) => x4.sech(),
          BigNumber: (x4) => new _BigNumber(1).div(x4.cosh())
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sin.js
  var name185, dependencies185, createSin;
  var init_sin = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/sin.js"() {
      init_factory();
      init_trigUnit();
      name185 = "sin";
      dependencies185 = ["typed"];
      createSin = /* @__PURE__ */ factory(name185, dependencies185, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name185, {
          number: Math.sin,
          "Complex | BigNumber": (x4) => x4.sin()
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
  var name186, dependencies186, createSinh;
  var init_sinh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/sinh.js"() {
      init_factory();
      init_number2();
      name186 = "sinh";
      dependencies186 = ["typed"];
      createSinh = /* @__PURE__ */ factory(name186, dependencies186, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name186, {
          number: sinhNumber,
          "Complex | BigNumber": (x4) => x4.sinh()
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tan.js
  var name187, dependencies187, createTan;
  var init_tan = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/tan.js"() {
      init_factory();
      init_trigUnit();
      name187 = "tan";
      dependencies187 = ["typed"];
      createTan = /* @__PURE__ */ factory(name187, dependencies187, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        var trigUnit = createTrigUnit({
          typed: typed3
        });
        return typed3(name187, {
          number: Math.tan,
          "Complex | BigNumber": (x4) => x4.tan()
        }, trigUnit);
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
  var name188, dependencies188, createTanh;
  var init_tanh = __esm({
    "node_modules/mathjs/lib/esm/function/trigonometry/tanh.js"() {
      init_factory();
      init_number();
      name188 = "tanh";
      dependencies188 = ["typed"];
      createTanh = /* @__PURE__ */ factory(name188, dependencies188, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3("tanh", {
          number: tanh,
          "Complex | BigNumber": (x4) => x4.tanh()
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setCartesian.js
  var name189, dependencies189, createSetCartesian;
  var init_setCartesian = __esm({
    "node_modules/mathjs/lib/esm/function/set/setCartesian.js"() {
      init_array();
      init_factory();
      name189 = "setCartesian";
      dependencies189 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      createSetCartesian = /* @__PURE__ */ factory(name189, dependencies189, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return typed3(name189, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            var result = [];
            if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a22), new Index2(0)) !== 0) {
              var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
              var b22 = flatten(Array.isArray(a22) ? a22 : a22.toArray()).sort(compareNatural2);
              result = [];
              for (var i5 = 0; i5 < b1.length; i5++) {
                for (var j4 = 0; j4 < b22.length; j4++) {
                  result.push([b1[i5], b22[j4]]);
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a22)) {
              return result;
            }
            return new DenseMatrix2(result);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setDifference.js
  var name190, dependencies190, createSetDifference;
  var init_setDifference = __esm({
    "node_modules/mathjs/lib/esm/function/set/setDifference.js"() {
      init_array();
      init_factory();
      name190 = "setDifference";
      dependencies190 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      createSetDifference = /* @__PURE__ */ factory(name190, dependencies190, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return typed3(name190, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            var result;
            if (subset2(size2(a1), new Index2(0)) === 0) {
              result = [];
            } else if (subset2(size2(a22), new Index2(0)) === 0) {
              return flatten(a1.toArray());
            } else {
              var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
              var b22 = identify(flatten(Array.isArray(a22) ? a22 : a22.toArray()).sort(compareNatural2));
              result = [];
              var inb2;
              for (var i5 = 0; i5 < b1.length; i5++) {
                inb2 = false;
                for (var j4 = 0; j4 < b22.length; j4++) {
                  if (compareNatural2(b1[i5].value, b22[j4].value) === 0 && b1[i5].identifier === b22[j4].identifier) {
                    inb2 = true;
                    break;
                  }
                }
                if (!inb2) {
                  result.push(b1[i5]);
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a22)) {
              return generalize(result);
            }
            return new DenseMatrix2(generalize(result));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setDistinct.js
  var name191, dependencies191, createSetDistinct;
  var init_setDistinct = __esm({
    "node_modules/mathjs/lib/esm/function/set/setDistinct.js"() {
      init_array();
      init_factory();
      name191 = "setDistinct";
      dependencies191 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      createSetDistinct = /* @__PURE__ */ factory(name191, dependencies191, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return typed3(name191, {
          "Array | Matrix": function ArrayMatrix(a3) {
            var result;
            if (subset2(size2(a3), new Index2(0)) === 0) {
              result = [];
            } else {
              var b3 = flatten(Array.isArray(a3) ? a3 : a3.toArray()).sort(compareNatural2);
              result = [];
              result.push(b3[0]);
              for (var i5 = 1; i5 < b3.length; i5++) {
                if (compareNatural2(b3[i5], b3[i5 - 1]) !== 0) {
                  result.push(b3[i5]);
                }
              }
            }
            if (Array.isArray(a3)) {
              return result;
            }
            return new DenseMatrix2(result);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setIntersect.js
  var name192, dependencies192, createSetIntersect;
  var init_setIntersect = __esm({
    "node_modules/mathjs/lib/esm/function/set/setIntersect.js"() {
      init_array();
      init_factory();
      name192 = "setIntersect";
      dependencies192 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      createSetIntersect = /* @__PURE__ */ factory(name192, dependencies192, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        return typed3(name192, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            var result;
            if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a22), new Index2(0)) === 0) {
              result = [];
            } else {
              var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
              var b22 = identify(flatten(Array.isArray(a22) ? a22 : a22.toArray()).sort(compareNatural2));
              result = [];
              for (var i5 = 0; i5 < b1.length; i5++) {
                for (var j4 = 0; j4 < b22.length; j4++) {
                  if (compareNatural2(b1[i5].value, b22[j4].value) === 0 && b1[i5].identifier === b22[j4].identifier) {
                    result.push(b1[i5]);
                    break;
                  }
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a22)) {
              return generalize(result);
            }
            return new DenseMatrix2(generalize(result));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setIsSubset.js
  var name193, dependencies193, createSetIsSubset;
  var init_setIsSubset = __esm({
    "node_modules/mathjs/lib/esm/function/set/setIsSubset.js"() {
      init_array();
      init_factory();
      name193 = "setIsSubset";
      dependencies193 = ["typed", "size", "subset", "compareNatural", "Index"];
      createSetIsSubset = /* @__PURE__ */ factory(name193, dependencies193, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2
        } = _ref;
        return typed3(name193, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            if (subset2(size2(a1), new Index2(0)) === 0) {
              return true;
            } else if (subset2(size2(a22), new Index2(0)) === 0) {
              return false;
            }
            var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
            var b22 = identify(flatten(Array.isArray(a22) ? a22 : a22.toArray()).sort(compareNatural2));
            var inb2;
            for (var i5 = 0; i5 < b1.length; i5++) {
              inb2 = false;
              for (var j4 = 0; j4 < b22.length; j4++) {
                if (compareNatural2(b1[i5].value, b22[j4].value) === 0 && b1[i5].identifier === b22[j4].identifier) {
                  inb2 = true;
                  break;
                }
              }
              if (inb2 === false) {
                return false;
              }
            }
            return true;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
  var name194, dependencies194, createSetMultiplicity;
  var init_setMultiplicity = __esm({
    "node_modules/mathjs/lib/esm/function/set/setMultiplicity.js"() {
      init_array();
      init_factory();
      name194 = "setMultiplicity";
      dependencies194 = ["typed", "size", "subset", "compareNatural", "Index"];
      createSetMultiplicity = /* @__PURE__ */ factory(name194, dependencies194, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2
        } = _ref;
        return typed3(name194, {
          "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e6, a3) {
            if (subset2(size2(a3), new Index2(0)) === 0) {
              return 0;
            }
            var b3 = flatten(Array.isArray(a3) ? a3 : a3.toArray());
            var count2 = 0;
            for (var i5 = 0; i5 < b3.length; i5++) {
              if (compareNatural2(b3[i5], e6) === 0) {
                count2++;
              }
            }
            return count2;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setPowerset.js
  var name195, dependencies195, createSetPowerset;
  var init_setPowerset = __esm({
    "node_modules/mathjs/lib/esm/function/set/setPowerset.js"() {
      init_array();
      init_factory();
      name195 = "setPowerset";
      dependencies195 = ["typed", "size", "subset", "compareNatural", "Index"];
      createSetPowerset = /* @__PURE__ */ factory(name195, dependencies195, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          subset: subset2,
          compareNatural: compareNatural2,
          Index: Index2
        } = _ref;
        return typed3(name195, {
          "Array | Matrix": function ArrayMatrix(a3) {
            if (subset2(size2(a3), new Index2(0)) === 0) {
              return [];
            }
            var b3 = flatten(Array.isArray(a3) ? a3 : a3.toArray()).sort(compareNatural2);
            var result = [];
            var number2 = 0;
            while (number2.toString(2).length <= b3.length) {
              result.push(_subset(b3, number2.toString(2).split("").reverse()));
              number2++;
            }
            return _sort(result);
          }
        });
        function _subset(array, bitarray) {
          var result = [];
          for (var i5 = 0; i5 < bitarray.length; i5++) {
            if (bitarray[i5] === "1") {
              result.push(array[i5]);
            }
          }
          return result;
        }
        function _sort(array) {
          var temp = [];
          for (var i5 = array.length - 1; i5 > 0; i5--) {
            for (var j4 = 0; j4 < i5; j4++) {
              if (array[j4].length > array[j4 + 1].length) {
                temp = array[j4];
                array[j4] = array[j4 + 1];
                array[j4 + 1] = temp;
              }
            }
          }
          return array;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setSize.js
  var name196, dependencies196, createSetSize;
  var init_setSize = __esm({
    "node_modules/mathjs/lib/esm/function/set/setSize.js"() {
      init_array();
      init_factory();
      name196 = "setSize";
      dependencies196 = ["typed", "compareNatural"];
      createSetSize = /* @__PURE__ */ factory(name196, dependencies196, (_ref) => {
        var {
          typed: typed3,
          compareNatural: compareNatural2
        } = _ref;
        return typed3(name196, {
          "Array | Matrix": function ArrayMatrix(a3) {
            return Array.isArray(a3) ? flatten(a3).length : flatten(a3.toArray()).length;
          },
          "Array | Matrix, boolean": function ArrayMatrixBoolean(a3, unique) {
            if (unique === false || a3.length === 0) {
              return Array.isArray(a3) ? flatten(a3).length : flatten(a3.toArray()).length;
            } else {
              var b3 = flatten(Array.isArray(a3) ? a3 : a3.toArray()).sort(compareNatural2);
              var count2 = 1;
              for (var i5 = 1; i5 < b3.length; i5++) {
                if (compareNatural2(b3[i5], b3[i5 - 1]) !== 0) {
                  count2++;
                }
              }
              return count2;
            }
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setSymDifference.js
  var name197, dependencies197, createSetSymDifference;
  var init_setSymDifference = __esm({
    "node_modules/mathjs/lib/esm/function/set/setSymDifference.js"() {
      init_array();
      init_factory();
      name197 = "setSymDifference";
      dependencies197 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
      createSetSymDifference = /* @__PURE__ */ factory(name197, dependencies197, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          concat: concat3,
          subset: subset2,
          setDifference: setDifference2,
          Index: Index2
        } = _ref;
        return typed3(name197, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            if (subset2(size2(a1), new Index2(0)) === 0) {
              return flatten(a22);
            } else if (subset2(size2(a22), new Index2(0)) === 0) {
              return flatten(a1);
            }
            var b1 = flatten(a1);
            var b22 = flatten(a22);
            return concat3(setDifference2(b1, b22), setDifference2(b22, b1));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setUnion.js
  var name198, dependencies198, createSetUnion;
  var init_setUnion = __esm({
    "node_modules/mathjs/lib/esm/function/set/setUnion.js"() {
      init_array();
      init_factory();
      name198 = "setUnion";
      dependencies198 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
      createSetUnion = /* @__PURE__ */ factory(name198, dependencies198, (_ref) => {
        var {
          typed: typed3,
          size: size2,
          concat: concat3,
          subset: subset2,
          setIntersect: setIntersect2,
          setSymDifference: setSymDifference2,
          Index: Index2
        } = _ref;
        return typed3(name198, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a22) {
            if (subset2(size2(a1), new Index2(0)) === 0) {
              return flatten(a22);
            } else if (subset2(size2(a22), new Index2(0)) === 0) {
              return flatten(a1);
            }
            var b1 = flatten(a1);
            var b22 = flatten(a22);
            return concat3(setSymDifference2(b1, b22), setIntersect2(b1, b22));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/add.js
  var name199, dependencies199, createAdd;
  var init_add = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/add.js"() {
      init_factory();
      init_matAlgo01xDSid();
      init_matAlgo04xSidSid();
      init_matAlgo10xSids();
      init_matrixAlgorithmSuite();
      name199 = "add";
      dependencies199 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
      createAdd = /* @__PURE__ */ factory(name199, dependencies199, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          addScalar: addScalar2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2,
          concat: concat3
        } = _ref;
        var matAlgo01xDSid = createMatAlgo01xDSid({
          typed: typed3
        });
        var matAlgo04xSidSid = createMatAlgo04xSidSid({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = createMatAlgo10xSids({
          typed: typed3,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
          typed: typed3,
          matrix: matrix2,
          concat: concat3
        });
        return typed3(name199, {
          "any, any": addScalar2,
          "any, any, ...any": typed3.referToSelf((self2) => (x4, y3, rest) => {
            var result = self2(x4, y3);
            for (var i5 = 0; i5 < rest.length; i5++) {
              result = self2(result, rest[i5]);
            }
            return result;
          })
        }, matrixAlgorithmSuite({
          elop: addScalar2,
          DS: matAlgo01xDSid,
          SS: matAlgo04xSidSid,
          Ss: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
  var name200, dependencies200, createHypot;
  var init_hypot = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/hypot.js"() {
      init_factory();
      init_array();
      init_is();
      name200 = "hypot";
      dependencies200 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
      createHypot = /* @__PURE__ */ factory(name200, dependencies200, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          addScalar: addScalar2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          sqrt: sqrt3,
          smaller: smaller2,
          isPositive: isPositive2
        } = _ref;
        return typed3(name200, {
          "... number | BigNumber": _hypot,
          Array: _hypot,
          Matrix: (M3) => _hypot(flatten(M3.toArray()))
        });
        function _hypot(args) {
          var result = 0;
          var largest = 0;
          for (var i5 = 0; i5 < args.length; i5++) {
            if (isComplex(args[i5])) {
              throw new TypeError("Unexpected type of argument to hypot");
            }
            var value = abs3(args[i5]);
            if (smaller2(largest, value)) {
              result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
              result = addScalar2(result, 1);
              largest = value;
            } else {
              result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
            }
          }
          return multiplyScalar2(largest, sqrt3(result));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/norm.js
  var name201, dependencies201, createNorm;
  var init_norm = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/norm.js"() {
      init_factory();
      name201 = "norm";
      dependencies201 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
      createNorm = /* @__PURE__ */ factory(name201, dependencies201, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          add: add3,
          pow: pow3,
          conj: conj2,
          sqrt: sqrt3,
          multiply: multiply2,
          equalScalar: equalScalar2,
          larger: larger2,
          smaller: smaller2,
          matrix: matrix2,
          ctranspose: ctranspose2,
          eigs: eigs2
        } = _ref;
        return typed3(name201, {
          number: Math.abs,
          Complex: function Complex3(x4) {
            return x4.abs();
          },
          BigNumber: function BigNumber2(x4) {
            return x4.abs();
          },
          boolean: function boolean2(x4) {
            return Math.abs(x4);
          },
          Array: function Array2(x4) {
            return _norm(matrix2(x4), 2);
          },
          Matrix: function Matrix2(x4) {
            return _norm(x4, 2);
          },
          "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x4, p3) {
            return _norm(matrix2(x4), p3);
          },
          "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x4, p3) {
            return _norm(x4, p3);
          }
        });
        function _vectorNormPlusInfinity(x4) {
          var pinf = 0;
          x4.forEach(function(value) {
            var v3 = abs3(value);
            if (larger2(v3, pinf)) {
              pinf = v3;
            }
          }, true);
          return pinf;
        }
        function _vectorNormMinusInfinity(x4) {
          var ninf;
          x4.forEach(function(value) {
            var v3 = abs3(value);
            if (!ninf || smaller2(v3, ninf)) {
              ninf = v3;
            }
          }, true);
          return ninf || 0;
        }
        function _vectorNorm(x4, p3) {
          if (p3 === Number.POSITIVE_INFINITY || p3 === "inf") {
            return _vectorNormPlusInfinity(x4);
          }
          if (p3 === Number.NEGATIVE_INFINITY || p3 === "-inf") {
            return _vectorNormMinusInfinity(x4);
          }
          if (p3 === "fro") {
            return _norm(x4, 2);
          }
          if (typeof p3 === "number" && !isNaN(p3)) {
            if (!equalScalar2(p3, 0)) {
              var n3 = 0;
              x4.forEach(function(value) {
                n3 = add3(pow3(abs3(value), p3), n3);
              }, true);
              return pow3(n3, 1 / p3);
            }
            return Number.POSITIVE_INFINITY;
          }
          throw new Error("Unsupported parameter value");
        }
        function _matrixNormFrobenius(x4) {
          var fro = 0;
          x4.forEach(function(value, index2) {
            fro = add3(fro, multiply2(value, conj2(value)));
          });
          return abs3(sqrt3(fro));
        }
        function _matrixNormOne(x4) {
          var c3 = [];
          var maxc = 0;
          x4.forEach(function(value, index2) {
            var j4 = index2[1];
            var cj = add3(c3[j4] || 0, abs3(value));
            if (larger2(cj, maxc)) {
              maxc = cj;
            }
            c3[j4] = cj;
          }, true);
          return maxc;
        }
        function _matrixNormTwo(x4) {
          var sizeX = x4.size();
          if (sizeX[0] !== sizeX[1]) {
            throw new RangeError("Invalid matrix dimensions");
          }
          var tx = ctranspose2(x4);
          var squaredX = multiply2(tx, x4);
          var eigenVals = eigs2(squaredX).values.toArray();
          var rho = eigenVals[eigenVals.length - 1];
          return abs3(sqrt3(rho));
        }
        function _matrixNormInfinity(x4) {
          var r3 = [];
          var maxr = 0;
          x4.forEach(function(value, index2) {
            var i5 = index2[0];
            var ri = add3(r3[i5] || 0, abs3(value));
            if (larger2(ri, maxr)) {
              maxr = ri;
            }
            r3[i5] = ri;
          }, true);
          return maxr;
        }
        function _matrixNorm(x4, p3) {
          if (p3 === 1) {
            return _matrixNormOne(x4);
          }
          if (p3 === Number.POSITIVE_INFINITY || p3 === "inf") {
            return _matrixNormInfinity(x4);
          }
          if (p3 === "fro") {
            return _matrixNormFrobenius(x4);
          }
          if (p3 === 2) {
            return _matrixNormTwo(x4);
          }
          throw new Error("Unsupported parameter value " + p3);
        }
        function _norm(x4, p3) {
          var sizeX = x4.size();
          if (sizeX.length === 1) {
            return _vectorNorm(x4, p3);
          }
          if (sizeX.length === 2) {
            if (sizeX[0] && sizeX[1]) {
              return _matrixNorm(x4, p3);
            } else {
              throw new RangeError("Invalid matrix dimensions");
            }
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name202, dependencies202, createDot;
  var init_dot = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/dot.js"() {
      init_factory();
      init_is();
      name202 = "dot";
      dependencies202 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
      createDot = /* @__PURE__ */ factory(name202, dependencies202, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          multiplyScalar: multiplyScalar2,
          conj: conj2,
          size: size2
        } = _ref;
        return typed3(name202, {
          "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
          "SparseMatrix, SparseMatrix": _sparseDot
        });
        function _validateDim(x4, y3) {
          var xSize = _size(x4);
          var ySize = _size(y3);
          var xLen, yLen;
          if (xSize.length === 1) {
            xLen = xSize[0];
          } else if (xSize.length === 2 && xSize[1] === 1) {
            xLen = xSize[0];
          } else {
            throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
          }
          if (ySize.length === 1) {
            yLen = ySize[0];
          } else if (ySize.length === 2 && ySize[1] === 1) {
            yLen = ySize[0];
          } else {
            throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
          }
          if (xLen !== yLen)
            throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
          if (xLen === 0)
            throw new RangeError("Cannot calculate the dot product of empty vectors");
          return xLen;
        }
        function _denseDot(a3, b3) {
          var N3 = _validateDim(a3, b3);
          var adata = isMatrix(a3) ? a3._data : a3;
          var adt = isMatrix(a3) ? a3._datatype : void 0;
          var bdata = isMatrix(b3) ? b3._data : b3;
          var bdt = isMatrix(b3) ? b3._datatype : void 0;
          var aIsColumn = _size(a3).length === 2;
          var bIsColumn = _size(b3).length === 2;
          var add3 = addScalar2;
          var mul2 = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string") {
            var dt = adt;
            add3 = typed3.find(addScalar2, [dt, dt]);
            mul2 = typed3.find(multiplyScalar2, [dt, dt]);
          }
          if (!aIsColumn && !bIsColumn) {
            var c3 = mul2(conj2(adata[0]), bdata[0]);
            for (var i5 = 1; i5 < N3; i5++) {
              c3 = add3(c3, mul2(conj2(adata[i5]), bdata[i5]));
            }
            return c3;
          }
          if (!aIsColumn && bIsColumn) {
            var _c = mul2(conj2(adata[0]), bdata[0][0]);
            for (var _i = 1; _i < N3; _i++) {
              _c = add3(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
            }
            return _c;
          }
          if (aIsColumn && !bIsColumn) {
            var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
            for (var _i2 = 1; _i2 < N3; _i2++) {
              _c2 = add3(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
            }
            return _c2;
          }
          if (aIsColumn && bIsColumn) {
            var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
            for (var _i3 = 1; _i3 < N3; _i3++) {
              _c3 = add3(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
            }
            return _c3;
          }
        }
        function _sparseDot(x4, y3) {
          _validateDim(x4, y3);
          var xindex = x4._index;
          var xvalues = x4._values;
          var yindex = y3._index;
          var yvalues = y3._values;
          var c3 = 0;
          var add3 = addScalar2;
          var mul2 = multiplyScalar2;
          var i5 = 0;
          var j4 = 0;
          while (i5 < xindex.length && j4 < yindex.length) {
            var I3 = xindex[i5];
            var J2 = yindex[j4];
            if (I3 < J2) {
              i5++;
              continue;
            }
            if (I3 > J2) {
              j4++;
              continue;
            }
            if (I3 === J2) {
              c3 = add3(c3, mul2(xvalues[i5], yvalues[j4]));
              i5++;
              j4++;
            }
          }
          return c3;
        }
        function _size(x4) {
          return isMatrix(x4) ? x4.size() : size2(x4);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/trace.js
  var name203, dependencies203, createTrace;
  var init_trace = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/trace.js"() {
      init_object();
      init_string();
      init_factory();
      name203 = "trace";
      dependencies203 = ["typed", "matrix", "add"];
      createTrace = /* @__PURE__ */ factory(name203, dependencies203, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          add: add3
        } = _ref;
        return typed3("trace", {
          Array: function _arrayTrace(x4) {
            return _denseTrace(matrix2(x4));
          },
          SparseMatrix: _sparseTrace,
          DenseMatrix: _denseTrace,
          any: clone
        });
        function _denseTrace(m3) {
          var size2 = m3._size;
          var data = m3._data;
          switch (size2.length) {
            case 1:
              if (size2[0] === 1) {
                return clone(data[0]);
              }
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            case 2: {
              var rows = size2[0];
              var cols = size2[1];
              if (rows === cols) {
                var sum3 = 0;
                for (var i5 = 0; i5 < rows; i5++) {
                  sum3 = add3(sum3, data[i5][i5]);
                }
                return sum3;
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
              }
            }
            default:
              throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
          }
        }
        function _sparseTrace(m3) {
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          var size2 = m3._size;
          var rows = size2[0];
          var columns = size2[1];
          if (rows === columns) {
            var sum3 = 0;
            if (values.length > 0) {
              for (var j4 = 0; j4 < columns; j4++) {
                var k0 = ptr[j4];
                var k1 = ptr[j4 + 1];
                for (var k4 = k0; k4 < k1; k4++) {
                  var i5 = index2[k4];
                  if (i5 === j4) {
                    sum3 = add3(sum3, values[k4]);
                    break;
                  }
                  if (i5 > j4) {
                    break;
                  }
                }
              }
            }
            return sum3;
          }
          throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/index.js
  var name204, dependencies204, createIndex;
  var init_function2 = __esm({
    "node_modules/mathjs/lib/esm/type/matrix/function/index.js"() {
      init_is();
      init_factory();
      name204 = "index";
      dependencies204 = ["typed", "Index"];
      createIndex = /* @__PURE__ */ factory(name204, dependencies204, (_ref) => {
        var {
          typed: typed3,
          Index: Index2
        } = _ref;
        return typed3(name204, {
          "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
            var ranges = args.map(function(arg2) {
              if (isBigNumber(arg2)) {
                return arg2.toNumber();
              } else if (isArray(arg2) || isMatrix(arg2)) {
                return arg2.map(function(elem) {
                  return isBigNumber(elem) ? elem.toNumber() : elem;
                });
              } else {
                return arg2;
              }
            });
            var res = new Index2();
            Index2.apply(res, ranges);
            return res;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/keywords.js
  var keywords;
  var init_keywords = __esm({
    "node_modules/mathjs/lib/esm/expression/keywords.js"() {
      keywords = /* @__PURE__ */ new Set(["end"]);
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/Node.js
  var name205, dependencies205, createNode;
  var init_Node = __esm({
    "node_modules/mathjs/lib/esm/expression/node/Node.js"() {
      init_is();
      init_keywords();
      init_object();
      init_factory();
      init_map();
      name205 = "Node";
      dependencies205 = ["mathWithTransform"];
      createNode = /* @__PURE__ */ factory(name205, dependencies205, (_ref) => {
        var {
          mathWithTransform: mathWithTransform2
        } = _ref;
        function _validateScope(scope) {
          for (var symbol of [...keywords]) {
            if (scope.has(symbol)) {
              throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
            }
          }
        }
        class Node2 {
          get type() {
            return "Node";
          }
          get isNode() {
            return true;
          }
          /**
           * Evaluate the node
           * @param {Object} [scope]  Scope to read/write variables
           * @return {*}              Returns the result
           */
          evaluate(scope) {
            return this.compile().evaluate(scope);
          }
          /**
           * Compile the node into an optimized, evauatable JavaScript function
           * @return {{evaluate: function([Object])}} object
           *                Returns an object with a function 'evaluate',
           *                which can be invoked as expr.evaluate([scope: Object]),
           *                where scope is an optional object with
           *                variables.
           */
          compile() {
            var expr = this._compile(mathWithTransform2, {});
            var args = {};
            var context = null;
            function evaluate2(scope) {
              var s3 = createMap(scope);
              _validateScope(s3);
              return expr(s3, args, context);
            }
            return {
              evaluate: evaluate2
            };
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            throw new Error("Method _compile must be implemented by type " + this.type);
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            throw new Error("Cannot run forEach on a Node interface");
          }
          /**
           * Create a new Node whose children are the results of calling the
           * provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {OperatorNode} Returns a transformed copy of the node
           */
          map(callback) {
            throw new Error("Cannot run map on a Node interface");
          }
          /**
           * Validate whether an object is a Node, for use with map
           * @param {Node} node
           * @returns {Node} Returns the input if it's a node, else throws an Error
           * @protected
           */
          _ifNode(node) {
            if (!isNode(node)) {
              throw new TypeError("Callback function must return a Node");
            }
            return node;
          }
          /**
           * Recursively traverse all nodes in a node tree. Executes given callback for
           * this node and each of its child nodes.
           * @param {function(node: Node, path: string, parent: Node)} callback
           *          A callback called for every node in the node tree.
           */
          traverse(callback) {
            callback(this, null, null);
            function _traverse(node, callback2) {
              node.forEach(function(child, path, parent) {
                callback2(child, path, parent);
                _traverse(child, callback2);
              });
            }
            _traverse(this, callback);
          }
          /**
           * Recursively transform a node tree via a transform function.
           *
           * For example, to replace all nodes of type SymbolNode having name 'x' with
           * a ConstantNode with value 2:
           *
           *     const res = Node.transform(function (node, path, parent) {
           *       if (node && node.isSymbolNode) && (node.name === 'x')) {
           *         return new ConstantNode(2)
           *       }
           *       else {
           *         return node
           *       }
           *     })
           *
           * @param {function(node: Node, path: string, parent: Node) : Node} callback
           *          A mapping function accepting a node, and returning
           *          a replacement for the node or the original node. The "signature"
           *          of the callback must be:
           *          callback(node: Node, index: string, parent: Node) : Node
           * @return {Node} Returns the original node or its replacement
           */
          transform(callback) {
            function _transform(child, path, parent) {
              var replacement = callback(child, path, parent);
              if (replacement !== child) {
                return replacement;
              }
              return child.map(_transform);
            }
            return _transform(this, null, null);
          }
          /**
           * Find any node in the node tree matching given filter function. For
           * example, to find all nodes of type SymbolNode having name 'x':
           *
           *     const results = Node.filter(function (node) {
           *       return (node && node.isSymbolNode) && (node.name === 'x')
           *     })
           *
           * @param {function(node: Node, path: string, parent: Node) : Node} callback
           *            A test function returning true when a node matches, and false
           *            otherwise. Function signature:
           *            callback(node: Node, index: string, parent: Node) : boolean
           * @return {Node[]} nodes
           *            An array with nodes matching given filter criteria
           */
          filter(callback) {
            var nodes = [];
            this.traverse(function(node, path, parent) {
              if (callback(node, path, parent)) {
                nodes.push(node);
              }
            });
            return nodes;
          }
          /**
           * Create a shallow clone of this node
           * @return {Node}
           */
          clone() {
            throw new Error("Cannot clone a Node interface");
          }
          /**
           * Create a deep clone of this node
           * @return {Node}
           */
          cloneDeep() {
            return this.map(function(node) {
              return node.cloneDeep();
            });
          }
          /**
           * Deep compare this node with another node.
           * @param {Node} other
           * @return {boolean} Returns true when both nodes are of the same type and
           *                   contain the same values (as do their childs)
           */
          equals(other) {
            return other ? this.type === other.type && deepStrictEqual(this, other) : false;
          }
          /**
           * Get string representation. (wrapper function)
           *
           * This function can get an object of the following form:
           * {
           *    handler: //This can be a callback function of the form
           *             // "function callback(node, options)"or
           *             // a map that maps function names (used in FunctionNodes)
           *             // to callbacks
           *    parenthesis: "keep" //the parenthesis option (This is optional)
           * }
           *
           * @param {Object} [options]
           * @return {string}
           */
          toString(options) {
            var customString = this._getCustomString(options);
            if (typeof customString !== "undefined") {
              return customString;
            }
            return this._toString(options);
          }
          /**
           * Get a JSON representation of the node
           * Both .toJSON() and the static .fromJSON(json) should be implemented by all
           * implementations of Node
           * @returns {Object}
           */
          toJSON() {
            throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
          }
          /**
           * Get HTML representation. (wrapper function)
           *
           * This function can get an object of the following form:
           * {
           *    handler: //This can be a callback function of the form
           *             // "function callback(node, options)" or
           *             // a map that maps function names (used in FunctionNodes)
           *             // to callbacks
           *    parenthesis: "keep" //the parenthesis option (This is optional)
           * }
           *
           * @param {Object} [options]
           * @return {string}
           */
          toHTML(options) {
            var customString = this._getCustomString(options);
            if (typeof customString !== "undefined") {
              return customString;
            }
            return this.toHTML(options);
          }
          /**
           * Internal function to generate the string output.
           * This has to be implemented by every Node
           *
           * @throws {Error}
           */
          _toString() {
            throw new Error("_toString not implemented for " + this.type);
          }
          /**
           * Get LaTeX representation. (wrapper function)
           *
           * This function can get an object of the following form:
           * {
           *    handler: //This can be a callback function of the form
           *             // "function callback(node, options)"or
           *             // a map that maps function names (used in FunctionNodes)
           *             // to callbacks
           *    parenthesis: "keep" //the parenthesis option (This is optional)
           * }
           *
           * @param {Object} [options]
           * @return {string}
           */
          toTex(options) {
            var customString = this._getCustomString(options);
            if (typeof customString !== "undefined") {
              return customString;
            }
            return this._toTex(options);
          }
          /**
           * Internal function to generate the LaTeX output.
           * This has to be implemented by every Node
           *
           * @param {Object} [options]
           * @throws {Error}
           */
          _toTex(options) {
            throw new Error("_toTex not implemented for " + this.type);
          }
          /**
           * Helper used by `to...` functions.
           */
          _getCustomString(options) {
            if (options && typeof options === "object") {
              switch (typeof options.handler) {
                case "object":
                case "undefined":
                  return;
                case "function":
                  return options.handler(this, options);
                default:
                  throw new TypeError("Object or function expected as callback");
              }
            }
          }
          /**
           * Get identifier.
           * @return {string}
           */
          getIdentifier() {
            return this.type;
          }
          /**
           * Get the content of the current Node.
           * @return {Node} node
           **/
          getContent() {
            return this;
          }
        }
        return Node2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
  function errorTransform(err) {
    if (err && err.isIndexError) {
      return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
    }
    return err;
  }
  var init_errorTransform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js"() {
      init_IndexError();
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/utils/access.js
  function accessFactory(_ref) {
    var {
      subset: subset2
    } = _ref;
    return function access(object, index2) {
      try {
        if (Array.isArray(object)) {
          return subset2(object, index2);
        } else if (object && typeof object.subset === "function") {
          return object.subset(index2);
        } else if (typeof object === "string") {
          return subset2(object, index2);
        } else if (typeof object === "object") {
          if (!index2.isObjectProperty()) {
            throw new TypeError("Cannot apply a numeric index as object property");
          }
          return getSafeProperty(object, index2.getObjectProperty());
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }
  var init_access = __esm({
    "node_modules/mathjs/lib/esm/expression/node/utils/access.js"() {
      init_errorTransform();
      init_customs();
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
  var name206, dependencies206, createAccessorNode;
  var init_AccessorNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/AccessorNode.js"() {
      init_defineProperty();
      init_is();
      init_customs();
      init_factory();
      init_access();
      name206 = "AccessorNode";
      dependencies206 = ["subset", "Node"];
      createAccessorNode = /* @__PURE__ */ factory(name206, dependencies206, (_ref) => {
        var {
          subset: subset2,
          Node: Node2
        } = _ref;
        var access = accessFactory({
          subset: subset2
        });
        function needParenthesis(node) {
          return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
        }
        class AccessorNode2 extends Node2 {
          /**
           * @constructor AccessorNode
           * @extends {Node}
           * Access an object property or get a matrix subset
           *
           * @param {Node} object                 The object from which to retrieve
           *                                      a property or subset.
           * @param {IndexNode} index             IndexNode containing ranges
           */
          constructor(object, index2) {
            super();
            if (!isNode(object)) {
              throw new TypeError('Node expected for parameter "object"');
            }
            if (!isIndexNode(index2)) {
              throw new TypeError('IndexNode expected for parameter "index"');
            }
            this.object = object;
            this.index = index2;
          }
          // readonly property name
          get name() {
            if (this.index) {
              return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
            } else {
              return this.object.name || "";
            }
          }
          get type() {
            return name206;
          }
          get isAccessorNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalObject = this.object._compile(math2, argNames);
            var evalIndex = this.index._compile(math2, argNames);
            if (this.index.isObjectProperty()) {
              var prop = this.index.getObjectProperty();
              return function evalAccessorNode(scope, args, context) {
                return getSafeProperty(evalObject(scope, args, context), prop);
              };
            } else {
              return function evalAccessorNode(scope, args, context) {
                var object = evalObject(scope, args, context);
                var index2 = evalIndex(scope, args, object);
                return access(object, index2);
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.object, "object", this);
            callback(this.index, "index", this);
          }
          /**
           * Create a new AccessorNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {AccessorNode} Returns a transformed copy of the node
           */
          map(callback) {
            return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {AccessorNode}
           */
          clone() {
            return new AccessorNode2(this.object, this.index);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string}
           */
          _toString(options) {
            var object = this.object.toString(options);
            if (needParenthesis(this.object)) {
              object = "(" + object + ")";
            }
            return object + this.index.toString(options);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string}
           */
          toHTML(options) {
            var object = this.object.toHTML(options);
            if (needParenthesis(this.object)) {
              object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return object + this.index.toHTML(options);
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string}
           */
          _toTex(options) {
            var object = this.object.toTex(options);
            if (needParenthesis(this.object)) {
              object = "\\left(' + object + '\\right)";
            }
            return object + this.index.toTex(options);
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name206,
              object: this.object,
              index: this.index
            };
          }
          /**
           * Instantiate an AccessorNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
           *     where mathjs is optional
           * @returns {AccessorNode}
           */
          static fromJSON(json) {
            return new AccessorNode2(json.object, json.index);
          }
        }
        _defineProperty(AccessorNode2, "name", name206);
        return AccessorNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
  var name207, dependencies207, createArrayNode;
  var init_ArrayNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"() {
      init_defineProperty();
      init_is();
      init_array();
      init_factory();
      name207 = "ArrayNode";
      dependencies207 = ["Node"];
      createArrayNode = /* @__PURE__ */ factory(name207, dependencies207, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        class ArrayNode2 extends Node2 {
          /**
           * @constructor ArrayNode
           * @extends {Node}
           * Holds an 1-dimensional array with items
           * @param {Node[]} [items]   1 dimensional array with items
           */
          constructor(items) {
            super();
            this.items = items || [];
            if (!Array.isArray(this.items) || !this.items.every(isNode)) {
              throw new TypeError("Array containing Nodes expected");
            }
          }
          get type() {
            return name207;
          }
          get isArrayNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalItems = map(this.items, function(item) {
              return item._compile(math2, argNames);
            });
            var asMatrix = math2.config.matrix !== "Array";
            if (asMatrix) {
              var matrix2 = math2.matrix;
              return function evalArrayNode(scope, args, context) {
                return matrix2(map(evalItems, function(evalItem) {
                  return evalItem(scope, args, context);
                }));
              };
            } else {
              return function evalArrayNode(scope, args, context) {
                return map(evalItems, function(evalItem) {
                  return evalItem(scope, args, context);
                });
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            for (var i5 = 0; i5 < this.items.length; i5++) {
              var node = this.items[i5];
              callback(node, "items[" + i5 + "]", this);
            }
          }
          /**
           * Create a new ArrayNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {ArrayNode} Returns a transformed copy of the node
           */
          map(callback) {
            var items = [];
            for (var i5 = 0; i5 < this.items.length; i5++) {
              items[i5] = this._ifNode(callback(this.items[i5], "items[" + i5 + "]", this));
            }
            return new ArrayNode2(items);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {ArrayNode}
           */
          clone() {
            return new ArrayNode2(this.items.slice(0));
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toString(options) {
            var items = this.items.map(function(node) {
              return node.toString(options);
            });
            return "[" + items.join(", ") + "]";
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name207,
              items: this.items
            };
          }
          /**
           * Instantiate an ArrayNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "ArrayNode", items: [...]}`,
           *                       where mathjs is optional
           * @returns {ArrayNode}
           */
          static fromJSON(json) {
            return new ArrayNode2(json.items);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toHTML(options) {
            var items = this.items.map(function(node) {
              return node.toHTML(options);
            });
            return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            function itemsToTex(items, nested) {
              var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
              var itemsFormRow = nested || mixedItems;
              var itemSep = itemsFormRow ? "&" : "\\\\";
              var itemsTex = items.map(function(node) {
                if (node.items) {
                  return itemsToTex(node.items, !nested);
                } else {
                  return node.toTex(options);
                }
              }).join(itemSep);
              return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
            }
            return itemsToTex(this.items, false);
          }
        }
        _defineProperty(ArrayNode2, "name", name207);
        return ArrayNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/utils/assign.js
  function assignFactory(_ref) {
    var {
      subset: subset2,
      matrix: matrix2
    } = _ref;
    return function assign2(object, index2, value) {
      try {
        if (Array.isArray(object)) {
          var result = matrix2(object).subset(index2, value).valueOf();
          result.forEach((item, index3) => {
            object[index3] = item;
          });
          return object;
        } else if (object && typeof object.subset === "function") {
          return object.subset(index2, value);
        } else if (typeof object === "string") {
          return subset2(object, index2, value);
        } else if (typeof object === "object") {
          if (!index2.isObjectProperty()) {
            throw TypeError("Cannot apply a numeric index as object property");
          }
          setSafeProperty(object, index2.getObjectProperty(), value);
          return object;
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }
  var init_assign = __esm({
    "node_modules/mathjs/lib/esm/expression/node/utils/assign.js"() {
      init_errorTransform();
      init_customs();
    }
  });

  // node_modules/mathjs/lib/esm/expression/operators.js
  function unwrapParen(_node, parenthesis) {
    if (!parenthesis || parenthesis !== "auto")
      return _node;
    var node = _node;
    while (isParenthesisNode(node))
      node = node.content;
    return node;
  }
  function getPrecedence(_node, parenthesis, implicit, parent) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var precedence = null;
    for (var i5 = 0; i5 < properties.length; i5++) {
      if (identifier in properties[i5]) {
        precedence = i5;
        break;
      }
    }
    if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
      var leftArg = unwrapParen(node.args[0], parenthesis);
      if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
        precedence += 1;
      }
    }
    return precedence;
  }
  function getAssociativity(_node, parenthesis) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var index2 = getPrecedence(node, parenthesis);
    if (index2 === null) {
      return null;
    }
    var property = properties[index2][identifier];
    if (hasOwnProperty2(property, "associativity")) {
      if (property.associativity === "left") {
        return "left";
      }
      if (property.associativity === "right") {
        return "right";
      }
      throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
    }
    return null;
  }
  function isAssociativeWith(nodeA, nodeB, parenthesis) {
    var a3 = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
    var b3 = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
    var identifierA = a3.getIdentifier();
    var identifierB = b3.getIdentifier();
    var index2 = getPrecedence(a3, parenthesis);
    if (index2 === null) {
      return null;
    }
    var property = properties[index2][identifierA];
    if (hasOwnProperty2(property, "associativeWith") && property.associativeWith instanceof Array) {
      for (var i5 = 0; i5 < property.associativeWith.length; i5++) {
        if (property.associativeWith[i5] === identifierB) {
          return true;
        }
      }
      return false;
    }
    return null;
  }
  function getOperator(fn2) {
    var identifier = "OperatorNode:" + fn2;
    for (var group of properties) {
      if (identifier in group) {
        return group[identifier].op;
      }
    }
    return null;
  }
  var properties;
  var init_operators = __esm({
    "node_modules/mathjs/lib/esm/expression/operators.js"() {
      init_object();
      init_is();
      properties = [{
        // assignment
        AssignmentNode: {},
        FunctionAssignmentNode: {}
      }, {
        // conditional expression
        ConditionalNode: {
          latexLeftParens: false,
          latexRightParens: false,
          latexParens: false
          // conditionals don't need parentheses in LaTeX because
          // they are 2 dimensional
        }
      }, {
        // logical or
        "OperatorNode:or": {
          op: "or",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // logical xor
        "OperatorNode:xor": {
          op: "xor",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // logical and
        "OperatorNode:and": {
          op: "and",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise or
        "OperatorNode:bitOr": {
          op: "|",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise xor
        "OperatorNode:bitXor": {
          op: "^|",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise and
        "OperatorNode:bitAnd": {
          op: "&",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // relational operators
        "OperatorNode:equal": {
          op: "==",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:unequal": {
          op: "!=",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:smaller": {
          op: "<",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:larger": {
          op: ">",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:smallerEq": {
          op: "<=",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:largerEq": {
          op: ">=",
          associativity: "left",
          associativeWith: []
        },
        RelationalNode: {
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitshift operators
        "OperatorNode:leftShift": {
          op: "<<",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:rightArithShift": {
          op: ">>",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:rightLogShift": {
          op: ">>>",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // unit conversion
        "OperatorNode:to": {
          op: "to",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // range
        RangeNode: {}
      }, {
        // addition, subtraction
        "OperatorNode:add": {
          op: "+",
          associativity: "left",
          associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
        },
        "OperatorNode:subtract": {
          op: "-",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // multiply, divide, modulus
        "OperatorNode:multiply": {
          op: "*",
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
        },
        "OperatorNode:divide": {
          op: "/",
          associativity: "left",
          associativeWith: [],
          latexLeftParens: false,
          latexRightParens: false,
          latexParens: false
          // fractions don't require parentheses because
          // they're 2 dimensional, so parens aren't needed
          // in LaTeX
        },
        "OperatorNode:dotMultiply": {
          op: ".*",
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
        },
        "OperatorNode:dotDivide": {
          op: "./",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:mod": {
          op: "mod",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // Repeat multiplication for implicit multiplication
        "OperatorNode:multiply": {
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
        }
      }, {
        // unary prefix operators
        "OperatorNode:unaryPlus": {
          op: "+",
          associativity: "right"
        },
        "OperatorNode:unaryMinus": {
          op: "-",
          associativity: "right"
        },
        "OperatorNode:bitNot": {
          op: "~",
          associativity: "right"
        },
        "OperatorNode:not": {
          op: "not",
          associativity: "right"
        }
      }, {
        // exponentiation
        "OperatorNode:pow": {
          op: "^",
          associativity: "right",
          associativeWith: [],
          latexRightParens: false
          // the exponent doesn't need parentheses in
          // LaTeX because it's 2 dimensional
          // (it's on top)
        },
        "OperatorNode:dotPow": {
          op: ".^",
          associativity: "right",
          associativeWith: []
        }
      }, {
        // factorial
        "OperatorNode:factorial": {
          op: "!",
          associativity: "left"
        }
      }, {
        // matrix transpose
        "OperatorNode:ctranspose": {
          op: "'",
          associativity: "left"
        }
      }];
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
  var name208, dependencies208, createAssignmentNode;
  var init_AssignmentNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js"() {
      init_defineProperty();
      init_is();
      init_customs();
      init_factory();
      init_access();
      init_assign();
      init_operators();
      name208 = "AssignmentNode";
      dependencies208 = [
        "subset",
        "?matrix",
        // FIXME: should not be needed at all, should be handled by subset
        "Node"
      ];
      createAssignmentNode = /* @__PURE__ */ factory(name208, dependencies208, (_ref) => {
        var {
          subset: subset2,
          matrix: matrix2,
          Node: Node2
        } = _ref;
        var access = accessFactory({
          subset: subset2
        });
        var assign2 = assignFactory({
          subset: subset2,
          matrix: matrix2
        });
        function needParenthesis(node, parenthesis, implicit) {
          if (!parenthesis) {
            parenthesis = "keep";
          }
          var precedence = getPrecedence(node, parenthesis, implicit);
          var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
          return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
        }
        class AssignmentNode2 extends Node2 {
          /**
           * @constructor AssignmentNode
           * @extends {Node}
           *
           * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
           * replace a subset of a matrix like `A[2,2]=42`.
           *
           * Syntax:
           *
           *     new AssignmentNode(symbol, value)
           *     new AssignmentNode(object, index, value)
           *
           * Usage:
           *
           *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
           *    new AssignmentNode(new SymbolNode('a'),
           *                       new IndexNode('b'),
           *                       new ConstantNode(2))   // a.b=2
           *    new AssignmentNode(new SymbolNode('a'),
           *                       new IndexNode(1, 2),
           *                       new ConstantNode(3))  // a[1,2]=3
           *
           * @param {SymbolNode | AccessorNode} object
           *     Object on which to assign a value
           * @param {IndexNode} [index=null]
           *     Index, property name or matrix index. Optional. If not provided
           *     and `object` is a SymbolNode, the property is assigned to the
           *     global scope.
           * @param {Node} value
           *     The value to be assigned
           */
          constructor(object, index2, value) {
            super();
            this.object = object;
            this.index = value ? index2 : null;
            this.value = value || index2;
            if (!isSymbolNode(object) && !isAccessorNode(object)) {
              throw new TypeError('SymbolNode or AccessorNode expected as "object"');
            }
            if (isSymbolNode(object) && object.name === "end") {
              throw new Error('Cannot assign to symbol "end"');
            }
            if (this.index && !isIndexNode(this.index)) {
              throw new TypeError('IndexNode expected as "index"');
            }
            if (!isNode(this.value)) {
              throw new TypeError('Node expected as "value"');
            }
          }
          // class name for typing purposes:
          // readonly property name
          get name() {
            if (this.index) {
              return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
            } else {
              return this.object.name || "";
            }
          }
          get type() {
            return name208;
          }
          get isAssignmentNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalObject = this.object._compile(math2, argNames);
            var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
            var evalValue = this.value._compile(math2, argNames);
            var name307 = this.object.name;
            if (!this.index) {
              if (!isSymbolNode(this.object)) {
                throw new TypeError("SymbolNode expected as object");
              }
              return function evalAssignmentNode(scope, args, context) {
                var value = evalValue(scope, args, context);
                scope.set(name307, value);
                return value;
              };
            } else if (this.index.isObjectProperty()) {
              var prop = this.index.getObjectProperty();
              return function evalAssignmentNode(scope, args, context) {
                var object = evalObject(scope, args, context);
                var value = evalValue(scope, args, context);
                setSafeProperty(object, prop, value);
                return value;
              };
            } else if (isSymbolNode(this.object)) {
              return function evalAssignmentNode(scope, args, context) {
                var childObject = evalObject(scope, args, context);
                var value = evalValue(scope, args, context);
                var index2 = evalIndex(scope, args, childObject);
                scope.set(name307, assign2(childObject, index2, value));
                return value;
              };
            } else {
              var evalParentObject = this.object.object._compile(math2, argNames);
              if (this.object.index.isObjectProperty()) {
                var parentProp = this.object.index.getObjectProperty();
                return function evalAssignmentNode(scope, args, context) {
                  var parent = evalParentObject(scope, args, context);
                  var childObject = getSafeProperty(parent, parentProp);
                  var index2 = evalIndex(scope, args, childObject);
                  var value = evalValue(scope, args, context);
                  setSafeProperty(parent, parentProp, assign2(childObject, index2, value));
                  return value;
                };
              } else {
                var evalParentIndex = this.object.index._compile(math2, argNames);
                return function evalAssignmentNode(scope, args, context) {
                  var parent = evalParentObject(scope, args, context);
                  var parentIndex = evalParentIndex(scope, args, parent);
                  var childObject = access(parent, parentIndex);
                  var index2 = evalIndex(scope, args, childObject);
                  var value = evalValue(scope, args, context);
                  assign2(parent, parentIndex, assign2(childObject, index2, value));
                  return value;
                };
              }
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.object, "object", this);
            if (this.index) {
              callback(this.index, "index", this);
            }
            callback(this.value, "value", this);
          }
          /**
           * Create a new AssignmentNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {AssignmentNode} Returns a transformed copy of the node
           */
          map(callback) {
            var object = this._ifNode(callback(this.object, "object", this));
            var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
            var value = this._ifNode(callback(this.value, "value", this));
            return new AssignmentNode2(object, index2, value);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {AssignmentNode}
           */
          clone() {
            return new AssignmentNode2(this.object, this.index, this.value);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string}
           */
          _toString(options) {
            var object = this.object.toString(options);
            var index2 = this.index ? this.index.toString(options) : "";
            var value = this.value.toString(options);
            if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
              value = "(" + value + ")";
            }
            return object + index2 + " = " + value;
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name208,
              object: this.object,
              index: this.index,
              value: this.value
            };
          }
          /**
           * Instantiate an AssignmentNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
           *     where mathjs is optional
           * @returns {AssignmentNode}
           */
          static fromJSON(json) {
            return new AssignmentNode2(json.object, json.index, json.value);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string}
           */
          toHTML(options) {
            var object = this.object.toHTML(options);
            var index2 = this.index ? this.index.toHTML(options) : "";
            var value = this.value.toHTML(options);
            if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
              value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
            }
            return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string}
           */
          _toTex(options) {
            var object = this.object.toTex(options);
            var index2 = this.index ? this.index.toTex(options) : "";
            var value = this.value.toTex(options);
            if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
              value = "\\left(".concat(value, "\\right)");
            }
            return object + index2 + ":=" + value;
          }
        }
        _defineProperty(AssignmentNode2, "name", name208);
        return AssignmentNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/BlockNode.js
  var name209, dependencies209, createBlockNode;
  var init_BlockNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/BlockNode.js"() {
      init_defineProperty();
      init_is();
      init_array();
      init_factory();
      name209 = "BlockNode";
      dependencies209 = ["ResultSet", "Node"];
      createBlockNode = /* @__PURE__ */ factory(name209, dependencies209, (_ref) => {
        var {
          ResultSet: ResultSet2,
          Node: Node2
        } = _ref;
        class BlockNode2 extends Node2 {
          /**
           * @constructor BlockNode
           * @extends {Node}
           * Holds a set with blocks
           * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
           *            An array with blocks, where a block is constructed as an
           *            Object with properties block, which is a Node, and visible,
           *            which is a boolean. The property visible is optional and
           *            is true by default
           */
          constructor(blocks) {
            super();
            if (!Array.isArray(blocks))
              throw new Error("Array expected");
            this.blocks = blocks.map(function(block) {
              var node = block && block.node;
              var visible = block && block.visible !== void 0 ? block.visible : true;
              if (!isNode(node))
                throw new TypeError('Property "node" must be a Node');
              if (typeof visible !== "boolean") {
                throw new TypeError('Property "visible" must be a boolean');
              }
              return {
                node,
                visible
              };
            });
          }
          get type() {
            return name209;
          }
          get isBlockNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalBlocks = map(this.blocks, function(block) {
              return {
                evaluate: block.node._compile(math2, argNames),
                visible: block.visible
              };
            });
            return function evalBlockNodes(scope, args, context) {
              var results = [];
              forEach(evalBlocks, function evalBlockNode(block) {
                var result = block.evaluate(scope, args, context);
                if (block.visible) {
                  results.push(result);
                }
              });
              return new ResultSet2(results);
            };
          }
          /**
           * Execute a callback for each of the child blocks of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            for (var i5 = 0; i5 < this.blocks.length; i5++) {
              callback(this.blocks[i5].node, "blocks[" + i5 + "].node", this);
            }
          }
          /**
           * Create a new BlockNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {BlockNode} Returns a transformed copy of the node
           */
          map(callback) {
            var blocks = [];
            for (var i5 = 0; i5 < this.blocks.length; i5++) {
              var block = this.blocks[i5];
              var node = this._ifNode(callback(block.node, "blocks[" + i5 + "].node", this));
              blocks[i5] = {
                node,
                visible: block.visible
              };
            }
            return new BlockNode2(blocks);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {BlockNode}
           */
          clone() {
            var blocks = this.blocks.map(function(block) {
              return {
                node: block.node,
                visible: block.visible
              };
            });
            return new BlockNode2(blocks);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toString(options) {
            return this.blocks.map(function(param) {
              return param.node.toString(options) + (param.visible ? "" : ";");
            }).join("\n");
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name209,
              blocks: this.blocks
            };
          }
          /**
           * Instantiate an BlockNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
           *     where mathjs is optional
           * @returns {BlockNode}
           */
          static fromJSON(json) {
            return new BlockNode2(json.blocks);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toHTML(options) {
            return this.blocks.map(function(param) {
              return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
            }).join('<span class="math-separator"><br /></span>');
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            return this.blocks.map(function(param) {
              return param.node.toTex(options) + (param.visible ? "" : ";");
            }).join("\\;\\;\n");
          }
        }
        _defineProperty(BlockNode2, "name", name209);
        return BlockNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
  var name210, dependencies210, createConditionalNode;
  var init_ConditionalNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"() {
      init_defineProperty();
      init_is();
      init_factory();
      init_operators();
      name210 = "ConditionalNode";
      dependencies210 = ["Node"];
      createConditionalNode = /* @__PURE__ */ factory(name210, dependencies210, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        function testCondition(condition) {
          if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
            return !!condition;
          }
          if (condition) {
            if (isBigNumber(condition)) {
              return !condition.isZero();
            }
            if (isComplex(condition)) {
              return !!(condition.re || condition.im);
            }
            if (isUnit(condition)) {
              return !!condition.value;
            }
          }
          if (condition === null || condition === void 0) {
            return false;
          }
          throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
        }
        class ConditionalNode2 extends Node2 {
          /**
           * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
           *
           * @param {Node} condition   Condition, must result in a boolean
           * @param {Node} trueExpr    Expression evaluated when condition is true
           * @param {Node} falseExpr   Expression evaluated when condition is true
           *
           * @constructor ConditionalNode
           * @extends {Node}
           */
          constructor(condition, trueExpr, falseExpr) {
            super();
            if (!isNode(condition)) {
              throw new TypeError("Parameter condition must be a Node");
            }
            if (!isNode(trueExpr)) {
              throw new TypeError("Parameter trueExpr must be a Node");
            }
            if (!isNode(falseExpr)) {
              throw new TypeError("Parameter falseExpr must be a Node");
            }
            this.condition = condition;
            this.trueExpr = trueExpr;
            this.falseExpr = falseExpr;
          }
          get type() {
            return name210;
          }
          get isConditionalNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalCondition = this.condition._compile(math2, argNames);
            var evalTrueExpr = this.trueExpr._compile(math2, argNames);
            var evalFalseExpr = this.falseExpr._compile(math2, argNames);
            return function evalConditionalNode(scope, args, context) {
              return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.condition, "condition", this);
            callback(this.trueExpr, "trueExpr", this);
            callback(this.falseExpr, "falseExpr", this);
          }
          /**
           * Create a new ConditionalNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {ConditionalNode} Returns a transformed copy of the node
           */
          map(callback) {
            return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {ConditionalNode}
           */
          clone() {
            return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var precedence = getPrecedence(this, parenthesis, options && options.implicit);
            var condition = this.condition.toString(options);
            var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
              condition = "(" + condition + ")";
            }
            var trueExpr = this.trueExpr.toString(options);
            var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
              trueExpr = "(" + trueExpr + ")";
            }
            var falseExpr = this.falseExpr.toString(options);
            var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
              falseExpr = "(" + falseExpr + ")";
            }
            return condition + " ? " + trueExpr + " : " + falseExpr;
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name210,
              condition: this.condition,
              trueExpr: this.trueExpr,
              falseExpr: this.falseExpr
            };
          }
          /**
           * Instantiate an ConditionalNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     ```
           *     {"mathjs": "ConditionalNode",
           *      "condition": ...,
           *      "trueExpr": ...,
           *      "falseExpr": ...}
           *     ```
           *     where mathjs is optional
           * @returns {ConditionalNode}
           */
          static fromJSON(json) {
            return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var precedence = getPrecedence(this, parenthesis, options && options.implicit);
            var condition = this.condition.toHTML(options);
            var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
              condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            var trueExpr = this.trueExpr.toHTML(options);
            var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
              trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            var falseExpr = this.falseExpr.toHTML(options);
            var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
            if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
              falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
          }
        }
        _defineProperty(ConditionalNode2, "name", name210);
        return ConditionalNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/escape-latex/dist/index.js
  var require_dist = __commonJS({
    "node_modules/escape-latex/dist/index.js"(exports, module) {
      "use strict";
      var _extends2 = Object.assign || function(target) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          var source = arguments[i5];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var defaultEscapes = {
        "{": "\\{",
        "}": "\\}",
        "\\": "\\textbackslash{}",
        "#": "\\#",
        $: "\\$",
        "%": "\\%",
        "&": "\\&",
        "^": "\\textasciicircum{}",
        _: "\\_",
        "~": "\\textasciitilde{}"
      };
      var formatEscapes = {
        "\u2013": "\\--",
        "\u2014": "\\---",
        " ": "~",
        "	": "\\qquad{}",
        "\r\n": "\\newline{}",
        "\n": "\\newline{}"
      };
      var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
        return _extends2({}, defaultEscapes2, formatEscapes2);
      };
      module.exports = function(str) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
        var runningStr = String(str);
        var result = "";
        var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
        var escapeKeys = Object.keys(escapes);
        var _loop = function _loop2() {
          var specialCharFound = false;
          escapeKeys.forEach(function(key, index2) {
            if (specialCharFound) {
              return;
            }
            if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
              result += escapes[escapeKeys[index2]];
              runningStr = runningStr.slice(key.length, runningStr.length);
              specialCharFound = true;
            }
          });
          if (!specialCharFound) {
            result += runningStr.slice(0, 1);
            runningStr = runningStr.slice(1, runningStr.length);
          }
        };
        while (runningStr) {
          _loop();
        }
        return result;
      };
    }
  });

  // node_modules/mathjs/lib/esm/utils/latex.js
  function escapeLatex(string2) {
    return (0, import_escape_latex.default)(string2, {
      preserveFormatting: true
    });
  }
  function toSymbol(name307, isUnit2) {
    isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
    if (isUnit2) {
      if (hasOwnProperty2(latexUnits, name307)) {
        return latexUnits[name307];
      }
      return "\\mathrm{" + escapeLatex(name307) + "}";
    }
    if (hasOwnProperty2(latexSymbols, name307)) {
      return latexSymbols[name307];
    }
    return escapeLatex(name307);
  }
  var import_escape_latex, latexSymbols, latexOperators, latexFunctions, defaultTemplate, latexUnits;
  var init_latex = __esm({
    "node_modules/mathjs/lib/esm/utils/latex.js"() {
      import_escape_latex = __toESM(require_dist(), 1);
      init_object();
      latexSymbols = {
        // GREEK LETTERS
        Alpha: "A",
        alpha: "\\alpha",
        Beta: "B",
        beta: "\\beta",
        Gamma: "\\Gamma",
        gamma: "\\gamma",
        Delta: "\\Delta",
        delta: "\\delta",
        Epsilon: "E",
        epsilon: "\\epsilon",
        varepsilon: "\\varepsilon",
        Zeta: "Z",
        zeta: "\\zeta",
        Eta: "H",
        eta: "\\eta",
        Theta: "\\Theta",
        theta: "\\theta",
        vartheta: "\\vartheta",
        Iota: "I",
        iota: "\\iota",
        Kappa: "K",
        kappa: "\\kappa",
        varkappa: "\\varkappa",
        Lambda: "\\Lambda",
        lambda: "\\lambda",
        Mu: "M",
        mu: "\\mu",
        Nu: "N",
        nu: "\\nu",
        Xi: "\\Xi",
        xi: "\\xi",
        Omicron: "O",
        omicron: "o",
        Pi: "\\Pi",
        pi: "\\pi",
        varpi: "\\varpi",
        Rho: "P",
        rho: "\\rho",
        varrho: "\\varrho",
        Sigma: "\\Sigma",
        sigma: "\\sigma",
        varsigma: "\\varsigma",
        Tau: "T",
        tau: "\\tau",
        Upsilon: "\\Upsilon",
        upsilon: "\\upsilon",
        Phi: "\\Phi",
        phi: "\\phi",
        varphi: "\\varphi",
        Chi: "X",
        chi: "\\chi",
        Psi: "\\Psi",
        psi: "\\psi",
        Omega: "\\Omega",
        omega: "\\omega",
        // logic
        true: "\\mathrm{True}",
        false: "\\mathrm{False}",
        // other
        i: "i",
        // TODO use \i ??
        inf: "\\infty",
        Inf: "\\infty",
        infinity: "\\infty",
        Infinity: "\\infty",
        oo: "\\infty",
        lim: "\\lim",
        undefined: "\\mathbf{?}"
      };
      latexOperators = {
        transpose: "^\\top",
        ctranspose: "^H",
        factorial: "!",
        pow: "^",
        dotPow: ".^\\wedge",
        // TODO find ideal solution
        unaryPlus: "+",
        unaryMinus: "-",
        bitNot: "\\~",
        // TODO find ideal solution
        not: "\\neg",
        multiply: "\\cdot",
        divide: "\\frac",
        // TODO how to handle that properly?
        dotMultiply: ".\\cdot",
        // TODO find ideal solution
        dotDivide: ".:",
        // TODO find ideal solution
        mod: "\\mod",
        add: "+",
        subtract: "-",
        to: "\\rightarrow",
        leftShift: "<<",
        rightArithShift: ">>",
        rightLogShift: ">>>",
        equal: "=",
        unequal: "\\neq",
        smaller: "<",
        larger: ">",
        smallerEq: "\\leq",
        largerEq: "\\geq",
        bitAnd: "\\&",
        bitXor: "\\underline{|}",
        bitOr: "|",
        and: "\\wedge",
        xor: "\\veebar",
        or: "\\vee"
      };
      latexFunctions = {
        // arithmetic
        abs: {
          1: "\\left|${args[0]}\\right|"
        },
        add: {
          2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
        },
        cbrt: {
          1: "\\sqrt[3]{${args[0]}}"
        },
        ceil: {
          1: "\\left\\lceil${args[0]}\\right\\rceil"
        },
        cube: {
          1: "\\left(${args[0]}\\right)^3"
        },
        divide: {
          2: "\\frac{${args[0]}}{${args[1]}}"
        },
        dotDivide: {
          2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
        },
        dotMultiply: {
          2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
        },
        dotPow: {
          2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
        },
        exp: {
          1: "\\exp\\left(${args[0]}\\right)"
        },
        expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
        fix: {
          1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
        },
        floor: {
          1: "\\left\\lfloor${args[0]}\\right\\rfloor"
        },
        gcd: "\\gcd\\left(${args}\\right)",
        hypot: "\\hypot\\left(${args}\\right)",
        log: {
          1: "\\ln\\left(${args[0]}\\right)",
          2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
        },
        log10: {
          1: "\\log_{10}\\left(${args[0]}\\right)"
        },
        log1p: {
          1: "\\ln\\left(${args[0]}+1\\right)",
          2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
        },
        log2: "\\log_{2}\\left(${args[0]}\\right)",
        mod: {
          2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
        },
        multiply: {
          2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
        },
        norm: {
          1: "\\left\\|${args[0]}\\right\\|",
          2: void 0
          // use default template
        },
        nthRoot: {
          2: "\\sqrt[${args[1]}]{${args[0]}}"
        },
        nthRoots: {
          2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
        },
        pow: {
          2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
        },
        round: {
          1: "\\left\\lfloor${args[0]}\\right\\rceil",
          2: void 0
          // use default template
        },
        sign: {
          1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
        },
        sqrt: {
          1: "\\sqrt{${args[0]}}"
        },
        square: {
          1: "\\left(${args[0]}\\right)^2"
        },
        subtract: {
          2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
        },
        unaryMinus: {
          1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
        },
        unaryPlus: {
          1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
        },
        // bitwise
        bitAnd: {
          2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
        },
        bitNot: {
          1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
        },
        bitOr: {
          2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
        },
        bitXor: {
          2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
        },
        leftShift: {
          2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
        },
        rightArithShift: {
          2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
        },
        rightLogShift: {
          2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
        },
        // combinatorics
        bellNumbers: {
          1: "\\mathrm{B}_{${args[0]}}"
        },
        catalan: {
          1: "\\mathrm{C}_{${args[0]}}"
        },
        stirlingS2: {
          2: "\\mathrm{S}\\left(${args}\\right)"
        },
        // complex
        arg: {
          1: "\\arg\\left(${args[0]}\\right)"
        },
        conj: {
          1: "\\left(${args[0]}\\right)^*"
        },
        im: {
          1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
        },
        re: {
          1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
        },
        // logical
        and: {
          2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
        },
        not: {
          1: latexOperators.not + "\\left(${args[0]}\\right)"
        },
        or: {
          2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
        },
        xor: {
          2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
        },
        // matrix
        cross: {
          2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
        },
        ctranspose: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
        },
        det: {
          1: "\\det\\left(${args[0]}\\right)"
        },
        dot: {
          2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
        },
        expm: {
          1: "\\exp\\left(${args[0]}\\right)"
        },
        inv: {
          1: "\\left(${args[0]}\\right)^{-1}"
        },
        pinv: {
          1: "\\left(${args[0]}\\right)^{+}"
        },
        sqrtm: {
          1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
        },
        trace: {
          1: "\\mathrm{tr}\\left(${args[0]}\\right)"
        },
        transpose: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
        },
        // probability
        combinations: {
          2: "\\binom{${args[0]}}{${args[1]}}"
        },
        combinationsWithRep: {
          2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
        },
        factorial: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
        },
        gamma: {
          1: "\\Gamma\\left(${args[0]}\\right)"
        },
        lgamma: {
          1: "\\ln\\Gamma\\left(${args[0]}\\right)"
        },
        // relational
        equal: {
          2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
        },
        larger: {
          2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
        },
        largerEq: {
          2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
        },
        smaller: {
          2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
        },
        smallerEq: {
          2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
        },
        unequal: {
          2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
        },
        // special
        erf: {
          1: "erf\\left(${args[0]}\\right)"
        },
        // statistics
        max: "\\max\\left(${args}\\right)",
        min: "\\min\\left(${args}\\right)",
        variance: "\\mathrm{Var}\\left(${args}\\right)",
        // trigonometry
        acos: {
          1: "\\cos^{-1}\\left(${args[0]}\\right)"
        },
        acosh: {
          1: "\\cosh^{-1}\\left(${args[0]}\\right)"
        },
        acot: {
          1: "\\cot^{-1}\\left(${args[0]}\\right)"
        },
        acoth: {
          1: "\\coth^{-1}\\left(${args[0]}\\right)"
        },
        acsc: {
          1: "\\csc^{-1}\\left(${args[0]}\\right)"
        },
        acsch: {
          1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
        },
        asec: {
          1: "\\sec^{-1}\\left(${args[0]}\\right)"
        },
        asech: {
          1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
        },
        asin: {
          1: "\\sin^{-1}\\left(${args[0]}\\right)"
        },
        asinh: {
          1: "\\sinh^{-1}\\left(${args[0]}\\right)"
        },
        atan: {
          1: "\\tan^{-1}\\left(${args[0]}\\right)"
        },
        atan2: {
          2: "\\mathrm{atan2}\\left(${args}\\right)"
        },
        atanh: {
          1: "\\tanh^{-1}\\left(${args[0]}\\right)"
        },
        cos: {
          1: "\\cos\\left(${args[0]}\\right)"
        },
        cosh: {
          1: "\\cosh\\left(${args[0]}\\right)"
        },
        cot: {
          1: "\\cot\\left(${args[0]}\\right)"
        },
        coth: {
          1: "\\coth\\left(${args[0]}\\right)"
        },
        csc: {
          1: "\\csc\\left(${args[0]}\\right)"
        },
        csch: {
          1: "\\mathrm{csch}\\left(${args[0]}\\right)"
        },
        sec: {
          1: "\\sec\\left(${args[0]}\\right)"
        },
        sech: {
          1: "\\mathrm{sech}\\left(${args[0]}\\right)"
        },
        sin: {
          1: "\\sin\\left(${args[0]}\\right)"
        },
        sinh: {
          1: "\\sinh\\left(${args[0]}\\right)"
        },
        tan: {
          1: "\\tan\\left(${args[0]}\\right)"
        },
        tanh: {
          1: "\\tanh\\left(${args[0]}\\right)"
        },
        // unit
        to: {
          2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
        },
        // utils
        numeric: function numeric(node, options) {
          return node.args[0].toTex();
        },
        // type
        number: {
          0: "0",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
        },
        string: {
          0: '\\mathtt{""}',
          1: "\\mathrm{string}\\left(${args[0]}\\right)"
        },
        bignumber: {
          0: "0",
          1: "\\left(${args[0]}\\right)"
        },
        complex: {
          0: "0",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
        },
        matrix: {
          0: "\\begin{bmatrix}\\end{bmatrix}",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(${args[0]}\\right)"
        },
        sparse: {
          0: "\\begin{bsparse}\\end{bsparse}",
          1: "\\left(${args[0]}\\right)"
        },
        unit: {
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
        }
      };
      defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
      latexUnits = {
        deg: "^\\circ"
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
  var name211, dependencies211, createConstantNode;
  var init_ConstantNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/ConstantNode.js"() {
      init_defineProperty();
      init_string();
      init_is();
      init_latex();
      init_factory();
      name211 = "ConstantNode";
      dependencies211 = ["Node"];
      createConstantNode = /* @__PURE__ */ factory(name211, dependencies211, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        class ConstantNode2 extends Node2 {
          /**
           * A ConstantNode holds a constant value like a number or string.
           *
           * Usage:
           *
           *     new ConstantNode(2.3)
           *     new ConstantNode('hello')
           *
           * @param {*} value    Value can be any type (number, BigNumber, string, ...)
           * @constructor ConstantNode
           * @extends {Node}
           */
          constructor(value) {
            super();
            this.value = value;
          }
          get type() {
            return name211;
          }
          get isConstantNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var value = this.value;
            return function evalConstantNode() {
              return value;
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
          }
          /**
           * Create a new ConstantNode with children produced by the given callback.
           * Trivial because there are no children.
           * @param {function(child: Node, path: string, parent: Node) : Node} callback
           * @returns {ConstantNode} Returns a clone of the node
           */
          map(callback) {
            return this.clone();
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {ConstantNode}
           */
          clone() {
            return new ConstantNode2(this.value);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            return format3(this.value, options);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var value = this._toString(options);
            switch (typeOf(this.value)) {
              case "number":
              case "BigNumber":
              case "Fraction":
                return '<span class="math-number">' + value + "</span>";
              case "string":
                return '<span class="math-string">' + value + "</span>";
              case "boolean":
                return '<span class="math-boolean">' + value + "</span>";
              case "null":
                return '<span class="math-null-symbol">' + value + "</span>";
              case "undefined":
                return '<span class="math-undefined">' + value + "</span>";
              default:
                return '<span class="math-symbol">' + value + "</span>";
            }
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name211,
              value: this.value
            };
          }
          /**
           * Instantiate a ConstantNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "SymbolNode", value: 2.3}`,
           *                       where mathjs is optional
           * @returns {ConstantNode}
           */
          static fromJSON(json) {
            return new ConstantNode2(json.value);
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var value = this._toString(options);
            switch (typeOf(this.value)) {
              case "string":
                return "\\mathtt{" + escapeLatex(value) + "}";
              case "number":
              case "BigNumber":
                {
                  if (!isFinite(this.value)) {
                    return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
                  }
                  var index2 = value.toLowerCase().indexOf("e");
                  if (index2 !== -1) {
                    return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
                  }
                }
                return value;
              case "Fraction":
                return this.value.toLatex();
              default:
                return value;
            }
          }
        }
        _defineProperty(ConstantNode2, "name", name211);
        return ConstantNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
  var name212, dependencies212, createFunctionAssignmentNode;
  var init_FunctionAssignmentNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"() {
      init_defineProperty();
      init_is();
      init_keywords();
      init_string();
      init_array();
      init_latex();
      init_operators();
      init_factory();
      name212 = "FunctionAssignmentNode";
      dependencies212 = ["typed", "Node"];
      createFunctionAssignmentNode = /* @__PURE__ */ factory(name212, dependencies212, (_ref) => {
        var {
          typed: typed3,
          Node: Node2
        } = _ref;
        function needParenthesis(node, parenthesis, implicit) {
          var precedence = getPrecedence(node, parenthesis, implicit);
          var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
          return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
        }
        class FunctionAssignmentNode2 extends Node2 {
          /**
           * @constructor FunctionAssignmentNode
           * @extends {Node}
           * Function assignment
           *
           * @param {string} name           Function name
           * @param {string[] | Array.<{name: string, type: string}>} params
           *                                Array with function parameter names, or an
           *                                array with objects containing the name
           *                                and type of the parameter
           * @param {Node} expr             The function expression
           */
          constructor(name307, params, expr) {
            super();
            if (typeof name307 !== "string") {
              throw new TypeError('String expected for parameter "name"');
            }
            if (!Array.isArray(params)) {
              throw new TypeError('Array containing strings or objects expected for parameter "params"');
            }
            if (!isNode(expr)) {
              throw new TypeError('Node expected for parameter "expr"');
            }
            if (keywords.has(name307)) {
              throw new Error('Illegal function name, "' + name307 + '" is a reserved keyword');
            }
            var paramNames = /* @__PURE__ */ new Set();
            for (var param of params) {
              var _name = typeof param === "string" ? param : param.name;
              if (paramNames.has(_name)) {
                throw new Error('Duplicate parameter name "'.concat(_name, '"'));
              } else {
                paramNames.add(_name);
              }
            }
            this.name = name307;
            this.params = params.map(function(param2) {
              return param2 && param2.name || param2;
            });
            this.types = params.map(function(param2) {
              return param2 && param2.type || "any";
            });
            this.expr = expr;
          }
          get type() {
            return name212;
          }
          get isFunctionAssignmentNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var childArgNames = Object.create(argNames);
            forEach(this.params, function(param) {
              childArgNames[param] = true;
            });
            var evalExpr = this.expr._compile(math2, childArgNames);
            var name307 = this.name;
            var params = this.params;
            var signature = join(this.types, ",");
            var syntax = name307 + "(" + join(this.params, ", ") + ")";
            return function evalFunctionAssignmentNode(scope, args, context) {
              var signatures = {};
              signatures[signature] = function() {
                var childArgs = Object.create(args);
                for (var i5 = 0; i5 < params.length; i5++) {
                  childArgs[params[i5]] = arguments[i5];
                }
                return evalExpr(scope, childArgs, context);
              };
              var fn2 = typed3(name307, signatures);
              fn2.syntax = syntax;
              scope.set(name307, fn2);
              return fn2;
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.expr, "expr", this);
          }
          /**
           * Create a new FunctionAssignmentNode whose children are the results of
           * calling the provided callback function for each child of the original
           * node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
           */
          map(callback) {
            var expr = this._ifNode(callback(this.expr, "expr", this));
            return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {FunctionAssignmentNode}
           */
          clone() {
            return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
          }
          /**
           * get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var expr = this.expr.toString(options);
            if (needParenthesis(this, parenthesis, options && options.implicit)) {
              expr = "(" + expr + ")";
            }
            return this.name + "(" + this.params.join(", ") + ") = " + expr;
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            var types = this.types;
            return {
              mathjs: name212,
              name: this.name,
              params: this.params.map(function(param, index2) {
                return {
                  name: param,
                  type: types[index2]
                };
              }),
              expr: this.expr
            };
          }
          /**
           * Instantiate an FunctionAssignmentNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     ```
           *     {"mathjs": "FunctionAssignmentNode",
           *      name: ..., params: ..., expr: ...}
           *     ```
           *     where mathjs is optional
           * @returns {FunctionAssignmentNode}
           */
          static fromJSON(json) {
            return new FunctionAssignmentNode2(json.name, json.params, json.expr);
          }
          /**
           * get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var params = [];
            for (var i5 = 0; i5 < this.params.length; i5++) {
              params.push('<span class="math-symbol math-parameter">' + escape(this.params[i5]) + "</span>");
            }
            var expr = this.expr.toHTML(options);
            if (needParenthesis(this, parenthesis, options && options.implicit)) {
              expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
          }
          /**
           * get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var expr = this.expr.toTex(options);
            if (needParenthesis(this, parenthesis, options && options.implicit)) {
              expr = "\\left(".concat(expr, "\\right)");
            }
            return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
          }
        }
        _defineProperty(FunctionAssignmentNode2, "name", name212);
        return FunctionAssignmentNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/IndexNode.js
  var name213, dependencies213, createIndexNode;
  var init_IndexNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/IndexNode.js"() {
      init_defineProperty();
      init_array();
      init_customs();
      init_factory();
      init_is();
      init_string();
      name213 = "IndexNode";
      dependencies213 = ["Node", "size"];
      createIndexNode = /* @__PURE__ */ factory(name213, dependencies213, (_ref) => {
        var {
          Node: Node2,
          size: size2
        } = _ref;
        class IndexNode2 extends Node2 {
          /**
           * @constructor IndexNode
           * @extends Node
           *
           * Describes a subset of a matrix or an object property.
           * Cannot be used on its own, needs to be used within an AccessorNode or
           * AssignmentNode.
           *
           * @param {Node[]} dimensions
           * @param {boolean} [dotNotation=false]
           *     Optional property describing whether this index was written using dot
           *     notation like `a.b`, or using bracket notation like `a["b"]`
           *     (which is the default). This property is used for string conversion.
           */
          constructor(dimensions, dotNotation) {
            super();
            this.dimensions = dimensions;
            this.dotNotation = dotNotation || false;
            if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
            }
            if (this.dotNotation && !this.isObjectProperty()) {
              throw new Error("dotNotation only applicable for object properties");
            }
          }
          get type() {
            return name213;
          }
          get isIndexNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalDimensions = map(this.dimensions, function(dimension, i5) {
              var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
              if (needsEnd) {
                var childArgNames = Object.create(argNames);
                childArgNames.end = true;
                var _evalDimension = dimension._compile(math2, childArgNames);
                return function evalDimension(scope, args, context) {
                  if (!isMatrix(context) && !isArray(context) && !isString(context)) {
                    throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
                  }
                  var s3 = size2(context).valueOf();
                  var childArgs = Object.create(args);
                  childArgs.end = s3[i5];
                  return _evalDimension(scope, childArgs, context);
                };
              } else {
                return dimension._compile(math2, argNames);
              }
            });
            var index2 = getSafeProperty(math2, "index");
            return function evalIndexNode(scope, args, context) {
              var dimensions = map(evalDimensions, function(evalDimension) {
                return evalDimension(scope, args, context);
              });
              return index2(...dimensions);
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            for (var i5 = 0; i5 < this.dimensions.length; i5++) {
              callback(this.dimensions[i5], "dimensions[" + i5 + "]", this);
            }
          }
          /**
           * Create a new IndexNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {IndexNode} Returns a transformed copy of the node
           */
          map(callback) {
            var dimensions = [];
            for (var i5 = 0; i5 < this.dimensions.length; i5++) {
              dimensions[i5] = this._ifNode(callback(this.dimensions[i5], "dimensions[" + i5 + "]", this));
            }
            return new IndexNode2(dimensions, this.dotNotation);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {IndexNode}
           */
          clone() {
            return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
          }
          /**
           * Test whether this IndexNode contains a single property name
           * @return {boolean}
           */
          isObjectProperty() {
            return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
          }
          /**
           * Returns the property name if IndexNode contains a property.
           * If not, returns null.
           * @return {string | null}
           */
          getObjectProperty() {
            return this.isObjectProperty() ? this.dimensions[0].value : null;
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name213,
              dimensions: this.dimensions,
              dotNotation: this.dotNotation
            };
          }
          /**
           * Instantiate an IndexNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
           *     where mathjs is optional
           * @returns {IndexNode}
           */
          static fromJSON(json) {
            return new IndexNode2(json.dimensions, json.dotNotation);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var dimensions = [];
            for (var i5 = 0; i5 < this.dimensions.length; i5++) {
              dimensions[i5] = this.dimensions[i5].toHTML();
            }
            if (this.dotNotation) {
              return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
            } else {
              return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
            }
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var dimensions = this.dimensions.map(function(range2) {
              return range2.toTex(options);
            });
            return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
          }
        }
        _defineProperty(IndexNode2, "name", name213);
        return IndexNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
  var name214, dependencies214, createObjectNode;
  var init_ObjectNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/ObjectNode.js"() {
      init_defineProperty();
      init_customs();
      init_factory();
      init_is();
      init_object();
      init_string();
      name214 = "ObjectNode";
      dependencies214 = ["Node"];
      createObjectNode = /* @__PURE__ */ factory(name214, dependencies214, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        class ObjectNode2 extends Node2 {
          /**
           * @constructor ObjectNode
           * @extends {Node}
           * Holds an object with keys/values
           * @param {Object.<string, Node>} [properties]   object with key/value pairs
           */
          constructor(properties2) {
            super();
            this.properties = properties2 || {};
            if (properties2) {
              if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
                return isNode(properties2[key]);
              })) {
                throw new TypeError("Object containing Nodes expected");
              }
            }
          }
          get type() {
            return name214;
          }
          get isObjectNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var evalEntries = {};
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                var stringifiedKey = stringify(key);
                var parsedKey = JSON.parse(stringifiedKey);
                var prop = getSafeProperty(this.properties, key);
                evalEntries[parsedKey] = prop._compile(math2, argNames);
              }
            }
            return function evalObjectNode(scope, args, context) {
              var obj = {};
              for (var _key in evalEntries) {
                if (hasOwnProperty2(evalEntries, _key)) {
                  obj[_key] = evalEntries[_key](scope, args, context);
                }
              }
              return obj;
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                callback(this.properties[key], "properties[" + stringify(key) + "]", this);
              }
            }
          }
          /**
           * Create a new ObjectNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {ObjectNode} Returns a transformed copy of the node
           */
          map(callback) {
            var properties2 = {};
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
              }
            }
            return new ObjectNode2(properties2);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {ObjectNode}
           */
          clone() {
            var properties2 = {};
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                properties2[key] = this.properties[key];
              }
            }
            return new ObjectNode2(properties2);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toString(options) {
            var entries = [];
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                entries.push(stringify(key) + ": " + this.properties[key].toString(options));
              }
            }
            return "{" + entries.join(", ") + "}";
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name214,
              properties: this.properties
            };
          }
          /**
           * Instantiate an OperatorNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
           *                       where mathjs is optional
           * @returns {ObjectNode}
           */
          static fromJSON(json) {
            return new ObjectNode2(json.properties);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toHTML(options) {
            var entries = [];
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
              }
            }
            return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var entries = [];
            for (var key in this.properties) {
              if (hasOwnProperty2(this.properties, key)) {
                entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
              }
            }
            var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
            return tex;
          }
        }
        _defineProperty(ObjectNode2, "name", name214);
        return ObjectNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
  var name215, dependencies215, createOperatorNode;
  var init_OperatorNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"() {
      init_defineProperty();
      init_is();
      init_array();
      init_string();
      init_customs();
      init_operators();
      init_latex();
      init_factory();
      name215 = "OperatorNode";
      dependencies215 = ["Node"];
      createOperatorNode = /* @__PURE__ */ factory(name215, dependencies215, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        function startsWithConstant(expr, parenthesis) {
          var curNode = expr;
          if (parenthesis === "auto") {
            while (isParenthesisNode(curNode))
              curNode = curNode.content;
          }
          if (isConstantNode(curNode))
            return true;
          if (isOperatorNode(curNode)) {
            return startsWithConstant(curNode.args[0], parenthesis);
          }
          return false;
        }
        function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
          var precedence = getPrecedence(root, parenthesis, implicit);
          var associativity = getAssociativity(root, parenthesis);
          if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
            return args.map(function(arg2) {
              switch (arg2.getContent().type) {
                case "ArrayNode":
                case "ConstantNode":
                case "SymbolNode":
                case "ParenthesisNode":
                  return false;
                default:
                  return true;
              }
            });
          }
          var result;
          switch (args.length) {
            case 0:
              result = [];
              break;
            case 1:
              {
                var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
                if (latex && operandPrecedence !== null) {
                  var operandIdentifier;
                  var rootIdentifier;
                  if (parenthesis === "keep") {
                    operandIdentifier = args[0].getIdentifier();
                    rootIdentifier = root.getIdentifier();
                  } else {
                    operandIdentifier = args[0].getContent().getIdentifier();
                    rootIdentifier = root.getContent().getIdentifier();
                  }
                  if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                    result = [false];
                    break;
                  }
                  if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                    result = [false];
                    break;
                  }
                }
                if (operandPrecedence === null) {
                  result = [false];
                  break;
                }
                if (operandPrecedence <= precedence) {
                  result = [true];
                  break;
                }
                result = [false];
              }
              break;
            case 2:
              {
                var lhsParens;
                var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
                var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
                if (lhsPrecedence === null) {
                  lhsParens = false;
                } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
                  lhsParens = true;
                } else if (lhsPrecedence < precedence) {
                  lhsParens = true;
                } else {
                  lhsParens = false;
                }
                var rhsParens;
                var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
                var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
                if (rhsPrecedence === null) {
                  rhsParens = false;
                } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
                  rhsParens = true;
                } else if (rhsPrecedence < precedence) {
                  rhsParens = true;
                } else {
                  rhsParens = false;
                }
                if (latex) {
                  var _rootIdentifier;
                  var lhsIdentifier;
                  var rhsIdentifier;
                  if (parenthesis === "keep") {
                    _rootIdentifier = root.getIdentifier();
                    lhsIdentifier = root.args[0].getIdentifier();
                    rhsIdentifier = root.args[1].getIdentifier();
                  } else {
                    _rootIdentifier = root.getContent().getIdentifier();
                    lhsIdentifier = root.args[0].getContent().getIdentifier();
                    rhsIdentifier = root.args[1].getContent().getIdentifier();
                  }
                  if (lhsPrecedence !== null) {
                    if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                      lhsParens = false;
                    }
                    if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                      lhsParens = false;
                    }
                  }
                  if (rhsPrecedence !== null) {
                    if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                      rhsParens = false;
                    }
                    if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                      rhsParens = false;
                    }
                  }
                }
                result = [lhsParens, rhsParens];
              }
              break;
            default:
              if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
                result = args.map(function(arg2) {
                  var argPrecedence = getPrecedence(arg2, parenthesis, implicit, root);
                  var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
                  var argAssociativity = getAssociativity(arg2, parenthesis);
                  if (argPrecedence === null) {
                    return false;
                  } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                    return true;
                  } else if (argPrecedence < precedence) {
                    return true;
                  }
                  return false;
                });
              }
              break;
          }
          if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
            for (var i5 = 1; i5 < result.length; ++i5) {
              if (startsWithConstant(args[i5], parenthesis) && !result[i5 - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i5 - 1]))) {
                result[i5] = true;
              }
            }
          }
          return result;
        }
        class OperatorNode2 extends Node2 {
          /**
           * @constructor OperatorNode
           * @extends {Node}
           * An operator with two arguments, like 2+3
           *
           * @param {string} op           Operator name, for example '+'
           * @param {string} fn           Function name, for example 'add'
           * @param {Node[]} args         Operator arguments
           * @param {boolean} [implicit]  Is this an implicit multiplication?
           * @param {boolean} [isPercentage] Is this an percentage Operation?
           */
          constructor(op, fn2, args, implicit, isPercentage) {
            super();
            if (typeof op !== "string") {
              throw new TypeError('string expected for parameter "op"');
            }
            if (typeof fn2 !== "string") {
              throw new TypeError('string expected for parameter "fn"');
            }
            if (!Array.isArray(args) || !args.every(isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "args"');
            }
            this.implicit = implicit === true;
            this.isPercentage = isPercentage === true;
            this.op = op;
            this.fn = fn2;
            this.args = args || [];
          }
          get type() {
            return name215;
          }
          get isOperatorNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
              if (!math2[this.fn]) {
                throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
              } else {
                throw new Error('No access to function "' + this.fn + '"');
              }
            }
            var fn2 = getSafeProperty(math2, this.fn);
            var evalArgs = map(this.args, function(arg2) {
              return arg2._compile(math2, argNames);
            });
            if (evalArgs.length === 1) {
              var evalArg0 = evalArgs[0];
              return function evalOperatorNode(scope, args, context) {
                return fn2(evalArg0(scope, args, context));
              };
            } else if (evalArgs.length === 2) {
              var _evalArg = evalArgs[0];
              var evalArg1 = evalArgs[1];
              return function evalOperatorNode(scope, args, context) {
                return fn2(_evalArg(scope, args, context), evalArg1(scope, args, context));
              };
            } else {
              return function evalOperatorNode(scope, args, context) {
                return fn2.apply(null, map(evalArgs, function(evalArg) {
                  return evalArg(scope, args, context);
                }));
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            for (var i5 = 0; i5 < this.args.length; i5++) {
              callback(this.args[i5], "args[" + i5 + "]", this);
            }
          }
          /**
           * Create a new OperatorNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {OperatorNode} Returns a transformed copy of the node
           */
          map(callback) {
            var args = [];
            for (var i5 = 0; i5 < this.args.length; i5++) {
              args[i5] = this._ifNode(callback(this.args[i5], "args[" + i5 + "]", this));
            }
            return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {OperatorNode}
           */
          clone() {
            return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
          }
          /**
           * Check whether this is an unary OperatorNode:
           * has exactly one argument, like `-a`.
           * @return {boolean}
           *     Returns true when an unary operator node, false otherwise.
           */
          isUnary() {
            return this.args.length === 1;
          }
          /**
           * Check whether this is a binary OperatorNode:
           * has exactly two arguments, like `a + b`.
           * @return {boolean}
           *     Returns true when a binary operator node, false otherwise.
           */
          isBinary() {
            return this.args.length === 2;
          }
          /**
           * Get string representation.
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var implicit = options && options.implicit ? options.implicit : "hide";
            var args = this.args;
            var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
            if (args.length === 1) {
              var assoc = getAssociativity(this, parenthesis);
              var operand = args[0].toString(options);
              if (parens[0]) {
                operand = "(" + operand + ")";
              }
              var opIsNamed = /[a-zA-Z]+/.test(this.op);
              if (assoc === "right") {
                return this.op + (opIsNamed ? " " : "") + operand;
              } else if (assoc === "left") {
                return operand + (opIsNamed ? " " : "") + this.op;
              }
              return operand + this.op;
            } else if (args.length === 2) {
              var lhs = args[0].toString(options);
              var rhs = args[1].toString(options);
              if (parens[0]) {
                lhs = "(" + lhs + ")";
              }
              if (parens[1]) {
                rhs = "(" + rhs + ")";
              }
              if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                return lhs + " " + rhs;
              }
              return lhs + " " + this.op + " " + rhs;
            } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
              var stringifiedArgs = args.map(function(arg2, index2) {
                arg2 = arg2.toString(options);
                if (parens[index2]) {
                  arg2 = "(" + arg2 + ")";
                }
                return arg2;
              });
              if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                return stringifiedArgs.join(" ");
              }
              return stringifiedArgs.join(" " + this.op + " ");
            } else {
              return this.fn + "(" + this.args.join(", ") + ")";
            }
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name215,
              op: this.op,
              fn: this.fn,
              args: this.args,
              implicit: this.implicit,
              isPercentage: this.isPercentage
            };
          }
          /**
           * Instantiate an OperatorNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     ```
           *     {"mathjs": "OperatorNode",
           *      "op": "+", "fn": "add", "args": [...],
           *      "implicit": false,
           *      "isPercentage":false}
           *     ```
           *     where mathjs is optional
           * @returns {OperatorNode}
           */
          static fromJSON(json) {
            return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
          }
          /**
           * Get HTML representation.
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var implicit = options && options.implicit ? options.implicit : "hide";
            var args = this.args;
            var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
            if (args.length === 1) {
              var assoc = getAssociativity(this, parenthesis);
              var operand = args[0].toHTML(options);
              if (parens[0]) {
                operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
              }
              if (assoc === "right") {
                return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
              } else {
                return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
              }
            } else if (args.length === 2) {
              var lhs = args[0].toHTML(options);
              var rhs = args[1].toHTML(options);
              if (parens[0]) {
                lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
              }
              if (parens[1]) {
                rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
              }
              if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
              }
              return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
            } else {
              var stringifiedArgs = args.map(function(arg2, index2) {
                arg2 = arg2.toHTML(options);
                if (parens[index2]) {
                  arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return arg2;
              });
              if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                  return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
                }
                return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
              } else {
                return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
              }
            }
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var implicit = options && options.implicit ? options.implicit : "hide";
            var args = this.args;
            var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
            var op = latexOperators[this.fn];
            op = typeof op === "undefined" ? this.op : op;
            if (args.length === 1) {
              var assoc = getAssociativity(this, parenthesis);
              var operand = args[0].toTex(options);
              if (parens[0]) {
                operand = "\\left(".concat(operand, "\\right)");
              }
              if (assoc === "right") {
                return op + operand;
              } else if (assoc === "left") {
                return operand + op;
              }
              return operand + op;
            } else if (args.length === 2) {
              var lhs = args[0];
              var lhsTex = lhs.toTex(options);
              if (parens[0]) {
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
              }
              var rhs = args[1];
              var rhsTex = rhs.toTex(options);
              if (parens[1]) {
                rhsTex = "\\left(".concat(rhsTex, "\\right)");
              }
              var lhsIdentifier;
              if (parenthesis === "keep") {
                lhsIdentifier = lhs.getIdentifier();
              } else {
                lhsIdentifier = lhs.getContent().getIdentifier();
              }
              switch (this.getIdentifier()) {
                case "OperatorNode:divide":
                  return op + "{" + lhsTex + "}{" + rhsTex + "}";
                case "OperatorNode:pow":
                  lhsTex = "{" + lhsTex + "}";
                  rhsTex = "{" + rhsTex + "}";
                  switch (lhsIdentifier) {
                    case "ConditionalNode":
                    case "OperatorNode:divide":
                      lhsTex = "\\left(".concat(lhsTex, "\\right)");
                  }
                  break;
                case "OperatorNode:multiply":
                  if (this.implicit && implicit === "hide") {
                    return lhsTex + "~" + rhsTex;
                  }
              }
              return lhsTex + op + rhsTex;
            } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
              var texifiedArgs = args.map(function(arg2, index2) {
                arg2 = arg2.toTex(options);
                if (parens[index2]) {
                  arg2 = "\\left(".concat(arg2, "\\right)");
                }
                return arg2;
              });
              if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
                return texifiedArgs.join("~");
              }
              return texifiedArgs.join(op);
            } else {
              return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
                return arg2.toTex(options);
              }).join(",") + "\\right)";
            }
          }
          /**
           * Get identifier.
           * @return {string}
           */
          getIdentifier() {
            return this.type + ":" + this.fn;
          }
        }
        _defineProperty(OperatorNode2, "name", name215);
        return OperatorNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
  var name216, dependencies216, createParenthesisNode;
  var init_ParenthesisNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js"() {
      init_defineProperty();
      init_is();
      init_factory();
      name216 = "ParenthesisNode";
      dependencies216 = ["Node"];
      createParenthesisNode = /* @__PURE__ */ factory(name216, dependencies216, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        class ParenthesisNode2 extends Node2 {
          /**
           * @constructor ParenthesisNode
           * @extends {Node}
           * A parenthesis node describes manual parenthesis from the user input
           * @param {Node} content
           * @extends {Node}
           */
          constructor(content) {
            super();
            if (!isNode(content)) {
              throw new TypeError('Node expected for parameter "content"');
            }
            this.content = content;
          }
          get type() {
            return name216;
          }
          get isParenthesisNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            return this.content._compile(math2, argNames);
          }
          /**
           * Get the content of the current Node.
           * @return {Node} content
           * @override
           **/
          getContent() {
            return this.content.getContent();
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.content, "content", this);
          }
          /**
           * Create a new ParenthesisNode whose child is the result of calling
           * the provided callback function on the child of this node.
           * @param {function(child: Node, path: string, parent: Node) : Node} callback
           * @returns {ParenthesisNode} Returns a clone of the node
           */
          map(callback) {
            var content = callback(this.content, "content", this);
            return new ParenthesisNode2(content);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {ParenthesisNode}
           */
          clone() {
            return new ParenthesisNode2(this.content);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toString(options) {
            if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
              return "(" + this.content.toString(options) + ")";
            }
            return this.content.toString(options);
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name216,
              content: this.content
            };
          }
          /**
           * Instantiate an ParenthesisNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
           *                       where mathjs is optional
           * @returns {ParenthesisNode}
           */
          static fromJSON(json) {
            return new ParenthesisNode2(json.content);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toHTML(options) {
            if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
              return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return this.content.toHTML(options);
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toTex(options) {
            if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
              return "\\left(".concat(this.content.toTex(options), "\\right)");
            }
            return this.content.toTex(options);
          }
        }
        _defineProperty(ParenthesisNode2, "name", name216);
        return ParenthesisNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/RangeNode.js
  var name217, dependencies217, createRangeNode;
  var init_RangeNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/RangeNode.js"() {
      init_defineProperty();
      init_is();
      init_factory();
      init_operators();
      name217 = "RangeNode";
      dependencies217 = ["Node"];
      createRangeNode = /* @__PURE__ */ factory(name217, dependencies217, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        function calculateNecessaryParentheses(node, parenthesis, implicit) {
          var precedence = getPrecedence(node, parenthesis, implicit);
          var parens = {};
          var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
          parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
          if (node.step) {
            var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
            parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
          }
          var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
          parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
          return parens;
        }
        class RangeNode2 extends Node2 {
          /**
           * @constructor RangeNode
           * @extends {Node}
           * create a range
           * @param {Node} start  included lower-bound
           * @param {Node} end    included upper-bound
           * @param {Node} [step] optional step
           */
          constructor(start, end, step) {
            super();
            if (!isNode(start))
              throw new TypeError("Node expected");
            if (!isNode(end))
              throw new TypeError("Node expected");
            if (step && !isNode(step))
              throw new TypeError("Node expected");
            if (arguments.length > 3)
              throw new Error("Too many arguments");
            this.start = start;
            this.end = end;
            this.step = step || null;
          }
          get type() {
            return name217;
          }
          get isRangeNode() {
            return true;
          }
          /**
           * Check whether the RangeNode needs the `end` symbol to be defined.
           * This end is the size of the Matrix in current dimension.
           * @return {boolean}
           */
          needsEnd() {
            var endSymbols = this.filter(function(node) {
              return isSymbolNode(node) && node.name === "end";
            });
            return endSymbols.length > 0;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var range2 = math2.range;
            var evalStart = this.start._compile(math2, argNames);
            var evalEnd = this.end._compile(math2, argNames);
            if (this.step) {
              var evalStep = this.step._compile(math2, argNames);
              return function evalRangeNode(scope, args, context) {
                return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
              };
            } else {
              return function evalRangeNode(scope, args, context) {
                return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.start, "start", this);
            callback(this.end, "end", this);
            if (this.step) {
              callback(this.step, "step", this);
            }
          }
          /**
           * Create a new RangeNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {RangeNode} Returns a transformed copy of the node
           */
          map(callback) {
            return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {RangeNode}
           */
          clone() {
            return new RangeNode2(this.start, this.end, this.step && this.step);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
            var str;
            var start = this.start.toString(options);
            if (parens.start) {
              start = "(" + start + ")";
            }
            str = start;
            if (this.step) {
              var step = this.step.toString(options);
              if (parens.step) {
                step = "(" + step + ")";
              }
              str += ":" + step;
            }
            var end = this.end.toString(options);
            if (parens.end) {
              end = "(" + end + ")";
            }
            str += ":" + end;
            return str;
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name217,
              start: this.start,
              end: this.end,
              step: this.step
            };
          }
          /**
           * Instantiate an RangeNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
           *     where mathjs is optional
           * @returns {RangeNode}
           */
          static fromJSON(json) {
            return new RangeNode2(json.start, json.end, json.step);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
            var str;
            var start = this.start.toHTML(options);
            if (parens.start) {
              start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            str = start;
            if (this.step) {
              var step = this.step.toHTML(options);
              if (parens.step) {
                step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
              }
              str += '<span class="math-operator math-range-operator">:</span>' + step;
            }
            var end = this.end.toHTML(options);
            if (parens.end) {
              end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            str += '<span class="math-operator math-range-operator">:</span>' + end;
            return str;
          }
          /**
           * Get LaTeX representation
           * @params {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
            var str = this.start.toTex(options);
            if (parens.start) {
              str = "\\left(".concat(str, "\\right)");
            }
            if (this.step) {
              var step = this.step.toTex(options);
              if (parens.step) {
                step = "\\left(".concat(step, "\\right)");
              }
              str += ":" + step;
            }
            var end = this.end.toTex(options);
            if (parens.end) {
              end = "\\left(".concat(end, "\\right)");
            }
            str += ":" + end;
            return str;
          }
        }
        _defineProperty(RangeNode2, "name", name217);
        return RangeNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
  var name218, dependencies218, createRelationalNode;
  var init_RelationalNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/RelationalNode.js"() {
      init_defineProperty();
      init_operators();
      init_string();
      init_customs();
      init_latex();
      init_factory();
      name218 = "RelationalNode";
      dependencies218 = ["Node"];
      createRelationalNode = /* @__PURE__ */ factory(name218, dependencies218, (_ref) => {
        var {
          Node: Node2
        } = _ref;
        var operatorMap = {
          equal: "==",
          unequal: "!=",
          smaller: "<",
          larger: ">",
          smallerEq: "<=",
          largerEq: ">="
        };
        class RelationalNode2 extends Node2 {
          /**
           * A node representing a chained conditional expression, such as 'x > y > z'
           *
           * @param {String[]} conditionals
           *     An array of conditional operators used to compare the parameters
           * @param {Node[]} params
           *     The parameters that will be compared
           *
           * @constructor RelationalNode
           * @extends {Node}
           */
          constructor(conditionals, params) {
            super();
            if (!Array.isArray(conditionals)) {
              throw new TypeError("Parameter conditionals must be an array");
            }
            if (!Array.isArray(params)) {
              throw new TypeError("Parameter params must be an array");
            }
            if (conditionals.length !== params.length - 1) {
              throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
            }
            this.conditionals = conditionals;
            this.params = params;
          }
          get type() {
            return name218;
          }
          get isRelationalNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math2, argNames) {
            var self2 = this;
            var compiled = this.params.map((p3) => p3._compile(math2, argNames));
            return function evalRelationalNode(scope, args, context) {
              var evalLhs;
              var evalRhs = compiled[0](scope, args, context);
              for (var i5 = 0; i5 < self2.conditionals.length; i5++) {
                evalLhs = evalRhs;
                evalRhs = compiled[i5 + 1](scope, args, context);
                var condFn = getSafeProperty(math2, self2.conditionals[i5]);
                if (!condFn(evalLhs, evalRhs)) {
                  return false;
                }
              }
              return true;
            };
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            this.params.forEach((n3, i5) => callback(n3, "params[" + i5 + "]", this), this);
          }
          /**
           * Create a new RelationalNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {RelationalNode} Returns a transformed copy of the node
           */
          map(callback) {
            return new RelationalNode2(this.conditionals.slice(), this.params.map((n3, i5) => this._ifNode(callback(n3, "params[" + i5 + "]", this)), this));
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {RelationalNode}
           */
          clone() {
            return new RelationalNode2(this.conditionals, this.params);
          }
          /**
           * Get string representation.
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var precedence = getPrecedence(this, parenthesis, options && options.implicit);
            var paramStrings = this.params.map(function(p3, index2) {
              var paramPrecedence = getPrecedence(p3, parenthesis, options && options.implicit);
              return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p3.toString(options) + ")" : p3.toString(options);
            });
            var ret = paramStrings[0];
            for (var i5 = 0; i5 < this.conditionals.length; i5++) {
              ret += " " + operatorMap[this.conditionals[i5]];
              ret += " " + paramStrings[i5 + 1];
            }
            return ret;
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name218,
              conditionals: this.conditionals,
              params: this.params
            };
          }
          /**
           * Instantiate a RelationalNode from its JSON representation
           * @param {Object} json
           *     An object structured like
           *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
           *     where mathjs is optional
           * @returns {RelationalNode}
           */
          static fromJSON(json) {
            return new RelationalNode2(json.conditionals, json.params);
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var precedence = getPrecedence(this, parenthesis, options && options.implicit);
            var paramStrings = this.params.map(function(p3, index2) {
              var paramPrecedence = getPrecedence(p3, parenthesis, options && options.implicit);
              return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p3.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p3.toHTML(options);
            });
            var ret = paramStrings[0];
            for (var i5 = 0; i5 < this.conditionals.length; i5++) {
              ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i5]]) + "</span>" + paramStrings[i5 + 1];
            }
            return ret;
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
            var precedence = getPrecedence(this, parenthesis, options && options.implicit);
            var paramStrings = this.params.map(function(p3, index2) {
              var paramPrecedence = getPrecedence(p3, parenthesis, options && options.implicit);
              return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p3.toTex(options) + "\right)" : p3.toTex(options);
            });
            var ret = paramStrings[0];
            for (var i5 = 0; i5 < this.conditionals.length; i5++) {
              ret += latexOperators[this.conditionals[i5]] + paramStrings[i5 + 1];
            }
            return ret;
          }
        }
        _defineProperty(RelationalNode2, "name", name218);
        return RelationalNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
  var name219, dependencies219, createSymbolNode;
  var init_SymbolNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"() {
      init_string();
      init_customs();
      init_factory();
      init_latex();
      name219 = "SymbolNode";
      dependencies219 = ["math", "?Unit", "Node"];
      createSymbolNode = /* @__PURE__ */ factory(name219, dependencies219, (_ref) => {
        var {
          math: math2,
          Unit: Unit2,
          Node: Node2
        } = _ref;
        function isValuelessUnit(name307) {
          return Unit2 ? Unit2.isValuelessUnit(name307) : false;
        }
        class SymbolNode2 extends Node2 {
          /**
           * @constructor SymbolNode
           * @extends {Node}
           * A symbol node can hold and resolve a symbol
           * @param {string} name
           * @extends {Node}
           */
          constructor(name307) {
            super();
            if (typeof name307 !== "string") {
              throw new TypeError('String expected for parameter "name"');
            }
            this.name = name307;
          }
          get type() {
            return "SymbolNode";
          }
          get isSymbolNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math3, argNames) {
            var name307 = this.name;
            if (argNames[name307] === true) {
              return function(scope, args, context) {
                return getSafeProperty(args, name307);
              };
            } else if (name307 in math3) {
              return function(scope, args, context) {
                return scope.has(name307) ? scope.get(name307) : getSafeProperty(math3, name307);
              };
            } else {
              var isUnit2 = isValuelessUnit(name307);
              return function(scope, args, context) {
                return scope.has(name307) ? scope.get(name307) : isUnit2 ? new Unit2(null, name307) : SymbolNode2.onUndefinedSymbol(name307);
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
          }
          /**
           * Create a new SymbolNode with children produced by the given callback.
           * Trivial since a SymbolNode has no children
           * @param {function(child: Node, path: string, parent: Node) : Node} callback
           * @returns {SymbolNode} Returns a clone of the node
           */
          map(callback) {
            return this.clone();
          }
          /**
           * Throws an error 'Undefined symbol {name}'
           * @param {string} name
           */
          static onUndefinedSymbol(name307) {
            throw new Error("Undefined symbol " + name307);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {SymbolNode}
           */
          clone() {
            return new SymbolNode2(this.name);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toString(options) {
            return this.name;
          }
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toHTML(options) {
            var name307 = escape(this.name);
            if (name307 === "true" || name307 === "false") {
              return '<span class="math-symbol math-boolean">' + name307 + "</span>";
            } else if (name307 === "i") {
              return '<span class="math-symbol math-imaginary-symbol">' + name307 + "</span>";
            } else if (name307 === "Infinity") {
              return '<span class="math-symbol math-infinity-symbol">' + name307 + "</span>";
            } else if (name307 === "NaN") {
              return '<span class="math-symbol math-nan-symbol">' + name307 + "</span>";
            } else if (name307 === "null") {
              return '<span class="math-symbol math-null-symbol">' + name307 + "</span>";
            } else if (name307 === "undefined") {
              return '<span class="math-symbol math-undefined-symbol">' + name307 + "</span>";
            }
            return '<span class="math-symbol">' + name307 + "</span>";
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: "SymbolNode",
              name: this.name
            };
          }
          /**
           * Instantiate a SymbolNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "SymbolNode", name: "x"}`,
           *                       where mathjs is optional
           * @returns {SymbolNode}
           */
          static fromJSON(json) {
            return new SymbolNode2(json.name);
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           * @override
           */
          _toTex(options) {
            var isUnit2 = false;
            if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
              isUnit2 = true;
            }
            var symbol = toSymbol(this.name, isUnit2);
            if (symbol[0] === "\\") {
              return symbol;
            }
            return " " + symbol;
          }
        }
        return SymbolNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/scope.js
  function createSubScope(parentScope) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (typeof parentScope.createSubScope === "function") {
      return assign(parentScope.createSubScope(), ...args);
    }
    return assign(createEmptyMap(), parentScope, ...args);
  }
  var init_scope = __esm({
    "node_modules/mathjs/lib/esm/utils/scope.js"() {
      init_map();
    }
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
  var name220, dependencies220, createFunctionNode;
  var init_FunctionNode = __esm({
    "node_modules/mathjs/lib/esm/expression/node/FunctionNode.js"() {
      init_defineProperty();
      init_is();
      init_string();
      init_object();
      init_customs();
      init_scope();
      init_factory();
      init_latex();
      name220 = "FunctionNode";
      dependencies220 = ["math", "Node", "SymbolNode"];
      createFunctionNode = /* @__PURE__ */ factory(name220, dependencies220, (_ref) => {
        var {
          math: math2,
          Node: Node2,
          SymbolNode: SymbolNode2
        } = _ref;
        var strin = (entity) => format3(entity, {
          truncate: 78
        });
        function expandTemplate(template, node, options) {
          var latex = "";
          var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
          var inputPos = 0;
          var match;
          while ((match = regex.exec(template)) !== null) {
            latex += template.substring(inputPos, match.index);
            inputPos = match.index;
            if (match[0] === "$$") {
              latex += "$";
              inputPos++;
            } else {
              inputPos += match[0].length;
              var property = node[match[1]];
              if (!property) {
                throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
              }
              if (match[2] === void 0) {
                switch (typeof property) {
                  case "string":
                    latex += property;
                    break;
                  case "object":
                    if (isNode(property)) {
                      latex += property.toTex(options);
                    } else if (Array.isArray(property)) {
                      latex += property.map(function(arg2, index2) {
                        if (isNode(arg2)) {
                          return arg2.toTex(options);
                        }
                        throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                      }).join(",");
                    } else {
                      throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                    }
                    break;
                  default:
                    throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                }
              } else {
                if (isNode(property[match[2]] && property[match[2]])) {
                  latex += property[match[2]].toTex(options);
                } else {
                  throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
                }
              }
            }
          }
          latex += template.slice(inputPos);
          return latex;
        }
        class FunctionNode2 extends Node2 {
          /**
           * @constructor FunctionNode
           * @extends {./Node}
           * invoke a list with arguments on a node
           * @param {./Node | string} fn
           *     Item resolving to a function on which to invoke
           *     the arguments, typically a SymboNode or AccessorNode
           * @param {./Node[]} args
           */
          constructor(fn2, args) {
            super();
            if (typeof fn2 === "string") {
              fn2 = new SymbolNode2(fn2);
            }
            if (!isNode(fn2))
              throw new TypeError('Node expected as parameter "fn"');
            if (!Array.isArray(args) || !args.every(isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "args"');
            }
            this.fn = fn2;
            this.args = args || [];
          }
          // readonly property name
          get name() {
            return this.fn.name || "";
          }
          get type() {
            return name220;
          }
          get isFunctionNode() {
            return true;
          }
          /**
           * Compile a node into a JavaScript function.
           * This basically pre-calculates as much as possible and only leaves open
           * calculations which depend on a dynamic scope with variables.
           * @param {Object} math     Math.js namespace with functions and constants.
           * @param {Object} argNames An object with argument names as key and `true`
           *                          as value. Used in the SymbolNode to optimize
           *                          for arguments from user assigned functions
           *                          (see FunctionAssignmentNode) or special symbols
           *                          like `end` (see IndexNode).
           * @return {function} Returns a function which can be called like:
           *                        evalNode(scope: Object, args: Object, context: *)
           */
          _compile(math3, argNames) {
            var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
            if (isSymbolNode(this.fn)) {
              var _name = this.fn.name;
              if (!argNames[_name]) {
                var fn2 = _name in math3 ? getSafeProperty(math3, _name) : void 0;
                var isRaw = typeof fn2 === "function" && fn2.rawArgs === true;
                var resolveFn = (scope) => {
                  var value;
                  if (scope.has(_name)) {
                    value = scope.get(_name);
                  } else if (_name in math3) {
                    value = getSafeProperty(math3, _name);
                  } else {
                    return FunctionNode2.onUndefinedFunction(_name);
                  }
                  if (typeof value === "function") {
                    return value;
                  }
                  throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
                };
                if (isRaw) {
                  var rawArgs = this.args;
                  return function evalFunctionNode(scope, args, context) {
                    var fn3 = resolveFn(scope);
                    return fn3(rawArgs, math3, createSubScope(scope, args), scope);
                  };
                } else {
                  switch (evalArgs.length) {
                    case 0:
                      return function evalFunctionNode(scope, args, context) {
                        var fn3 = resolveFn(scope);
                        return fn3();
                      };
                    case 1:
                      return function evalFunctionNode(scope, args, context) {
                        var fn3 = resolveFn(scope);
                        var evalArg0 = evalArgs[0];
                        return fn3(evalArg0(scope, args, context));
                      };
                    case 2:
                      return function evalFunctionNode(scope, args, context) {
                        var fn3 = resolveFn(scope);
                        var evalArg0 = evalArgs[0];
                        var evalArg1 = evalArgs[1];
                        return fn3(evalArg0(scope, args, context), evalArg1(scope, args, context));
                      };
                    default:
                      return function evalFunctionNode(scope, args, context) {
                        var fn3 = resolveFn(scope);
                        var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                        return fn3(...values);
                      };
                  }
                }
              } else {
                var _rawArgs = this.args;
                return function evalFunctionNode(scope, args, context) {
                  var fn3 = getSafeProperty(args, _name);
                  if (typeof fn3 !== "function") {
                    throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn3)));
                  }
                  if (fn3.rawArgs) {
                    return fn3(_rawArgs, math3, createSubScope(scope, args), scope);
                  } else {
                    var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                    return fn3.apply(fn3, values);
                  }
                };
              }
            } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
              var evalObject = this.fn.object._compile(math3, argNames);
              var prop = this.fn.index.getObjectProperty();
              var _rawArgs2 = this.args;
              return function evalFunctionNode(scope, args, context) {
                var object = evalObject(scope, args, context);
                var fn3 = getSafeMethod(object, prop);
                if (fn3 !== null && fn3 !== void 0 && fn3.rawArgs) {
                  return fn3(_rawArgs2, math3, createSubScope(scope, args), scope);
                } else {
                  var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn3.apply(object, values);
                }
              };
            } else {
              var fnExpr = this.fn.toString();
              var evalFn = this.fn._compile(math3, argNames);
              var _rawArgs3 = this.args;
              return function evalFunctionNode(scope, args, context) {
                var fn3 = evalFn(scope, args, context);
                if (typeof fn3 !== "function") {
                  throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn3)));
                }
                if (fn3.rawArgs) {
                  return fn3(_rawArgs3, math3, createSubScope(scope, args), scope);
                } else {
                  var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn3.apply(fn3, values);
                }
              };
            }
          }
          /**
           * Execute a callback for each of the child nodes of this node
           * @param {function(child: Node, path: string, parent: Node)} callback
           */
          forEach(callback) {
            callback(this.fn, "fn", this);
            for (var i5 = 0; i5 < this.args.length; i5++) {
              callback(this.args[i5], "args[" + i5 + "]", this);
            }
          }
          /**
           * Create a new FunctionNode whose children are the results of calling
           * the provided callback function for each child of the original node.
           * @param {function(child: Node, path: string, parent: Node): Node} callback
           * @returns {FunctionNode} Returns a transformed copy of the node
           */
          map(callback) {
            var fn2 = this._ifNode(callback(this.fn, "fn", this));
            var args = [];
            for (var i5 = 0; i5 < this.args.length; i5++) {
              args[i5] = this._ifNode(callback(this.args[i5], "args[" + i5 + "]", this));
            }
            return new FunctionNode2(fn2, args);
          }
          /**
           * Create a clone of this node, a shallow copy
           * @return {FunctionNode}
           */
          clone() {
            return new FunctionNode2(this.fn, this.args.slice(0));
          }
          /**
           * Throws an error 'Undefined function {name}'
           * @param {string} name
           */
          /**
           * Get string representation. (wrapper function)
           * This overrides parts of Node's toString function.
           * If callback is an object containing callbacks, it
           * calls the correct callback for the current node,
           * otherwise it falls back to calling Node's toString
           * function.
           *
           * @param {Object} options
           * @return {string} str
           * @override
           */
          toString(options) {
            var customString;
            var name307 = this.fn.toString(options);
            if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, name307)) {
              customString = options.handler[name307](this, options);
            }
            if (typeof customString !== "undefined") {
              return customString;
            }
            return super.toString(options);
          }
          /**
           * Get string representation
           * @param {Object} options
           * @return {string} str
           */
          _toString(options) {
            var args = this.args.map(function(arg2) {
              return arg2.toString(options);
            });
            var fn2 = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
            return fn2 + "(" + args.join(", ") + ")";
          }
          /**
           * Get a JSON representation of the node
           * @returns {Object}
           */
          toJSON() {
            return {
              mathjs: name220,
              fn: this.fn,
              args: this.args
            };
          }
          /**
           * Instantiate an AssignmentNode from its JSON representation
           * @param {Object} json  An object structured like
           *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
           *                       where mathjs is optional
           * @returns {FunctionNode}
           */
          /**
           * Get HTML representation
           * @param {Object} options
           * @return {string} str
           */
          toHTML(options) {
            var args = this.args.map(function(arg2) {
              return arg2.toHTML(options);
            });
            return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
          /**
           * Get LaTeX representation. (wrapper function)
           * This overrides parts of Node's toTex function.
           * If callback is an object containing callbacks, it
           * calls the correct callback for the current node,
           * otherwise it falls back to calling Node's toTex
           * function.
           *
           * @param {Object} options
           * @return {string}
           */
          toTex(options) {
            var customTex;
            if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, this.name)) {
              customTex = options.handler[this.name](this, options);
            }
            if (typeof customTex !== "undefined") {
              return customTex;
            }
            return super.toTex(options);
          }
          /**
           * Get LaTeX representation
           * @param {Object} options
           * @return {string} str
           */
          _toTex(options) {
            var args = this.args.map(function(arg2) {
              return arg2.toTex(options);
            });
            var latexConverter;
            if (latexFunctions[this.name]) {
              latexConverter = latexFunctions[this.name];
            }
            if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
              latexConverter = math2[this.name].toTex;
            }
            var customToTex;
            switch (typeof latexConverter) {
              case "function":
                customToTex = latexConverter(this, options);
                break;
              case "string":
                customToTex = expandTemplate(latexConverter, this, options);
                break;
              case "object":
                switch (typeof latexConverter[args.length]) {
                  case "function":
                    customToTex = latexConverter[args.length](this, options);
                    break;
                  case "string":
                    customToTex = expandTemplate(latexConverter[args.length], this, options);
                    break;
                }
            }
            if (typeof customToTex !== "undefined") {
              return customToTex;
            }
            return expandTemplate(defaultTemplate, this, options);
          }
          /**
           * Get identifier.
           * @return {string}
           */
          getIdentifier() {
            return this.type + ":" + this.name;
          }
        }
        _defineProperty(FunctionNode2, "name", name220);
        _defineProperty(FunctionNode2, "onUndefinedFunction", function(name307) {
          throw new Error("Undefined function " + name307);
        });
        _defineProperty(FunctionNode2, "fromJSON", function(json) {
          return new FunctionNode2(json.fn, json.args);
        });
        return FunctionNode2;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/parse.js
  var name221, dependencies221, createParse;
  var init_parse = __esm({
    "node_modules/mathjs/lib/esm/expression/parse.js"() {
      init_extends();
      init_factory();
      init_is();
      init_collection();
      init_object();
      name221 = "parse";
      dependencies221 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
      createParse = /* @__PURE__ */ factory(name221, dependencies221, (_ref) => {
        var {
          typed: typed3,
          numeric: numeric3,
          config: config4,
          AccessorNode: AccessorNode2,
          ArrayNode: ArrayNode2,
          AssignmentNode: AssignmentNode2,
          BlockNode: BlockNode2,
          ConditionalNode: ConditionalNode2,
          ConstantNode: ConstantNode2,
          FunctionAssignmentNode: FunctionAssignmentNode2,
          FunctionNode: FunctionNode2,
          IndexNode: IndexNode2,
          ObjectNode: ObjectNode2,
          OperatorNode: OperatorNode2,
          ParenthesisNode: ParenthesisNode2,
          RangeNode: RangeNode2,
          RelationalNode: RelationalNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        var parse2 = typed3(name221, {
          string: function string2(expression) {
            return parseStart(expression, {});
          },
          "Array | Matrix": function ArrayMatrix(expressions) {
            return parseMultiple(expressions, {});
          },
          "string, Object": function stringObject(expression, options) {
            var extraNodes = options.nodes !== void 0 ? options.nodes : {};
            return parseStart(expression, extraNodes);
          },
          "Array | Matrix, Object": parseMultiple
        });
        function parseMultiple(expressions) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var extraNodes = options.nodes !== void 0 ? options.nodes : {};
          return deepMap(expressions, function(elem) {
            if (typeof elem !== "string")
              throw new TypeError("String expected");
            return parseStart(elem, extraNodes);
          });
        }
        var TOKENTYPE = {
          NULL: 0,
          DELIMITER: 1,
          NUMBER: 2,
          SYMBOL: 3,
          UNKNOWN: 4
        };
        var DELIMITERS = {
          ",": true,
          "(": true,
          ")": true,
          "[": true,
          "]": true,
          "{": true,
          "}": true,
          '"': true,
          "'": true,
          ";": true,
          "+": true,
          "-": true,
          "*": true,
          ".*": true,
          "/": true,
          "./": true,
          "%": true,
          "^": true,
          ".^": true,
          "~": true,
          "!": true,
          "&": true,
          "|": true,
          "^|": true,
          "=": true,
          ":": true,
          "?": true,
          "==": true,
          "!=": true,
          "<": true,
          ">": true,
          "<=": true,
          ">=": true,
          "<<": true,
          ">>": true,
          ">>>": true
        };
        var NAMED_DELIMITERS = {
          mod: true,
          to: true,
          in: true,
          and: true,
          xor: true,
          or: true,
          not: true
        };
        var CONSTANTS = {
          true: true,
          false: false,
          null: null,
          undefined: void 0
        };
        var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
        function initialState() {
          return {
            extraNodes: {},
            // current extra nodes, must be careful not to mutate
            expression: "",
            // current expression
            comment: "",
            // last parsed comment
            index: 0,
            // current index in expr
            token: "",
            // current token
            tokenType: TOKENTYPE.NULL,
            // type of the token
            nestingLevel: 0,
            // level of nesting inside parameters, used to ignore newline characters
            conditionalLevel: null
            // when a conditional is being parsed, the level of the conditional is stored here
          };
        }
        function currentString(state, length) {
          return state.expression.substr(state.index, length);
        }
        function currentCharacter(state) {
          return currentString(state, 1);
        }
        function next(state) {
          state.index++;
        }
        function prevCharacter(state) {
          return state.expression.charAt(state.index - 1);
        }
        function nextCharacter(state) {
          return state.expression.charAt(state.index + 1);
        }
        function getToken(state) {
          state.tokenType = TOKENTYPE.NULL;
          state.token = "";
          state.comment = "";
          while (true) {
            if (currentCharacter(state) === "#") {
              while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
                state.comment += currentCharacter(state);
                next(state);
              }
            }
            if (parse2.isWhitespace(currentCharacter(state), state.nestingLevel)) {
              next(state);
            } else {
              break;
            }
          }
          if (currentCharacter(state) === "") {
            state.tokenType = TOKENTYPE.DELIMITER;
            return;
          }
          if (currentCharacter(state) === "\n" && !state.nestingLevel) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = currentCharacter(state);
            next(state);
            return;
          }
          var c1 = currentCharacter(state);
          var c22 = currentString(state, 2);
          var c3 = currentString(state, 3);
          if (c3.length === 3 && DELIMITERS[c3]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c3;
            next(state);
            next(state);
            next(state);
            return;
          }
          if (c22.length === 2 && DELIMITERS[c22]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c22;
            next(state);
            next(state);
            return;
          }
          if (DELIMITERS[c1]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c1;
            next(state);
            return;
          }
          if (parse2.isDigitDot(c1)) {
            state.tokenType = TOKENTYPE.NUMBER;
            var _c = currentString(state, 2);
            if (_c === "0b" || _c === "0o" || _c === "0x") {
              state.token += currentCharacter(state);
              next(state);
              state.token += currentCharacter(state);
              next(state);
              while (parse2.isHexDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
              if (currentCharacter(state) === ".") {
                state.token += ".";
                next(state);
                while (parse2.isHexDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
              } else if (currentCharacter(state) === "i") {
                state.token += "i";
                next(state);
                while (parse2.isDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
              }
              return;
            }
            if (currentCharacter(state) === ".") {
              state.token += currentCharacter(state);
              next(state);
              if (!parse2.isDigit(currentCharacter(state))) {
                state.tokenType = TOKENTYPE.DELIMITER;
                return;
              }
            } else {
              while (parse2.isDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
              if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
            }
            while (parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
              if (parse2.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
                state.token += currentCharacter(state);
                next(state);
                if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
                  state.token += currentCharacter(state);
                  next(state);
                }
                if (!parse2.isDigit(currentCharacter(state))) {
                  throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                }
                while (parse2.isDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
                if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                  throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                }
              } else if (nextCharacter(state) === ".") {
                next(state);
                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
              }
            }
            return;
          }
          if (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
            while (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (hasOwnProperty2(NAMED_DELIMITERS, state.token)) {
              state.tokenType = TOKENTYPE.DELIMITER;
            } else {
              state.tokenType = TOKENTYPE.SYMBOL;
            }
            return;
          }
          state.tokenType = TOKENTYPE.UNKNOWN;
          while (currentCharacter(state) !== "") {
            state.token += currentCharacter(state);
            next(state);
          }
          throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
        }
        function getTokenSkipNewline(state) {
          do {
            getToken(state);
          } while (state.token === "\n");
        }
        function openParams(state) {
          state.nestingLevel++;
        }
        function closeParams(state) {
          state.nestingLevel--;
        }
        parse2.isAlpha = function isAlpha(c3, cPrev, cNext) {
          return parse2.isValidLatinOrGreek(c3) || parse2.isValidMathSymbol(c3, cNext) || parse2.isValidMathSymbol(cPrev, c3);
        };
        parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c3) {
          return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c3);
        };
        parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
          return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
        };
        parse2.isWhitespace = function isWhitespace(c3, nestingLevel) {
          return c3 === " " || c3 === "	" || c3 === "\n" && nestingLevel > 0;
        };
        parse2.isDecimalMark = function isDecimalMark(c3, cNext) {
          return c3 === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
        };
        parse2.isDigitDot = function isDigitDot(c3) {
          return c3 >= "0" && c3 <= "9" || c3 === ".";
        };
        parse2.isDigit = function isDigit(c3) {
          return c3 >= "0" && c3 <= "9";
        };
        parse2.isHexDigit = function isHexDigit(c3) {
          return c3 >= "0" && c3 <= "9" || c3 >= "a" && c3 <= "f" || c3 >= "A" && c3 <= "F";
        };
        function parseStart(expression, extraNodes) {
          var state = initialState();
          _extends(state, {
            expression,
            extraNodes
          });
          getToken(state);
          var node = parseBlock(state);
          if (state.token !== "") {
            if (state.tokenType === TOKENTYPE.DELIMITER) {
              throw createError(state, "Unexpected operator " + state.token);
            } else {
              throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
            }
          }
          return node;
        }
        function parseBlock(state) {
          var node;
          var blocks = [];
          var visible;
          if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
            node = parseAssignment(state);
            if (state.comment) {
              node.comment = state.comment;
            }
          }
          while (state.token === "\n" || state.token === ";") {
            if (blocks.length === 0 && node) {
              visible = state.token !== ";";
              blocks.push({
                node,
                visible
              });
            }
            getToken(state);
            if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
              node = parseAssignment(state);
              if (state.comment) {
                node.comment = state.comment;
              }
              visible = state.token !== ";";
              blocks.push({
                node,
                visible
              });
            }
          }
          if (blocks.length > 0) {
            return new BlockNode2(blocks);
          } else {
            if (!node) {
              node = new ConstantNode2(void 0);
              if (state.comment) {
                node.comment = state.comment;
              }
            }
            return node;
          }
        }
        function parseAssignment(state) {
          var name307, args, value, valid;
          var node = parseConditional(state);
          if (state.token === "=") {
            if (isSymbolNode(node)) {
              name307 = node.name;
              getTokenSkipNewline(state);
              value = parseAssignment(state);
              return new AssignmentNode2(new SymbolNode2(name307), value);
            } else if (isAccessorNode(node)) {
              getTokenSkipNewline(state);
              value = parseAssignment(state);
              return new AssignmentNode2(node.object, node.index, value);
            } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
              valid = true;
              args = [];
              name307 = node.name;
              node.args.forEach(function(arg2, index2) {
                if (isSymbolNode(arg2)) {
                  args[index2] = arg2.name;
                } else {
                  valid = false;
                }
              });
              if (valid) {
                getTokenSkipNewline(state);
                value = parseAssignment(state);
                return new FunctionAssignmentNode2(name307, args, value);
              }
            }
            throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
          }
          return node;
        }
        function parseConditional(state) {
          var node = parseLogicalOr(state);
          while (state.token === "?") {
            var prev = state.conditionalLevel;
            state.conditionalLevel = state.nestingLevel;
            getTokenSkipNewline(state);
            var condition = node;
            var trueExpr = parseAssignment(state);
            if (state.token !== ":")
              throw createSyntaxError(state, "False part of conditional expression expected");
            state.conditionalLevel = null;
            getTokenSkipNewline(state);
            var falseExpr = parseAssignment(state);
            node = new ConditionalNode2(condition, trueExpr, falseExpr);
            state.conditionalLevel = prev;
          }
          return node;
        }
        function parseLogicalOr(state) {
          var node = parseLogicalXor(state);
          while (state.token === "or") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("or", "or", [node, parseLogicalXor(state)]);
          }
          return node;
        }
        function parseLogicalXor(state) {
          var node = parseLogicalAnd(state);
          while (state.token === "xor") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state)]);
          }
          return node;
        }
        function parseLogicalAnd(state) {
          var node = parseBitwiseOr(state);
          while (state.token === "and") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state)]);
          }
          return node;
        }
        function parseBitwiseOr(state) {
          var node = parseBitwiseXor(state);
          while (state.token === "|") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state)]);
          }
          return node;
        }
        function parseBitwiseXor(state) {
          var node = parseBitwiseAnd(state);
          while (state.token === "^|") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state)]);
          }
          return node;
        }
        function parseBitwiseAnd(state) {
          var node = parseRelational(state);
          while (state.token === "&") {
            getTokenSkipNewline(state);
            node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state)]);
          }
          return node;
        }
        function parseRelational(state) {
          var params = [parseShift(state)];
          var conditionals = [];
          var operators = {
            "==": "equal",
            "!=": "unequal",
            "<": "smaller",
            ">": "larger",
            "<=": "smallerEq",
            ">=": "largerEq"
          };
          while (hasOwnProperty2(operators, state.token)) {
            var cond = {
              name: state.token,
              fn: operators[state.token]
            };
            conditionals.push(cond);
            getTokenSkipNewline(state);
            params.push(parseShift(state));
          }
          if (params.length === 1) {
            return params[0];
          } else if (params.length === 2) {
            return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
          } else {
            return new RelationalNode2(conditionals.map((c3) => c3.fn), params);
          }
        }
        function parseShift(state) {
          var node, name307, fn2, params;
          node = parseConversion(state);
          var operators = {
            "<<": "leftShift",
            ">>": "rightArithShift",
            ">>>": "rightLogShift"
          };
          while (hasOwnProperty2(operators, state.token)) {
            name307 = state.token;
            fn2 = operators[name307];
            getTokenSkipNewline(state);
            params = [node, parseConversion(state)];
            node = new OperatorNode2(name307, fn2, params);
          }
          return node;
        }
        function parseConversion(state) {
          var node, name307, fn2, params;
          node = parseRange(state);
          var operators = {
            to: "to",
            in: "to"
            // alias of 'to'
          };
          while (hasOwnProperty2(operators, state.token)) {
            name307 = state.token;
            fn2 = operators[name307];
            getTokenSkipNewline(state);
            if (name307 === "in" && state.token === "") {
              node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
            } else {
              params = [node, parseRange(state)];
              node = new OperatorNode2(name307, fn2, params);
            }
          }
          return node;
        }
        function parseRange(state) {
          var node;
          var params = [];
          if (state.token === ":") {
            node = new ConstantNode2(1);
          } else {
            node = parseAddSubtract(state);
          }
          if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
            params.push(node);
            while (state.token === ":" && params.length < 3) {
              getTokenSkipNewline(state);
              if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
                params.push(new SymbolNode2("end"));
              } else {
                params.push(parseAddSubtract(state));
              }
            }
            if (params.length === 3) {
              node = new RangeNode2(params[0], params[2], params[1]);
            } else {
              node = new RangeNode2(params[0], params[1]);
            }
          }
          return node;
        }
        function parseAddSubtract(state) {
          var node, name307, fn2, params;
          node = parseMultiplyDivide(state);
          var operators = {
            "+": "add",
            "-": "subtract"
          };
          while (hasOwnProperty2(operators, state.token)) {
            name307 = state.token;
            fn2 = operators[name307];
            getTokenSkipNewline(state);
            var rightNode = parseMultiplyDivide(state);
            if (rightNode.isPercentage) {
              params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
            } else {
              params = [node, rightNode];
            }
            node = new OperatorNode2(name307, fn2, params);
          }
          return node;
        }
        function parseMultiplyDivide(state) {
          var node, last, name307, fn2;
          node = parseImplicitMultiplication(state);
          last = node;
          var operators = {
            "*": "multiply",
            ".*": "dotMultiply",
            "/": "divide",
            "./": "dotDivide"
          };
          while (true) {
            if (hasOwnProperty2(operators, state.token)) {
              name307 = state.token;
              fn2 = operators[name307];
              getTokenSkipNewline(state);
              last = parseImplicitMultiplication(state);
              node = new OperatorNode2(name307, fn2, [node, last]);
            } else {
              break;
            }
          }
          return node;
        }
        function parseImplicitMultiplication(state) {
          var node, last;
          node = parseRule2(state);
          last = node;
          while (true) {
            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
              last = parseRule2(state);
              node = new OperatorNode2(
                "*",
                "multiply",
                [node, last],
                true
                /* implicit */
              );
            } else {
              break;
            }
          }
          return node;
        }
        function parseRule2(state) {
          var node = parsePercentage(state);
          var last = node;
          var tokenStates = [];
          while (true) {
            if (state.token === "/" && rule2Node(last)) {
              tokenStates.push(_extends({}, state));
              getTokenSkipNewline(state);
              if (state.tokenType === TOKENTYPE.NUMBER) {
                tokenStates.push(_extends({}, state));
                getTokenSkipNewline(state);
                if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
                  _extends(state, tokenStates.pop());
                  tokenStates.pop();
                  last = parsePercentage(state);
                  node = new OperatorNode2("/", "divide", [node, last]);
                } else {
                  tokenStates.pop();
                  _extends(state, tokenStates.pop());
                  break;
                }
              } else {
                _extends(state, tokenStates.pop());
                break;
              }
            } else {
              break;
            }
          }
          return node;
        }
        function parsePercentage(state) {
          var node, name307, fn2, params;
          node = parseUnary(state);
          var operators = {
            "%": "mod",
            mod: "mod"
          };
          while (hasOwnProperty2(operators, state.token)) {
            name307 = state.token;
            fn2 = operators[name307];
            getTokenSkipNewline(state);
            if (name307 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
              node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
            } else {
              params = [node, parseUnary(state)];
              node = new OperatorNode2(name307, fn2, params);
            }
          }
          return node;
        }
        function parseUnary(state) {
          var name307, params, fn2;
          var operators = {
            "-": "unaryMinus",
            "+": "unaryPlus",
            "~": "bitNot",
            not: "not"
          };
          if (hasOwnProperty2(operators, state.token)) {
            fn2 = operators[state.token];
            name307 = state.token;
            getTokenSkipNewline(state);
            params = [parseUnary(state)];
            return new OperatorNode2(name307, fn2, params);
          }
          return parsePow(state);
        }
        function parsePow(state) {
          var node, name307, fn2, params;
          node = parseLeftHandOperators(state);
          if (state.token === "^" || state.token === ".^") {
            name307 = state.token;
            fn2 = name307 === "^" ? "pow" : "dotPow";
            getTokenSkipNewline(state);
            params = [node, parseUnary(state)];
            node = new OperatorNode2(name307, fn2, params);
          }
          return node;
        }
        function parseLeftHandOperators(state) {
          var node, name307, fn2, params;
          node = parseCustomNodes(state);
          var operators = {
            "!": "factorial",
            "'": "ctranspose"
          };
          while (hasOwnProperty2(operators, state.token)) {
            name307 = state.token;
            fn2 = operators[name307];
            getToken(state);
            params = [node];
            node = new OperatorNode2(name307, fn2, params);
            node = parseAccessors(state, node);
          }
          return node;
        }
        function parseCustomNodes(state) {
          var params = [];
          if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty2(state.extraNodes, state.token)) {
            var CustomNode = state.extraNodes[state.token];
            getToken(state);
            if (state.token === "(") {
              params = [];
              openParams(state);
              getToken(state);
              if (state.token !== ")") {
                params.push(parseAssignment(state));
                while (state.token === ",") {
                  getToken(state);
                  params.push(parseAssignment(state));
                }
              }
              if (state.token !== ")") {
                throw createSyntaxError(state, "Parenthesis ) expected");
              }
              closeParams(state);
              getToken(state);
            }
            return new CustomNode(params);
          }
          return parseSymbol(state);
        }
        function parseSymbol(state) {
          var node, name307;
          if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            name307 = state.token;
            getToken(state);
            if (hasOwnProperty2(CONSTANTS, name307)) {
              node = new ConstantNode2(CONSTANTS[name307]);
            } else if (NUMERIC_CONSTANTS.indexOf(name307) !== -1) {
              node = new ConstantNode2(numeric3(name307, "number"));
            } else {
              node = new SymbolNode2(name307);
            }
            node = parseAccessors(state, node);
            return node;
          }
          return parseDoubleQuotesString(state);
        }
        function parseAccessors(state, node, types) {
          var params;
          while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
            params = [];
            if (state.token === "(") {
              if (isSymbolNode(node) || isAccessorNode(node)) {
                openParams(state);
                getToken(state);
                if (state.token !== ")") {
                  params.push(parseAssignment(state));
                  while (state.token === ",") {
                    getToken(state);
                    params.push(parseAssignment(state));
                  }
                }
                if (state.token !== ")") {
                  throw createSyntaxError(state, "Parenthesis ) expected");
                }
                closeParams(state);
                getToken(state);
                node = new FunctionNode2(node, params);
              } else {
                return node;
              }
            } else if (state.token === "[") {
              openParams(state);
              getToken(state);
              if (state.token !== "]") {
                params.push(parseAssignment(state));
                while (state.token === ",") {
                  getToken(state);
                  params.push(parseAssignment(state));
                }
              }
              if (state.token !== "]") {
                throw createSyntaxError(state, "Parenthesis ] expected");
              }
              closeParams(state);
              getToken(state);
              node = new AccessorNode2(node, new IndexNode2(params));
            } else {
              getToken(state);
              if (state.tokenType !== TOKENTYPE.SYMBOL) {
                throw createSyntaxError(state, "Property name expected after dot");
              }
              params.push(new ConstantNode2(state.token));
              getToken(state);
              var dotNotation = true;
              node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
            }
          }
          return node;
        }
        function parseDoubleQuotesString(state) {
          var node, str;
          if (state.token === '"') {
            str = parseDoubleQuotesStringToken(state);
            node = new ConstantNode2(str);
            node = parseAccessors(state, node);
            return node;
          }
          return parseSingleQuotesString(state);
        }
        function parseDoubleQuotesStringToken(state) {
          var str = "";
          while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
            if (currentCharacter(state) === "\\") {
              str += currentCharacter(state);
              next(state);
            }
            str += currentCharacter(state);
            next(state);
          }
          getToken(state);
          if (state.token !== '"') {
            throw createSyntaxError(state, 'End of string " expected');
          }
          getToken(state);
          return JSON.parse('"' + str + '"');
        }
        function parseSingleQuotesString(state) {
          var node, str;
          if (state.token === "'") {
            str = parseSingleQuotesStringToken(state);
            node = new ConstantNode2(str);
            node = parseAccessors(state, node);
            return node;
          }
          return parseMatrix(state);
        }
        function parseSingleQuotesStringToken(state) {
          var str = "";
          while (currentCharacter(state) !== "" && currentCharacter(state) !== "'") {
            if (currentCharacter(state) === "\\") {
              str += currentCharacter(state);
              next(state);
            }
            str += currentCharacter(state);
            next(state);
          }
          getToken(state);
          if (state.token !== "'") {
            throw createSyntaxError(state, "End of string ' expected");
          }
          getToken(state);
          return JSON.parse('"' + str + '"');
        }
        function parseMatrix(state) {
          var array, params, rows, cols;
          if (state.token === "[") {
            openParams(state);
            getToken(state);
            if (state.token !== "]") {
              var row2 = parseRow(state);
              if (state.token === ";") {
                rows = 1;
                params = [row2];
                while (state.token === ";") {
                  getToken(state);
                  params[rows] = parseRow(state);
                  rows++;
                }
                if (state.token !== "]") {
                  throw createSyntaxError(state, "End of matrix ] expected");
                }
                closeParams(state);
                getToken(state);
                cols = params[0].items.length;
                for (var r3 = 1; r3 < rows; r3++) {
                  if (params[r3].items.length !== cols) {
                    throw createError(state, "Column dimensions mismatch (" + params[r3].items.length + " !== " + cols + ")");
                  }
                }
                array = new ArrayNode2(params);
              } else {
                if (state.token !== "]") {
                  throw createSyntaxError(state, "End of matrix ] expected");
                }
                closeParams(state);
                getToken(state);
                array = row2;
              }
            } else {
              closeParams(state);
              getToken(state);
              array = new ArrayNode2([]);
            }
            return parseAccessors(state, array);
          }
          return parseObject(state);
        }
        function parseRow(state) {
          var params = [parseAssignment(state)];
          var len = 1;
          while (state.token === ",") {
            getToken(state);
            params[len] = parseAssignment(state);
            len++;
          }
          return new ArrayNode2(params);
        }
        function parseObject(state) {
          if (state.token === "{") {
            openParams(state);
            var key;
            var properties2 = {};
            do {
              getToken(state);
              if (state.token !== "}") {
                if (state.token === '"') {
                  key = parseDoubleQuotesStringToken(state);
                } else if (state.token === "'") {
                  key = parseSingleQuotesStringToken(state);
                } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
                  key = state.token;
                  getToken(state);
                } else {
                  throw createSyntaxError(state, "Symbol or string expected as object key");
                }
                if (state.token !== ":") {
                  throw createSyntaxError(state, "Colon : expected after object key");
                }
                getToken(state);
                properties2[key] = parseAssignment(state);
              }
            } while (state.token === ",");
            if (state.token !== "}") {
              throw createSyntaxError(state, "Comma , or bracket } expected after object value");
            }
            closeParams(state);
            getToken(state);
            var node = new ObjectNode2(properties2);
            node = parseAccessors(state, node);
            return node;
          }
          return parseNumber(state);
        }
        function parseNumber(state) {
          var numberStr;
          if (state.tokenType === TOKENTYPE.NUMBER) {
            numberStr = state.token;
            getToken(state);
            return new ConstantNode2(numeric3(numberStr, config4.number));
          }
          return parseParentheses(state);
        }
        function parseParentheses(state) {
          var node;
          if (state.token === "(") {
            openParams(state);
            getToken(state);
            node = parseAssignment(state);
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new ParenthesisNode2(node);
            node = parseAccessors(state, node);
            return node;
          }
          return parseEnd(state);
        }
        function parseEnd(state) {
          if (state.token === "") {
            throw createSyntaxError(state, "Unexpected end of expression");
          } else {
            throw createSyntaxError(state, "Value expected");
          }
        }
        function col(state) {
          return state.index - state.token.length + 1;
        }
        function createSyntaxError(state, message) {
          var c3 = col(state);
          var error = new SyntaxError(message + " (char " + c3 + ")");
          error.char = c3;
          return error;
        }
        function createError(state, message) {
          var c3 = col(state);
          var error = new SyntaxError(message + " (char " + c3 + ")");
          error.char = c3;
          return error;
        }
        typed3.addConversion({
          from: "string",
          to: "Node",
          convert: parse2
        });
        return parse2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/function/compile.js
  var name222, dependencies222, createCompile;
  var init_compile = __esm({
    "node_modules/mathjs/lib/esm/expression/function/compile.js"() {
      init_collection();
      init_factory();
      name222 = "compile";
      dependencies222 = ["typed", "parse"];
      createCompile = /* @__PURE__ */ factory(name222, dependencies222, (_ref) => {
        var {
          typed: typed3,
          parse: parse2
        } = _ref;
        return typed3(name222, {
          string: function string2(expr) {
            return parse2(expr).compile();
          },
          "Array | Matrix": function ArrayMatrix(expr) {
            return deepMap(expr, function(entry) {
              return parse2(entry).compile();
            });
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/function/evaluate.js
  var name223, dependencies223, createEvaluate;
  var init_evaluate = __esm({
    "node_modules/mathjs/lib/esm/expression/function/evaluate.js"() {
      init_collection();
      init_factory();
      init_map();
      name223 = "evaluate";
      dependencies223 = ["typed", "parse"];
      createEvaluate = /* @__PURE__ */ factory(name223, dependencies223, (_ref) => {
        var {
          typed: typed3,
          parse: parse2
        } = _ref;
        return typed3(name223, {
          string: function string2(expr) {
            var scope = createEmptyMap();
            return parse2(expr).compile().evaluate(scope);
          },
          "string, Map | Object": function stringMapObject(expr, scope) {
            return parse2(expr).compile().evaluate(scope);
          },
          "Array | Matrix": function ArrayMatrix(expr) {
            var scope = createEmptyMap();
            return deepMap(expr, function(entry) {
              return parse2(entry).compile().evaluate(scope);
            });
          },
          "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
            return deepMap(expr, function(entry) {
              return parse2(entry).compile().evaluate(scope);
            });
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/Parser.js
  var name224, dependencies224, createParserClass;
  var init_Parser = __esm({
    "node_modules/mathjs/lib/esm/expression/Parser.js"() {
      init_factory();
      init_map();
      name224 = "Parser";
      dependencies224 = ["evaluate"];
      createParserClass = /* @__PURE__ */ factory(name224, dependencies224, (_ref) => {
        var {
          evaluate: evaluate2
        } = _ref;
        function Parser2() {
          if (!(this instanceof Parser2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          Object.defineProperty(this, "scope", {
            value: createEmptyMap(),
            writable: false
          });
        }
        Parser2.prototype.type = "Parser";
        Parser2.prototype.isParser = true;
        Parser2.prototype.evaluate = function(expr) {
          return evaluate2(expr, this.scope);
        };
        Parser2.prototype.get = function(name307) {
          if (this.scope.has(name307)) {
            return this.scope.get(name307);
          }
        };
        Parser2.prototype.getAll = function() {
          return toObject(this.scope);
        };
        Parser2.prototype.getAllAsMap = function() {
          return this.scope;
        };
        Parser2.prototype.set = function(name307, value) {
          this.scope.set(name307, value);
          return value;
        };
        Parser2.prototype.remove = function(name307) {
          this.scope.delete(name307);
        };
        Parser2.prototype.clear = function() {
          this.scope.clear();
        };
        return Parser2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/function/parser.js
  var name225, dependencies225, createParser;
  var init_parser = __esm({
    "node_modules/mathjs/lib/esm/expression/function/parser.js"() {
      init_factory();
      name225 = "parser";
      dependencies225 = ["typed", "Parser"];
      createParser = /* @__PURE__ */ factory(name225, dependencies225, (_ref) => {
        var {
          typed: typed3,
          Parser: Parser2
        } = _ref;
        return typed3(name225, {
          "": function _3() {
            return new Parser2();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
  var name226, dependencies226, createLup;
  var init_lup = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"() {
      init_object();
      init_factory();
      name226 = "lup";
      dependencies226 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
      createLup = /* @__PURE__ */ factory(name226, dependencies226, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          abs: abs3,
          addScalar: addScalar2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          larger: larger2,
          equalScalar: equalScalar2,
          unaryMinus: unaryMinus2,
          DenseMatrix: DenseMatrix2,
          SparseMatrix: SparseMatrix2,
          Spa: Spa2
        } = _ref;
        return typed3(name226, {
          DenseMatrix: function DenseMatrix3(m3) {
            return _denseLUP(m3);
          },
          SparseMatrix: function SparseMatrix3(m3) {
            return _sparseLUP(m3);
          },
          Array: function Array2(a3) {
            var m3 = matrix2(a3);
            var r3 = _denseLUP(m3);
            return {
              L: r3.L.valueOf(),
              U: r3.U.valueOf(),
              p: r3.p
            };
          }
        });
        function _denseLUP(m3) {
          var rows = m3._size[0];
          var columns = m3._size[1];
          var n3 = Math.min(rows, columns);
          var data = clone(m3._data);
          var ldata = [];
          var lsize = [rows, n3];
          var udata = [];
          var usize = [n3, columns];
          var i5, j4, k4;
          var p3 = [];
          for (i5 = 0; i5 < rows; i5++) {
            p3[i5] = i5;
          }
          for (j4 = 0; j4 < columns; j4++) {
            if (j4 > 0) {
              for (i5 = 0; i5 < rows; i5++) {
                var min3 = Math.min(i5, j4);
                var s3 = 0;
                for (k4 = 0; k4 < min3; k4++) {
                  s3 = addScalar2(s3, multiplyScalar2(data[i5][k4], data[k4][j4]));
                }
                data[i5][j4] = subtract2(data[i5][j4], s3);
              }
            }
            var pi3 = j4;
            var pabsv = 0;
            var vjj = 0;
            for (i5 = j4; i5 < rows; i5++) {
              var v3 = data[i5][j4];
              var absv = abs3(v3);
              if (larger2(absv, pabsv)) {
                pi3 = i5;
                pabsv = absv;
                vjj = v3;
              }
            }
            if (j4 !== pi3) {
              p3[j4] = [p3[pi3], p3[pi3] = p3[j4]][0];
              DenseMatrix2._swapRows(j4, pi3, data);
            }
            if (j4 < rows) {
              for (i5 = j4 + 1; i5 < rows; i5++) {
                var vij = data[i5][j4];
                if (!equalScalar2(vij, 0)) {
                  data[i5][j4] = divideScalar2(data[i5][j4], vjj);
                }
              }
            }
          }
          for (j4 = 0; j4 < columns; j4++) {
            for (i5 = 0; i5 < rows; i5++) {
              if (j4 === 0) {
                if (i5 < columns) {
                  udata[i5] = [];
                }
                ldata[i5] = [];
              }
              if (i5 < j4) {
                if (i5 < columns) {
                  udata[i5][j4] = data[i5][j4];
                }
                if (j4 < rows) {
                  ldata[i5][j4] = 0;
                }
                continue;
              }
              if (i5 === j4) {
                if (i5 < columns) {
                  udata[i5][j4] = data[i5][j4];
                }
                if (j4 < rows) {
                  ldata[i5][j4] = 1;
                }
                continue;
              }
              if (i5 < columns) {
                udata[i5][j4] = 0;
              }
              if (j4 < rows) {
                ldata[i5][j4] = data[i5][j4];
              }
            }
          }
          var l3 = new DenseMatrix2({
            data: ldata,
            size: lsize
          });
          var u3 = new DenseMatrix2({
            data: udata,
            size: usize
          });
          var pv = [];
          for (i5 = 0, n3 = p3.length; i5 < n3; i5++) {
            pv[p3[i5]] = i5;
          }
          return {
            L: l3,
            U: u3,
            p: pv,
            toString: function toString2() {
              return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
            }
          };
        }
        function _sparseLUP(m3) {
          var rows = m3._size[0];
          var columns = m3._size[1];
          var n3 = Math.min(rows, columns);
          var values = m3._values;
          var index2 = m3._index;
          var ptr = m3._ptr;
          var lvalues = [];
          var lindex = [];
          var lptr = [];
          var lsize = [rows, n3];
          var uvalues = [];
          var uindex = [];
          var uptr = [];
          var usize = [n3, columns];
          var i5, j4, k4;
          var pvCo = [];
          var pvOc = [];
          for (i5 = 0; i5 < rows; i5++) {
            pvCo[i5] = i5;
            pvOc[i5] = i5;
          }
          var swapIndeces = function swapIndeces2(x4, y3) {
            var kx = pvOc[x4];
            var ky = pvOc[y3];
            pvCo[kx] = y3;
            pvCo[ky] = x4;
            pvOc[x4] = ky;
            pvOc[y3] = kx;
          };
          var _loop = function _loop2() {
            var spa = new Spa2();
            if (j4 < rows) {
              lptr.push(lvalues.length);
              lvalues.push(1);
              lindex.push(j4);
            }
            uptr.push(uvalues.length);
            var k0 = ptr[j4];
            var k1 = ptr[j4 + 1];
            for (k4 = k0; k4 < k1; k4++) {
              i5 = index2[k4];
              spa.set(pvCo[i5], values[k4]);
            }
            if (j4 > 0) {
              spa.forEach(0, j4 - 1, function(k5, vkj) {
                SparseMatrix2._forEachRow(k5, lvalues, lindex, lptr, function(i6, vik) {
                  if (i6 > k5) {
                    spa.accumulate(i6, unaryMinus2(multiplyScalar2(vik, vkj)));
                  }
                });
              });
            }
            var pi3 = j4;
            var vjj = spa.get(j4);
            var pabsv = abs3(vjj);
            spa.forEach(j4 + 1, rows - 1, function(x4, v3) {
              var absv = abs3(v3);
              if (larger2(absv, pabsv)) {
                pi3 = x4;
                pabsv = absv;
                vjj = v3;
              }
            });
            if (j4 !== pi3) {
              SparseMatrix2._swapRows(j4, pi3, lsize[1], lvalues, lindex, lptr);
              SparseMatrix2._swapRows(j4, pi3, usize[1], uvalues, uindex, uptr);
              spa.swap(j4, pi3);
              swapIndeces(j4, pi3);
            }
            spa.forEach(0, rows - 1, function(x4, v3) {
              if (x4 <= j4) {
                uvalues.push(v3);
                uindex.push(x4);
              } else {
                v3 = divideScalar2(v3, vjj);
                if (!equalScalar2(v3, 0)) {
                  lvalues.push(v3);
                  lindex.push(x4);
                }
              }
            });
          };
          for (j4 = 0; j4 < columns; j4++) {
            _loop();
          }
          uptr.push(uvalues.length);
          lptr.push(lvalues.length);
          return {
            L: new SparseMatrix2({
              values: lvalues,
              index: lindex,
              ptr: lptr,
              size: lsize
            }),
            U: new SparseMatrix2({
              values: uvalues,
              index: uindex,
              ptr: uptr,
              size: usize
            }),
            p: pvCo,
            toString: function toString2() {
              return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
            }
          };
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
  var name227, dependencies227, createQr;
  var init_qr = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js"() {
      init_extends();
      init_factory();
      name227 = "qr";
      dependencies227 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
      createQr = /* @__PURE__ */ factory(name227, dependencies227, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          zeros: zeros3,
          identity: identity2,
          isZero: isZero2,
          equal: equal2,
          sign: sign4,
          sqrt: sqrt3,
          conj: conj2,
          unaryMinus: unaryMinus2,
          addScalar: addScalar2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          subtract: subtract2,
          complex: complex2
        } = _ref;
        return _extends(typed3(name227, {
          DenseMatrix: function DenseMatrix2(m3) {
            return _denseQR(m3);
          },
          SparseMatrix: function SparseMatrix2(m3) {
            return _sparseQR(m3);
          },
          Array: function Array2(a3) {
            var m3 = matrix2(a3);
            var r3 = _denseQR(m3);
            return {
              Q: r3.Q.valueOf(),
              R: r3.R.valueOf()
            };
          }
        }), {
          _denseQRimpl
        });
        function _denseQRimpl(m3) {
          var rows = m3._size[0];
          var cols = m3._size[1];
          var Q3 = identity2([rows], "dense");
          var Qdata = Q3._data;
          var R2 = m3.clone();
          var Rdata = R2._data;
          var i5, j4, k4;
          var w4 = zeros3([rows], "");
          for (k4 = 0; k4 < Math.min(cols, rows); ++k4) {
            var pivot = Rdata[k4][k4];
            var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign4(pivot));
            var conjSgn = conj2(sgn);
            var alphaSquared = 0;
            for (i5 = k4; i5 < rows; i5++) {
              alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i5][k4], conj2(Rdata[i5][k4])));
            }
            var alpha = multiplyScalar2(sgn, sqrt3(alphaSquared));
            if (!isZero2(alpha)) {
              var u1 = subtract2(pivot, alpha);
              w4[k4] = 1;
              for (i5 = k4 + 1; i5 < rows; i5++) {
                w4[i5] = divideScalar2(Rdata[i5][k4], u1);
              }
              var tau3 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
              var s3 = void 0;
              for (j4 = k4; j4 < cols; j4++) {
                s3 = 0;
                for (i5 = k4; i5 < rows; i5++) {
                  s3 = addScalar2(s3, multiplyScalar2(conj2(w4[i5]), Rdata[i5][j4]));
                }
                s3 = multiplyScalar2(s3, tau3);
                for (i5 = k4; i5 < rows; i5++) {
                  Rdata[i5][j4] = multiplyScalar2(subtract2(Rdata[i5][j4], multiplyScalar2(w4[i5], s3)), conjSgn);
                }
              }
              for (i5 = 0; i5 < rows; i5++) {
                s3 = 0;
                for (j4 = k4; j4 < rows; j4++) {
                  s3 = addScalar2(s3, multiplyScalar2(Qdata[i5][j4], w4[j4]));
                }
                s3 = multiplyScalar2(s3, tau3);
                for (j4 = k4; j4 < rows; ++j4) {
                  Qdata[i5][j4] = divideScalar2(subtract2(Qdata[i5][j4], multiplyScalar2(s3, conj2(w4[j4]))), conjSgn);
                }
              }
            }
          }
          return {
            Q: Q3,
            R: R2,
            toString: function toString2() {
              return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
            }
          };
        }
        function _denseQR(m3) {
          var ret = _denseQRimpl(m3);
          var Rdata = ret.R._data;
          if (m3._data.length > 0) {
            var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
            for (var i5 = 0; i5 < Rdata.length; ++i5) {
              for (var j4 = 0; j4 < i5 && j4 < (Rdata[0] || []).length; ++j4) {
                Rdata[i5][j4] = zero;
              }
            }
          }
          return ret;
        }
        function _sparseQR(m3) {
          throw new Error("qr not implemented for sparse matrices yet");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
  function csPermute(a3, pinv2, q4, values) {
    var avalues = a3._values;
    var aindex = a3._index;
    var aptr = a3._ptr;
    var asize = a3._size;
    var adt = a3._datatype;
    var m3 = asize[0];
    var n3 = asize[1];
    var cvalues = values && a3._values ? [] : null;
    var cindex = [];
    var cptr = [];
    var nz = 0;
    for (var k4 = 0; k4 < n3; k4++) {
      cptr[k4] = nz;
      var j4 = q4 ? q4[k4] : k4;
      for (var t0 = aptr[j4], t1 = aptr[j4 + 1], t3 = t0; t3 < t1; t3++) {
        var r3 = pinv2 ? pinv2[aindex[t3]] : aindex[t3];
        cindex[nz] = r3;
        if (cvalues) {
          cvalues[nz] = avalues[t3];
        }
        nz++;
      }
    }
    cptr[n3] = nz;
    return a3.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m3, n3],
      datatype: adt
    });
  }
  var init_csPermute = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
  function csTdfs(j4, k4, w4, head, next, post, stack) {
    var top = 0;
    w4[stack] = j4;
    while (top >= 0) {
      var p3 = w4[stack + top];
      var i5 = w4[head + p3];
      if (i5 === -1) {
        top--;
        post[k4++] = p3;
      } else {
        w4[head + p3] = w4[next + i5];
        ++top;
        w4[stack + top] = i5;
      }
    }
    return k4;
  }
  var init_csTdfs = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
  function csPost(parent, n3) {
    if (!parent) {
      return null;
    }
    var k4 = 0;
    var j4;
    var post = [];
    var w4 = [];
    var head = 0;
    var next = n3;
    var stack = 2 * n3;
    for (j4 = 0; j4 < n3; j4++) {
      w4[head + j4] = -1;
    }
    for (j4 = n3 - 1; j4 >= 0; j4--) {
      if (parent[j4] === -1) {
        continue;
      }
      w4[next + j4] = w4[head + parent[j4]];
      w4[head + parent[j4]] = j4;
    }
    for (j4 = 0; j4 < n3; j4++) {
      if (parent[j4] !== -1) {
        continue;
      }
      k4 = csTdfs(j4, k4, w4, head, next, post, stack);
    }
    return post;
  }
  var init_csPost = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js"() {
      init_csTdfs();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
  function csEtree(a3, ata) {
    if (!a3) {
      return null;
    }
    var aindex = a3._index;
    var aptr = a3._ptr;
    var asize = a3._size;
    var m3 = asize[0];
    var n3 = asize[1];
    var parent = [];
    var w4 = [];
    var ancestor = 0;
    var prev = n3;
    var i5, inext;
    if (ata) {
      for (i5 = 0; i5 < m3; i5++) {
        w4[prev + i5] = -1;
      }
    }
    for (var k4 = 0; k4 < n3; k4++) {
      parent[k4] = -1;
      w4[ancestor + k4] = -1;
      for (var p0 = aptr[k4], p1 = aptr[k4 + 1], p3 = p0; p3 < p1; p3++) {
        var r3 = aindex[p3];
        i5 = ata ? w4[prev + r3] : r3;
        for (; i5 !== -1 && i5 < k4; i5 = inext) {
          inext = w4[ancestor + i5];
          w4[ancestor + i5] = k4;
          if (inext === -1) {
            parent[i5] = k4;
          }
        }
        if (ata) {
          w4[prev + r3] = k4;
        }
      }
    }
    return parent;
  }
  var init_csEtree = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
  function csFkeep(a3, callback, other) {
    var avalues = a3._values;
    var aindex = a3._index;
    var aptr = a3._ptr;
    var asize = a3._size;
    var n3 = asize[1];
    var nz = 0;
    for (var j4 = 0; j4 < n3; j4++) {
      var p3 = aptr[j4];
      aptr[j4] = nz;
      for (; p3 < aptr[j4 + 1]; p3++) {
        if (callback(aindex[p3], j4, avalues ? avalues[p3] : 1, other)) {
          aindex[nz] = aindex[p3];
          if (avalues) {
            avalues[nz] = avalues[p3];
          }
          nz++;
        }
      }
    }
    aptr[n3] = nz;
    aindex.splice(nz, aindex.length - nz);
    if (avalues) {
      avalues.splice(nz, avalues.length - nz);
    }
    return nz;
  }
  var init_csFkeep = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
  function csFlip(i5) {
    return -i5 - 2;
  }
  var init_csFlip = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
  var name228, dependencies228, createCsAmd;
  var init_csAmd = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js"() {
      init_factory();
      init_csFkeep();
      init_csFlip();
      init_csTdfs();
      name228 = "csAmd";
      dependencies228 = ["add", "multiply", "transpose"];
      createCsAmd = /* @__PURE__ */ factory(name228, dependencies228, (_ref) => {
        var {
          add: add3,
          multiply: multiply2,
          transpose: transpose2
        } = _ref;
        return function csAmd(order, a3) {
          if (!a3 || order <= 0 || order > 3) {
            return null;
          }
          var asize = a3._size;
          var m3 = asize[0];
          var n3 = asize[1];
          var lemax = 0;
          var dense = Math.max(16, 10 * Math.sqrt(n3));
          dense = Math.min(n3 - 2, dense);
          var cm = _createTargetMatrix(order, a3, m3, n3, dense);
          csFkeep(cm, _diag, null);
          var cindex = cm._index;
          var cptr = cm._ptr;
          var cnz = cptr[n3];
          var P6 = [];
          var W2 = [];
          var len = 0;
          var nv = n3 + 1;
          var next = 2 * (n3 + 1);
          var head = 3 * (n3 + 1);
          var elen = 4 * (n3 + 1);
          var degree = 5 * (n3 + 1);
          var w4 = 6 * (n3 + 1);
          var hhead = 7 * (n3 + 1);
          var last = P6;
          var mark = _initializeQuotientGraph(n3, cptr, W2, len, head, last, next, hhead, nv, w4, elen, degree);
          var nel = _initializeDegreeLists(n3, cptr, W2, degree, elen, w4, dense, nv, head, last, next);
          var mindeg = 0;
          var i5, j4, k4, k1, k22, e6, pj, ln3, nvi, pk, eln, p1, p22, pn2, h3, d3;
          while (nel < n3) {
            for (k4 = -1; mindeg < n3 && (k4 = W2[head + mindeg]) === -1; mindeg++)
              ;
            if (W2[next + k4] !== -1) {
              last[W2[next + k4]] = -1;
            }
            W2[head + mindeg] = W2[next + k4];
            var elenk = W2[elen + k4];
            var nvk = W2[nv + k4];
            nel += nvk;
            var dk = 0;
            W2[nv + k4] = -nvk;
            var p3 = cptr[k4];
            var pk1 = elenk === 0 ? p3 : cnz;
            var pk2 = pk1;
            for (k1 = 1; k1 <= elenk + 1; k1++) {
              if (k1 > elenk) {
                e6 = k4;
                pj = p3;
                ln3 = W2[len + k4] - elenk;
              } else {
                e6 = cindex[p3++];
                pj = cptr[e6];
                ln3 = W2[len + e6];
              }
              for (k22 = 1; k22 <= ln3; k22++) {
                i5 = cindex[pj++];
                if ((nvi = W2[nv + i5]) <= 0) {
                  continue;
                }
                dk += nvi;
                W2[nv + i5] = -nvi;
                cindex[pk2++] = i5;
                if (W2[next + i5] !== -1) {
                  last[W2[next + i5]] = last[i5];
                }
                if (last[i5] !== -1) {
                  W2[next + last[i5]] = W2[next + i5];
                } else {
                  W2[head + W2[degree + i5]] = W2[next + i5];
                }
              }
              if (e6 !== k4) {
                cptr[e6] = csFlip(k4);
                W2[w4 + e6] = 0;
              }
            }
            if (elenk !== 0) {
              cnz = pk2;
            }
            W2[degree + k4] = dk;
            cptr[k4] = pk1;
            W2[len + k4] = pk2 - pk1;
            W2[elen + k4] = -2;
            mark = _wclear(mark, lemax, W2, w4, n3);
            for (pk = pk1; pk < pk2; pk++) {
              i5 = cindex[pk];
              if ((eln = W2[elen + i5]) <= 0) {
                continue;
              }
              nvi = -W2[nv + i5];
              var wnvi = mark - nvi;
              for (p3 = cptr[i5], p1 = cptr[i5] + eln - 1; p3 <= p1; p3++) {
                e6 = cindex[p3];
                if (W2[w4 + e6] >= mark) {
                  W2[w4 + e6] -= nvi;
                } else if (W2[w4 + e6] !== 0) {
                  W2[w4 + e6] = W2[degree + e6] + wnvi;
                }
              }
            }
            for (pk = pk1; pk < pk2; pk++) {
              i5 = cindex[pk];
              p1 = cptr[i5];
              p22 = p1 + W2[elen + i5] - 1;
              pn2 = p1;
              for (h3 = 0, d3 = 0, p3 = p1; p3 <= p22; p3++) {
                e6 = cindex[p3];
                if (W2[w4 + e6] !== 0) {
                  var dext = W2[w4 + e6] - mark;
                  if (dext > 0) {
                    d3 += dext;
                    cindex[pn2++] = e6;
                    h3 += e6;
                  } else {
                    cptr[e6] = csFlip(k4);
                    W2[w4 + e6] = 0;
                  }
                }
              }
              W2[elen + i5] = pn2 - p1 + 1;
              var p32 = pn2;
              var p4 = p1 + W2[len + i5];
              for (p3 = p22 + 1; p3 < p4; p3++) {
                j4 = cindex[p3];
                var nvj = W2[nv + j4];
                if (nvj <= 0) {
                  continue;
                }
                d3 += nvj;
                cindex[pn2++] = j4;
                h3 += j4;
              }
              if (d3 === 0) {
                cptr[i5] = csFlip(k4);
                nvi = -W2[nv + i5];
                dk -= nvi;
                nvk += nvi;
                nel += nvi;
                W2[nv + i5] = 0;
                W2[elen + i5] = -1;
              } else {
                W2[degree + i5] = Math.min(W2[degree + i5], d3);
                cindex[pn2] = cindex[p32];
                cindex[p32] = cindex[p1];
                cindex[p1] = k4;
                W2[len + i5] = pn2 - p1 + 1;
                h3 = (h3 < 0 ? -h3 : h3) % n3;
                W2[next + i5] = W2[hhead + h3];
                W2[hhead + h3] = i5;
                last[i5] = h3;
              }
            }
            W2[degree + k4] = dk;
            lemax = Math.max(lemax, dk);
            mark = _wclear(mark + lemax, lemax, W2, w4, n3);
            for (pk = pk1; pk < pk2; pk++) {
              i5 = cindex[pk];
              if (W2[nv + i5] >= 0) {
                continue;
              }
              h3 = last[i5];
              i5 = W2[hhead + h3];
              W2[hhead + h3] = -1;
              for (; i5 !== -1 && W2[next + i5] !== -1; i5 = W2[next + i5], mark++) {
                ln3 = W2[len + i5];
                eln = W2[elen + i5];
                for (p3 = cptr[i5] + 1; p3 <= cptr[i5] + ln3 - 1; p3++) {
                  W2[w4 + cindex[p3]] = mark;
                }
                var jlast = i5;
                for (j4 = W2[next + i5]; j4 !== -1; ) {
                  var ok = W2[len + j4] === ln3 && W2[elen + j4] === eln;
                  for (p3 = cptr[j4] + 1; ok && p3 <= cptr[j4] + ln3 - 1; p3++) {
                    if (W2[w4 + cindex[p3]] !== mark) {
                      ok = 0;
                    }
                  }
                  if (ok) {
                    cptr[j4] = csFlip(i5);
                    W2[nv + i5] += W2[nv + j4];
                    W2[nv + j4] = 0;
                    W2[elen + j4] = -1;
                    j4 = W2[next + j4];
                    W2[next + jlast] = j4;
                  } else {
                    jlast = j4;
                    j4 = W2[next + j4];
                  }
                }
              }
            }
            for (p3 = pk1, pk = pk1; pk < pk2; pk++) {
              i5 = cindex[pk];
              if ((nvi = -W2[nv + i5]) <= 0) {
                continue;
              }
              W2[nv + i5] = nvi;
              d3 = W2[degree + i5] + dk - nvi;
              d3 = Math.min(d3, n3 - nel - nvi);
              if (W2[head + d3] !== -1) {
                last[W2[head + d3]] = i5;
              }
              W2[next + i5] = W2[head + d3];
              last[i5] = -1;
              W2[head + d3] = i5;
              mindeg = Math.min(mindeg, d3);
              W2[degree + i5] = d3;
              cindex[p3++] = i5;
            }
            W2[nv + k4] = nvk;
            if ((W2[len + k4] = p3 - pk1) === 0) {
              cptr[k4] = -1;
              W2[w4 + k4] = 0;
            }
            if (elenk !== 0) {
              cnz = p3;
            }
          }
          for (i5 = 0; i5 < n3; i5++) {
            cptr[i5] = csFlip(cptr[i5]);
          }
          for (j4 = 0; j4 <= n3; j4++) {
            W2[head + j4] = -1;
          }
          for (j4 = n3; j4 >= 0; j4--) {
            if (W2[nv + j4] > 0) {
              continue;
            }
            W2[next + j4] = W2[head + cptr[j4]];
            W2[head + cptr[j4]] = j4;
          }
          for (e6 = n3; e6 >= 0; e6--) {
            if (W2[nv + e6] <= 0) {
              continue;
            }
            if (cptr[e6] !== -1) {
              W2[next + e6] = W2[head + cptr[e6]];
              W2[head + cptr[e6]] = e6;
            }
          }
          for (k4 = 0, i5 = 0; i5 <= n3; i5++) {
            if (cptr[i5] === -1) {
              k4 = csTdfs(i5, k4, W2, head, next, P6, w4);
            }
          }
          P6.splice(P6.length - 1, 1);
          return P6;
        };
        function _createTargetMatrix(order, a3, m3, n3, dense) {
          var at = transpose2(a3);
          if (order === 1 && n3 === m3) {
            return add3(a3, at);
          }
          if (order === 2) {
            var tindex = at._index;
            var tptr = at._ptr;
            var p22 = 0;
            for (var j4 = 0; j4 < m3; j4++) {
              var p3 = tptr[j4];
              tptr[j4] = p22;
              if (tptr[j4 + 1] - p3 > dense) {
                continue;
              }
              for (var p1 = tptr[j4 + 1]; p3 < p1; p3++) {
                tindex[p22++] = tindex[p3];
              }
            }
            tptr[m3] = p22;
            a3 = transpose2(at);
            return multiply2(at, a3);
          }
          return multiply2(at, a3);
        }
        function _initializeQuotientGraph(n3, cptr, W2, len, head, last, next, hhead, nv, w4, elen, degree) {
          for (var k4 = 0; k4 < n3; k4++) {
            W2[len + k4] = cptr[k4 + 1] - cptr[k4];
          }
          W2[len + n3] = 0;
          for (var i5 = 0; i5 <= n3; i5++) {
            W2[head + i5] = -1;
            last[i5] = -1;
            W2[next + i5] = -1;
            W2[hhead + i5] = -1;
            W2[nv + i5] = 1;
            W2[w4 + i5] = 1;
            W2[elen + i5] = 0;
            W2[degree + i5] = W2[len + i5];
          }
          var mark = _wclear(0, 0, W2, w4, n3);
          W2[elen + n3] = -2;
          cptr[n3] = -1;
          W2[w4 + n3] = 0;
          return mark;
        }
        function _initializeDegreeLists(n3, cptr, W2, degree, elen, w4, dense, nv, head, last, next) {
          var nel = 0;
          for (var i5 = 0; i5 < n3; i5++) {
            var d3 = W2[degree + i5];
            if (d3 === 0) {
              W2[elen + i5] = -2;
              nel++;
              cptr[i5] = -1;
              W2[w4 + i5] = 0;
            } else if (d3 > dense) {
              W2[nv + i5] = 0;
              W2[elen + i5] = -1;
              nel++;
              cptr[i5] = csFlip(n3);
              W2[nv + n3]++;
            } else {
              var h3 = W2[head + d3];
              if (h3 !== -1) {
                last[h3] = i5;
              }
              W2[next + i5] = W2[head + d3];
              W2[head + d3] = i5;
            }
          }
          return nel;
        }
        function _wclear(mark, lemax, W2, w4, n3) {
          if (mark < 2 || mark + lemax < 0) {
            for (var k4 = 0; k4 < n3; k4++) {
              if (W2[w4 + k4] !== 0) {
                W2[w4 + k4] = 1;
              }
            }
            mark = 2;
          }
          return mark;
        }
        function _diag(i5, j4) {
          return i5 !== j4;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
  function csLeaf(i5, j4, w4, first, maxfirst, prevleaf, ancestor) {
    var s3, sparent;
    var jleaf = 0;
    var q4;
    if (i5 <= j4 || w4[first + j4] <= w4[maxfirst + i5]) {
      return -1;
    }
    w4[maxfirst + i5] = w4[first + j4];
    var jprev = w4[prevleaf + i5];
    w4[prevleaf + i5] = j4;
    if (jprev === -1) {
      jleaf = 1;
      q4 = i5;
    } else {
      jleaf = 2;
      for (q4 = jprev; q4 !== w4[ancestor + q4]; q4 = w4[ancestor + q4])
        ;
      for (s3 = jprev; s3 !== q4; s3 = sparent) {
        sparent = w4[ancestor + s3];
        w4[ancestor + s3] = q4;
      }
    }
    return {
      jleaf,
      q: q4
    };
  }
  var init_csLeaf = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
  var name229, dependencies229, createCsCounts;
  var init_csCounts = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js"() {
      init_factory();
      init_csLeaf();
      name229 = "csCounts";
      dependencies229 = ["transpose"];
      createCsCounts = /* @__PURE__ */ factory(name229, dependencies229, (_ref) => {
        var {
          transpose: transpose2
        } = _ref;
        return function(a3, parent, post, ata) {
          if (!a3 || !parent || !post) {
            return null;
          }
          var asize = a3._size;
          var m3 = asize[0];
          var n3 = asize[1];
          var i5, j4, k4, J2, p3, p0, p1;
          var s3 = 4 * n3 + (ata ? n3 + m3 + 1 : 0);
          var w4 = [];
          var ancestor = 0;
          var maxfirst = n3;
          var prevleaf = 2 * n3;
          var first = 3 * n3;
          var head = 4 * n3;
          var next = 5 * n3 + 1;
          for (k4 = 0; k4 < s3; k4++) {
            w4[k4] = -1;
          }
          var colcount = [];
          var at = transpose2(a3);
          var tindex = at._index;
          var tptr = at._ptr;
          for (k4 = 0; k4 < n3; k4++) {
            j4 = post[k4];
            colcount[j4] = w4[first + j4] === -1 ? 1 : 0;
            for (; j4 !== -1 && w4[first + j4] === -1; j4 = parent[j4]) {
              w4[first + j4] = k4;
            }
          }
          if (ata) {
            for (k4 = 0; k4 < n3; k4++) {
              w4[post[k4]] = k4;
            }
            for (i5 = 0; i5 < m3; i5++) {
              for (k4 = n3, p0 = tptr[i5], p1 = tptr[i5 + 1], p3 = p0; p3 < p1; p3++) {
                k4 = Math.min(k4, w4[tindex[p3]]);
              }
              w4[next + i5] = w4[head + k4];
              w4[head + k4] = i5;
            }
          }
          for (i5 = 0; i5 < n3; i5++) {
            w4[ancestor + i5] = i5;
          }
          for (k4 = 0; k4 < n3; k4++) {
            j4 = post[k4];
            if (parent[j4] !== -1) {
              colcount[parent[j4]]--;
            }
            for (J2 = ata ? w4[head + k4] : j4; J2 !== -1; J2 = ata ? w4[next + J2] : -1) {
              for (p3 = tptr[J2]; p3 < tptr[J2 + 1]; p3++) {
                i5 = tindex[p3];
                var r3 = csLeaf(i5, j4, w4, first, maxfirst, prevleaf, ancestor);
                if (r3.jleaf >= 1) {
                  colcount[j4]++;
                }
                if (r3.jleaf === 2) {
                  colcount[r3.q]--;
                }
              }
            }
            if (parent[j4] !== -1) {
              w4[ancestor + j4] = parent[j4];
            }
          }
          for (j4 = 0; j4 < n3; j4++) {
            if (parent[j4] !== -1) {
              colcount[parent[j4]] += colcount[j4];
            }
          }
          return colcount;
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
  var name230, dependencies230, createCsSqr;
  var init_csSqr = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js"() {
      init_csPermute();
      init_csPost();
      init_csEtree();
      init_csAmd();
      init_csCounts();
      init_factory();
      name230 = "csSqr";
      dependencies230 = ["add", "multiply", "transpose"];
      createCsSqr = /* @__PURE__ */ factory(name230, dependencies230, (_ref) => {
        var {
          add: add3,
          multiply: multiply2,
          transpose: transpose2
        } = _ref;
        var csAmd = createCsAmd({
          add: add3,
          multiply: multiply2,
          transpose: transpose2
        });
        var csCounts = createCsCounts({
          transpose: transpose2
        });
        return function csSqr(order, a3, qr2) {
          var aptr = a3._ptr;
          var asize = a3._size;
          var n3 = asize[1];
          var k4;
          var s3 = {};
          s3.q = csAmd(order, a3);
          if (order && !s3.q) {
            return null;
          }
          if (qr2) {
            var c3 = order ? csPermute(a3, null, s3.q, 0) : a3;
            s3.parent = csEtree(c3, 1);
            var post = csPost(s3.parent, n3);
            s3.cp = csCounts(c3, s3.parent, post, 1);
            if (c3 && s3.parent && s3.cp && _vcount(c3, s3)) {
              for (s3.unz = 0, k4 = 0; k4 < n3; k4++) {
                s3.unz += s3.cp[k4];
              }
            }
          } else {
            s3.unz = 4 * aptr[n3] + n3;
            s3.lnz = s3.unz;
          }
          return s3;
        };
        function _vcount(a3, s3) {
          var aptr = a3._ptr;
          var aindex = a3._index;
          var asize = a3._size;
          var m3 = asize[0];
          var n3 = asize[1];
          s3.pinv = [];
          s3.leftmost = [];
          var parent = s3.parent;
          var pinv2 = s3.pinv;
          var leftmost = s3.leftmost;
          var w4 = [];
          var next = 0;
          var head = m3;
          var tail = m3 + n3;
          var nque = m3 + 2 * n3;
          var i5, k4, p3, p0, p1;
          for (k4 = 0; k4 < n3; k4++) {
            w4[head + k4] = -1;
            w4[tail + k4] = -1;
            w4[nque + k4] = 0;
          }
          for (i5 = 0; i5 < m3; i5++) {
            leftmost[i5] = -1;
          }
          for (k4 = n3 - 1; k4 >= 0; k4--) {
            for (p0 = aptr[k4], p1 = aptr[k4 + 1], p3 = p0; p3 < p1; p3++) {
              leftmost[aindex[p3]] = k4;
            }
          }
          for (i5 = m3 - 1; i5 >= 0; i5--) {
            pinv2[i5] = -1;
            k4 = leftmost[i5];
            if (k4 === -1) {
              continue;
            }
            if (w4[nque + k4]++ === 0) {
              w4[tail + k4] = i5;
            }
            w4[next + i5] = w4[head + k4];
            w4[head + k4] = i5;
          }
          s3.lnz = 0;
          s3.m2 = m3;
          for (k4 = 0; k4 < n3; k4++) {
            i5 = w4[head + k4];
            s3.lnz++;
            if (i5 < 0) {
              i5 = s3.m2++;
            }
            pinv2[i5] = k4;
            if (--nque[k4] <= 0) {
              continue;
            }
            s3.lnz += w4[nque + k4];
            var pa = parent[k4];
            if (pa !== -1) {
              if (w4[nque + pa] === 0) {
                w4[tail + pa] = w4[tail + k4];
              }
              w4[next + w4[tail + k4]] = w4[head + pa];
              w4[head + pa] = w4[next + i5];
              w4[nque + pa] += w4[nque + k4];
            }
          }
          for (i5 = 0; i5 < m3; i5++) {
            if (pinv2[i5] < 0) {
              pinv2[i5] = k4++;
            }
          }
          return true;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
  function csMarked(w4, j4) {
    return w4[j4] < 0;
  }
  var init_csMarked = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
  function csMark(w4, j4) {
    w4[j4] = csFlip(w4[j4]);
  }
  var init_csMark = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js"() {
      init_csFlip();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
  function csUnflip(i5) {
    return i5 < 0 ? csFlip(i5) : i5;
  }
  var init_csUnflip = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js"() {
      init_csFlip();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
  function csDfs(j4, g4, top, xi, pinv2) {
    var index2 = g4._index;
    var ptr = g4._ptr;
    var size2 = g4._size;
    var n3 = size2[1];
    var i5, p3, p22;
    var head = 0;
    xi[0] = j4;
    while (head >= 0) {
      j4 = xi[head];
      var jnew = pinv2 ? pinv2[j4] : j4;
      if (!csMarked(ptr, j4)) {
        csMark(ptr, j4);
        xi[n3 + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
      }
      var done = 1;
      for (p3 = xi[n3 + head], p22 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p3 < p22; p3++) {
        i5 = index2[p3];
        if (csMarked(ptr, i5)) {
          continue;
        }
        xi[n3 + head] = p3;
        xi[++head] = i5;
        done = 0;
        break;
      }
      if (done) {
        head--;
        xi[--top] = j4;
      }
    }
    return top;
  }
  var init_csDfs = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js"() {
      init_csMarked();
      init_csMark();
      init_csUnflip();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
  function csReach(g4, b3, k4, xi, pinv2) {
    var gptr = g4._ptr;
    var gsize = g4._size;
    var bindex = b3._index;
    var bptr = b3._ptr;
    var n3 = gsize[1];
    var p3, p0, p1;
    var top = n3;
    for (p0 = bptr[k4], p1 = bptr[k4 + 1], p3 = p0; p3 < p1; p3++) {
      var i5 = bindex[p3];
      if (!csMarked(gptr, i5)) {
        top = csDfs(i5, g4, top, xi, pinv2);
      }
    }
    for (p3 = top; p3 < n3; p3++) {
      csMark(gptr, xi[p3]);
    }
    return top;
  }
  var init_csReach = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js"() {
      init_csMarked();
      init_csMark();
      init_csDfs();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
  var name231, dependencies231, createCsSpsolve;
  var init_csSpsolve = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js"() {
      init_csReach();
      init_factory();
      name231 = "csSpsolve";
      dependencies231 = ["divideScalar", "multiply", "subtract"];
      createCsSpsolve = /* @__PURE__ */ factory(name231, dependencies231, (_ref) => {
        var {
          divideScalar: divideScalar2,
          multiply: multiply2,
          subtract: subtract2
        } = _ref;
        return function csSpsolve(g4, b3, k4, xi, x4, pinv2, lo) {
          var gvalues = g4._values;
          var gindex = g4._index;
          var gptr = g4._ptr;
          var gsize = g4._size;
          var n3 = gsize[1];
          var bvalues = b3._values;
          var bindex = b3._index;
          var bptr = b3._ptr;
          var p3, p0, p1, q4;
          var top = csReach(g4, b3, k4, xi, pinv2);
          for (p3 = top; p3 < n3; p3++) {
            x4[xi[p3]] = 0;
          }
          for (p0 = bptr[k4], p1 = bptr[k4 + 1], p3 = p0; p3 < p1; p3++) {
            x4[bindex[p3]] = bvalues[p3];
          }
          for (var px = top; px < n3; px++) {
            var j4 = xi[px];
            var J2 = pinv2 ? pinv2[j4] : j4;
            if (J2 < 0) {
              continue;
            }
            p0 = gptr[J2];
            p1 = gptr[J2 + 1];
            x4[j4] = divideScalar2(x4[j4], gvalues[lo ? p0 : p1 - 1]);
            p3 = lo ? p0 + 1 : p0;
            q4 = lo ? p1 : p1 - 1;
            for (; p3 < q4; p3++) {
              var i5 = gindex[p3];
              x4[i5] = subtract2(x4[i5], multiply2(gvalues[p3], x4[j4]));
            }
          }
          return top;
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
  var name232, dependencies232, createCsLu;
  var init_csLu = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js"() {
      init_factory();
      init_csSpsolve();
      name232 = "csLu";
      dependencies232 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
      createCsLu = /* @__PURE__ */ factory(name232, dependencies232, (_ref) => {
        var {
          abs: abs3,
          divideScalar: divideScalar2,
          multiply: multiply2,
          subtract: subtract2,
          larger: larger2,
          largerEq: largerEq2,
          SparseMatrix: SparseMatrix2
        } = _ref;
        var csSpsolve = createCsSpsolve({
          divideScalar: divideScalar2,
          multiply: multiply2,
          subtract: subtract2
        });
        return function csLu(m3, s3, tol) {
          if (!m3) {
            return null;
          }
          var size2 = m3._size;
          var n3 = size2[1];
          var q4;
          var lnz = 100;
          var unz = 100;
          if (s3) {
            q4 = s3.q;
            lnz = s3.lnz || lnz;
            unz = s3.unz || unz;
          }
          var lvalues = [];
          var lindex = [];
          var lptr = [];
          var L3 = new SparseMatrix2({
            values: lvalues,
            index: lindex,
            ptr: lptr,
            size: [n3, n3]
          });
          var uvalues = [];
          var uindex = [];
          var uptr = [];
          var U2 = new SparseMatrix2({
            values: uvalues,
            index: uindex,
            ptr: uptr,
            size: [n3, n3]
          });
          var pinv2 = [];
          var i5, p3;
          var x4 = [];
          var xi = [];
          for (i5 = 0; i5 < n3; i5++) {
            x4[i5] = 0;
            pinv2[i5] = -1;
            lptr[i5 + 1] = 0;
          }
          lnz = 0;
          unz = 0;
          for (var k4 = 0; k4 < n3; k4++) {
            lptr[k4] = lnz;
            uptr[k4] = unz;
            var col = q4 ? q4[k4] : k4;
            var top = csSpsolve(L3, m3, col, xi, x4, pinv2, 1);
            var ipiv = -1;
            var a3 = -1;
            for (p3 = top; p3 < n3; p3++) {
              i5 = xi[p3];
              if (pinv2[i5] < 0) {
                var xabs = abs3(x4[i5]);
                if (larger2(xabs, a3)) {
                  a3 = xabs;
                  ipiv = i5;
                }
              } else {
                uindex[unz] = pinv2[i5];
                uvalues[unz++] = x4[i5];
              }
            }
            if (ipiv === -1 || a3 <= 0) {
              return null;
            }
            if (pinv2[col] < 0 && largerEq2(abs3(x4[col]), multiply2(a3, tol))) {
              ipiv = col;
            }
            var pivot = x4[ipiv];
            uindex[unz] = k4;
            uvalues[unz++] = pivot;
            pinv2[ipiv] = k4;
            lindex[lnz] = ipiv;
            lvalues[lnz++] = 1;
            for (p3 = top; p3 < n3; p3++) {
              i5 = xi[p3];
              if (pinv2[i5] < 0) {
                lindex[lnz] = i5;
                lvalues[lnz++] = divideScalar2(x4[i5], pivot);
              }
              x4[i5] = 0;
            }
          }
          lptr[n3] = lnz;
          uptr[n3] = unz;
          for (p3 = 0; p3 < lnz; p3++) {
            lindex[p3] = pinv2[lindex[p3]];
          }
          lvalues.splice(lnz, lvalues.length - lnz);
          lindex.splice(lnz, lindex.length - lnz);
          uvalues.splice(unz, uvalues.length - unz);
          uindex.splice(unz, uindex.length - unz);
          return {
            L: L3,
            U: U2,
            pinv: pinv2
          };
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
  var name233, dependencies233, createSlu;
  var init_slu = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js"() {
      init_number();
      init_factory();
      init_csSqr();
      init_csLu();
      name233 = "slu";
      dependencies233 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
      createSlu = /* @__PURE__ */ factory(name233, dependencies233, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          add: add3,
          multiply: multiply2,
          transpose: transpose2,
          divideScalar: divideScalar2,
          subtract: subtract2,
          larger: larger2,
          largerEq: largerEq2,
          SparseMatrix: SparseMatrix2
        } = _ref;
        var csSqr = createCsSqr({
          add: add3,
          multiply: multiply2,
          transpose: transpose2
        });
        var csLu = createCsLu({
          abs: abs3,
          divideScalar: divideScalar2,
          multiply: multiply2,
          subtract: subtract2,
          larger: larger2,
          largerEq: largerEq2,
          SparseMatrix: SparseMatrix2
        });
        return typed3(name233, {
          "SparseMatrix, number, number": function SparseMatrixNumberNumber(a3, order, threshold) {
            if (!isInteger(order) || order < 0 || order > 3) {
              throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
            }
            if (threshold < 0 || threshold > 1) {
              throw new Error("Partial pivoting threshold must be a number from 0 to 1");
            }
            var s3 = csSqr(order, a3, false);
            var f3 = csLu(a3, s3, threshold);
            return {
              L: f3.L,
              U: f3.U,
              p: f3.pinv,
              q: s3.q,
              toString: function toString2() {
                return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
              }
            };
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
  function csIpvec(p3, b3) {
    var k4;
    var n3 = b3.length;
    var x4 = [];
    if (p3) {
      for (k4 = 0; k4 < n3; k4++) {
        x4[p3[k4]] = b3[k4];
      }
    } else {
      for (k4 = 0; k4 < n3; k4++) {
        x4[k4] = b3[k4];
      }
    }
    return x4;
  }
  var init_csIpvec = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
  var name234, dependencies234, createLusolve;
  var init_lusolve = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js"() {
      init_is();
      init_factory();
      init_solveValidation();
      init_csIpvec();
      name234 = "lusolve";
      dependencies234 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
      createLusolve = /* @__PURE__ */ factory(name234, dependencies234, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          lup: lup2,
          slu: slu2,
          usolve: usolve2,
          lsolve: lsolve2,
          DenseMatrix: DenseMatrix2
        } = _ref;
        var solveValidation = createSolveValidation({
          DenseMatrix: DenseMatrix2
        });
        return typed3(name234, {
          "Array, Array | Matrix": function ArrayArrayMatrix(a3, b3) {
            a3 = matrix2(a3);
            var d3 = lup2(a3);
            var x4 = _lusolve(d3.L, d3.U, d3.p, null, b3);
            return x4.valueOf();
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a3, b3) {
            var d3 = lup2(a3);
            return _lusolve(d3.L, d3.U, d3.p, null, b3);
          },
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a3, b3) {
            var d3 = lup2(a3);
            return _lusolve(d3.L, d3.U, d3.p, null, b3);
          },
          "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a3, b3, order, threshold) {
            var d3 = slu2(a3, order, threshold);
            return _lusolve(d3.L, d3.U, d3.p, d3.q, b3);
          },
          "Object, Array | Matrix": function ObjectArrayMatrix(d3, b3) {
            return _lusolve(d3.L, d3.U, d3.p, d3.q, b3);
          }
        });
        function _toMatrix(a3) {
          if (isMatrix(a3)) {
            return a3;
          }
          if (isArray(a3)) {
            return matrix2(a3);
          }
          throw new TypeError("Invalid Matrix LU decomposition");
        }
        function _lusolve(l3, u3, p3, q4, b3) {
          l3 = _toMatrix(l3);
          u3 = _toMatrix(u3);
          if (p3) {
            b3 = solveValidation(l3, b3, true);
            b3._data = csIpvec(p3, b3._data);
          }
          var y3 = lsolve2(l3, b3);
          var x4 = usolve2(u3, y3);
          if (q4) {
            x4._data = csIpvec(q4, x4._data);
          }
          return x4;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
  var name235, dependencies235, createPolynomialRoot;
  var init_polynomialRoot = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js"() {
      init_factory();
      name235 = "polynomialRoot";
      dependencies235 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
      createPolynomialRoot = /* @__PURE__ */ factory(name235, dependencies235, (_ref) => {
        var {
          typed: typed3,
          isZero: isZero2,
          equalScalar: equalScalar2,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          sqrt: sqrt3,
          unaryMinus: unaryMinus2,
          cbrt: cbrt5,
          typeOf: typeOf3,
          im: im2,
          re: re2
        } = _ref;
        return typed3(name235, {
          "number|Complex, ...number|Complex": (constant, restCoeffs) => {
            var coeffs = [constant, ...restCoeffs];
            while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
              coeffs.pop();
            }
            if (coeffs.length < 2) {
              throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
            }
            switch (coeffs.length) {
              case 2:
                return [unaryMinus2(divide3(coeffs[0], coeffs[1]))];
              case 3: {
                var [c3, b3, a3] = coeffs;
                var denom = multiply2(2, a3);
                var d1 = multiply2(b3, b3);
                var d22 = multiply2(4, a3, c3);
                if (equalScalar2(d1, d22))
                  return [divide3(unaryMinus2(b3), denom)];
                var discriminant = sqrt3(subtract2(d1, d22));
                return [divide3(subtract2(discriminant, b3), denom), divide3(subtract2(unaryMinus2(discriminant), b3), denom)];
              }
              case 4: {
                var [d3, _c, _b, _a] = coeffs;
                var _denom = unaryMinus2(multiply2(3, _a));
                var D0_1 = multiply2(_b, _b);
                var D0_2 = multiply2(3, _a, _c);
                var D1_1 = add3(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d3));
                var D1_2 = multiply2(9, _a, _b, _c);
                if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
                  return [divide3(_b, _denom)];
                }
                var Delta0 = subtract2(D0_1, D0_2);
                var Delta1 = subtract2(D1_1, D1_2);
                var discriminant1 = add3(multiply2(18, _a, _b, _c, d3), multiply2(_b, _b, _c, _c));
                var discriminant2 = add3(multiply2(4, _b, _b, _b, d3), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d3, d3));
                if (equalScalar2(discriminant1, discriminant2)) {
                  return [
                    divide3(subtract2(multiply2(4, _a, _b, _c), add3(multiply2(9, _a, _a, d3), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
                    // simple root
                    divide3(subtract2(multiply2(9, _a, d3), multiply2(_b, _c)), multiply2(2, Delta0))
                    // double root
                  ];
                }
                var Ccubed;
                if (equalScalar2(D0_1, D0_2)) {
                  Ccubed = Delta1;
                } else {
                  Ccubed = divide3(add3(Delta1, sqrt3(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
                }
                var allRoots = true;
                var rawRoots = cbrt5(Ccubed, allRoots).toArray().map((C3) => divide3(add3(_b, C3, divide3(Delta0, C3)), _denom));
                return rawRoots.map((r3) => {
                  if (typeOf3(r3) === "Complex" && equalScalar2(re2(r3), re2(r3) + im2(r3))) {
                    return re2(r3);
                  }
                  return r3;
                });
              }
              default:
                throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
            }
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/Help.js
  var name236, dependencies236, createHelpClass;
  var init_Help = __esm({
    "node_modules/mathjs/lib/esm/expression/Help.js"() {
      init_is();
      init_object();
      init_string();
      init_factory();
      name236 = "Help";
      dependencies236 = ["parse"];
      createHelpClass = /* @__PURE__ */ factory(name236, dependencies236, (_ref) => {
        var {
          parse: parse2
        } = _ref;
        function Help2(doc) {
          if (!(this instanceof Help2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (!doc)
            throw new Error('Argument "doc" missing');
          this.doc = doc;
        }
        Help2.prototype.type = "Help";
        Help2.prototype.isHelp = true;
        Help2.prototype.toString = function() {
          var doc = this.doc || {};
          var desc = "\n";
          if (doc.name) {
            desc += "Name: " + doc.name + "\n\n";
          }
          if (doc.category) {
            desc += "Category: " + doc.category + "\n\n";
          }
          if (doc.description) {
            desc += "Description:\n    " + doc.description + "\n\n";
          }
          if (doc.syntax) {
            desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
          }
          if (doc.examples) {
            desc += "Examples:\n";
            var scope = {};
            for (var i5 = 0; i5 < doc.examples.length; i5++) {
              var expr = doc.examples[i5];
              desc += "    " + expr + "\n";
              var res = void 0;
              try {
                res = parse2(expr).compile().evaluate(scope);
              } catch (e6) {
                res = e6;
              }
              if (res !== void 0 && !isHelp(res)) {
                desc += "        " + format3(res, {
                  precision: 14
                }) + "\n";
              }
            }
            desc += "\n";
          }
          if (doc.mayThrow && doc.mayThrow.length) {
            desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
          }
          if (doc.seealso && doc.seealso.length) {
            desc += "See also: " + doc.seealso.join(", ") + "\n";
          }
          return desc;
        };
        Help2.prototype.toJSON = function() {
          var obj = clone(this.doc);
          obj.mathjs = "Help";
          return obj;
        };
        Help2.fromJSON = function(json) {
          var doc = {};
          Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
            doc[prop] = json[prop];
          });
          return new Help2(doc);
        };
        Help2.prototype.valueOf = Help2.prototype.toString;
        return Help2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/chain/Chain.js
  var name237, dependencies237, createChainClass;
  var init_Chain = __esm({
    "node_modules/mathjs/lib/esm/type/chain/Chain.js"() {
      init_is();
      init_string();
      init_object();
      init_factory();
      name237 = "Chain";
      dependencies237 = ["?on", "math", "typed"];
      createChainClass = /* @__PURE__ */ factory(name237, dependencies237, (_ref) => {
        var {
          on: on2,
          math: math2,
          typed: typed3
        } = _ref;
        function Chain2(value) {
          if (!(this instanceof Chain2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (isChain(value)) {
            this.value = value.value;
          } else {
            this.value = value;
          }
        }
        Chain2.prototype.type = "Chain";
        Chain2.prototype.isChain = true;
        Chain2.prototype.done = function() {
          return this.value;
        };
        Chain2.prototype.valueOf = function() {
          return this.value;
        };
        Chain2.prototype.toString = function() {
          return format3(this.value);
        };
        Chain2.prototype.toJSON = function() {
          return {
            mathjs: "Chain",
            value: this.value
          };
        };
        Chain2.fromJSON = function(json) {
          return new Chain2(json.value);
        };
        function createProxy(name307, fn2) {
          if (typeof fn2 === "function") {
            Chain2.prototype[name307] = chainify(fn2);
          }
        }
        function createLazyProxy(name307, resolver) {
          lazy(Chain2.prototype, name307, function outerResolver() {
            var fn2 = resolver();
            if (typeof fn2 === "function") {
              return chainify(fn2);
            }
            return void 0;
          });
        }
        function chainify(fn2) {
          return function() {
            if (arguments.length === 0) {
              return new Chain2(fn2(this.value));
            }
            var args = [this.value];
            for (var i5 = 0; i5 < arguments.length; i5++) {
              args[i5 + 1] = arguments[i5];
            }
            if (typed3.isTypedFunction(fn2)) {
              var sigObject = typed3.resolve(fn2, args);
              if (sigObject.params.length === 1) {
                throw new Error("chain function " + fn2.name + " cannot match rest parameter between chain value and additional arguments.");
              }
              return new Chain2(sigObject.implementation.apply(fn2, args));
            }
            return new Chain2(fn2.apply(fn2, args));
          };
        }
        Chain2.createProxy = function(arg0, arg1) {
          if (typeof arg0 === "string") {
            createProxy(arg0, arg1);
          } else {
            var _loop = function _loop2(_name2) {
              if (hasOwnProperty2(arg0, _name2) && excludedNames[_name2] === void 0) {
                createLazyProxy(_name2, () => arg0[_name2]);
              }
            };
            for (var _name in arg0) {
              _loop(_name);
            }
          }
        };
        var excludedNames = {
          expression: true,
          docs: true,
          type: true,
          classes: true,
          json: true,
          error: true,
          isChain: true
          // conflicts with the property isChain of a Chain instance
        };
        Chain2.createProxy(math2);
        if (on2) {
          on2("import", function(name307, resolver, path) {
            if (!path) {
              createLazyProxy(name307, resolver);
            }
          });
        }
        return Chain2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
  var eDocs;
  var init_e = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js"() {
      eDocs = {
        name: "e",
        category: "Constants",
        syntax: ["e"],
        description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
        examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
        seealso: ["exp"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
  var falseDocs;
  var init_false = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js"() {
      falseDocs = {
        name: "false",
        category: "Constants",
        syntax: ["false"],
        description: "Boolean value false",
        examples: ["false"],
        seealso: ["true"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
  var iDocs;
  var init_i = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js"() {
      iDocs = {
        name: "i",
        category: "Constants",
        syntax: ["i"],
        description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
        examples: ["i", "i * i", "sqrt(-1)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
  var InfinityDocs;
  var init_Infinity = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js"() {
      InfinityDocs = {
        name: "Infinity",
        category: "Constants",
        syntax: ["Infinity"],
        description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
        examples: ["Infinity", "1 / 0"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
  var LN10Docs;
  var init_LN10 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js"() {
      LN10Docs = {
        name: "LN10",
        category: "Constants",
        syntax: ["LN10"],
        description: "Returns the natural logarithm of 10, approximately equal to 2.302",
        examples: ["LN10", "log(10)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
  var LN2Docs;
  var init_LN2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js"() {
      LN2Docs = {
        name: "LN2",
        category: "Constants",
        syntax: ["LN2"],
        description: "Returns the natural logarithm of 2, approximately equal to 0.693",
        examples: ["LN2", "log(2)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
  var LOG10EDocs;
  var init_LOG10E = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js"() {
      LOG10EDocs = {
        name: "LOG10E",
        category: "Constants",
        syntax: ["LOG10E"],
        description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
        examples: ["LOG10E", "log(e, 10)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
  var LOG2EDocs;
  var init_LOG2E = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js"() {
      LOG2EDocs = {
        name: "LOG2E",
        category: "Constants",
        syntax: ["LOG2E"],
        description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
        examples: ["LOG2E", "log(e, 2)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
  var NaNDocs;
  var init_NaN = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js"() {
      NaNDocs = {
        name: "NaN",
        category: "Constants",
        syntax: ["NaN"],
        description: "Not a number",
        examples: ["NaN", "0 / 0"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
  var nullDocs;
  var init_null = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js"() {
      nullDocs = {
        name: "null",
        category: "Constants",
        syntax: ["null"],
        description: "Value null",
        examples: ["null"],
        seealso: ["true", "false"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
  var phiDocs;
  var init_phi = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js"() {
      phiDocs = {
        name: "phi",
        category: "Constants",
        syntax: ["phi"],
        description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
        examples: ["phi"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
  var piDocs;
  var init_pi = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js"() {
      piDocs = {
        name: "pi",
        category: "Constants",
        syntax: ["pi"],
        description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
        examples: ["pi", "sin(pi/2)"],
        seealso: ["tau"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
  var SQRT12Docs;
  var init_SQRT1_2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js"() {
      SQRT12Docs = {
        name: "SQRT1_2",
        category: "Constants",
        syntax: ["SQRT1_2"],
        description: "Returns the square root of 1/2, approximately equal to 0.707",
        examples: ["SQRT1_2", "sqrt(1/2)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
  var SQRT2Docs;
  var init_SQRT2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js"() {
      SQRT2Docs = {
        name: "SQRT2",
        category: "Constants",
        syntax: ["SQRT2"],
        description: "Returns the square root of 2, approximately equal to 1.414",
        examples: ["SQRT2", "sqrt(2)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
  var tauDocs;
  var init_tau = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js"() {
      tauDocs = {
        name: "tau",
        category: "Constants",
        syntax: ["tau"],
        description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
        examples: ["tau", "2 * pi"],
        seealso: ["pi"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
  var trueDocs;
  var init_true = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js"() {
      trueDocs = {
        name: "true",
        category: "Constants",
        syntax: ["true"],
        description: "Boolean value true",
        examples: ["true"],
        seealso: ["false"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
  var versionDocs;
  var init_version = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js"() {
      versionDocs = {
        name: "version",
        category: "Constants",
        syntax: ["version"],
        description: "A string with the version number of math.js",
        examples: ["version"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
  var bignumberDocs;
  var init_bignumber2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js"() {
      bignumberDocs = {
        name: "bignumber",
        category: "Construction",
        syntax: ["bignumber(x)"],
        description: "Create a big number from a number or string.",
        examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
        seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
  var booleanDocs;
  var init_boolean2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js"() {
      booleanDocs = {
        name: "boolean",
        category: "Construction",
        syntax: ["x", "boolean(x)"],
        description: "Convert a string or number into a boolean.",
        examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
        seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
  var complexDocs;
  var init_complex3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js"() {
      complexDocs = {
        name: "complex",
        category: "Construction",
        syntax: ["complex()", "complex(re, im)", "complex(string)"],
        description: "Create a complex number.",
        examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
        seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
  var createUnitDocs;
  var init_createUnit2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js"() {
      createUnitDocs = {
        name: "createUnit",
        category: "Construction",
        syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
        description: "Create a user-defined unit and register it with the Unit type.",
        examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
        seealso: ["unit", "splitUnit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
  var fractionDocs;
  var init_fraction2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js"() {
      fractionDocs = {
        name: "fraction",
        category: "Construction",
        syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
        description: "Create a fraction from a number or from integer numerator and denominator.",
        examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
  var indexDocs;
  var init_construction = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js"() {
      indexDocs = {
        name: "index",
        category: "Construction",
        syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
        description: "Create an index to get or replace a subset of a matrix",
        examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
        seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
  var matrixDocs;
  var init_matrix2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js"() {
      matrixDocs = {
        name: "matrix",
        category: "Construction",
        syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
        description: "Create a matrix.",
        examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
        seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
  var numberDocs;
  var init_number4 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js"() {
      numberDocs = {
        name: "number",
        category: "Construction",
        syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
        description: "Create a number or convert a string or boolean into a number.",
        examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
        seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
  var sparseDocs;
  var init_sparse2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js"() {
      sparseDocs = {
        name: "sparse",
        category: "Construction",
        syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
        description: "Create a sparse matrix.",
        examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
        seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
  var splitUnitDocs;
  var init_splitUnit2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js"() {
      splitUnitDocs = {
        name: "splitUnit",
        category: "Construction",
        syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
        description: "Split a unit in an array of units whose sum is equal to the original unit.",
        examples: ['splitUnit(1 m, ["feet", "inch"])'],
        seealso: ["unit", "createUnit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
  var stringDocs;
  var init_string3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js"() {
      stringDocs = {
        name: "string",
        category: "Construction",
        syntax: ['"text"', "string(x)"],
        description: "Create a string or convert a value to a string",
        examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
  var unitDocs;
  var init_unit2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js"() {
      unitDocs = {
        name: "unit",
        category: "Construction",
        syntax: ["value unit", "unit(value, unit)", "unit(string)"],
        description: "Create a unit.",
        examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
  var configDocs;
  var init_config3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js"() {
      configDocs = {
        name: "config",
        category: "Core",
        syntax: ["config()", "config(options)"],
        description: "Get configuration or change configuration.",
        examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
  var importDocs;
  var init_import = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js"() {
      importDocs = {
        name: "import",
        category: "Core",
        syntax: ["import(functions)", "import(functions, options)"],
        description: "Import functions or constants from an object.",
        examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
  var typedDocs;
  var init_typed2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js"() {
      typedDocs = {
        name: "typed",
        category: "Core",
        syntax: ["typed(signatures)", "typed(name, signatures)"],
        description: "Create a typed function.",
        examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
  var derivativeDocs;
  var init_derivative = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js"() {
      derivativeDocs = {
        name: "derivative",
        category: "Algebra",
        syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
        description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
        examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
        seealso: ["simplify", "parse", "evaluate"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
  var leafCountDocs;
  var init_leafCount = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js"() {
      leafCountDocs = {
        name: "leafCount",
        category: "Algebra",
        syntax: ["leafCount(expr)"],
        description: "Computes the number of leaves in the parse tree of the given expression",
        examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
        seealso: ["simplify"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
  var lsolveDocs;
  var init_lsolve2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js"() {
      lsolveDocs = {
        name: "lsolve",
        category: "Algebra",
        syntax: ["x=lsolve(L, b)"],
        description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
        seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
  var lsolveAllDocs;
  var init_lsolveAll2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js"() {
      lsolveAllDocs = {
        name: "lsolveAll",
        category: "Algebra",
        syntax: ["x=lsolveAll(L, b)"],
        description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
        seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
  var lupDocs;
  var init_lup2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js"() {
      lupDocs = {
        name: "lup",
        category: "Algebra",
        syntax: ["lup(m)"],
        description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
        examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
        seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
  var lusolveDocs;
  var init_lusolve2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js"() {
      lusolveDocs = {
        name: "lusolve",
        category: "Algebra",
        syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
        description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
        seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
  var polynomialRootDocs;
  var init_polynomialRoot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js"() {
      polynomialRootDocs = {
        name: "polynomialRoot",
        category: "Algebra",
        syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
        description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
        examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
        seealso: ["cbrt", "sqrt"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
  var qrDocs;
  var init_qr2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js"() {
      qrDocs = {
        name: "qr",
        category: "Algebra",
        syntax: ["qr(A)"],
        description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
        examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
        seealso: ["lup", "slu", "matrix"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
  var rationalizeDocs;
  var init_rationalize = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js"() {
      rationalizeDocs = {
        name: "rationalize",
        category: "Algebra",
        syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
        description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
        examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
        seealso: ["simplify"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
  var resolveDocs;
  var init_resolve = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js"() {
      resolveDocs = {
        name: "resolve",
        category: "Algebra",
        syntax: ["resolve(node, scope)"],
        description: "Recursively substitute variables in an expression tree.",
        examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
        seealso: ["simplify", "evaluate"],
        mayThrow: ["ReferenceError"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
  var simplifyDocs;
  var init_simplify = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js"() {
      simplifyDocs = {
        name: "simplify",
        category: "Algebra",
        syntax: ["simplify(expr)", "simplify(expr, rules)"],
        description: "Simplify an expression tree.",
        examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
        seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
  var simplifyConstantDocs;
  var init_simplifyConstant = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js"() {
      simplifyConstantDocs = {
        name: "simplifyConstant",
        category: "Algebra",
        syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
        description: "Replace constant subexpressions of node with their values.",
        examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
        seealso: ["simplify", "simplifyCore", "evaluate"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
  var simplifyCoreDocs;
  var init_simplifyCore = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js"() {
      simplifyCoreDocs = {
        name: "simplifyCore",
        category: "Algebra",
        syntax: ["simplifyCore(node)"],
        description: "Perform simple one-pass simplifications on an expression tree.",
        examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
        seealso: ["simplify", "simplifyConstant", "evaluate"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
  var sluDocs;
  var init_slu2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js"() {
      sluDocs = {
        name: "slu",
        category: "Algebra",
        syntax: ["slu(A, order, threshold)"],
        description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
        examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
        seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
  var symbolicEqualDocs;
  var init_symbolicEqual = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js"() {
      symbolicEqualDocs = {
        name: "symbolicEqual",
        category: "Algebra",
        syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
        description: "Returns true if the difference of the expressions simplifies to 0",
        examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
        seealso: ["simplify", "evaluate"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
  var usolveDocs;
  var init_usolve2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js"() {
      usolveDocs = {
        name: "usolve",
        category: "Algebra",
        syntax: ["x=usolve(U, b)"],
        description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
        examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
        seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
  var usolveAllDocs;
  var init_usolveAll2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js"() {
      usolveAllDocs = {
        name: "usolveAll",
        category: "Algebra",
        syntax: ["x=usolve(U, b)"],
        description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
        examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
        seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
  var absDocs;
  var init_abs2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js"() {
      absDocs = {
        name: "abs",
        category: "Arithmetic",
        syntax: ["abs(x)"],
        description: "Compute the absolute value.",
        examples: ["abs(3.5)", "abs(-4.2)"],
        seealso: ["sign"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
  var addDocs;
  var init_add2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js"() {
      addDocs = {
        name: "add",
        category: "Operators",
        syntax: ["x + y", "add(x, y)"],
        description: "Add two values.",
        examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
        seealso: ["subtract"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
  var cbrtDocs;
  var init_cbrt2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js"() {
      cbrtDocs = {
        name: "cbrt",
        category: "Arithmetic",
        syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
        description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
        examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
        seealso: ["square", "sqrt", "cube", "multiply"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
  var ceilDocs;
  var init_ceil2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js"() {
      ceilDocs = {
        name: "ceil",
        category: "Arithmetic",
        syntax: ["ceil(x)"],
        description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
        examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
        seealso: ["floor", "fix", "round"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
  var cubeDocs;
  var init_cube2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js"() {
      cubeDocs = {
        name: "cube",
        category: "Arithmetic",
        syntax: ["cube(x)"],
        description: "Compute the cube of a value. The cube of x is x * x * x.",
        examples: ["cube(2)", "2^3", "2 * 2 * 2"],
        seealso: ["multiply", "square", "pow"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
  var divideDocs;
  var init_divide = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js"() {
      divideDocs = {
        name: "divide",
        category: "Operators",
        syntax: ["x / y", "divide(x, y)"],
        description: "Divide two values.",
        examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
        seealso: ["multiply"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
  var dotDivideDocs;
  var init_dotDivide2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js"() {
      dotDivideDocs = {
        name: "dotDivide",
        category: "Operators",
        syntax: ["x ./ y", "dotDivide(x, y)"],
        description: "Divide two values element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
        seealso: ["multiply", "dotMultiply", "divide"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
  var dotMultiplyDocs;
  var init_dotMultiply2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js"() {
      dotMultiplyDocs = {
        name: "dotMultiply",
        category: "Operators",
        syntax: ["x .* y", "dotMultiply(x, y)"],
        description: "Multiply two values element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
        seealso: ["multiply", "divide", "dotDivide"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
  var dotPowDocs;
  var init_dotPow2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js"() {
      dotPowDocs = {
        name: "dotPow",
        category: "Operators",
        syntax: ["x .^ y", "dotPow(x, y)"],
        description: "Calculates the power of x to y element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
        seealso: ["pow"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
  var expDocs;
  var init_exp2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js"() {
      expDocs = {
        name: "exp",
        category: "Arithmetic",
        syntax: ["exp(x)"],
        description: "Calculate the exponent of a value.",
        examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
        seealso: ["expm", "expm1", "pow", "log"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
  var expmDocs;
  var init_expm = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js"() {
      expmDocs = {
        name: "expm",
        category: "Arithmetic",
        syntax: ["exp(x)"],
        description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
        examples: ["expm([[0,2],[0,0]])"],
        seealso: ["exp"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
  var expm1Docs;
  var init_expm12 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js"() {
      expm1Docs = {
        name: "expm1",
        category: "Arithmetic",
        syntax: ["expm1(x)"],
        description: "Calculate the value of subtracting 1 from the exponential value.",
        examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
        seealso: ["exp", "pow", "log"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
  var fixDocs;
  var init_fix2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js"() {
      fixDocs = {
        name: "fix",
        category: "Arithmetic",
        syntax: ["fix(x)"],
        description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
        examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
        seealso: ["ceil", "floor", "round"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
  var floorDocs;
  var init_floor2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js"() {
      floorDocs = {
        name: "floor",
        category: "Arithmetic",
        syntax: ["floor(x)"],
        description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
        examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
        seealso: ["ceil", "fix", "round"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
  var gcdDocs;
  var init_gcd2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js"() {
      gcdDocs = {
        name: "gcd",
        category: "Arithmetic",
        syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
        description: "Compute the greatest common divisor.",
        examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
        seealso: ["lcm", "xgcd"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
  var hypotDocs;
  var init_hypot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js"() {
      hypotDocs = {
        name: "hypot",
        category: "Arithmetic",
        syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
        description: "Calculate the hypotenusa of a list with values. ",
        examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
        seealso: ["abs", "norm"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
  var invmodDocs;
  var init_invmod2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js"() {
      invmodDocs = {
        name: "invmod",
        category: "Arithmetic",
        syntax: ["invmod(a, b)"],
        description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
        examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
        seealso: ["gcd", "xgcd"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
  var lcmDocs;
  var init_lcm2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js"() {
      lcmDocs = {
        name: "lcm",
        category: "Arithmetic",
        syntax: ["lcm(x, y)"],
        description: "Compute the least common multiple.",
        examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
        seealso: ["gcd"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
  var logDocs;
  var init_log3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js"() {
      logDocs = {
        name: "log",
        category: "Arithmetic",
        syntax: ["log(x)", "log(x, base)"],
        description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
        examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
        seealso: ["exp", "log1p", "log2", "log10"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
  var log10Docs;
  var init_log102 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js"() {
      log10Docs = {
        name: "log10",
        category: "Arithmetic",
        syntax: ["log10(x)"],
        description: "Compute the 10-base logarithm of a value.",
        examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
        seealso: ["exp", "log"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
  var log1pDocs;
  var init_log1p2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js"() {
      log1pDocs = {
        name: "log1p",
        category: "Arithmetic",
        syntax: ["log1p(x)", "log1p(x, base)"],
        description: "Calculate the logarithm of a `value+1`",
        examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
        seealso: ["exp", "log", "log2", "log10"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
  var log2Docs;
  var init_log22 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js"() {
      log2Docs = {
        name: "log2",
        category: "Arithmetic",
        syntax: ["log2(x)"],
        description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
        examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
        seealso: ["exp", "log1p", "log", "log10"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
  var modDocs;
  var init_mod2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js"() {
      modDocs = {
        name: "mod",
        category: "Operators",
        syntax: ["x % y", "x mod y", "mod(x, y)"],
        description: "Calculates the modulus, the remainder of an integer division.",
        examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
        seealso: ["divide"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
  var multiplyDocs;
  var init_multiply2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js"() {
      multiplyDocs = {
        name: "multiply",
        category: "Operators",
        syntax: ["x * y", "multiply(x, y)"],
        description: "multiply two values.",
        examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
        seealso: ["divide"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
  var normDocs;
  var init_norm2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js"() {
      normDocs = {
        name: "norm",
        category: "Arithmetic",
        syntax: ["norm(x)", "norm(x, p)"],
        description: "Calculate the norm of a number, vector or matrix.",
        examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
  var nthRootDocs;
  var init_nthRoot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js"() {
      nthRootDocs = {
        name: "nthRoot",
        category: "Arithmetic",
        syntax: ["nthRoot(a)", "nthRoot(a, root)"],
        description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
        examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
        seealso: ["nthRoots", "pow", "sqrt"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
  var nthRootsDocs;
  var init_nthRoots2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js"() {
      nthRootsDocs = {
        name: "nthRoots",
        category: "Arithmetic",
        syntax: ["nthRoots(A)", "nthRoots(A, root)"],
        description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
        examples: ["nthRoots(1)", "nthRoots(1, 3)"],
        seealso: ["sqrt", "pow", "nthRoot"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
  var powDocs;
  var init_pow2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js"() {
      powDocs = {
        name: "pow",
        category: "Operators",
        syntax: ["x ^ y", "pow(x, y)"],
        description: "Calculates the power of x to y, x^y.",
        examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
        seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
  var roundDocs;
  var init_round2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js"() {
      roundDocs = {
        name: "round",
        category: "Arithmetic",
        syntax: ["round(x)", "round(x, n)"],
        description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
        examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
        seealso: ["ceil", "floor", "fix"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
  var signDocs;
  var init_sign2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js"() {
      signDocs = {
        name: "sign",
        category: "Arithmetic",
        syntax: ["sign(x)"],
        description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
        examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
        seealso: ["abs"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
  var sqrtDocs;
  var init_sqrt2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js"() {
      sqrtDocs = {
        name: "sqrt",
        category: "Arithmetic",
        syntax: ["sqrt(x)"],
        description: "Compute the square root value. If x = y * y, then y is the square root of x.",
        examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
        seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
  var sqrtmDocs;
  var init_sqrtm = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js"() {
      sqrtmDocs = {
        name: "sqrtm",
        category: "Arithmetic",
        syntax: ["sqrtm(x)"],
        description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
        examples: ["sqrtm([[33, 24], [48, 57]])"],
        seealso: ["sqrt", "abs", "square", "multiply"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js
  var sylvesterDocs;
  var init_sylvester = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js"() {
      sylvesterDocs = {
        name: "sylvester",
        category: "Algebra",
        syntax: ["sylvester(A,B,C)"],
        description: "Solves the real-valued Sylvester equation AX+XB=C for X",
        examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
        seealso: ["schur", "lyap"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js
  var schurDocs;
  var init_schur = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js"() {
      schurDocs = {
        name: "schur",
        category: "Algebra",
        syntax: ["schur(A)"],
        description: "Performs a real Schur decomposition of the real matrix A = UTU'",
        examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
        seealso: ["lyap", "sylvester"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js
  var lyapDocs;
  var init_lyap = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js"() {
      lyapDocs = {
        name: "lyap",
        category: "Algebra",
        syntax: ["lyap(A,Q)"],
        description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
        examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
        seealso: ["schur", "sylvester"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
  var squareDocs;
  var init_square2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js"() {
      squareDocs = {
        name: "square",
        category: "Arithmetic",
        syntax: ["square(x)"],
        description: "Compute the square of a value. The square of x is x * x.",
        examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
        seealso: ["multiply", "pow", "sqrt", "cube"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
  var subtractDocs;
  var init_subtract2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js"() {
      subtractDocs = {
        name: "subtract",
        category: "Operators",
        syntax: ["x - y", "subtract(x, y)"],
        description: "subtract two values.",
        examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
        seealso: ["add"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
  var unaryMinusDocs;
  var init_unaryMinus2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js"() {
      unaryMinusDocs = {
        name: "unaryMinus",
        category: "Operators",
        syntax: ["-x", "unaryMinus(x)"],
        description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
        examples: ["-4.5", "-(-5.6)", '-"22"'],
        seealso: ["add", "subtract", "unaryPlus"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
  var unaryPlusDocs;
  var init_unaryPlus2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js"() {
      unaryPlusDocs = {
        name: "unaryPlus",
        category: "Operators",
        syntax: ["+x", "unaryPlus(x)"],
        description: "Converts booleans and strings to numbers.",
        examples: ["+true", '+"2"'],
        seealso: ["add", "subtract", "unaryMinus"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
  var xgcdDocs;
  var init_xgcd2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js"() {
      xgcdDocs = {
        name: "xgcd",
        category: "Arithmetic",
        syntax: ["xgcd(a, b)"],
        description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
        examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
        seealso: ["gcd", "lcm"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
  var bitAndDocs;
  var init_bitAnd2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js"() {
      bitAndDocs = {
        name: "bitAnd",
        category: "Bitwise",
        syntax: ["x & y", "bitAnd(x, y)"],
        description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
        examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
        seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
  var bitNotDocs;
  var init_bitNot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js"() {
      bitNotDocs = {
        name: "bitNot",
        category: "Bitwise",
        syntax: ["~x", "bitNot(x)"],
        description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
        examples: ["~1", "~2", "bitNot([2, -3, 4])"],
        seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
  var bitOrDocs;
  var init_bitOr2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js"() {
      bitOrDocs = {
        name: "bitOr",
        category: "Bitwise",
        syntax: ["x | y", "bitOr(x, y)"],
        description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
        examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
        seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
  var bitXorDocs;
  var init_bitXor2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js"() {
      bitXorDocs = {
        name: "bitXor",
        category: "Bitwise",
        syntax: ["bitXor(x, y)"],
        description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
        examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
        seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
  var leftShiftDocs;
  var init_leftShift2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js"() {
      leftShiftDocs = {
        name: "leftShift",
        category: "Bitwise",
        syntax: ["x << y", "leftShift(x, y)"],
        description: "Bitwise left logical shift of a value x by y number of bits.",
        examples: ["4 << 1", "8 >> 1"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
  var rightArithShiftDocs;
  var init_rightArithShift2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js"() {
      rightArithShiftDocs = {
        name: "rightArithShift",
        category: "Bitwise",
        syntax: ["x >> y", "rightArithShift(x, y)"],
        description: "Bitwise right arithmetic shift of a value x by y number of bits.",
        examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
  var rightLogShiftDocs;
  var init_rightLogShift2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js"() {
      rightLogShiftDocs = {
        name: "rightLogShift",
        category: "Bitwise",
        syntax: ["x >>> y", "rightLogShift(x, y)"],
        description: "Bitwise right logical shift of a value x by y number of bits.",
        examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
  var bellNumbersDocs;
  var init_bellNumbers = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js"() {
      bellNumbersDocs = {
        name: "bellNumbers",
        category: "Combinatorics",
        syntax: ["bellNumbers(n)"],
        description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
        examples: ["bellNumbers(3)", "bellNumbers(8)"],
        seealso: ["stirlingS2"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
  var catalanDocs;
  var init_catalan = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js"() {
      catalanDocs = {
        name: "catalan",
        category: "Combinatorics",
        syntax: ["catalan(n)"],
        description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
        examples: ["catalan(3)", "catalan(8)"],
        seealso: ["bellNumbers"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
  var compositionDocs;
  var init_composition = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js"() {
      compositionDocs = {
        name: "composition",
        category: "Combinatorics",
        syntax: ["composition(n, k)"],
        description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
        examples: ["composition(5, 3)"],
        seealso: ["combinations"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
  var stirlingS2Docs;
  var init_stirlingS2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js"() {
      stirlingS2Docs = {
        name: "stirlingS2",
        category: "Combinatorics",
        syntax: ["stirlingS2(n, k)"],
        description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
        examples: ["stirlingS2(5, 3)"],
        seealso: ["bellNumbers"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
  var argDocs;
  var init_arg2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js"() {
      argDocs = {
        name: "arg",
        category: "Complex",
        syntax: ["arg(x)"],
        description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
        examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
        seealso: ["re", "im", "conj", "abs"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
  var conjDocs;
  var init_conj2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js"() {
      conjDocs = {
        name: "conj",
        category: "Complex",
        syntax: ["conj(x)"],
        description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
        examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
        seealso: ["re", "im", "abs", "arg"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
  var imDocs;
  var init_im2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js"() {
      imDocs = {
        name: "im",
        category: "Complex",
        syntax: ["im(x)"],
        description: "Get the imaginary part of a complex number.",
        examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
        seealso: ["re", "conj", "abs", "arg"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
  var reDocs;
  var init_re2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js"() {
      reDocs = {
        name: "re",
        category: "Complex",
        syntax: ["re(x)"],
        description: "Get the real part of a complex number.",
        examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
        seealso: ["im", "conj", "abs", "arg"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
  var evaluateDocs;
  var init_evaluate2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js"() {
      evaluateDocs = {
        name: "evaluate",
        category: "Expression",
        syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
        description: "Evaluate an expression or an array with expressions.",
        examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
  var helpDocs;
  var init_help = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js"() {
      helpDocs = {
        name: "help",
        category: "Expression",
        syntax: ["help(object)", "help(string)"],
        description: "Display documentation on a function or data type.",
        examples: ["help(sqrt)", 'help("complex")'],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
  var distanceDocs;
  var init_distance = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js"() {
      distanceDocs = {
        name: "distance",
        category: "Geometry",
        syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
        description: "Calculates the Euclidean distance between two points.",
        examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
  var intersectDocs;
  var init_intersect = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js"() {
      intersectDocs = {
        name: "intersect",
        category: "Geometry",
        syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
        description: "Computes the intersection point of lines and/or planes.",
        examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
  var andDocs;
  var init_and2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js"() {
      andDocs = {
        name: "and",
        category: "Logical",
        syntax: ["x and y", "and(x, y)"],
        description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
        examples: ["true and false", "true and true", "2 and 4"],
        seealso: ["not", "or", "xor"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
  var notDocs;
  var init_not2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js"() {
      notDocs = {
        name: "not",
        category: "Logical",
        syntax: ["not x", "not(x)"],
        description: "Logical not. Flips the boolean value of given argument.",
        examples: ["not true", "not false", "not 2", "not 0"],
        seealso: ["and", "or", "xor"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
  var orDocs;
  var init_or2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js"() {
      orDocs = {
        name: "or",
        category: "Logical",
        syntax: ["x or y", "or(x, y)"],
        description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
        examples: ["true or false", "false or false", "0 or 4"],
        seealso: ["not", "and", "xor"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
  var xorDocs;
  var init_xor2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js"() {
      xorDocs = {
        name: "xor",
        category: "Logical",
        syntax: ["x xor y", "xor(x, y)"],
        description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
        examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
        seealso: ["not", "and", "or"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
  var columnDocs;
  var init_column2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js"() {
      columnDocs = {
        name: "column",
        category: "Matrix",
        syntax: ["column(x, index)"],
        description: "Return a column from a matrix or array.",
        examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
        seealso: ["row", "matrixFromColumns"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
  var concatDocs;
  var init_concat2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js"() {
      concatDocs = {
        name: "concat",
        category: "Matrix",
        syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
        description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
        examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
        seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
  var countDocs;
  var init_count2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js"() {
      countDocs = {
        name: "count",
        category: "Matrix",
        syntax: ["count(x)"],
        description: "Count the number of elements of a matrix, array or string.",
        examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
        seealso: ["size"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
  var crossDocs;
  var init_cross2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js"() {
      crossDocs = {
        name: "cross",
        category: "Matrix",
        syntax: ["cross(A, B)"],
        description: "Calculate the cross product for two vectors in three dimensional space.",
        examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
        seealso: ["multiply", "dot"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
  var ctransposeDocs;
  var init_ctranspose2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js"() {
      ctransposeDocs = {
        name: "ctranspose",
        category: "Matrix",
        syntax: ["x'", "ctranspose(x)"],
        description: "Complex Conjugate and Transpose a matrix",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
  var detDocs;
  var init_det = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js"() {
      detDocs = {
        name: "det",
        category: "Matrix",
        syntax: ["det(x)"],
        description: "Calculate the determinant of a matrix",
        examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
        seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
  var diagDocs;
  var init_diag2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js"() {
      diagDocs = {
        name: "diag",
        category: "Matrix",
        syntax: ["diag(x)", "diag(x, k)"],
        description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
        examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
        seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
  var diffDocs;
  var init_diff2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js"() {
      diffDocs = {
        name: "diff",
        category: "Matrix",
        syntax: ["diff(arr)", "diff(arr, dim)"],
        description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
        examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
        seealso: ["subtract", "partitionSelect"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
  var dotDocs;
  var init_dot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js"() {
      dotDocs = {
        name: "dot",
        category: "Matrix",
        syntax: ["dot(A, B)", "A * B"],
        description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
        examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
        seealso: ["multiply", "cross"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
  var eigsDocs;
  var init_eigs = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js"() {
      eigsDocs = {
        name: "eigs",
        category: "Matrix",
        syntax: ["eigs(x)"],
        description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
        examples: ["eigs([[5, 2.3], [2.3, 1]])"],
        seealso: ["inv"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
  var filterDocs;
  var init_filter2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js"() {
      filterDocs = {
        name: "filter",
        category: "Matrix",
        syntax: ["filter(x, test)"],
        description: "Filter items in a matrix.",
        examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
        seealso: ["sort", "map", "forEach"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
  var flattenDocs;
  var init_flatten2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js"() {
      flattenDocs = {
        name: "flatten",
        category: "Matrix",
        syntax: ["flatten(x)"],
        description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
        seealso: ["concat", "resize", "size", "squeeze"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
  var forEachDocs;
  var init_forEach2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js"() {
      forEachDocs = {
        name: "forEach",
        category: "Matrix",
        syntax: ["forEach(x, callback)"],
        description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
        examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
        seealso: ["map", "sort", "filter"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
  var getMatrixDataTypeDocs;
  var init_getMatrixDataType2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js"() {
      getMatrixDataTypeDocs = {
        name: "getMatrixDataType",
        category: "Matrix",
        syntax: ["getMatrixDataType(x)"],
        description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
        examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
        seealso: ["matrix", "sparse", "typeOf"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
  var identityDocs;
  var init_identity2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js"() {
      identityDocs = {
        name: "identity",
        category: "Matrix",
        syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
        description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
        examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
        seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
  var invDocs;
  var init_inv = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js"() {
      invDocs = {
        name: "inv",
        category: "Matrix",
        syntax: ["inv(x)"],
        description: "Calculate the inverse of a matrix",
        examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
        seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
  var pinvDocs;
  var init_pinv = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js"() {
      pinvDocs = {
        name: "pinv",
        category: "Matrix",
        syntax: ["pinv(x)"],
        description: "Calculate the Moore\u2013Penrose inverse of a matrix",
        examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
        seealso: ["inv"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
  var kronDocs;
  var init_kron2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js"() {
      kronDocs = {
        name: "kron",
        category: "Matrix",
        syntax: ["kron(x, y)"],
        description: "Calculates the kronecker product of 2 matrices or vectors.",
        examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
        seealso: ["multiply", "dot", "cross"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
  var mapDocs;
  var init_map3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js"() {
      mapDocs = {
        name: "map",
        category: "Matrix",
        syntax: ["map(x, callback)"],
        description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
        examples: ["map([1, 2, 3], square)"],
        seealso: ["filter", "forEach"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
  var matrixFromColumnsDocs;
  var init_matrixFromColumns2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js"() {
      matrixFromColumnsDocs = {
        name: "matrixFromColumns",
        category: "Matrix",
        syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
        description: "Create a dense matrix from vectors as individual columns.",
        examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
        seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
  var matrixFromFunctionDocs;
  var init_matrixFromFunction2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js"() {
      matrixFromFunctionDocs = {
        name: "matrixFromFunction",
        category: "Matrix",
        syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
        description: "Create a matrix by evaluating a generating function at each index.",
        examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
        seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
  var matrixFromRowsDocs;
  var init_matrixFromRows2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js"() {
      matrixFromRowsDocs = {
        name: "matrixFromRows",
        category: "Matrix",
        syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
        description: "Create a dense matrix from vectors as individual rows.",
        examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
        seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
  var onesDocs;
  var init_ones2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js"() {
      onesDocs = {
        name: "ones",
        category: "Matrix",
        syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
        description: "Create a matrix containing ones.",
        examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
  var partitionSelectDocs;
  var init_partitionSelect2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js"() {
      partitionSelectDocs = {
        name: "partitionSelect",
        category: "Matrix",
        syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
        description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
        examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
        seealso: ["sort"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
  var rangeDocs;
  var init_range2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js"() {
      rangeDocs = {
        name: "range",
        category: "Type",
        syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
        description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
        examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
  var reshapeDocs;
  var init_reshape2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js"() {
      reshapeDocs = {
        name: "reshape",
        category: "Matrix",
        syntax: ["reshape(x, sizes)"],
        description: "Reshape a multi dimensional array to fit the specified dimensions.",
        examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
        seealso: ["size", "squeeze", "resize"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
  var resizeDocs;
  var init_resize2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js"() {
      resizeDocs = {
        name: "resize",
        category: "Matrix",
        syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
        description: "Resize a matrix.",
        examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
        seealso: ["size", "subset", "squeeze", "reshape"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
  var rotateDocs;
  var init_rotate2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js"() {
      rotateDocs = {
        name: "rotate",
        category: "Matrix",
        syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
        description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
        examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
        seealso: ["matrix", "rotationMatrix"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
  var rotationMatrixDocs;
  var init_rotationMatrix2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js"() {
      rotationMatrixDocs = {
        name: "rotationMatrix",
        category: "Matrix",
        syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
        description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
        examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
        seealso: ["cos", "sin"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
  var rowDocs;
  var init_row2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js"() {
      rowDocs = {
        name: "row",
        category: "Matrix",
        syntax: ["row(x, index)"],
        description: "Return a row from a matrix or array.",
        examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
        seealso: ["column", "matrixFromRows"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
  var sizeDocs;
  var init_size2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js"() {
      sizeDocs = {
        name: "size",
        category: "Matrix",
        syntax: ["size(x)"],
        description: "Calculate the size of a matrix.",
        examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
        seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
  var sortDocs;
  var init_sort2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js"() {
      sortDocs = {
        name: "sort",
        category: "Matrix",
        syntax: ["sort(x)", "sort(x, compare)"],
        description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
        examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
        seealso: ["map", "filter", "forEach"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
  var squeezeDocs;
  var init_squeeze2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js"() {
      squeezeDocs = {
        name: "squeeze",
        category: "Matrix",
        syntax: ["squeeze(x)"],
        description: "Remove inner and outer singleton dimensions from a matrix.",
        examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
  var subsetDocs;
  var init_subset2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js"() {
      subsetDocs = {
        name: "subset",
        category: "Matrix",
        syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
        description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
        examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
  var traceDocs;
  var init_trace2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js"() {
      traceDocs = {
        name: "trace",
        category: "Matrix",
        syntax: ["trace(A)"],
        description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
        examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
  var transposeDocs;
  var init_transpose2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js"() {
      transposeDocs = {
        name: "transpose",
        category: "Matrix",
        syntax: ["x'", "transpose(x)"],
        description: "Transpose a matrix",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
  var zerosDocs;
  var init_zeros2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js"() {
      zerosDocs = {
        name: "zeros",
        category: "Matrix",
        syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
        description: "Create a matrix containing zeros.",
        examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
  var fftDocs;
  var init_fft2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js"() {
      fftDocs = {
        name: "fft",
        category: "Matrix",
        syntax: ["fft(x)"],
        description: "Calculate N-dimensional fourier transform",
        examples: ["fft([[1, 0], [1, 0]])"],
        seealso: ["ifft"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
  var ifftDocs;
  var init_ifft2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js"() {
      ifftDocs = {
        name: "ifft",
        category: "Matrix",
        syntax: ["ifft(x)"],
        description: "Calculate N-dimensional inverse fourier transform",
        examples: ["ifft([[2, 2], [0, 0]])"],
        seealso: ["fft"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
  var combinationsDocs;
  var init_combinations2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js"() {
      combinationsDocs = {
        name: "combinations",
        category: "Probability",
        syntax: ["combinations(n, k)"],
        description: "Compute the number of combinations of n items taken k at a time",
        examples: ["combinations(7, 5)"],
        seealso: ["combinationsWithRep", "permutations", "factorial"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
  var combinationsWithRepDocs;
  var init_combinationsWithRep = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js"() {
      combinationsWithRepDocs = {
        name: "combinationsWithRep",
        category: "Probability",
        syntax: ["combinationsWithRep(n, k)"],
        description: "Compute the number of combinations of n items taken k at a time with replacements.",
        examples: ["combinationsWithRep(7, 5)"],
        seealso: ["combinations", "permutations", "factorial"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
  var factorialDocs;
  var init_factorial = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js"() {
      factorialDocs = {
        name: "factorial",
        category: "Probability",
        syntax: ["n!", "factorial(n)"],
        description: "Compute the factorial of a value",
        examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
        seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
  var gammaDocs;
  var init_gamma = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js"() {
      gammaDocs = {
        name: "gamma",
        category: "Probability",
        syntax: ["gamma(n)"],
        description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
        examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
        seealso: ["factorial"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
  var lgammaDocs;
  var init_lgamma = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js"() {
      lgammaDocs = {
        name: "lgamma",
        category: "Probability",
        syntax: ["lgamma(n)"],
        description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
        examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
        seealso: ["gamma"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
  var kldivergenceDocs;
  var init_kldivergence = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js"() {
      kldivergenceDocs = {
        name: "kldivergence",
        category: "Probability",
        syntax: ["kldivergence(x, y)"],
        description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
        examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
  var multinomialDocs;
  var init_multinomial = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js"() {
      multinomialDocs = {
        name: "multinomial",
        category: "Probability",
        syntax: ["multinomial(A)"],
        description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
        examples: ["multinomial([1, 2, 1])"],
        seealso: ["combinations", "factorial"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
  var permutationsDocs;
  var init_permutations = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js"() {
      permutationsDocs = {
        name: "permutations",
        category: "Probability",
        syntax: ["permutations(n)", "permutations(n, k)"],
        description: "Compute the number of permutations of n items taken k at a time",
        examples: ["permutations(5)", "permutations(5, 3)"],
        seealso: ["combinations", "combinationsWithRep", "factorial"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
  var pickRandomDocs;
  var init_pickRandom = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js"() {
      pickRandomDocs = {
        name: "pickRandom",
        category: "Probability",
        syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
        description: "Pick a random entry from a given array.",
        examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
        seealso: ["random", "randomInt"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
  var randomDocs;
  var init_random = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js"() {
      randomDocs = {
        name: "random",
        category: "Probability",
        syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
        description: "Return a random number.",
        examples: ["random()", "random(10, 20)", "random([2, 3])"],
        seealso: ["pickRandom", "randomInt"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
  var randomIntDocs;
  var init_randomInt = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js"() {
      randomIntDocs = {
        name: "randomInt",
        category: "Probability",
        syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
        description: "Return a random integer number",
        examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
        seealso: ["pickRandom", "random"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
  var compareDocs;
  var init_compare2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js"() {
      compareDocs = {
        name: "compare",
        category: "Relational",
        syntax: ["compare(x, y)"],
        description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
  var compareNaturalDocs;
  var init_compareNatural2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js"() {
      compareNaturalDocs = {
        name: "compareNatural",
        category: "Relational",
        syntax: ["compareNatural(x, y)"],
        description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
  var compareTextDocs;
  var init_compareText2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js"() {
      compareTextDocs = {
        name: "compareText",
        category: "Relational",
        syntax: ["compareText(x, y)"],
        description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
        seealso: ["compare", "compareNatural"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
  var deepEqualDocs;
  var init_deepEqual2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js"() {
      deepEqualDocs = {
        name: "deepEqual",
        category: "Relational",
        syntax: ["deepEqual(x, y)"],
        description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
        examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
        seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
  var equalDocs;
  var init_equal2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js"() {
      equalDocs = {
        name: "equal",
        category: "Relational",
        syntax: ["x == y", "equal(x, y)"],
        description: "Check equality of two values. Returns true if the values are equal, and false if not.",
        examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
        seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
  var equalTextDocs;
  var init_equalText2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js"() {
      equalTextDocs = {
        name: "equalText",
        category: "Relational",
        syntax: ["equalText(x, y)"],
        description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
        examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
        seealso: ["compare", "compareNatural", "compareText", "equal"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
  var largerDocs;
  var init_larger2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js"() {
      largerDocs = {
        name: "larger",
        category: "Relational",
        syntax: ["x > y", "larger(x, y)"],
        description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
        examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
  var largerEqDocs;
  var init_largerEq2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js"() {
      largerEqDocs = {
        name: "largerEq",
        category: "Relational",
        syntax: ["x >= y", "largerEq(x, y)"],
        description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
        examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
        seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
  var smallerDocs;
  var init_smaller2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js"() {
      smallerDocs = {
        name: "smaller",
        category: "Relational",
        syntax: ["x < y", "smaller(x, y)"],
        description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
        examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
        seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
  var smallerEqDocs;
  var init_smallerEq2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js"() {
      smallerEqDocs = {
        name: "smallerEq",
        category: "Relational",
        syntax: ["x <= y", "smallerEq(x, y)"],
        description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
        examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
        seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
  var unequalDocs;
  var init_unequal2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js"() {
      unequalDocs = {
        name: "unequal",
        category: "Relational",
        syntax: ["x != y", "unequal(x, y)"],
        description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
        examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
        seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
  var setCartesianDocs;
  var init_setCartesian2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js"() {
      setCartesianDocs = {
        name: "setCartesian",
        category: "Set",
        syntax: ["setCartesian(set1, set2)"],
        description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
        examples: ["setCartesian([1, 2], [3, 4])"],
        seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
  var setDifferenceDocs;
  var init_setDifference2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js"() {
      setDifferenceDocs = {
        name: "setDifference",
        category: "Set",
        syntax: ["setDifference(set1, set2)"],
        description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setIntersect", "setSymDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
  var setDistinctDocs;
  var init_setDistinct2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js"() {
      setDistinctDocs = {
        name: "setDistinct",
        category: "Set",
        syntax: ["setDistinct(set)"],
        description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
        seealso: ["setMultiplicity"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
  var setIntersectDocs;
  var init_setIntersect2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js"() {
      setIntersectDocs = {
        name: "setIntersect",
        category: "Set",
        syntax: ["setIntersect(set1, set2)"],
        description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
  var setIsSubsetDocs;
  var init_setIsSubset2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js"() {
      setIsSubsetDocs = {
        name: "setIsSubset",
        category: "Set",
        syntax: ["setIsSubset(set1, set2)"],
        description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
  var setMultiplicityDocs;
  var init_setMultiplicity2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js"() {
      setMultiplicityDocs = {
        name: "setMultiplicity",
        category: "Set",
        syntax: ["setMultiplicity(element, set)"],
        description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
        seealso: ["setDistinct", "setSize"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
  var setPowersetDocs;
  var init_setPowerset2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js"() {
      setPowersetDocs = {
        name: "setPowerset",
        category: "Set",
        syntax: ["setPowerset(set)"],
        description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setPowerset([1, 2, 3])"],
        seealso: ["setCartesian"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
  var setSizeDocs;
  var init_setSize2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js"() {
      setSizeDocs = {
        name: "setSize",
        category: "Set",
        syntax: ["setSize(set)", "setSize(set, unique)"],
        description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
        examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
  var setSymDifferenceDocs;
  var init_setSymDifference2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js"() {
      setSymDifferenceDocs = {
        name: "setSymDifference",
        category: "Set",
        syntax: ["setSymDifference(set1, set2)"],
        description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
  var setUnionDocs;
  var init_setUnion2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js"() {
      setUnionDocs = {
        name: "setUnion",
        category: "Set",
        syntax: ["setUnion(set1, set2)"],
        description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js
  var zpk2tfDocs;
  var init_zpk2tf = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js"() {
      zpk2tfDocs = {
        name: "zpk2tf",
        category: "Signal",
        syntax: ["zpk2tf(z, p, k)"],
        description: "Compute the transfer function of a zero-pole-gain model.",
        examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js
  var freqzDocs;
  var init_freqz = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js"() {
      freqzDocs = {
        name: "freqz",
        category: "Signal",
        syntax: ["freqz(b, a)", "freqz(b, a, w)"],
        description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
        examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
  var erfDocs;
  var init_erf2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js"() {
      erfDocs = {
        name: "erf",
        category: "Special",
        syntax: ["erf(x)"],
        description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
        examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js
  var zetaDocs;
  var init_zeta2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js"() {
      zetaDocs = {
        name: "zeta",
        category: "Special",
        syntax: ["zeta(s)"],
        description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
        examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
  var madDocs;
  var init_mad = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js"() {
      madDocs = {
        name: "mad",
        category: "Statistics",
        syntax: ["mad(a, b, c, ...)", "mad(A)"],
        description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
        examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
        seealso: ["mean", "median", "std", "abs"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
  var maxDocs;
  var init_max2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js"() {
      maxDocs = {
        name: "max",
        category: "Statistics",
        syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
        description: "Compute the maximum value of a list of values.",
        examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
        seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
  var meanDocs;
  var init_mean = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js"() {
      meanDocs = {
        name: "mean",
        category: "Statistics",
        syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
        description: "Compute the arithmetic mean of a list of values.",
        examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
        seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
  var medianDocs;
  var init_median = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js"() {
      medianDocs = {
        name: "median",
        category: "Statistics",
        syntax: ["median(a, b, c, ...)", "median(A)"],
        description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
        examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
        seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
  var minDocs;
  var init_min2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js"() {
      minDocs = {
        name: "min",
        category: "Statistics",
        syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
        description: "Compute the minimum value of a list of values.",
        examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
        seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
  var modeDocs;
  var init_mode2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js"() {
      modeDocs = {
        name: "mode",
        category: "Statistics",
        syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
        description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
        examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
        seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
  var prodDocs;
  var init_prod2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js"() {
      prodDocs = {
        name: "prod",
        category: "Statistics",
        syntax: ["prod(a, b, c, ...)", "prod(A)"],
        description: "Compute the product of all values.",
        examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
        seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
  var quantileSeqDocs;
  var init_quantileSeq = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js"() {
      quantileSeqDocs = {
        name: "quantileSeq",
        category: "Statistics",
        syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
        description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
        examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
        seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
  var stdDocs;
  var init_std = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js"() {
      stdDocs = {
        name: "std",
        category: "Statistics",
        syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
        description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
        examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
        seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
  var cumSumDocs;
  var init_cumsum = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js"() {
      cumSumDocs = {
        name: "cumsum",
        category: "Statistics",
        syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
        description: "Compute the cumulative sum of all values.",
        examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
        seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
  var sumDocs;
  var init_sum = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js"() {
      sumDocs = {
        name: "sum",
        category: "Statistics",
        syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
        description: "Compute the sum of all values.",
        examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
        seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
  var varianceDocs;
  var init_variance = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js"() {
      varianceDocs = {
        name: "variance",
        category: "Statistics",
        syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
        description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
        examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
        seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
  var acosDocs;
  var init_acos2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js"() {
      acosDocs = {
        name: "acos",
        category: "Trigonometry",
        syntax: ["acos(x)"],
        description: "Compute the inverse cosine of a value in radians.",
        examples: ["acos(0.5)", "acos(cos(2.3))"],
        seealso: ["cos", "atan", "asin"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
  var acoshDocs;
  var init_acosh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js"() {
      acoshDocs = {
        name: "acosh",
        category: "Trigonometry",
        syntax: ["acosh(x)"],
        description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
        examples: ["acosh(1.5)"],
        seealso: ["cosh", "asinh", "atanh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
  var acotDocs;
  var init_acot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js"() {
      acotDocs = {
        name: "acot",
        category: "Trigonometry",
        syntax: ["acot(x)"],
        description: "Calculate the inverse cotangent of a value.",
        examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
        seealso: ["cot", "atan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
  var acothDocs;
  var init_acoth2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js"() {
      acothDocs = {
        name: "acoth",
        category: "Trigonometry",
        syntax: ["acoth(x)"],
        description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
        examples: ["acoth(2)", "acoth(0.5)"],
        seealso: ["acsch", "asech"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
  var acscDocs;
  var init_acsc2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js"() {
      acscDocs = {
        name: "acsc",
        category: "Trigonometry",
        syntax: ["acsc(x)"],
        description: "Calculate the inverse cotangent of a value.",
        examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
        seealso: ["csc", "asin", "asec"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
  var acschDocs;
  var init_acsch2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js"() {
      acschDocs = {
        name: "acsch",
        category: "Trigonometry",
        syntax: ["acsch(x)"],
        description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
        examples: ["acsch(0.5)"],
        seealso: ["asech", "acoth"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
  var asecDocs;
  var init_asec2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js"() {
      asecDocs = {
        name: "asec",
        category: "Trigonometry",
        syntax: ["asec(x)"],
        description: "Calculate the inverse secant of a value.",
        examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
        seealso: ["acos", "acot", "acsc"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
  var asechDocs;
  var init_asech2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js"() {
      asechDocs = {
        name: "asech",
        category: "Trigonometry",
        syntax: ["asech(x)"],
        description: "Calculate the inverse secant of a value.",
        examples: ["asech(0.5)"],
        seealso: ["acsch", "acoth"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
  var asinDocs;
  var init_asin2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js"() {
      asinDocs = {
        name: "asin",
        category: "Trigonometry",
        syntax: ["asin(x)"],
        description: "Compute the inverse sine of a value in radians.",
        examples: ["asin(0.5)", "asin(sin(0.5))"],
        seealso: ["sin", "acos", "atan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
  var asinhDocs;
  var init_asinh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js"() {
      asinhDocs = {
        name: "asinh",
        category: "Trigonometry",
        syntax: ["asinh(x)"],
        description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
        examples: ["asinh(0.5)"],
        seealso: ["acosh", "atanh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
  var atanDocs;
  var init_atan3 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js"() {
      atanDocs = {
        name: "atan",
        category: "Trigonometry",
        syntax: ["atan(x)"],
        description: "Compute the inverse tangent of a value in radians.",
        examples: ["atan(0.5)", "atan(tan(0.5))"],
        seealso: ["tan", "acos", "asin"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
  var atan2Docs;
  var init_atan22 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js"() {
      atan2Docs = {
        name: "atan2",
        category: "Trigonometry",
        syntax: ["atan2(y, x)"],
        description: "Computes the principal value of the arc tangent of y/x in radians.",
        examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
        seealso: ["sin", "cos", "tan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
  var atanhDocs;
  var init_atanh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js"() {
      atanhDocs = {
        name: "atanh",
        category: "Trigonometry",
        syntax: ["atanh(x)"],
        description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
        examples: ["atanh(0.5)"],
        seealso: ["acosh", "asinh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
  var cosDocs;
  var init_cos2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js"() {
      cosDocs = {
        name: "cos",
        category: "Trigonometry",
        syntax: ["cos(x)"],
        description: "Compute the cosine of x in radians.",
        examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
        seealso: ["acos", "sin", "tan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
  var coshDocs;
  var init_cosh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js"() {
      coshDocs = {
        name: "cosh",
        category: "Trigonometry",
        syntax: ["cosh(x)"],
        description: "Compute the hyperbolic cosine of x in radians.",
        examples: ["cosh(0.5)"],
        seealso: ["sinh", "tanh", "coth"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
  var cotDocs;
  var init_cot2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js"() {
      cotDocs = {
        name: "cot",
        category: "Trigonometry",
        syntax: ["cot(x)"],
        description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
        examples: ["cot(2)", "1 / tan(2)"],
        seealso: ["sec", "csc", "tan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
  var cothDocs;
  var init_coth2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js"() {
      cothDocs = {
        name: "coth",
        category: "Trigonometry",
        syntax: ["coth(x)"],
        description: "Compute the hyperbolic cotangent of x in radians.",
        examples: ["coth(2)", "1 / tanh(2)"],
        seealso: ["sech", "csch", "tanh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
  var cscDocs;
  var init_csc2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js"() {
      cscDocs = {
        name: "csc",
        category: "Trigonometry",
        syntax: ["csc(x)"],
        description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
        examples: ["csc(2)", "1 / sin(2)"],
        seealso: ["sec", "cot", "sin"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
  var cschDocs;
  var init_csch2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js"() {
      cschDocs = {
        name: "csch",
        category: "Trigonometry",
        syntax: ["csch(x)"],
        description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
        examples: ["csch(2)", "1 / sinh(2)"],
        seealso: ["sech", "coth", "sinh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
  var secDocs;
  var init_sec2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js"() {
      secDocs = {
        name: "sec",
        category: "Trigonometry",
        syntax: ["sec(x)"],
        description: "Compute the secant of x in radians. Defined as 1/cos(x)",
        examples: ["sec(2)", "1 / cos(2)"],
        seealso: ["cot", "csc", "cos"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
  var sechDocs;
  var init_sech2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js"() {
      sechDocs = {
        name: "sech",
        category: "Trigonometry",
        syntax: ["sech(x)"],
        description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
        examples: ["sech(2)", "1 / cosh(2)"],
        seealso: ["coth", "csch", "cosh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
  var sinDocs;
  var init_sin2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js"() {
      sinDocs = {
        name: "sin",
        category: "Trigonometry",
        syntax: ["sin(x)"],
        description: "Compute the sine of x in radians.",
        examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
        seealso: ["asin", "cos", "tan"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
  var sinhDocs;
  var init_sinh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js"() {
      sinhDocs = {
        name: "sinh",
        category: "Trigonometry",
        syntax: ["sinh(x)"],
        description: "Compute the hyperbolic sine of x in radians.",
        examples: ["sinh(0.5)"],
        seealso: ["cosh", "tanh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
  var tanDocs;
  var init_tan2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js"() {
      tanDocs = {
        name: "tan",
        category: "Trigonometry",
        syntax: ["tan(x)"],
        description: "Compute the tangent of x in radians.",
        examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
        seealso: ["atan", "sin", "cos"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
  var tanhDocs;
  var init_tanh2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js"() {
      tanhDocs = {
        name: "tanh",
        category: "Trigonometry",
        syntax: ["tanh(x)"],
        description: "Compute the hyperbolic tangent of x in radians.",
        examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
        seealso: ["sinh", "cosh"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
  var toDocs;
  var init_to2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js"() {
      toDocs = {
        name: "to",
        category: "Units",
        syntax: ["x to unit", "to(x, unit)"],
        description: "Change the unit of a value.",
        examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
  var binDocs;
  var init_bin2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js"() {
      binDocs = {
        name: "bin",
        category: "Utils",
        syntax: ["bin(value)"],
        description: "Format a number as binary",
        examples: ["bin(2)"],
        seealso: ["oct", "hex"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
  var cloneDocs;
  var init_clone2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js"() {
      cloneDocs = {
        name: "clone",
        category: "Utils",
        syntax: ["clone(x)"],
        description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
        examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
        seealso: []
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
  var formatDocs;
  var init_format2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js"() {
      formatDocs = {
        name: "format",
        category: "Utils",
        syntax: ["format(value)", "format(value, precision)"],
        description: "Format a value of any type as string.",
        examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
        seealso: ["print"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
  var hasNumericValueDocs;
  var init_hasNumericValue2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js"() {
      hasNumericValueDocs = {
        name: "hasNumericValue",
        category: "Utils",
        syntax: ["hasNumericValue(x)"],
        description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
        examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
        seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
  var hexDocs;
  var init_hex2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js"() {
      hexDocs = {
        name: "hex",
        category: "Utils",
        syntax: ["hex(value)"],
        description: "Format a number as hexadecimal",
        examples: ["hex(240)"],
        seealso: ["bin", "oct"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
  var isIntegerDocs;
  var init_isInteger2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js"() {
      isIntegerDocs = {
        name: "isInteger",
        category: "Utils",
        syntax: ["isInteger(x)"],
        description: "Test whether a value is an integer number.",
        examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
        seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
  var isNaNDocs;
  var init_isNaN2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js"() {
      isNaNDocs = {
        name: "isNaN",
        category: "Utils",
        syntax: ["isNaN(x)"],
        description: "Test whether a value is NaN (not a number)",
        examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
        seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
  var isNegativeDocs;
  var init_isNegative2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js"() {
      isNegativeDocs = {
        name: "isNegative",
        category: "Utils",
        syntax: ["isNegative(x)"],
        description: "Test whether a value is negative: smaller than zero.",
        examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
        seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
  var isNumericDocs;
  var init_isNumeric2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js"() {
      isNumericDocs = {
        name: "isNumeric",
        category: "Utils",
        syntax: ["isNumeric(x)"],
        description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
        examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
        seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
  var isPositiveDocs;
  var init_isPositive2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js"() {
      isPositiveDocs = {
        name: "isPositive",
        category: "Utils",
        syntax: ["isPositive(x)"],
        description: "Test whether a value is positive: larger than zero.",
        examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
  var isPrimeDocs;
  var init_isPrime2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js"() {
      isPrimeDocs = {
        name: "isPrime",
        category: "Utils",
        syntax: ["isPrime(x)"],
        description: "Test whether a value is prime: has no divisors other than itself and one.",
        examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
  var isZeroDocs;
  var init_isZero2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js"() {
      isZeroDocs = {
        name: "isZero",
        category: "Utils",
        syntax: ["isZero(x)"],
        description: "Test whether a value is zero.",
        examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
  var numericDocs;
  var init_numeric2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js"() {
      numericDocs = {
        name: "numeric",
        category: "Utils",
        syntax: ["numeric(x)"],
        description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
        examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
        seealso: ["number", "fraction", "bignumber", "string", "format"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
  var octDocs;
  var init_oct2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js"() {
      octDocs = {
        name: "oct",
        category: "Utils",
        syntax: ["oct(value)"],
        description: "Format a number as octal",
        examples: ["oct(56)"],
        seealso: ["bin", "hex"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
  var printDocs;
  var init_print2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js"() {
      printDocs = {
        name: "print",
        category: "Utils",
        syntax: ["print(template, values)", "print(template, values, precision)"],
        description: "Interpolate values into a string template.",
        examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
        seealso: ["format"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
  var typeOfDocs;
  var init_typeOf2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js"() {
      typeOfDocs = {
        name: "typeOf",
        category: "Utils",
        syntax: ["typeOf(x)"],
        description: "Get the type of a variable.",
        examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
        seealso: ["getMatrixDataType"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js
  var solveODEDocs;
  var init_solveODE2 = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js"() {
      solveODEDocs = {
        name: "solveODE",
        category: "Numeric",
        syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
        description: "Numerical Integration of Ordinary Differential Equations.",
        examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
        seealso: ["derivative", "simplifyCore"]
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
  var embeddedDocs;
  var init_embeddedDocs = __esm({
    "node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js"() {
      init_e();
      init_false();
      init_i();
      init_Infinity();
      init_LN10();
      init_LN2();
      init_LOG10E();
      init_LOG2E();
      init_NaN();
      init_null();
      init_phi();
      init_pi();
      init_SQRT1_2();
      init_SQRT2();
      init_tau();
      init_true();
      init_version();
      init_bignumber2();
      init_boolean2();
      init_complex3();
      init_createUnit2();
      init_fraction2();
      init_construction();
      init_matrix2();
      init_number4();
      init_sparse2();
      init_splitUnit2();
      init_string3();
      init_unit2();
      init_config3();
      init_import();
      init_typed2();
      init_derivative();
      init_leafCount();
      init_lsolve2();
      init_lsolveAll2();
      init_lup2();
      init_lusolve2();
      init_polynomialRoot2();
      init_qr2();
      init_rationalize();
      init_resolve();
      init_simplify();
      init_simplifyConstant();
      init_simplifyCore();
      init_slu2();
      init_symbolicEqual();
      init_usolve2();
      init_usolveAll2();
      init_abs2();
      init_add2();
      init_cbrt2();
      init_ceil2();
      init_cube2();
      init_divide();
      init_dotDivide2();
      init_dotMultiply2();
      init_dotPow2();
      init_exp2();
      init_expm();
      init_expm12();
      init_fix2();
      init_floor2();
      init_gcd2();
      init_hypot2();
      init_invmod2();
      init_lcm2();
      init_log3();
      init_log102();
      init_log1p2();
      init_log22();
      init_mod2();
      init_multiply2();
      init_norm2();
      init_nthRoot2();
      init_nthRoots2();
      init_pow2();
      init_round2();
      init_sign2();
      init_sqrt2();
      init_sqrtm();
      init_sylvester();
      init_schur();
      init_lyap();
      init_square2();
      init_subtract2();
      init_unaryMinus2();
      init_unaryPlus2();
      init_xgcd2();
      init_bitAnd2();
      init_bitNot2();
      init_bitOr2();
      init_bitXor2();
      init_leftShift2();
      init_rightArithShift2();
      init_rightLogShift2();
      init_bellNumbers();
      init_catalan();
      init_composition();
      init_stirlingS2();
      init_arg2();
      init_conj2();
      init_im2();
      init_re2();
      init_evaluate2();
      init_help();
      init_distance();
      init_intersect();
      init_and2();
      init_not2();
      init_or2();
      init_xor2();
      init_column2();
      init_concat2();
      init_count2();
      init_cross2();
      init_ctranspose2();
      init_det();
      init_diag2();
      init_diff2();
      init_dot2();
      init_eigs();
      init_filter2();
      init_flatten2();
      init_forEach2();
      init_getMatrixDataType2();
      init_identity2();
      init_inv();
      init_pinv();
      init_kron2();
      init_map3();
      init_matrixFromColumns2();
      init_matrixFromFunction2();
      init_matrixFromRows2();
      init_ones2();
      init_partitionSelect2();
      init_range2();
      init_reshape2();
      init_resize2();
      init_rotate2();
      init_rotationMatrix2();
      init_row2();
      init_size2();
      init_sort2();
      init_squeeze2();
      init_subset2();
      init_trace2();
      init_transpose2();
      init_zeros2();
      init_fft2();
      init_ifft2();
      init_combinations2();
      init_combinationsWithRep();
      init_factorial();
      init_gamma();
      init_lgamma();
      init_kldivergence();
      init_multinomial();
      init_permutations();
      init_pickRandom();
      init_random();
      init_randomInt();
      init_compare2();
      init_compareNatural2();
      init_compareText2();
      init_deepEqual2();
      init_equal2();
      init_equalText2();
      init_larger2();
      init_largerEq2();
      init_smaller2();
      init_smallerEq2();
      init_unequal2();
      init_setCartesian2();
      init_setDifference2();
      init_setDistinct2();
      init_setIntersect2();
      init_setIsSubset2();
      init_setMultiplicity2();
      init_setPowerset2();
      init_setSize2();
      init_setSymDifference2();
      init_setUnion2();
      init_zpk2tf();
      init_freqz();
      init_erf2();
      init_zeta2();
      init_mad();
      init_max2();
      init_mean();
      init_median();
      init_min2();
      init_mode2();
      init_prod2();
      init_quantileSeq();
      init_std();
      init_cumsum();
      init_sum();
      init_variance();
      init_acos2();
      init_acosh2();
      init_acot2();
      init_acoth2();
      init_acsc2();
      init_acsch2();
      init_asec2();
      init_asech2();
      init_asin2();
      init_asinh2();
      init_atan3();
      init_atan22();
      init_atanh2();
      init_cos2();
      init_cosh2();
      init_cot2();
      init_coth2();
      init_csc2();
      init_csch2();
      init_sec2();
      init_sech2();
      init_sin2();
      init_sinh2();
      init_tan2();
      init_tanh2();
      init_to2();
      init_bin2();
      init_clone2();
      init_format2();
      init_hasNumericValue2();
      init_hex2();
      init_isInteger2();
      init_isNaN2();
      init_isNegative2();
      init_isNumeric2();
      init_isPositive2();
      init_isPrime2();
      init_isZero2();
      init_numeric2();
      init_oct2();
      init_print2();
      init_typeOf2();
      init_solveODE2();
      embeddedDocs = {
        // construction functions
        bignumber: bignumberDocs,
        boolean: booleanDocs,
        complex: complexDocs,
        createUnit: createUnitDocs,
        fraction: fractionDocs,
        index: indexDocs,
        matrix: matrixDocs,
        number: numberDocs,
        sparse: sparseDocs,
        splitUnit: splitUnitDocs,
        string: stringDocs,
        unit: unitDocs,
        // constants
        e: eDocs,
        E: eDocs,
        false: falseDocs,
        i: iDocs,
        Infinity: InfinityDocs,
        LN2: LN2Docs,
        LN10: LN10Docs,
        LOG2E: LOG2EDocs,
        LOG10E: LOG10EDocs,
        NaN: NaNDocs,
        null: nullDocs,
        pi: piDocs,
        PI: piDocs,
        phi: phiDocs,
        SQRT1_2: SQRT12Docs,
        SQRT2: SQRT2Docs,
        tau: tauDocs,
        true: trueDocs,
        version: versionDocs,
        // physical constants
        // TODO: more detailed docs for physical constants
        speedOfLight: {
          description: "Speed of light in vacuum",
          examples: ["speedOfLight"]
        },
        gravitationConstant: {
          description: "Newtonian constant of gravitation",
          examples: ["gravitationConstant"]
        },
        planckConstant: {
          description: "Planck constant",
          examples: ["planckConstant"]
        },
        reducedPlanckConstant: {
          description: "Reduced Planck constant",
          examples: ["reducedPlanckConstant"]
        },
        magneticConstant: {
          description: "Magnetic constant (vacuum permeability)",
          examples: ["magneticConstant"]
        },
        electricConstant: {
          description: "Electric constant (vacuum permeability)",
          examples: ["electricConstant"]
        },
        vacuumImpedance: {
          description: "Characteristic impedance of vacuum",
          examples: ["vacuumImpedance"]
        },
        coulomb: {
          description: "Coulomb's constant",
          examples: ["coulomb"]
        },
        elementaryCharge: {
          description: "Elementary charge",
          examples: ["elementaryCharge"]
        },
        bohrMagneton: {
          description: "Borh magneton",
          examples: ["bohrMagneton"]
        },
        conductanceQuantum: {
          description: "Conductance quantum",
          examples: ["conductanceQuantum"]
        },
        inverseConductanceQuantum: {
          description: "Inverse conductance quantum",
          examples: ["inverseConductanceQuantum"]
        },
        // josephson: {description: 'Josephson constant', examples: ['josephson']},
        magneticFluxQuantum: {
          description: "Magnetic flux quantum",
          examples: ["magneticFluxQuantum"]
        },
        nuclearMagneton: {
          description: "Nuclear magneton",
          examples: ["nuclearMagneton"]
        },
        klitzing: {
          description: "Von Klitzing constant",
          examples: ["klitzing"]
        },
        bohrRadius: {
          description: "Borh radius",
          examples: ["bohrRadius"]
        },
        classicalElectronRadius: {
          description: "Classical electron radius",
          examples: ["classicalElectronRadius"]
        },
        electronMass: {
          description: "Electron mass",
          examples: ["electronMass"]
        },
        fermiCoupling: {
          description: "Fermi coupling constant",
          examples: ["fermiCoupling"]
        },
        fineStructure: {
          description: "Fine-structure constant",
          examples: ["fineStructure"]
        },
        hartreeEnergy: {
          description: "Hartree energy",
          examples: ["hartreeEnergy"]
        },
        protonMass: {
          description: "Proton mass",
          examples: ["protonMass"]
        },
        deuteronMass: {
          description: "Deuteron Mass",
          examples: ["deuteronMass"]
        },
        neutronMass: {
          description: "Neutron mass",
          examples: ["neutronMass"]
        },
        quantumOfCirculation: {
          description: "Quantum of circulation",
          examples: ["quantumOfCirculation"]
        },
        rydberg: {
          description: "Rydberg constant",
          examples: ["rydberg"]
        },
        thomsonCrossSection: {
          description: "Thomson cross section",
          examples: ["thomsonCrossSection"]
        },
        weakMixingAngle: {
          description: "Weak mixing angle",
          examples: ["weakMixingAngle"]
        },
        efimovFactor: {
          description: "Efimov factor",
          examples: ["efimovFactor"]
        },
        atomicMass: {
          description: "Atomic mass constant",
          examples: ["atomicMass"]
        },
        avogadro: {
          description: "Avogadro's number",
          examples: ["avogadro"]
        },
        boltzmann: {
          description: "Boltzmann constant",
          examples: ["boltzmann"]
        },
        faraday: {
          description: "Faraday constant",
          examples: ["faraday"]
        },
        firstRadiation: {
          description: "First radiation constant",
          examples: ["firstRadiation"]
        },
        loschmidt: {
          description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
          examples: ["loschmidt"]
        },
        gasConstant: {
          description: "Gas constant",
          examples: ["gasConstant"]
        },
        molarPlanckConstant: {
          description: "Molar Planck constant",
          examples: ["molarPlanckConstant"]
        },
        molarVolume: {
          description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
          examples: ["molarVolume"]
        },
        sackurTetrode: {
          description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
          examples: ["sackurTetrode"]
        },
        secondRadiation: {
          description: "Second radiation constant",
          examples: ["secondRadiation"]
        },
        stefanBoltzmann: {
          description: "Stefan-Boltzmann constant",
          examples: ["stefanBoltzmann"]
        },
        wienDisplacement: {
          description: "Wien displacement law constant",
          examples: ["wienDisplacement"]
        },
        // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
        molarMass: {
          description: "Molar mass constant",
          examples: ["molarMass"]
        },
        molarMassC12: {
          description: "Molar mass constant of carbon-12",
          examples: ["molarMassC12"]
        },
        gravity: {
          description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
          examples: ["gravity"]
        },
        planckLength: {
          description: "Planck length",
          examples: ["planckLength"]
        },
        planckMass: {
          description: "Planck mass",
          examples: ["planckMass"]
        },
        planckTime: {
          description: "Planck time",
          examples: ["planckTime"]
        },
        planckCharge: {
          description: "Planck charge",
          examples: ["planckCharge"]
        },
        planckTemperature: {
          description: "Planck temperature",
          examples: ["planckTemperature"]
        },
        // functions - algebra
        derivative: derivativeDocs,
        lsolve: lsolveDocs,
        lsolveAll: lsolveAllDocs,
        lup: lupDocs,
        lusolve: lusolveDocs,
        leafCount: leafCountDocs,
        polynomialRoot: polynomialRootDocs,
        resolve: resolveDocs,
        simplify: simplifyDocs,
        simplifyConstant: simplifyConstantDocs,
        simplifyCore: simplifyCoreDocs,
        symbolicEqual: symbolicEqualDocs,
        rationalize: rationalizeDocs,
        slu: sluDocs,
        usolve: usolveDocs,
        usolveAll: usolveAllDocs,
        qr: qrDocs,
        // functions - arithmetic
        abs: absDocs,
        add: addDocs,
        cbrt: cbrtDocs,
        ceil: ceilDocs,
        cube: cubeDocs,
        divide: divideDocs,
        dotDivide: dotDivideDocs,
        dotMultiply: dotMultiplyDocs,
        dotPow: dotPowDocs,
        exp: expDocs,
        expm: expmDocs,
        expm1: expm1Docs,
        fix: fixDocs,
        floor: floorDocs,
        gcd: gcdDocs,
        hypot: hypotDocs,
        lcm: lcmDocs,
        log: logDocs,
        log2: log2Docs,
        log1p: log1pDocs,
        log10: log10Docs,
        mod: modDocs,
        multiply: multiplyDocs,
        norm: normDocs,
        nthRoot: nthRootDocs,
        nthRoots: nthRootsDocs,
        pow: powDocs,
        round: roundDocs,
        sign: signDocs,
        sqrt: sqrtDocs,
        sqrtm: sqrtmDocs,
        square: squareDocs,
        subtract: subtractDocs,
        unaryMinus: unaryMinusDocs,
        unaryPlus: unaryPlusDocs,
        xgcd: xgcdDocs,
        invmod: invmodDocs,
        // functions - bitwise
        bitAnd: bitAndDocs,
        bitNot: bitNotDocs,
        bitOr: bitOrDocs,
        bitXor: bitXorDocs,
        leftShift: leftShiftDocs,
        rightArithShift: rightArithShiftDocs,
        rightLogShift: rightLogShiftDocs,
        // functions - combinatorics
        bellNumbers: bellNumbersDocs,
        catalan: catalanDocs,
        composition: compositionDocs,
        stirlingS2: stirlingS2Docs,
        // functions - core
        config: configDocs,
        import: importDocs,
        typed: typedDocs,
        // functions - complex
        arg: argDocs,
        conj: conjDocs,
        re: reDocs,
        im: imDocs,
        // functions - expression
        evaluate: evaluateDocs,
        help: helpDocs,
        // functions - geometry
        distance: distanceDocs,
        intersect: intersectDocs,
        // functions - logical
        and: andDocs,
        not: notDocs,
        or: orDocs,
        xor: xorDocs,
        // functions - matrix
        concat: concatDocs,
        count: countDocs,
        cross: crossDocs,
        column: columnDocs,
        ctranspose: ctransposeDocs,
        det: detDocs,
        diag: diagDocs,
        diff: diffDocs,
        dot: dotDocs,
        getMatrixDataType: getMatrixDataTypeDocs,
        identity: identityDocs,
        filter: filterDocs,
        flatten: flattenDocs,
        forEach: forEachDocs,
        inv: invDocs,
        pinv: pinvDocs,
        eigs: eigsDocs,
        kron: kronDocs,
        matrixFromFunction: matrixFromFunctionDocs,
        matrixFromRows: matrixFromRowsDocs,
        matrixFromColumns: matrixFromColumnsDocs,
        map: mapDocs,
        ones: onesDocs,
        partitionSelect: partitionSelectDocs,
        range: rangeDocs,
        resize: resizeDocs,
        reshape: reshapeDocs,
        rotate: rotateDocs,
        rotationMatrix: rotationMatrixDocs,
        row: rowDocs,
        size: sizeDocs,
        sort: sortDocs,
        squeeze: squeezeDocs,
        subset: subsetDocs,
        trace: traceDocs,
        transpose: transposeDocs,
        zeros: zerosDocs,
        fft: fftDocs,
        ifft: ifftDocs,
        sylvester: sylvesterDocs,
        schur: schurDocs,
        lyap: lyapDocs,
        // functions - numeric
        solveODE: solveODEDocs,
        // functions - probability
        combinations: combinationsDocs,
        combinationsWithRep: combinationsWithRepDocs,
        // distribution: distributionDocs,
        factorial: factorialDocs,
        gamma: gammaDocs,
        kldivergence: kldivergenceDocs,
        lgamma: lgammaDocs,
        multinomial: multinomialDocs,
        permutations: permutationsDocs,
        pickRandom: pickRandomDocs,
        random: randomDocs,
        randomInt: randomIntDocs,
        // functions - relational
        compare: compareDocs,
        compareNatural: compareNaturalDocs,
        compareText: compareTextDocs,
        deepEqual: deepEqualDocs,
        equal: equalDocs,
        equalText: equalTextDocs,
        larger: largerDocs,
        largerEq: largerEqDocs,
        smaller: smallerDocs,
        smallerEq: smallerEqDocs,
        unequal: unequalDocs,
        // functions - set
        setCartesian: setCartesianDocs,
        setDifference: setDifferenceDocs,
        setDistinct: setDistinctDocs,
        setIntersect: setIntersectDocs,
        setIsSubset: setIsSubsetDocs,
        setMultiplicity: setMultiplicityDocs,
        setPowerset: setPowersetDocs,
        setSize: setSizeDocs,
        setSymDifference: setSymDifferenceDocs,
        setUnion: setUnionDocs,
        // functions - signal
        zpk2tf: zpk2tfDocs,
        freqz: freqzDocs,
        // functions - special
        erf: erfDocs,
        zeta: zetaDocs,
        // functions - statistics
        cumsum: cumSumDocs,
        mad: madDocs,
        max: maxDocs,
        mean: meanDocs,
        median: medianDocs,
        min: minDocs,
        mode: modeDocs,
        prod: prodDocs,
        quantileSeq: quantileSeqDocs,
        std: stdDocs,
        sum: sumDocs,
        variance: varianceDocs,
        // functions - trigonometry
        acos: acosDocs,
        acosh: acoshDocs,
        acot: acotDocs,
        acoth: acothDocs,
        acsc: acscDocs,
        acsch: acschDocs,
        asec: asecDocs,
        asech: asechDocs,
        asin: asinDocs,
        asinh: asinhDocs,
        atan: atanDocs,
        atanh: atanhDocs,
        atan2: atan2Docs,
        cos: cosDocs,
        cosh: coshDocs,
        cot: cotDocs,
        coth: cothDocs,
        csc: cscDocs,
        csch: cschDocs,
        sec: secDocs,
        sech: sechDocs,
        sin: sinDocs,
        sinh: sinhDocs,
        tan: tanDocs,
        tanh: tanhDocs,
        // functions - units
        to: toDocs,
        // functions - utils
        clone: cloneDocs,
        format: formatDocs,
        bin: binDocs,
        oct: octDocs,
        hex: hexDocs,
        isNaN: isNaNDocs,
        isInteger: isIntegerDocs,
        isNegative: isNegativeDocs,
        isNumeric: isNumericDocs,
        hasNumericValue: hasNumericValueDocs,
        isPositive: isPositiveDocs,
        isPrime: isPrimeDocs,
        isZero: isZeroDocs,
        print: printDocs,
        typeOf: typeOfDocs,
        numeric: numericDocs
      };
    }
  });

  // node_modules/mathjs/lib/esm/expression/function/help.js
  var name238, dependencies238, createHelp;
  var init_help2 = __esm({
    "node_modules/mathjs/lib/esm/expression/function/help.js"() {
      init_factory();
      init_customs();
      init_embeddedDocs();
      init_object();
      name238 = "help";
      dependencies238 = ["typed", "mathWithTransform", "Help"];
      createHelp = /* @__PURE__ */ factory(name238, dependencies238, (_ref) => {
        var {
          typed: typed3,
          mathWithTransform: mathWithTransform2,
          Help: Help2
        } = _ref;
        return typed3(name238, {
          any: function any(search) {
            var prop;
            var searchName = search;
            if (typeof search !== "string") {
              for (prop in mathWithTransform2) {
                if (hasOwnProperty2(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
                  searchName = prop;
                  break;
                }
              }
            }
            var doc = getSafeProperty(embeddedDocs, searchName);
            if (!doc) {
              var searchText = typeof searchName === "function" ? searchName.name : searchName;
              throw new Error('No documentation found on "' + searchText + '"');
            }
            return new Help2(doc);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/type/chain/function/chain.js
  var name239, dependencies239, createChain;
  var init_chain = __esm({
    "node_modules/mathjs/lib/esm/type/chain/function/chain.js"() {
      init_factory();
      name239 = "chain";
      dependencies239 = ["typed", "Chain"];
      createChain = /* @__PURE__ */ factory(name239, dependencies239, (_ref) => {
        var {
          typed: typed3,
          Chain: Chain2
        } = _ref;
        return typed3(name239, {
          "": function _3() {
            return new Chain2();
          },
          any: function any(value) {
            return new Chain2(value);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/det.js
  var name240, dependencies240, createDet;
  var init_det2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/det.js"() {
      init_is();
      init_object();
      init_string();
      init_factory();
      name240 = "det";
      dependencies240 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
      createDet = /* @__PURE__ */ factory(name240, dependencies240, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          subtract: subtract2,
          multiply: multiply2,
          divideScalar: divideScalar2,
          isZero: isZero2,
          unaryMinus: unaryMinus2
        } = _ref;
        return typed3(name240, {
          any: function any(x4) {
            return clone(x4);
          },
          "Array | Matrix": function det2(x4) {
            var size2;
            if (isMatrix(x4)) {
              size2 = x4.size();
            } else if (Array.isArray(x4)) {
              x4 = matrix2(x4);
              size2 = x4.size();
            } else {
              size2 = [];
            }
            switch (size2.length) {
              case 0:
                return clone(x4);
              case 1:
                if (size2[0] === 1) {
                  return clone(x4.valueOf()[0]);
                }
                if (size2[0] === 0) {
                  return 1;
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
                }
              case 2: {
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  return _det(x4.clone().valueOf(), rows, cols);
                }
                if (cols === 0) {
                  return 1;
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
            }
          }
        });
        function _det(matrix3, rows, cols) {
          if (rows === 1) {
            return clone(matrix3[0][0]);
          } else if (rows === 2) {
            return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
          } else {
            var negated = false;
            var rowIndices = new Array(rows).fill(0).map((_3, i6) => i6);
            for (var k4 = 0; k4 < rows; k4++) {
              var k_ = rowIndices[k4];
              if (isZero2(matrix3[k_][k4])) {
                var _k = void 0;
                for (_k = k4 + 1; _k < rows; _k++) {
                  if (!isZero2(matrix3[rowIndices[_k]][k4])) {
                    k_ = rowIndices[_k];
                    rowIndices[_k] = rowIndices[k4];
                    rowIndices[k4] = k_;
                    negated = !negated;
                    break;
                  }
                }
                if (_k === rows)
                  return matrix3[k_][k4];
              }
              var piv = matrix3[k_][k4];
              var piv_ = k4 === 0 ? 1 : matrix3[rowIndices[k4 - 1]][k4 - 1];
              for (var i5 = k4 + 1; i5 < rows; i5++) {
                var i_ = rowIndices[i5];
                for (var j4 = k4 + 1; j4 < rows; j4++) {
                  matrix3[i_][j4] = divideScalar2(subtract2(multiply2(matrix3[i_][j4], piv), multiply2(matrix3[i_][k4], matrix3[k_][j4])), piv_);
                }
              }
            }
            var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
            return negated ? unaryMinus2(det2) : det2;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/inv.js
  var name241, dependencies241, createInv;
  var init_inv2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/inv.js"() {
      init_is();
      init_array();
      init_factory();
      init_string();
      name241 = "inv";
      dependencies241 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
      createInv = /* @__PURE__ */ factory(name241, dependencies241, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divideScalar: divideScalar2,
          addScalar: addScalar2,
          multiply: multiply2,
          unaryMinus: unaryMinus2,
          det: det2,
          identity: identity2,
          abs: abs3
        } = _ref;
        return typed3(name241, {
          "Array | Matrix": function ArrayMatrix(x4) {
            var size2 = isMatrix(x4) ? x4.size() : arraySize(x4);
            switch (size2.length) {
              case 1:
                if (size2[0] === 1) {
                  if (isMatrix(x4)) {
                    return matrix2([divideScalar2(1, x4.valueOf()[0])]);
                  } else {
                    return [divideScalar2(1, x4[0])];
                  }
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
                }
              case 2: {
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  if (isMatrix(x4)) {
                    return matrix2(_inv(x4.valueOf(), rows, cols), x4.storage());
                  } else {
                    return _inv(x4, rows, cols);
                  }
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
            }
          },
          any: function any(x4) {
            return divideScalar2(1, x4);
          }
        });
        function _inv(mat, rows, cols) {
          var r3, s3, f3, value, temp;
          if (rows === 1) {
            value = mat[0][0];
            if (value === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            return [[divideScalar2(1, value)]];
          } else if (rows === 2) {
            var d3 = det2(mat);
            if (d3 === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            return [[divideScalar2(mat[1][1], d3), divideScalar2(unaryMinus2(mat[0][1]), d3)], [divideScalar2(unaryMinus2(mat[1][0]), d3), divideScalar2(mat[0][0], d3)]];
          } else {
            var A4 = mat.concat();
            for (r3 = 0; r3 < rows; r3++) {
              A4[r3] = A4[r3].concat();
            }
            var B4 = identity2(rows).valueOf();
            for (var c3 = 0; c3 < cols; c3++) {
              var ABig = abs3(A4[c3][c3]);
              var rBig = c3;
              r3 = c3 + 1;
              while (r3 < rows) {
                if (abs3(A4[r3][c3]) > ABig) {
                  ABig = abs3(A4[r3][c3]);
                  rBig = r3;
                }
                r3++;
              }
              if (ABig === 0) {
                throw Error("Cannot calculate inverse, determinant is zero");
              }
              r3 = rBig;
              if (r3 !== c3) {
                temp = A4[c3];
                A4[c3] = A4[r3];
                A4[r3] = temp;
                temp = B4[c3];
                B4[c3] = B4[r3];
                B4[r3] = temp;
              }
              var Ac = A4[c3];
              var Bc = B4[c3];
              for (r3 = 0; r3 < rows; r3++) {
                var Ar = A4[r3];
                var Br = B4[r3];
                if (r3 !== c3) {
                  if (Ar[c3] !== 0) {
                    f3 = divideScalar2(unaryMinus2(Ar[c3]), Ac[c3]);
                    for (s3 = c3; s3 < cols; s3++) {
                      Ar[s3] = addScalar2(Ar[s3], multiply2(f3, Ac[s3]));
                    }
                    for (s3 = 0; s3 < cols; s3++) {
                      Br[s3] = addScalar2(Br[s3], multiply2(f3, Bc[s3]));
                    }
                  }
                } else {
                  f3 = Ac[c3];
                  for (s3 = c3; s3 < cols; s3++) {
                    Ar[s3] = divideScalar2(Ar[s3], f3);
                  }
                  for (s3 = 0; s3 < cols; s3++) {
                    Br[s3] = divideScalar2(Br[s3], f3);
                  }
                }
              }
            }
            return B4;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/pinv.js
  var name242, dependencies242, createPinv;
  var init_pinv2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/pinv.js"() {
      init_is();
      init_array();
      init_factory();
      init_string();
      init_object();
      name242 = "pinv";
      dependencies242 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
      createPinv = /* @__PURE__ */ factory(name242, dependencies242, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          inv: inv2,
          deepEqual: deepEqual2,
          equal: equal2,
          dotDivide: dotDivide2,
          dot: dot2,
          ctranspose: ctranspose2,
          divideScalar: divideScalar2,
          multiply: multiply2,
          add: add3,
          Complex: Complex3
        } = _ref;
        return typed3(name242, {
          "Array | Matrix": function ArrayMatrix(x4) {
            var size2 = isMatrix(x4) ? x4.size() : arraySize(x4);
            switch (size2.length) {
              case 1:
                if (_isZeros(x4))
                  return ctranspose2(x4);
                if (size2[0] === 1) {
                  return inv2(x4);
                } else {
                  return dotDivide2(ctranspose2(x4), dot2(x4, x4));
                }
              case 2: {
                if (_isZeros(x4))
                  return ctranspose2(x4);
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  try {
                    return inv2(x4);
                  } catch (err) {
                    if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                    } else {
                      throw err;
                    }
                  }
                }
                if (isMatrix(x4)) {
                  return matrix2(_pinv(x4.valueOf(), rows, cols), x4.storage());
                } else {
                  return _pinv(x4, rows, cols);
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
            }
          },
          any: function any(x4) {
            if (equal2(x4, 0))
              return clone(x4);
            return divideScalar2(1, x4);
          }
        });
        function _pinv(mat, rows, cols) {
          var {
            C: C3,
            F: F4
          } = _rankFact(mat, rows, cols);
          var Cpinv = multiply2(inv2(multiply2(ctranspose2(C3), C3)), ctranspose2(C3));
          var Fpinv = multiply2(ctranspose2(F4), inv2(multiply2(F4, ctranspose2(F4))));
          return multiply2(Fpinv, Cpinv);
        }
        function _rref(mat, rows, cols) {
          var M3 = clone(mat);
          var lead = 0;
          for (var r3 = 0; r3 < rows; r3++) {
            if (cols <= lead) {
              return M3;
            }
            var i5 = r3;
            while (_isZero(M3[i5][lead])) {
              i5++;
              if (rows === i5) {
                i5 = r3;
                lead++;
                if (cols === lead) {
                  return M3;
                }
              }
            }
            [M3[i5], M3[r3]] = [M3[r3], M3[i5]];
            var val = M3[r3][lead];
            for (var j4 = 0; j4 < cols; j4++) {
              M3[r3][j4] = dotDivide2(M3[r3][j4], val);
            }
            for (var _i = 0; _i < rows; _i++) {
              if (_i === r3)
                continue;
              val = M3[_i][lead];
              for (var _j = 0; _j < cols; _j++) {
                M3[_i][_j] = add3(M3[_i][_j], multiply2(-1, multiply2(val, M3[r3][_j])));
              }
            }
            lead++;
          }
          return M3;
        }
        function _rankFact(mat, rows, cols) {
          var rref = _rref(mat, rows, cols);
          var C3 = mat.map((_3, i5) => _3.filter((_4, j4) => j4 < rows && !_isZero(dot2(rref[j4], rref[j4]))));
          var F4 = rref.filter((_3, i5) => !_isZero(dot2(rref[i5], rref[i5])));
          return {
            C: C3,
            F: F4
          };
        }
        function _isZero(x4) {
          return equal2(add3(x4, Complex3(1, 1)), add3(0, Complex3(1, 1)));
        }
        function _isZeros(arr) {
          return deepEqual2(add3(arr, Complex3(1, 1)), add3(multiply2(arr, 0), Complex3(1, 1)));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
  function createComplexEigs(_ref) {
    var {
      addScalar: addScalar2,
      subtract: subtract2,
      flatten: flatten3,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      sqrt: sqrt3,
      abs: abs3,
      bignumber: bignumber2,
      diag: diag2,
      inv: inv2,
      qr: qr2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      equal: equal2,
      complex: complex2,
      larger: larger2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    } = _ref;
    function complexEigs(arr, N3, prec, type, findVectors) {
      if (findVectors === void 0) {
        findVectors = true;
      }
      var R2 = balance(arr, N3, prec, type, findVectors);
      reduceToHessenberg(arr, N3, prec, type, findVectors, R2);
      var {
        values,
        C: C3
      } = iterateUntilTriangular(arr, N3, prec, type, findVectors);
      var vectors;
      if (findVectors) {
        vectors = findEigenvectors(arr, N3, C3, R2, values, prec, type);
        vectors = matrixFromColumns2(...vectors);
      }
      return {
        values,
        vectors
      };
    }
    function balance(arr, N3, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var realzero = big ? bignumber2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var realone = big ? bignumber2(1) : 1;
      var radix = big ? bignumber2(10) : 2;
      var radixSq = multiplyScalar2(radix, radix);
      var Rdiag;
      if (findVectors) {
        Rdiag = Array(N3).fill(one);
      }
      var last = false;
      while (!last) {
        last = true;
        for (var i5 = 0; i5 < N3; i5++) {
          var colNorm = realzero;
          var rowNorm = realzero;
          for (var j4 = 0; j4 < N3; j4++) {
            if (i5 === j4)
              continue;
            var c3 = abs3(arr[i5][j4]);
            colNorm = addScalar2(colNorm, c3);
            rowNorm = addScalar2(rowNorm, c3);
          }
          if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
            var f3 = realone;
            var _c = colNorm;
            var rowDivRadix = divideScalar2(rowNorm, radix);
            var rowMulRadix = multiplyScalar2(rowNorm, radix);
            while (smaller2(_c, rowDivRadix)) {
              _c = multiplyScalar2(_c, radixSq);
              f3 = multiplyScalar2(f3, radix);
            }
            while (larger2(_c, rowMulRadix)) {
              _c = divideScalar2(_c, radixSq);
              f3 = divideScalar2(f3, radix);
            }
            var condition = smaller2(divideScalar2(addScalar2(_c, rowNorm), f3), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
            if (condition) {
              last = false;
              var g4 = divideScalar2(1, f3);
              for (var _j = 0; _j < N3; _j++) {
                if (i5 === _j) {
                  continue;
                }
                arr[i5][_j] = multiplyScalar2(arr[i5][_j], f3);
                arr[_j][i5] = multiplyScalar2(arr[_j][i5], g4);
              }
              if (findVectors) {
                Rdiag[i5] = multiplyScalar2(Rdiag[i5], f3);
              }
            }
          }
        }
      }
      return diag2(Rdiag);
    }
    function reduceToHessenberg(arr, N3, prec, type, findVectors, R2) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      if (big) {
        prec = bignumber2(prec);
      }
      for (var i5 = 0; i5 < N3 - 2; i5++) {
        var maxIndex = 0;
        var max3 = zero;
        for (var j4 = i5 + 1; j4 < N3; j4++) {
          var el = arr[j4][i5];
          if (smaller2(abs3(max3), abs3(el))) {
            max3 = el;
            maxIndex = j4;
          }
        }
        if (smaller2(abs3(max3), prec)) {
          continue;
        }
        if (maxIndex !== i5 + 1) {
          var tmp1 = arr[maxIndex];
          arr[maxIndex] = arr[i5 + 1];
          arr[i5 + 1] = tmp1;
          for (var _j2 = 0; _j2 < N3; _j2++) {
            var tmp2 = arr[_j2][maxIndex];
            arr[_j2][maxIndex] = arr[_j2][i5 + 1];
            arr[_j2][i5 + 1] = tmp2;
          }
          if (findVectors) {
            var tmp3 = R2[maxIndex];
            R2[maxIndex] = R2[i5 + 1];
            R2[i5 + 1] = tmp3;
          }
        }
        for (var _j3 = i5 + 2; _j3 < N3; _j3++) {
          var n3 = divideScalar2(arr[_j3][i5], max3);
          if (n3 === 0) {
            continue;
          }
          for (var k4 = 0; k4 < N3; k4++) {
            arr[_j3][k4] = subtract2(arr[_j3][k4], multiplyScalar2(n3, arr[i5 + 1][k4]));
          }
          for (var _k = 0; _k < N3; _k++) {
            arr[_k][i5 + 1] = addScalar2(arr[_k][i5 + 1], multiplyScalar2(n3, arr[_k][_j3]));
          }
          if (findVectors) {
            for (var _k2 = 0; _k2 < N3; _k2++) {
              R2[_j3][_k2] = subtract2(R2[_j3][_k2], multiplyScalar2(n3, R2[i5 + 1][_k2]));
            }
          }
        }
      }
      return R2;
    }
    function iterateUntilTriangular(A4, N3, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (big) {
        prec = bignumber2(prec);
      }
      var arr = clone(A4);
      var lambdas = [];
      var n3 = N3;
      var Sdiag = [];
      var Qtotal = findVectors ? diag2(Array(N3).fill(one)) : void 0;
      var Qpartial = findVectors ? diag2(Array(n3).fill(one)) : void 0;
      var lastConvergenceBefore = 0;
      while (lastConvergenceBefore <= 100) {
        lastConvergenceBefore += 1;
        var k4 = 0;
        for (var i5 = 0; i5 < n3; i5++) {
          arr[i5][i5] = subtract2(arr[i5][i5], k4);
        }
        var {
          Q: Q3,
          R: R2
        } = qr2(arr);
        arr = multiply2(R2, Q3);
        for (var _i = 0; _i < n3; _i++) {
          arr[_i][_i] = addScalar2(arr[_i][_i], k4);
        }
        if (findVectors) {
          Qpartial = multiply2(Qpartial, Q3);
        }
        if (n3 === 1 || smaller2(abs3(arr[n3 - 1][n3 - 2]), prec)) {
          lastConvergenceBefore = 0;
          lambdas.push(arr[n3 - 1][n3 - 1]);
          if (findVectors) {
            Sdiag.unshift([[1]]);
            inflateMatrix(Qpartial, N3);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n3 > 1) {
              Qpartial = diag2(Array(n3 - 1).fill(one));
            }
          }
          n3 -= 1;
          arr.pop();
          for (var _i2 = 0; _i2 < n3; _i2++) {
            arr[_i2].pop();
          }
        } else if (n3 === 2 || smaller2(abs3(arr[n3 - 2][n3 - 3]), prec)) {
          lastConvergenceBefore = 0;
          var ll = eigenvalues2x2(arr[n3 - 2][n3 - 2], arr[n3 - 2][n3 - 1], arr[n3 - 1][n3 - 2], arr[n3 - 1][n3 - 1]);
          lambdas.push(...ll);
          if (findVectors) {
            Sdiag.unshift(jordanBase2x2(arr[n3 - 2][n3 - 2], arr[n3 - 2][n3 - 1], arr[n3 - 1][n3 - 2], arr[n3 - 1][n3 - 1], ll[0], ll[1], prec, type));
            inflateMatrix(Qpartial, N3);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n3 > 2) {
              Qpartial = diag2(Array(n3 - 2).fill(one));
            }
          }
          n3 -= 2;
          arr.pop();
          arr.pop();
          for (var _i3 = 0; _i3 < n3; _i3++) {
            arr[_i3].pop();
            arr[_i3].pop();
          }
        }
        if (n3 === 0) {
          break;
        }
      }
      lambdas.sort((a3, b3) => +subtract2(abs3(a3), abs3(b3)));
      if (lastConvergenceBefore > 100) {
        var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
        err.values = lambdas;
        err.vectors = [];
        throw err;
      }
      var C3 = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N3)) : void 0;
      return {
        values: lambdas,
        C: C3
      };
    }
    function findEigenvectors(A4, N3, C3, R2, values, prec, type) {
      var Cinv = inv2(C3);
      var U2 = multiply2(Cinv, A4, C3);
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var uniqueValues = [];
      var multiplicities = [];
      for (var \u03BB of values) {
        var i5 = indexOf(uniqueValues, \u03BB, equal2);
        if (i5 === -1) {
          uniqueValues.push(\u03BB);
          multiplicities.push(1);
        } else {
          multiplicities[i5] += 1;
        }
      }
      var vectors = [];
      var len = uniqueValues.length;
      var b3 = Array(N3).fill(zero);
      var E3 = diag2(Array(N3).fill(one));
      var failedLambdas = [];
      var _loop = function _loop2() {
        var \u03BB2 = uniqueValues[_i4];
        var S2 = subtract2(U2, multiply2(\u03BB2, E3));
        var solutions = usolveAll2(S2, b3);
        solutions.shift();
        while (solutions.length < multiplicities[_i4]) {
          var approxVec = inverseIterate(S2, N3, solutions, prec, type);
          if (approxVec == null) {
            failedLambdas.push(\u03BB2);
            break;
          }
          solutions.push(approxVec);
        }
        var correction = multiply2(inv2(R2), C3);
        solutions = solutions.map((v3) => multiply2(correction, v3));
        vectors.push(...solutions.map((v3) => flatten3(v3)));
      };
      for (var _i4 = 0; _i4 < len; _i4++) {
        _loop();
      }
      if (failedLambdas.length !== 0) {
        var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
        err.values = values;
        err.vectors = vectors;
        throw err;
      }
      return vectors;
    }
    function eigenvalues2x2(a3, b3, c3, d3) {
      var trA = addScalar2(a3, d3);
      var detA = subtract2(multiplyScalar2(a3, d3), multiplyScalar2(b3, c3));
      var x4 = multiplyScalar2(trA, 0.5);
      var y3 = multiplyScalar2(sqrt3(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
      return [addScalar2(x4, y3), subtract2(x4, y3)];
    }
    function jordanBase2x2(a3, b3, c3, d3, l1, l22, prec, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (smaller2(abs3(c3), prec)) {
        return [[one, zero], [zero, one]];
      }
      if (larger2(abs3(subtract2(l1, l22)), prec)) {
        return [[subtract2(l1, d3), subtract2(l22, d3)], [c3, c3]];
      }
      var na = subtract2(a3, l1);
      var nb = subtract2(b3, l1);
      var nc = subtract2(c3, l1);
      var nd = subtract2(d3, l1);
      if (smaller2(abs3(nb), prec)) {
        return [[na, one], [nc, zero]];
      } else {
        return [[nb, zero], [nd, one]];
      }
    }
    function inflateMatrix(arr, N3) {
      for (var i5 = 0; i5 < arr.length; i5++) {
        arr[i5].push(...Array(N3 - arr[i5].length).fill(0));
      }
      for (var _i5 = arr.length; _i5 < N3; _i5++) {
        arr.push(Array(N3).fill(0));
        arr[_i5][_i5] = 1;
      }
      return arr;
    }
    function blockDiag(arr, N3) {
      var M3 = [];
      for (var i5 = 0; i5 < N3; i5++) {
        M3[i5] = Array(N3).fill(0);
      }
      var I3 = 0;
      for (var sub2 of arr) {
        var n3 = sub2.length;
        for (var _i6 = 0; _i6 < n3; _i6++) {
          for (var j4 = 0; j4 < n3; j4++) {
            M3[I3 + _i6][I3 + j4] = sub2[_i6][j4];
          }
        }
        I3 += n3;
      }
      return M3;
    }
    function indexOf(arr, el, fn2) {
      for (var i5 = 0; i5 < arr.length; i5++) {
        if (fn2(arr[i5], el)) {
          return i5;
        }
      }
      return -1;
    }
    function inverseIterate(A4, N3, orthog, prec, type) {
      var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
      var b3;
      var i5 = 0;
      while (true) {
        b3 = randomOrthogonalVector(N3, orthog, type);
        b3 = usolve2(A4, b3);
        if (larger2(norm2(b3), largeNum)) {
          break;
        }
        if (++i5 >= 5) {
          return null;
        }
      }
      i5 = 0;
      while (true) {
        var c3 = usolve2(A4, b3);
        if (smaller2(norm2(orthogonalComplement(b3, [c3])), prec)) {
          break;
        }
        if (++i5 >= 10) {
          return null;
        }
        b3 = normalize(c3);
      }
      return b3;
    }
    function randomOrthogonalVector(N3, orthog, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var v3 = Array(N3).fill(0).map((_3) => 2 * Math.random() - 1);
      if (big) {
        v3 = v3.map((n3) => bignumber2(n3));
      }
      if (cplx) {
        v3 = v3.map((n3) => complex2(n3));
      }
      v3 = orthogonalComplement(v3, orthog);
      return normalize(v3, type);
    }
    function orthogonalComplement(v3, orthog) {
      for (var w4 of orthog) {
        v3 = subtract2(v3, multiply2(divideScalar2(dot2(w4, v3), dot2(w4, w4)), w4));
      }
      return v3;
    }
    function norm2(v3) {
      return abs3(sqrt3(dot2(v3, v3)));
    }
    function normalize(v3, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      return multiply2(divideScalar2(one, norm2(v3)), v3);
    }
    return complexEigs;
  }
  var init_complexEigs = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"() {
      init_object();
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
  function createRealSymmetric(_ref) {
    var {
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      abs: abs3,
      atan: atan4,
      cos: cos3,
      sin: sin3,
      multiplyScalar: multiplyScalar2,
      inv: inv2,
      bignumber: bignumber2,
      multiply: multiply2,
      add: add3
    } = _ref;
    function main(arr, N3) {
      var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config4.epsilon;
      var type = arguments.length > 3 ? arguments[3] : void 0;
      if (type === "number") {
        return diag2(arr, prec);
      }
      if (type === "BigNumber") {
        return diagBig(arr, prec);
      }
      throw TypeError("Unsupported data type: " + type);
    }
    function diag2(x4, precision) {
      var N3 = x4.length;
      var e0 = Math.abs(precision / N3);
      var psi;
      var Sij = new Array(N3);
      for (var i5 = 0; i5 < N3; i5++) {
        Sij[i5] = createArray(N3, 0);
        Sij[i5][i5] = 1;
      }
      var Vab = getAij(x4);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j4 = Vab[0][1];
        psi = getTheta(x4[_i][_i], x4[j4][j4], x4[_i][j4]);
        x4 = x1(x4, psi, _i, j4);
        Sij = Sij1(Sij, psi, _i, j4);
        Vab = getAij(x4);
      }
      var Ei = createArray(N3, 0);
      for (var _i2 = 0; _i2 < N3; _i2++) {
        Ei[_i2] = x4[_i2][_i2];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function diagBig(x4, precision) {
      var N3 = x4.length;
      var e0 = abs3(precision / N3);
      var psi;
      var Sij = new Array(N3);
      for (var i5 = 0; i5 < N3; i5++) {
        Sij[i5] = createArray(N3, 0);
        Sij[i5][i5] = 1;
      }
      var Vab = getAijBig(x4);
      while (abs3(Vab[1]) >= abs3(e0)) {
        var _i3 = Vab[0][0];
        var j4 = Vab[0][1];
        psi = getThetaBig(x4[_i3][_i3], x4[j4][j4], x4[_i3][j4]);
        x4 = x1Big(x4, psi, _i3, j4);
        Sij = Sij1Big(Sij, psi, _i3, j4);
        Vab = getAijBig(x4);
      }
      var Ei = createArray(N3, 0);
      for (var _i4 = 0; _i4 < N3; _i4++) {
        Ei[_i4] = x4[_i4][_i4];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config4.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    }
    function getThetaBig(aii, ajj, aij) {
      var denom = subtract2(ajj, aii);
      if (abs3(denom) <= config4.epsilon) {
        return bignumber2(-1).acos().div(4);
      } else {
        return multiplyScalar2(0.5, atan4(multiply2(2, aij, inv2(denom))));
      }
    }
    function Sij1(Sij, theta, i5, j4) {
      var N3 = Sij.length;
      var c3 = Math.cos(theta);
      var s3 = Math.sin(theta);
      var Ski = createArray(N3, 0);
      var Skj = createArray(N3, 0);
      for (var k4 = 0; k4 < N3; k4++) {
        Ski[k4] = c3 * Sij[k4][i5] - s3 * Sij[k4][j4];
        Skj[k4] = s3 * Sij[k4][i5] + c3 * Sij[k4][j4];
      }
      for (var _k = 0; _k < N3; _k++) {
        Sij[_k][i5] = Ski[_k];
        Sij[_k][j4] = Skj[_k];
      }
      return Sij;
    }
    function Sij1Big(Sij, theta, i5, j4) {
      var N3 = Sij.length;
      var c3 = cos3(theta);
      var s3 = sin3(theta);
      var Ski = createArray(N3, bignumber2(0));
      var Skj = createArray(N3, bignumber2(0));
      for (var k4 = 0; k4 < N3; k4++) {
        Ski[k4] = subtract2(multiplyScalar2(c3, Sij[k4][i5]), multiplyScalar2(s3, Sij[k4][j4]));
        Skj[k4] = addScalar2(multiplyScalar2(s3, Sij[k4][i5]), multiplyScalar2(c3, Sij[k4][j4]));
      }
      for (var _k2 = 0; _k2 < N3; _k2++) {
        Sij[_k2][i5] = Ski[_k2];
        Sij[_k2][j4] = Skj[_k2];
      }
      return Sij;
    }
    function x1Big(Hij, theta, i5, j4) {
      var N3 = Hij.length;
      var c3 = bignumber2(cos3(theta));
      var s3 = bignumber2(sin3(theta));
      var c22 = multiplyScalar2(c3, c3);
      var s22 = multiplyScalar2(s3, s3);
      var Aki = createArray(N3, bignumber2(0));
      var Akj = createArray(N3, bignumber2(0));
      var csHij = multiply2(bignumber2(2), c3, s3, Hij[i5][j4]);
      var Aii = addScalar2(subtract2(multiplyScalar2(c22, Hij[i5][i5]), csHij), multiplyScalar2(s22, Hij[j4][j4]));
      var Ajj = add3(multiplyScalar2(s22, Hij[i5][i5]), csHij, multiplyScalar2(c22, Hij[j4][j4]));
      for (var k4 = 0; k4 < N3; k4++) {
        Aki[k4] = subtract2(multiplyScalar2(c3, Hij[i5][k4]), multiplyScalar2(s3, Hij[j4][k4]));
        Akj[k4] = addScalar2(multiplyScalar2(s3, Hij[i5][k4]), multiplyScalar2(c3, Hij[j4][k4]));
      }
      Hij[i5][i5] = Aii;
      Hij[j4][j4] = Ajj;
      Hij[i5][j4] = bignumber2(0);
      Hij[j4][i5] = bignumber2(0);
      for (var _k3 = 0; _k3 < N3; _k3++) {
        if (_k3 !== i5 && _k3 !== j4) {
          Hij[i5][_k3] = Aki[_k3];
          Hij[_k3][i5] = Aki[_k3];
          Hij[j4][_k3] = Akj[_k3];
          Hij[_k3][j4] = Akj[_k3];
        }
      }
      return Hij;
    }
    function x1(Hij, theta, i5, j4) {
      var N3 = Hij.length;
      var c3 = Math.cos(theta);
      var s3 = Math.sin(theta);
      var c22 = c3 * c3;
      var s22 = s3 * s3;
      var Aki = createArray(N3, 0);
      var Akj = createArray(N3, 0);
      var Aii = c22 * Hij[i5][i5] - 2 * c3 * s3 * Hij[i5][j4] + s22 * Hij[j4][j4];
      var Ajj = s22 * Hij[i5][i5] + 2 * c3 * s3 * Hij[i5][j4] + c22 * Hij[j4][j4];
      for (var k4 = 0; k4 < N3; k4++) {
        Aki[k4] = c3 * Hij[i5][k4] - s3 * Hij[j4][k4];
        Akj[k4] = s3 * Hij[i5][k4] + c3 * Hij[j4][k4];
      }
      Hij[i5][i5] = Aii;
      Hij[j4][j4] = Ajj;
      Hij[i5][j4] = 0;
      Hij[j4][i5] = 0;
      for (var _k4 = 0; _k4 < N3; _k4++) {
        if (_k4 !== i5 && _k4 !== j4) {
          Hij[i5][_k4] = Aki[_k4];
          Hij[_k4][i5] = Aki[_k4];
          Hij[j4][_k4] = Akj[_k4];
          Hij[_k4][j4] = Akj[_k4];
        }
      }
      return Hij;
    }
    function getAij(Mij) {
      var N3 = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i5 = 0; i5 < N3; i5++) {
        for (var j4 = i5 + 1; j4 < N3; j4++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i5][j4])) {
            maxMij = Math.abs(Mij[i5][j4]);
            maxIJ = [i5, j4];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function getAijBig(Mij) {
      var N3 = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i5 = 0; i5 < N3; i5++) {
        for (var j4 = i5 + 1; j4 < N3; j4++) {
          if (abs3(maxMij) < abs3(Mij[i5][j4])) {
            maxMij = abs3(Mij[i5][j4]);
            maxIJ = [i5, j4];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function sorting(E3, S2) {
      var N3 = E3.length;
      var values = Array(N3);
      var vectors = Array(N3);
      for (var k4 = 0; k4 < N3; k4++) {
        vectors[k4] = Array(N3);
      }
      for (var i5 = 0; i5 < N3; i5++) {
        var minID = 0;
        var minE = E3[0];
        for (var j4 = 0; j4 < E3.length; j4++) {
          if (abs3(E3[j4]) < abs3(minE)) {
            minID = j4;
            minE = E3[minID];
          }
        }
        values[i5] = E3.splice(minID, 1)[0];
        for (var _k5 = 0; _k5 < N3; _k5++) {
          vectors[_k5][i5] = S2[_k5][minID];
          S2[_k5].splice(minID, 1);
        }
      }
      return {
        values,
        vectors
      };
    }
    function createArray(size2, value) {
      var array = new Array(size2);
      for (var i5 = 0; i5 < size2; i5++) {
        array[i5] = value;
      }
      return array;
    }
    return main;
  }
  var init_realSymetric = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js"() {
      init_object();
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs.js
  var name243, dependencies243, createEigs;
  var init_eigs2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/eigs.js"() {
      init_factory();
      init_string();
      init_complexEigs();
      init_realSymetric();
      init_is();
      name243 = "eigs";
      dependencies243 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
      createEigs = /* @__PURE__ */ factory(name243, dependencies243, (_ref) => {
        var {
          config: config4,
          typed: typed3,
          matrix: matrix2,
          addScalar: addScalar2,
          subtract: subtract2,
          equal: equal2,
          abs: abs3,
          atan: atan4,
          cos: cos3,
          sin: sin3,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          inv: inv2,
          bignumber: bignumber2,
          multiply: multiply2,
          add: add3,
          larger: larger2,
          column: column2,
          flatten: flatten3,
          number: number2,
          complex: complex2,
          sqrt: sqrt3,
          diag: diag2,
          qr: qr2,
          usolve: usolve2,
          usolveAll: usolveAll2,
          im: im2,
          re: re2,
          smaller: smaller2,
          matrixFromColumns: matrixFromColumns2,
          dot: dot2
        } = _ref;
        var doRealSymetric = createRealSymmetric({
          config: config4,
          addScalar: addScalar2,
          subtract: subtract2,
          column: column2,
          flatten: flatten3,
          equal: equal2,
          abs: abs3,
          atan: atan4,
          cos: cos3,
          sin: sin3,
          multiplyScalar: multiplyScalar2,
          inv: inv2,
          bignumber: bignumber2,
          complex: complex2,
          multiply: multiply2,
          add: add3
        });
        var doComplexEigs = createComplexEigs({
          config: config4,
          addScalar: addScalar2,
          subtract: subtract2,
          multiply: multiply2,
          multiplyScalar: multiplyScalar2,
          flatten: flatten3,
          divideScalar: divideScalar2,
          sqrt: sqrt3,
          abs: abs3,
          bignumber: bignumber2,
          diag: diag2,
          qr: qr2,
          inv: inv2,
          usolve: usolve2,
          usolveAll: usolveAll2,
          equal: equal2,
          complex: complex2,
          larger: larger2,
          smaller: smaller2,
          matrixFromColumns: matrixFromColumns2,
          dot: dot2
        });
        return typed3("eigs", {
          Array: function Array2(x4) {
            var mat = matrix2(x4);
            return computeValuesAndVectors(mat);
          },
          "Array, number|BigNumber": function ArrayNumberBigNumber(x4, prec) {
            var mat = matrix2(x4);
            return computeValuesAndVectors(mat, prec);
          },
          Matrix: function Matrix2(mat) {
            var {
              values,
              vectors
            } = computeValuesAndVectors(mat);
            return {
              values: matrix2(values),
              vectors: matrix2(vectors)
            };
          },
          "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
            var {
              values,
              vectors
            } = computeValuesAndVectors(mat, prec);
            return {
              values: matrix2(values),
              vectors: matrix2(vectors)
            };
          }
        });
        function computeValuesAndVectors(mat, prec) {
          if (prec === void 0) {
            prec = config4.epsilon;
          }
          var size2 = mat.size();
          if (size2.length !== 2 || size2[0] !== size2[1]) {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
          var arr = mat.toArray();
          var N3 = size2[0];
          if (isReal(arr, N3, prec)) {
            coerceReal(arr, N3);
            if (isSymmetric(arr, N3, prec)) {
              var _type = coerceTypes(mat, arr, N3);
              return doRealSymetric(arr, N3, prec, _type);
            }
          }
          var type = coerceTypes(mat, arr, N3);
          return doComplexEigs(arr, N3, prec, type);
        }
        function isSymmetric(arr, N3, prec) {
          for (var i5 = 0; i5 < N3; i5++) {
            for (var j4 = i5; j4 < N3; j4++) {
              if (larger2(bignumber2(abs3(subtract2(arr[i5][j4], arr[j4][i5]))), prec)) {
                return false;
              }
            }
          }
          return true;
        }
        function isReal(arr, N3, prec) {
          for (var i5 = 0; i5 < N3; i5++) {
            for (var j4 = 0; j4 < N3; j4++) {
              if (larger2(bignumber2(abs3(im2(arr[i5][j4]))), prec)) {
                return false;
              }
            }
          }
          return true;
        }
        function coerceReal(arr, N3) {
          for (var i5 = 0; i5 < N3; i5++) {
            for (var j4 = 0; j4 < N3; j4++) {
              arr[i5][j4] = re2(arr[i5][j4]);
            }
          }
        }
        function coerceTypes(mat, arr, N3) {
          var type = mat.datatype();
          if (type === "number" || type === "BigNumber" || type === "Complex") {
            return type;
          }
          var hasNumber = false;
          var hasBig = false;
          var hasComplex = false;
          for (var i5 = 0; i5 < N3; i5++) {
            for (var j4 = 0; j4 < N3; j4++) {
              var el = arr[i5][j4];
              if (isNumber(el) || isFraction(el)) {
                hasNumber = true;
              } else if (isBigNumber(el)) {
                hasBig = true;
              } else if (isComplex(el)) {
                hasComplex = true;
              } else {
                throw TypeError("Unsupported type in Matrix: " + typeOf(el));
              }
            }
          }
          if (hasBig && hasComplex) {
            console.warn("Complex BigNumbers not supported, this operation will lose precission.");
          }
          if (hasComplex) {
            for (var _i = 0; _i < N3; _i++) {
              for (var _j = 0; _j < N3; _j++) {
                arr[_i][_j] = complex2(arr[_i][_j]);
              }
            }
            return "Complex";
          }
          if (hasBig) {
            for (var _i2 = 0; _i2 < N3; _i2++) {
              for (var _j2 = 0; _j2 < N3; _j2++) {
                arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
              }
            }
            return "BigNumber";
          }
          if (hasNumber) {
            for (var _i3 = 0; _i3 < N3; _i3++) {
              for (var _j3 = 0; _j3 < N3; _j3++) {
                arr[_i3][_j3] = number2(arr[_i3][_j3]);
              }
            }
            return "number";
          } else {
            throw TypeError("Matrix contains unsupported types only.");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/expm.js
  var name244, dependencies244, createExpm;
  var init_expm2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/expm.js"() {
      init_is();
      init_string();
      init_factory();
      name244 = "expm";
      dependencies244 = ["typed", "abs", "add", "identity", "inv", "multiply"];
      createExpm = /* @__PURE__ */ factory(name244, dependencies244, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          add: add3,
          identity: identity2,
          inv: inv2,
          multiply: multiply2
        } = _ref;
        return typed3(name244, {
          Matrix: function Matrix2(A4) {
            var size2 = A4.size();
            if (size2.length !== 2 || size2[0] !== size2[1]) {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
            var n3 = size2[0];
            var eps = 1e-15;
            var infNorm = infinityNorm(A4);
            var params = findParams(infNorm, eps);
            var q4 = params.q;
            var j4 = params.j;
            var Apos = multiply2(A4, Math.pow(2, -j4));
            var N3 = identity2(n3);
            var D3 = identity2(n3);
            var factor = 1;
            var AposToI = Apos;
            var alternate = -1;
            for (var i5 = 1; i5 <= q4; i5++) {
              if (i5 > 1) {
                AposToI = multiply2(AposToI, Apos);
                alternate = -alternate;
              }
              factor = factor * (q4 - i5 + 1) / ((2 * q4 - i5 + 1) * i5);
              N3 = add3(N3, multiply2(factor, AposToI));
              D3 = add3(D3, multiply2(factor * alternate, AposToI));
            }
            var R2 = multiply2(inv2(D3), N3);
            for (var _i = 0; _i < j4; _i++) {
              R2 = multiply2(R2, R2);
            }
            return isSparseMatrix(A4) ? A4.createSparseMatrix(R2) : R2;
          }
        });
        function infinityNorm(A4) {
          var n3 = A4.size()[0];
          var infNorm = 0;
          for (var i5 = 0; i5 < n3; i5++) {
            var rowSum = 0;
            for (var j4 = 0; j4 < n3; j4++) {
              rowSum += abs3(A4.get([i5, j4]));
            }
            infNorm = Math.max(rowSum, infNorm);
          }
          return infNorm;
        }
        function findParams(infNorm, eps) {
          var maxSearchSize = 30;
          for (var k4 = 0; k4 < maxSearchSize; k4++) {
            for (var q4 = 0; q4 <= k4; q4++) {
              var j4 = k4 - q4;
              if (errorEstimate(infNorm, q4, j4) < eps) {
                return {
                  q: q4,
                  j: j4
                };
              }
            }
          }
          throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
        }
        function errorEstimate(infNorm, q4, j4) {
          var qfac = 1;
          for (var i5 = 2; i5 <= q4; i5++) {
            qfac *= i5;
          }
          var twoqfac = qfac;
          for (var _i2 = q4 + 1; _i2 <= 2 * q4; _i2++) {
            twoqfac *= _i2;
          }
          var twoqp1fac = twoqfac * (2 * q4 + 1);
          return 8 * Math.pow(infNorm / Math.pow(2, j4), 2 * q4) * qfac * qfac / (twoqfac * twoqp1fac);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
  var name245, dependencies245, createSqrtm;
  var init_sqrtm2 = __esm({
    "node_modules/mathjs/lib/esm/function/matrix/sqrtm.js"() {
      init_is();
      init_string();
      init_array();
      init_factory();
      name245 = "sqrtm";
      dependencies245 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
      createSqrtm = /* @__PURE__ */ factory(name245, dependencies245, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          add: add3,
          multiply: multiply2,
          map: map3,
          sqrt: sqrt3,
          subtract: subtract2,
          inv: inv2,
          size: size2,
          max: max3,
          identity: identity2
        } = _ref;
        var _maxIterations = 1e3;
        var _tolerance = 1e-6;
        function _denmanBeavers(A4) {
          var error;
          var iterations = 0;
          var Y2 = A4;
          var Z2 = identity2(size2(A4));
          do {
            var Yk = Y2;
            Y2 = multiply2(0.5, add3(Yk, inv2(Z2)));
            Z2 = multiply2(0.5, add3(Z2, inv2(Yk)));
            error = max3(abs3(subtract2(Y2, Yk)));
            if (error > _tolerance && ++iterations > _maxIterations) {
              throw new Error("computing square root of matrix: iterative method could not converge");
            }
          } while (error > _tolerance);
          return Y2;
        }
        return typed3(name245, {
          "Array | Matrix": function ArrayMatrix(A4) {
            var size3 = isMatrix(A4) ? A4.size() : arraySize(A4);
            switch (size3.length) {
              case 1:
                if (size3[0] === 1) {
                  return map3(A4, sqrt3);
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
                }
              case 2: {
                var rows = size3[0];
                var cols = size3[1];
                if (rows === cols) {
                  return _denmanBeavers(A4);
                } else {
                  throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size3) + ")");
            }
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sylvester.js
  var name246, dependencies246, createSylvester;
  var init_sylvester2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/sylvester.js"() {
      init_factory();
      name246 = "sylvester";
      dependencies246 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
      createSylvester = /* @__PURE__ */ factory(name246, dependencies246, (_ref) => {
        var {
          typed: typed3,
          schur: schur2,
          matrixFromColumns: matrixFromColumns2,
          matrix: matrix2,
          multiply: multiply2,
          range: range2,
          concat: concat3,
          transpose: transpose2,
          index: index2,
          subset: subset2,
          add: add3,
          subtract: subtract2,
          identity: identity2,
          lusolve: lusolve2,
          abs: abs3
        } = _ref;
        return typed3(name246, {
          "Matrix, Matrix, Matrix": _sylvester,
          "Array, Matrix, Matrix": function ArrayMatrixMatrix(A4, B4, C3) {
            return _sylvester(matrix2(A4), B4, C3);
          },
          "Array, Array, Matrix": function ArrayArrayMatrix(A4, B4, C3) {
            return _sylvester(matrix2(A4), matrix2(B4), C3);
          },
          "Array, Matrix, Array": function ArrayMatrixArray(A4, B4, C3) {
            return _sylvester(matrix2(A4), B4, matrix2(C3));
          },
          "Matrix, Array, Matrix": function MatrixArrayMatrix(A4, B4, C3) {
            return _sylvester(A4, matrix2(B4), C3);
          },
          "Matrix, Array, Array": function MatrixArrayArray(A4, B4, C3) {
            return _sylvester(A4, matrix2(B4), matrix2(C3));
          },
          "Matrix, Matrix, Array": function MatrixMatrixArray(A4, B4, C3) {
            return _sylvester(A4, B4, matrix2(C3));
          },
          "Array, Array, Array": function ArrayArrayArray(A4, B4, C3) {
            return _sylvester(matrix2(A4), matrix2(B4), matrix2(C3)).toArray();
          }
        });
        function _sylvester(A4, B4, C3) {
          var n3 = B4.size()[0];
          var m3 = A4.size()[0];
          var sA = schur2(A4);
          var F4 = sA.T;
          var U2 = sA.U;
          var sB = schur2(multiply2(-1, B4));
          var G2 = sB.T;
          var V3 = sB.U;
          var D3 = multiply2(multiply2(transpose2(U2), C3), V3);
          var all = range2(0, m3);
          var y3 = [];
          var hc = (a3, b3) => concat3(a3, b3, 1);
          var vc = (a3, b3) => concat3(a3, b3, 0);
          for (var k4 = 0; k4 < n3; k4++) {
            if (k4 < n3 - 1 && abs3(subset2(G2, index2(k4 + 1, k4))) > 1e-5) {
              var RHS = vc(subset2(D3, index2(all, k4)), subset2(D3, index2(all, k4 + 1)));
              for (var j4 = 0; j4 < k4; j4++) {
                RHS = add3(RHS, vc(multiply2(y3[j4], subset2(G2, index2(j4, k4))), multiply2(y3[j4], subset2(G2, index2(j4, k4 + 1)))));
              }
              var gkk = multiply2(identity2(m3), multiply2(-1, subset2(G2, index2(k4, k4))));
              var gmk = multiply2(identity2(m3), multiply2(-1, subset2(G2, index2(k4 + 1, k4))));
              var gkm = multiply2(identity2(m3), multiply2(-1, subset2(G2, index2(k4, k4 + 1))));
              var gmm = multiply2(identity2(m3), multiply2(-1, subset2(G2, index2(k4 + 1, k4 + 1))));
              var LHS = vc(hc(add3(F4, gkk), gmk), hc(gkm, add3(F4, gmm)));
              var yAux = lusolve2(LHS, RHS);
              y3[k4] = yAux.subset(index2(range2(0, m3), 0));
              y3[k4 + 1] = yAux.subset(index2(range2(m3, 2 * m3), 0));
              k4++;
            } else {
              var _RHS = subset2(D3, index2(all, k4));
              for (var _j = 0; _j < k4; _j++) {
                _RHS = add3(_RHS, multiply2(y3[_j], subset2(G2, index2(_j, k4))));
              }
              var _gkk = subset2(G2, index2(k4, k4));
              var _LHS = subtract2(F4, multiply2(_gkk, identity2(m3)));
              y3[k4] = lusolve2(_LHS, _RHS);
            }
          }
          var Y2 = matrix2(matrixFromColumns2(...y3));
          var X2 = multiply2(U2, multiply2(Y2, transpose2(V3)));
          return X2;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
  var name247, dependencies247, createSchur;
  var init_schur2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js"() {
      init_factory();
      name247 = "schur";
      dependencies247 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
      createSchur = /* @__PURE__ */ factory(name247, dependencies247, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          identity: identity2,
          multiply: multiply2,
          qr: qr2,
          norm: norm2,
          subtract: subtract2
        } = _ref;
        return typed3(name247, {
          Array: function Array2(X2) {
            var r3 = _schur(matrix2(X2));
            return {
              U: r3.U.valueOf(),
              T: r3.T.valueOf()
            };
          },
          Matrix: function Matrix2(X2) {
            return _schur(X2);
          }
        });
        function _schur(X2) {
          var n3 = X2.size()[0];
          var A4 = X2;
          var U2 = identity2(n3);
          var k4 = 0;
          var A0;
          do {
            A0 = A4;
            var QR = qr2(A4);
            var Q3 = QR.Q;
            var R2 = QR.R;
            A4 = multiply2(R2, Q3);
            U2 = multiply2(U2, Q3);
            if (k4++ > 100) {
              break;
            }
          } while (norm2(subtract2(A4, A0)) > 1e-4);
          return {
            U: U2,
            T: A4
          };
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/lyap.js
  var name248, dependencies248, createLyap;
  var init_lyap2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/lyap.js"() {
      init_factory();
      name248 = "lyap";
      dependencies248 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
      createLyap = /* @__PURE__ */ factory(name248, dependencies248, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          sylvester: sylvester2,
          multiply: multiply2,
          transpose: transpose2
        } = _ref;
        return typed3(name248, {
          "Matrix, Matrix": function MatrixMatrix(A4, Q3) {
            return sylvester2(A4, transpose2(A4), multiply2(-1, Q3));
          },
          "Array, Matrix": function ArrayMatrix(A4, Q3) {
            return sylvester2(matrix2(A4), transpose2(matrix2(A4)), multiply2(-1, Q3));
          },
          "Matrix, Array": function MatrixArray(A4, Q3) {
            return sylvester2(A4, transpose2(matrix2(A4)), matrix2(multiply2(-1, Q3)));
          },
          "Array, Array": function ArrayArray(A4, Q3) {
            return sylvester2(matrix2(A4), transpose2(matrix2(A4)), matrix2(multiply2(-1, Q3))).toArray();
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divide.js
  var name249, dependencies249, createDivide;
  var init_divide2 = __esm({
    "node_modules/mathjs/lib/esm/function/arithmetic/divide.js"() {
      init_factory();
      init_object();
      init_matAlgo11xS0s();
      init_matAlgo14xDs();
      name249 = "divide";
      dependencies249 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
      createDivide = /* @__PURE__ */ factory(name249, dependencies249, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          multiply: multiply2,
          equalScalar: equalScalar2,
          divideScalar: divideScalar2,
          inv: inv2
        } = _ref;
        var matAlgo11xS0s = createMatAlgo11xS0s({
          typed: typed3,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = createMatAlgo14xDs({
          typed: typed3
        });
        return typed3("divide", extend({
          // we extend the signatures of divideScalar with signatures dealing with matrices
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x4, y3) {
            return multiply2(x4, inv2(y3));
          },
          "DenseMatrix, any": function DenseMatrixAny(x4, y3) {
            return matAlgo14xDs(x4, y3, divideScalar2, false);
          },
          "SparseMatrix, any": function SparseMatrixAny(x4, y3) {
            return matAlgo11xS0s(x4, y3, divideScalar2, false);
          },
          "Array, any": function ArrayAny(x4, y3) {
            return matAlgo14xDs(matrix2(x4), y3, divideScalar2, false).valueOf();
          },
          "any, Array | Matrix": function anyArrayMatrix(x4, y3) {
            return multiply2(x4, inv2(y3));
          }
        }, divideScalar2.signatures));
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/geometry/distance.js
  var name250, dependencies250, createDistance;
  var init_distance2 = __esm({
    "node_modules/mathjs/lib/esm/function/geometry/distance.js"() {
      init_is();
      init_factory();
      name250 = "distance";
      dependencies250 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
      createDistance = /* @__PURE__ */ factory(name250, dependencies250, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          subtract: subtract2,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          deepEqual: deepEqual2,
          sqrt: sqrt3,
          abs: abs3
        } = _ref;
        return typed3(name250, {
          "Array, Array, Array": function ArrayArrayArray(x4, y3, z5) {
            if (x4.length === 2 && y3.length === 2 && z5.length === 2) {
              if (!_2d(x4)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
              }
              if (!_2d(y3)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
              }
              if (!_2d(z5)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
              }
              if (deepEqual2(y3, z5)) {
                throw new TypeError("LinePoint1 should not be same with LinePoint2");
              }
              var xCoeff = subtract2(z5[1], y3[1]);
              var yCoeff = subtract2(y3[0], z5[0]);
              var constant = subtract2(multiplyScalar2(z5[0], y3[1]), multiplyScalar2(y3[0], z5[1]));
              return _distancePointLine2D(x4[0], x4[1], xCoeff, yCoeff, constant);
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Object, Object, Object": function ObjectObjectObject(x4, y3, z5) {
            if (Object.keys(x4).length === 2 && Object.keys(y3).length === 2 && Object.keys(z5).length === 2) {
              if (!_2d(x4)) {
                throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
              }
              if (!_2d(y3)) {
                throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
              }
              if (!_2d(z5)) {
                throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
              }
              if (deepEqual2(_objectToArray(y3), _objectToArray(z5))) {
                throw new TypeError("LinePoint1 should not be same with LinePoint2");
              }
              if ("pointX" in x4 && "pointY" in x4 && "lineOnePtX" in y3 && "lineOnePtY" in y3 && "lineTwoPtX" in z5 && "lineTwoPtY" in z5) {
                var xCoeff = subtract2(z5.lineTwoPtY, y3.lineOnePtY);
                var yCoeff = subtract2(y3.lineOnePtX, z5.lineTwoPtX);
                var constant = subtract2(multiplyScalar2(z5.lineTwoPtX, y3.lineOnePtY), multiplyScalar2(y3.lineOnePtX, z5.lineTwoPtY));
                return _distancePointLine2D(x4.pointX, x4.pointY, xCoeff, yCoeff, constant);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Array, Array": function ArrayArray(x4, y3) {
            if (x4.length === 2 && y3.length === 3) {
              if (!_2d(x4)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
              }
              if (!_3d(y3)) {
                throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
              }
              return _distancePointLine2D(x4[0], x4[1], y3[0], y3[1], y3[2]);
            } else if (x4.length === 3 && y3.length === 6) {
              if (!_3d(x4)) {
                throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
              }
              if (!_parametricLine(y3)) {
                throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
              }
              return _distancePointLine3D(x4[0], x4[1], x4[2], y3[0], y3[1], y3[2], y3[3], y3[4], y3[5]);
            } else if (x4.length === y3.length && x4.length > 0) {
              if (!_containsOnlyNumbers(x4)) {
                throw new TypeError("All values of an array should be numbers or BigNumbers");
              }
              if (!_containsOnlyNumbers(y3)) {
                throw new TypeError("All values of an array should be numbers or BigNumbers");
              }
              return _euclideanDistance(x4, y3);
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Object, Object": function ObjectObject(x4, y3) {
            if (Object.keys(x4).length === 2 && Object.keys(y3).length === 3) {
              if (!_2d(x4)) {
                throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
              }
              if (!_3d(y3)) {
                throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
              }
              if ("pointX" in x4 && "pointY" in x4 && "xCoeffLine" in y3 && "yCoeffLine" in y3 && "constant" in y3) {
                return _distancePointLine2D(x4.pointX, x4.pointY, y3.xCoeffLine, y3.yCoeffLine, y3.constant);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x4).length === 3 && Object.keys(y3).length === 6) {
              if (!_3d(x4)) {
                throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
              }
              if (!_parametricLine(y3)) {
                throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
              }
              if ("pointX" in x4 && "pointY" in x4 && "x0" in y3 && "y0" in y3 && "z0" in y3 && "a" in y3 && "b" in y3 && "c" in y3) {
                return _distancePointLine3D(x4.pointX, x4.pointY, x4.pointZ, y3.x0, y3.y0, y3.z0, y3.a, y3.b, y3.c);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x4).length === 2 && Object.keys(y3).length === 2) {
              if (!_2d(x4)) {
                throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
              }
              if (!_2d(y3)) {
                throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
              }
              if ("pointOneX" in x4 && "pointOneY" in x4 && "pointTwoX" in y3 && "pointTwoY" in y3) {
                return _euclideanDistance([x4.pointOneX, x4.pointOneY], [y3.pointTwoX, y3.pointTwoY]);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x4).length === 3 && Object.keys(y3).length === 3) {
              if (!_3d(x4)) {
                throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
              }
              if (!_3d(y3)) {
                throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
              }
              if ("pointOneX" in x4 && "pointOneY" in x4 && "pointOneZ" in x4 && "pointTwoX" in y3 && "pointTwoY" in y3 && "pointTwoZ" in y3) {
                return _euclideanDistance([x4.pointOneX, x4.pointOneY, x4.pointOneZ], [y3.pointTwoX, y3.pointTwoY, y3.pointTwoZ]);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          Array: function Array2(arr) {
            if (!_pairwise(arr)) {
              throw new TypeError("Incorrect array format entered for pairwise distance calculation");
            }
            return _distancePairwise(arr);
          }
        });
        function _isNumber(a3) {
          return typeof a3 === "number" || isBigNumber(a3);
        }
        function _2d(a3) {
          if (a3.constructor !== Array) {
            a3 = _objectToArray(a3);
          }
          return _isNumber(a3[0]) && _isNumber(a3[1]);
        }
        function _3d(a3) {
          if (a3.constructor !== Array) {
            a3 = _objectToArray(a3);
          }
          return _isNumber(a3[0]) && _isNumber(a3[1]) && _isNumber(a3[2]);
        }
        function _containsOnlyNumbers(a3) {
          if (!Array.isArray(a3)) {
            a3 = _objectToArray(a3);
          }
          return a3.every(_isNumber);
        }
        function _parametricLine(a3) {
          if (a3.constructor !== Array) {
            a3 = _objectToArray(a3);
          }
          return _isNumber(a3[0]) && _isNumber(a3[1]) && _isNumber(a3[2]) && _isNumber(a3[3]) && _isNumber(a3[4]) && _isNumber(a3[5]);
        }
        function _objectToArray(o3) {
          var keys = Object.keys(o3);
          var a3 = [];
          for (var i5 = 0; i5 < keys.length; i5++) {
            a3.push(o3[keys[i5]]);
          }
          return a3;
        }
        function _pairwise(a3) {
          if (a3[0].length === 2 && _isNumber(a3[0][0]) && _isNumber(a3[0][1])) {
            if (a3.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
              return false;
            }
          } else if (a3[0].length === 3 && _isNumber(a3[0][0]) && _isNumber(a3[0][1]) && _isNumber(a3[0][2])) {
            if (a3.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
              return false;
            }
          } else {
            return false;
          }
          return true;
        }
        function _distancePointLine2D(x4, y3, a3, b3, c3) {
          var num = abs3(addScalar2(addScalar2(multiplyScalar2(a3, x4), multiplyScalar2(b3, y3)), c3));
          var den = sqrt3(addScalar2(multiplyScalar2(a3, a3), multiplyScalar2(b3, b3)));
          return divideScalar2(num, den);
        }
        function _distancePointLine3D(x4, y3, z5, x0, y0, z0, a3, b3, c3) {
          var num = [subtract2(multiplyScalar2(subtract2(y0, y3), c3), multiplyScalar2(subtract2(z0, z5), b3)), subtract2(multiplyScalar2(subtract2(z0, z5), a3), multiplyScalar2(subtract2(x0, x4), c3)), subtract2(multiplyScalar2(subtract2(x0, x4), b3), multiplyScalar2(subtract2(y0, y3), a3))];
          num = sqrt3(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
          var den = sqrt3(addScalar2(addScalar2(multiplyScalar2(a3, a3), multiplyScalar2(b3, b3)), multiplyScalar2(c3, c3)));
          return divideScalar2(num, den);
        }
        function _euclideanDistance(x4, y3) {
          var vectorSize = x4.length;
          var result = 0;
          var diff2 = 0;
          for (var i5 = 0; i5 < vectorSize; i5++) {
            diff2 = subtract2(x4[i5], y3[i5]);
            result = addScalar2(multiplyScalar2(diff2, diff2), result);
          }
          return sqrt3(result);
        }
        function _distancePairwise(a3) {
          var result = [];
          var pointA = [];
          var pointB = [];
          for (var i5 = 0; i5 < a3.length - 1; i5++) {
            for (var j4 = i5 + 1; j4 < a3.length; j4++) {
              if (a3[0].length === 2) {
                pointA = [a3[i5][0], a3[i5][1]];
                pointB = [a3[j4][0], a3[j4][1]];
              } else if (a3[0].length === 3) {
                pointA = [a3[i5][0], a3[i5][1], a3[i5][2]];
                pointB = [a3[j4][0], a3[j4][1], a3[j4][2]];
              }
              result.push(_euclideanDistance(pointA, pointB));
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/geometry/intersect.js
  var name251, dependencies251, createIntersect;
  var init_intersect2 = __esm({
    "node_modules/mathjs/lib/esm/function/geometry/intersect.js"() {
      init_factory();
      name251 = "intersect";
      dependencies251 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
      createIntersect = /* @__PURE__ */ factory(name251, dependencies251, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          abs: abs3,
          add: add3,
          addScalar: addScalar2,
          matrix: matrix2,
          multiply: multiply2,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          subtract: subtract2,
          smaller: smaller2,
          equalScalar: equalScalar2,
          flatten: flatten3,
          isZero: isZero2,
          isNumeric: isNumeric2
        } = _ref;
        return typed3("intersect", {
          "Array, Array, Array": _AAA,
          "Array, Array, Array, Array": _AAAA,
          "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x4, y3, plane) {
            var arr = _AAA(x4.valueOf(), y3.valueOf(), plane.valueOf());
            return arr === null ? null : matrix2(arr);
          },
          "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w4, x4, y3, z5) {
            var arr = _AAAA(w4.valueOf(), x4.valueOf(), y3.valueOf(), z5.valueOf());
            return arr === null ? null : matrix2(arr);
          }
        });
        function _AAA(x4, y3, plane) {
          x4 = _coerceArr(x4);
          y3 = _coerceArr(y3);
          plane = _coerceArr(plane);
          if (!_3d(x4)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(y3)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          if (!_4d(plane)) {
            throw new TypeError("Array with 4 numbers expected as third argument");
          }
          return _intersectLinePlane(x4[0], x4[1], x4[2], y3[0], y3[1], y3[2], plane[0], plane[1], plane[2], plane[3]);
        }
        function _AAAA(w4, x4, y3, z5) {
          w4 = _coerceArr(w4);
          x4 = _coerceArr(x4);
          y3 = _coerceArr(y3);
          z5 = _coerceArr(z5);
          if (w4.length === 2) {
            if (!_2d(w4)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
            }
            if (!_2d(x4)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
            }
            if (!_2d(y3)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
            }
            if (!_2d(z5)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
            }
            return _intersect2d(w4, x4, y3, z5);
          } else if (w4.length === 3) {
            if (!_3d(w4)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
            }
            if (!_3d(x4)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
            }
            if (!_3d(y3)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
            }
            if (!_3d(z5)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
            }
            return _intersect3d(w4[0], w4[1], w4[2], x4[0], x4[1], x4[2], y3[0], y3[1], y3[2], z5[0], z5[1], z5[2]);
          } else {
            throw new TypeError("Arrays with two or thee dimensional points expected");
          }
        }
        function _coerceArr(arr) {
          if (arr.length === 1)
            return arr[0];
          if (arr.length > 1 && Array.isArray(arr[0])) {
            if (arr.every((el) => Array.isArray(el) && el.length === 1))
              return flatten3(arr);
          }
          return arr;
        }
        function _2d(x4) {
          return x4.length === 2 && isNumeric2(x4[0]) && isNumeric2(x4[1]);
        }
        function _3d(x4) {
          return x4.length === 3 && isNumeric2(x4[0]) && isNumeric2(x4[1]) && isNumeric2(x4[2]);
        }
        function _4d(x4) {
          return x4.length === 4 && isNumeric2(x4[0]) && isNumeric2(x4[1]) && isNumeric2(x4[2]) && isNumeric2(x4[3]);
        }
        function _intersect2d(p1a, p1b, p2a, p2b) {
          var o1 = p1a;
          var o22 = p2a;
          var d1 = subtract2(o1, p1b);
          var d22 = subtract2(o22, p2b);
          var det2 = subtract2(multiplyScalar2(d1[0], d22[1]), multiplyScalar2(d22[0], d1[1]));
          if (isZero2(det2))
            return null;
          if (smaller2(abs3(det2), config4.epsilon)) {
            return null;
          }
          var d20o11 = multiplyScalar2(d22[0], o1[1]);
          var d21o10 = multiplyScalar2(d22[1], o1[0]);
          var d20o21 = multiplyScalar2(d22[0], o22[1]);
          var d21o20 = multiplyScalar2(d22[1], o22[0]);
          var t3 = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
          return add3(multiply2(d1, t3), o1);
        }
        function _intersect3dHelper(a3, b3, c3, d3, e6, f3, g4, h3, i5, j4, k4, l3) {
          var add1 = multiplyScalar2(subtract2(a3, b3), subtract2(c3, d3));
          var add22 = multiplyScalar2(subtract2(e6, f3), subtract2(g4, h3));
          var add32 = multiplyScalar2(subtract2(i5, j4), subtract2(k4, l3));
          return addScalar2(addScalar2(add1, add22), add32);
        }
        function _intersect3d(x1, y1, z1, x22, y22, z22, x32, y3, z32, x4, y4, z42) {
          var d1343 = _intersect3dHelper(x1, x32, x4, x32, y1, y3, y4, y3, z1, z32, z42, z32);
          var d4321 = _intersect3dHelper(x4, x32, x22, x1, y4, y3, y22, y1, z42, z32, z22, z1);
          var d1321 = _intersect3dHelper(x1, x32, x22, x1, y1, y3, y22, y1, z1, z32, z22, z1);
          var d4343 = _intersect3dHelper(x4, x32, x4, x32, y4, y3, y4, y3, z42, z32, z42, z32);
          var d2121 = _intersect3dHelper(x22, x1, x22, x1, y22, y1, y22, y1, z22, z1, z22, z1);
          var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
          var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
          if (isZero2(denominator))
            return null;
          var ta = divideScalar2(numerator, denominator);
          var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
          var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x22, x1)));
          var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y22, y1)));
          var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z22, z1)));
          var pbx = addScalar2(x32, multiplyScalar2(tb, subtract2(x4, x32)));
          var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
          var pbz = addScalar2(z32, multiplyScalar2(tb, subtract2(z42, z32)));
          if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
            return [pax, pay, paz];
          } else {
            return null;
          }
        }
        function _intersectLinePlane(x1, y1, z1, x22, y22, z22, x4, y3, z5, c3) {
          var x1x = multiplyScalar2(x1, x4);
          var x2x = multiplyScalar2(x22, x4);
          var y1y = multiplyScalar2(y1, y3);
          var y2y = multiplyScalar2(y22, y3);
          var z1z = multiplyScalar2(z1, z5);
          var z2z = multiplyScalar2(z22, z5);
          var numerator = subtract2(subtract2(subtract2(c3, x1x), y1y), z1z);
          var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
          var t3 = divideScalar2(numerator, denominator);
          var px = addScalar2(x1, multiplyScalar2(t3, subtract2(x22, x1)));
          var py = addScalar2(y1, multiplyScalar2(t3, subtract2(y22, y1)));
          var pz = addScalar2(z1, multiplyScalar2(t3, subtract2(z22, z1)));
          return [px, py, pz];
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/sum.js
  var name252, dependencies252, createSum;
  var init_sum2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/sum.js"() {
      init_collection();
      init_factory();
      init_improveErrorMessage();
      name252 = "sum";
      dependencies252 = ["typed", "config", "add", "numeric"];
      createSum = /* @__PURE__ */ factory(name252, dependencies252, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          add: add3,
          numeric: numeric3
        } = _ref;
        return typed3(name252, {
          // sum([a, b, c, d, ...])
          "Array | Matrix": _sum,
          // sum([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": _nsumDim,
          // sum(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("Scalar values expected in function sum");
            }
            return _sum(args);
          }
        });
        function _sum(array) {
          var sum3;
          deepForEach(array, function(value) {
            try {
              sum3 = sum3 === void 0 ? value : add3(sum3, value);
            } catch (err) {
              throw improveErrorMessage(err, "sum", value);
            }
          });
          if (sum3 === void 0) {
            sum3 = numeric3(0, config4.number);
          }
          if (typeof sum3 === "string") {
            sum3 = numeric3(sum3, config4.number);
          }
          return sum3;
        }
        function _nsumDim(array, dim) {
          try {
            var sum3 = reduce(array, dim, add3);
            return sum3;
          } catch (err) {
            throw improveErrorMessage(err, "sum");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/cumsum.js
  var name253, dependencies253, createCumSum;
  var init_cumsum2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/cumsum.js"() {
      init_collection();
      init_factory();
      init_switch();
      init_improveErrorMessage();
      init_array();
      init_IndexError();
      name253 = "cumsum";
      dependencies253 = ["typed", "add", "unaryPlus"];
      createCumSum = /* @__PURE__ */ factory(name253, dependencies253, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          unaryPlus: unaryPlus2
        } = _ref;
        return typed3(name253, {
          // sum([a, b, c, d, ...])
          Array: _cumsum,
          Matrix: function Matrix2(matrix2) {
            return matrix2.create(_cumsum(matrix2.valueOf()));
          },
          // sum([a, b, c, d, ...], dim)
          "Array, number | BigNumber": _ncumSumDim,
          "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
            return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
          },
          // cumsum(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("All values expected to be scalar in function cumsum");
            }
            return _cumsum(args);
          }
        });
        function _cumsum(array) {
          try {
            return _cumsummap(array);
          } catch (err) {
            throw improveErrorMessage(err, name253);
          }
        }
        function _cumsummap(array) {
          if (array.length === 0) {
            return [];
          }
          var sums = [unaryPlus2(array[0])];
          for (var i5 = 1; i5 < array.length; ++i5) {
            sums.push(add3(sums[i5 - 1], array[i5]));
          }
          return sums;
        }
        function _ncumSumDim(array, dim) {
          var size2 = arraySize(array);
          if (dim < 0 || dim >= size2.length) {
            throw new IndexError(dim, size2.length);
          }
          try {
            return _cumsumDimensional(array, dim);
          } catch (err) {
            throw improveErrorMessage(err, name253);
          }
        }
        function _cumsumDimensional(mat, dim) {
          var i5, ret, tran;
          if (dim <= 0) {
            var initialValue = mat[0][0];
            if (!Array.isArray(initialValue)) {
              return _cumsummap(mat);
            } else {
              tran = _switch(mat);
              ret = [];
              for (i5 = 0; i5 < tran.length; i5++) {
                ret[i5] = _cumsumDimensional(tran[i5], dim - 1);
              }
              return ret;
            }
          } else {
            ret = [];
            for (i5 = 0; i5 < mat.length; i5++) {
              ret[i5] = _cumsumDimensional(mat[i5], dim - 1);
            }
            return ret;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mean.js
  var name254, dependencies254, createMean;
  var init_mean2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/mean.js"() {
      init_collection();
      init_array();
      init_factory();
      init_improveErrorMessage();
      name254 = "mean";
      dependencies254 = ["typed", "add", "divide"];
      createMean = /* @__PURE__ */ factory(name254, dependencies254, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          divide: divide3
        } = _ref;
        return typed3(name254, {
          // mean([a, b, c, d, ...])
          "Array | Matrix": _mean,
          // mean([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": _nmeanDim,
          // mean(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("Scalar values expected in function mean");
            }
            return _mean(args);
          }
        });
        function _nmeanDim(array, dim) {
          try {
            var sum3 = reduce(array, dim, add3);
            var s3 = Array.isArray(array) ? arraySize(array) : array.size();
            return divide3(sum3, s3[dim]);
          } catch (err) {
            throw improveErrorMessage(err, "mean");
          }
        }
        function _mean(array) {
          var sum3;
          var num = 0;
          deepForEach(array, function(value) {
            try {
              sum3 = sum3 === void 0 ? value : add3(sum3, value);
              num++;
            } catch (err) {
              throw improveErrorMessage(err, "mean", value);
            }
          });
          if (num === 0) {
            throw new Error("Cannot calculate the mean of an empty array");
          }
          return divide3(sum3, num);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/median.js
  var name255, dependencies255, createMedian;
  var init_median2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/median.js"() {
      init_collection();
      init_array();
      init_factory();
      init_improveErrorMessage();
      name255 = "median";
      dependencies255 = ["typed", "add", "divide", "compare", "partitionSelect"];
      createMedian = /* @__PURE__ */ factory(name255, dependencies255, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          divide: divide3,
          compare: compare3,
          partitionSelect: partitionSelect2
        } = _ref;
        function _median(array) {
          try {
            array = flatten(array.valueOf());
            var num = array.length;
            if (num === 0) {
              throw new Error("Cannot calculate median of an empty array");
            }
            if (num % 2 === 0) {
              var mid = num / 2 - 1;
              var right = partitionSelect2(array, mid + 1);
              var left = array[mid];
              for (var i5 = 0; i5 < mid; ++i5) {
                if (compare3(array[i5], left) > 0) {
                  left = array[i5];
                }
              }
              return middle2(left, right);
            } else {
              var m3 = partitionSelect2(array, (num - 1) / 2);
              return middle(m3);
            }
          } catch (err) {
            throw improveErrorMessage(err, "median");
          }
        }
        var middle = typed3({
          "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
            return value;
          }
        });
        var middle2 = typed3({
          "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
            return divide3(add3(left, right), 2);
          }
        });
        return typed3(name255, {
          // median([a, b, c, d, ...])
          "Array | Matrix": _median,
          // median([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            throw new Error("median(A, dim) is not yet supported");
          },
          // median(a, b, c, d, ...)
          "...": function _3(args) {
            if (containsCollections(args)) {
              throw new TypeError("Scalar values expected in function median");
            }
            return _median(args);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mad.js
  var name256, dependencies256, createMad;
  var init_mad2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/mad.js"() {
      init_array();
      init_factory();
      init_improveErrorMessage();
      name256 = "mad";
      dependencies256 = ["typed", "abs", "map", "median", "subtract"];
      createMad = /* @__PURE__ */ factory(name256, dependencies256, (_ref) => {
        var {
          typed: typed3,
          abs: abs3,
          map: map3,
          median: median2,
          subtract: subtract2
        } = _ref;
        return typed3(name256, {
          // mad([a, b, c, d, ...])
          "Array | Matrix": _mad,
          // mad(a, b, c, d, ...)
          "...": function _3(args) {
            return _mad(args);
          }
        });
        function _mad(array) {
          array = flatten(array.valueOf());
          if (array.length === 0) {
            throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
          }
          try {
            var med = median2(array);
            return median2(map3(array, function(value) {
              return abs3(subtract2(value, med));
            }));
          } catch (err) {
            if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
              throw new TypeError(err.message.replace("median", "mad"));
            } else {
              throw improveErrorMessage(err, "mad");
            }
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/variance.js
  var DEFAULT_NORMALIZATION, name257, dependencies257, createVariance;
  var init_variance2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/variance.js"() {
      init_collection();
      init_is();
      init_factory();
      init_improveErrorMessage();
      DEFAULT_NORMALIZATION = "unbiased";
      name257 = "variance";
      dependencies257 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
      createVariance = /* @__PURE__ */ factory(name257, dependencies257, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          apply: apply2,
          isNaN: isNaN3
        } = _ref;
        return typed3(name257, {
          // variance([a, b, c, d, ...])
          "Array | Matrix": function ArrayMatrix(array) {
            return _var(array, DEFAULT_NORMALIZATION);
          },
          // variance([a, b, c, d, ...], normalization)
          "Array | Matrix, string": _var,
          // variance([a, b, c, c, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return _varDim(array, dim, DEFAULT_NORMALIZATION);
          },
          // variance([a, b, c, c, ...], dim, normalization)
          "Array | Matrix, number | BigNumber, string": _varDim,
          // variance(a, b, c, d, ...)
          "...": function _3(args) {
            return _var(args, DEFAULT_NORMALIZATION);
          }
        });
        function _var(array, normalization) {
          var sum3;
          var num = 0;
          if (array.length === 0) {
            throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
          }
          deepForEach(array, function(value) {
            try {
              sum3 = sum3 === void 0 ? value : add3(sum3, value);
              num++;
            } catch (err) {
              throw improveErrorMessage(err, "variance", value);
            }
          });
          if (num === 0)
            throw new Error("Cannot calculate variance of an empty array");
          var mean2 = divide3(sum3, num);
          sum3 = void 0;
          deepForEach(array, function(value) {
            var diff2 = subtract2(value, mean2);
            sum3 = sum3 === void 0 ? multiply2(diff2, diff2) : add3(sum3, multiply2(diff2, diff2));
          });
          if (isNaN3(sum3)) {
            return sum3;
          }
          switch (normalization) {
            case "uncorrected":
              return divide3(sum3, num);
            case "biased":
              return divide3(sum3, num + 1);
            case "unbiased": {
              var zero = isBigNumber(sum3) ? sum3.mul(0) : 0;
              return num === 1 ? zero : divide3(sum3, num - 1);
            }
            default:
              throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
          }
        }
        function _varDim(array, dim, normalization) {
          try {
            if (array.length === 0) {
              throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
            }
            return apply2(array, dim, (x4) => _var(x4, normalization));
          } catch (err) {
            throw improveErrorMessage(err, "variance");
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
  var name258, dependencies258, createQuantileSeq;
  var init_quantileSeq2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js"() {
      init_is();
      init_array();
      init_factory();
      init_apply();
      name258 = "quantileSeq";
      dependencies258 = ["typed", "add", "multiply", "partitionSelect", "compare", "isInteger"];
      createQuantileSeq = /* @__PURE__ */ factory(name258, dependencies258, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          multiply: multiply2,
          partitionSelect: partitionSelect2,
          compare: compare3,
          isInteger: isInteger3
        } = _ref;
        var apply2 = createApply({
          typed: typed3,
          isInteger: isInteger3
        });
        var validate2 = typed3({
          "number | BigNumber | Unit": function numberBigNumberUnit(x4) {
            return x4;
          }
        });
        return typed3(name258, {
          "Array|Matrix, number|BigNumber|Array": (data, prob) => quantileSeq2(data, prob, false),
          "Array|Matrix, number|BigNumber|Array, boolean": quantileSeq2,
          "Array|Matrix, number|BigNumber|Array, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim),
          "Array|Matrix, number|BigNumber|Array, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim)
        });
        function _quantileSeqDim(data, prob, sorted, dim) {
          return apply2(data, dim, (x4) => quantileSeq2(x4, prob, sorted));
        }
        function quantileSeq2(data, probOrN, sorted) {
          var probArr, dataArr, one;
          if (arguments.length < 2 || arguments.length > 3) {
            throw new SyntaxError("Function quantileSeq requires two or three parameters");
          }
          if (isCollection(data)) {
            sorted = sorted || false;
            if (typeof sorted === "boolean") {
              dataArr = data.valueOf();
              if (isNumber(probOrN)) {
                if (probOrN < 0) {
                  throw new Error("N/prob must be non-negative");
                }
                if (probOrN <= 1) {
                  return _quantileSeq(dataArr, probOrN, sorted);
                }
                if (probOrN > 1) {
                  if (!isInteger3(probOrN)) {
                    throw new Error("N must be a positive integer");
                  }
                  var nPlusOne = probOrN + 1;
                  probArr = new Array(probOrN);
                  for (var i5 = 0; i5 < probOrN; ) {
                    probArr[i5] = _quantileSeq(dataArr, ++i5 / nPlusOne, sorted);
                  }
                  return probArr;
                }
              }
              if (isBigNumber(probOrN)) {
                var BigNumber2 = probOrN.constructor;
                if (probOrN.isNegative()) {
                  throw new Error("N/prob must be non-negative");
                }
                one = new BigNumber2(1);
                if (probOrN.lte(one)) {
                  return new BigNumber2(_quantileSeq(dataArr, probOrN, sorted));
                }
                if (probOrN.gt(one)) {
                  if (!probOrN.isInteger()) {
                    throw new Error("N must be a positive integer");
                  }
                  var intN = probOrN.toNumber();
                  if (intN > 4294967295) {
                    throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
                  }
                  var _nPlusOne = new BigNumber2(intN + 1);
                  probArr = new Array(intN);
                  for (var _i = 0; _i < intN; ) {
                    probArr[_i] = new BigNumber2(_quantileSeq(dataArr, new BigNumber2(++_i).div(_nPlusOne), sorted));
                  }
                  return probArr;
                }
              }
              if (isCollection(probOrN)) {
                var probOrNArr = probOrN.valueOf();
                probArr = new Array(probOrNArr.length);
                for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
                  var currProb = probOrNArr[_i2];
                  if (isNumber(currProb)) {
                    if (currProb < 0 || currProb > 1) {
                      throw new Error("Probability must be between 0 and 1, inclusive");
                    }
                  } else if (isBigNumber(currProb)) {
                    one = new currProb.constructor(1);
                    if (currProb.isNegative() || currProb.gt(one)) {
                      throw new Error("Probability must be between 0 and 1, inclusive");
                    }
                  } else {
                    throw new TypeError("Unexpected type of argument in function quantileSeq");
                  }
                  probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
                }
                return probArr;
              }
              throw new TypeError("Unexpected type of argument in function quantileSeq");
            }
            throw new TypeError("Unexpected type of argument in function quantileSeq");
          }
          throw new TypeError("Unexpected type of argument in function quantileSeq");
        }
        function _quantileSeq(array, prob, sorted) {
          var flat = flatten(array);
          var len = flat.length;
          if (len === 0) {
            throw new Error("Cannot calculate quantile of an empty sequence");
          }
          if (isNumber(prob)) {
            var _index = prob * (len - 1);
            var _fracPart = _index % 1;
            if (_fracPart === 0) {
              var value = sorted ? flat[_index] : partitionSelect2(flat, _index);
              validate2(value);
              return value;
            }
            var _integerPart = Math.floor(_index);
            var _left;
            var _right;
            if (sorted) {
              _left = flat[_integerPart];
              _right = flat[_integerPart + 1];
            } else {
              _right = partitionSelect2(flat, _integerPart + 1);
              _left = flat[_integerPart];
              for (var i5 = 0; i5 < _integerPart; ++i5) {
                if (compare3(flat[i5], _left) > 0) {
                  _left = flat[i5];
                }
              }
            }
            validate2(_left);
            validate2(_right);
            return add3(multiply2(_left, 1 - _fracPart), multiply2(_right, _fracPart));
          }
          var index2 = prob.times(len - 1);
          if (index2.isInteger()) {
            index2 = index2.toNumber();
            var _value = sorted ? flat[index2] : partitionSelect2(flat, index2);
            validate2(_value);
            return _value;
          }
          var integerPart = index2.floor();
          var fracPart = index2.minus(integerPart);
          var integerPartNumber = integerPart.toNumber();
          var left;
          var right;
          if (sorted) {
            left = flat[integerPartNumber];
            right = flat[integerPartNumber + 1];
          } else {
            right = partitionSelect2(flat, integerPartNumber + 1);
            left = flat[integerPartNumber];
            for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
              if (compare3(flat[_i3], left) > 0) {
                left = flat[_i3];
              }
            }
          }
          validate2(left);
          validate2(right);
          var one = new fracPart.constructor(1);
          return add3(multiply2(left, one.minus(fracPart)), multiply2(right, fracPart));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/std.js
  var name259, dependencies259, createStd;
  var init_std2 = __esm({
    "node_modules/mathjs/lib/esm/function/statistics/std.js"() {
      init_factory();
      init_is();
      name259 = "std";
      dependencies259 = ["typed", "map", "sqrt", "variance"];
      createStd = /* @__PURE__ */ factory(name259, dependencies259, (_ref) => {
        var {
          typed: typed3,
          map: map3,
          sqrt: sqrt3,
          variance: variance2
        } = _ref;
        return typed3(name259, {
          // std([a, b, c, d, ...])
          "Array | Matrix": _std,
          // std([a, b, c, d, ...], normalization)
          "Array | Matrix, string": _std,
          // std([a, b, c, c, ...], dim)
          "Array | Matrix, number | BigNumber": _std,
          // std([a, b, c, c, ...], dim, normalization)
          "Array | Matrix, number | BigNumber, string": _std,
          // std(a, b, c, d, ...)
          "...": function _3(args) {
            return _std(args);
          }
        });
        function _std(array, normalization) {
          if (array.length === 0) {
            throw new SyntaxError("Function std requires one or more parameters (0 provided)");
          }
          try {
            var v3 = variance2.apply(null, arguments);
            if (isCollection(v3)) {
              return map3(v3, sqrt3);
            } else {
              return sqrt3(v3);
            }
          } catch (err) {
            if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
              throw new TypeError(err.message.replace(" variance", " std"));
            } else {
              throw err;
            }
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/combinations.js
  function isPositiveInteger(n3) {
    return n3.isInteger() && n3.gte(0);
  }
  var name260, dependencies260, createCombinations;
  var init_combinations3 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/combinations.js"() {
      init_factory();
      init_combinations();
      name260 = "combinations";
      dependencies260 = ["typed"];
      createCombinations = /* @__PURE__ */ factory(name260, dependencies260, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name260, {
          "number, number": combinationsNumber,
          "BigNumber, BigNumber": function BigNumberBigNumber(n3, k4) {
            var BigNumber2 = n3.constructor;
            var result, i5;
            var nMinusk = n3.minus(k4);
            var one = new BigNumber2(1);
            if (!isPositiveInteger(n3) || !isPositiveInteger(k4)) {
              throw new TypeError("Positive integer value expected in function combinations");
            }
            if (k4.gt(n3)) {
              throw new TypeError("k must be less than n in function combinations");
            }
            result = one;
            if (k4.lt(nMinusk)) {
              for (i5 = one; i5.lte(nMinusk); i5 = i5.plus(one)) {
                result = result.times(k4.plus(i5)).dividedBy(i5);
              }
            } else {
              for (i5 = one; i5.lte(k4); i5 = i5.plus(one)) {
                result = result.times(nMinusk.plus(i5)).dividedBy(i5);
              }
            }
            return result;
          }
          // TODO: implement support for collection in combinations
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
  function isPositiveInteger2(n3) {
    return n3.isInteger() && n3.gte(0);
  }
  var name261, dependencies261, createCombinationsWithRep;
  var init_combinationsWithRep2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js"() {
      init_factory();
      init_number();
      init_product();
      name261 = "combinationsWithRep";
      dependencies261 = ["typed"];
      createCombinationsWithRep = /* @__PURE__ */ factory(name261, dependencies261, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        return typed3(name261, {
          "number, number": function numberNumber(n3, k4) {
            if (!isInteger(n3) || n3 < 0) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (!isInteger(k4) || k4 < 0) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (n3 < 1) {
              throw new TypeError("k must be less than or equal to n + k - 1");
            }
            if (k4 < n3 - 1) {
              var _prodrange = product2(n3, n3 + k4 - 1);
              return _prodrange / product2(1, k4);
            }
            var prodrange = product2(k4 + 1, n3 + k4 - 1);
            return prodrange / product2(1, n3 - 1);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(n3, k4) {
            var BigNumber2 = n3.constructor;
            var result, i5;
            var one = new BigNumber2(1);
            var nMinusOne = n3.minus(one);
            if (!isPositiveInteger2(n3) || !isPositiveInteger2(k4)) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (n3.lt(one)) {
              throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
            }
            result = one;
            if (k4.lt(nMinusOne)) {
              for (i5 = one; i5.lte(nMinusOne); i5 = i5.plus(one)) {
                result = result.times(k4.plus(i5)).dividedBy(i5);
              }
            } else {
              for (i5 = one; i5.lte(k4); i5 = i5.plus(one)) {
                result = result.times(nMinusOne.plus(i5)).dividedBy(i5);
              }
            }
            return result;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/gamma.js
  var name262, dependencies262, createGamma;
  var init_gamma2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/gamma.js"() {
      init_factory();
      init_number2();
      name262 = "gamma";
      dependencies262 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
      createGamma = /* @__PURE__ */ factory(name262, dependencies262, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          multiplyScalar: multiplyScalar2,
          pow: pow3,
          BigNumber: _BigNumber,
          Complex: Complex3
        } = _ref;
        function gammaComplex(n3) {
          if (n3.im === 0) {
            return gammaNumber(n3.re);
          }
          if (n3.re < 0.5) {
            var _t = new Complex3(1 - n3.re, -n3.im);
            var r3 = new Complex3(Math.PI * n3.re, Math.PI * n3.im);
            return new Complex3(Math.PI).div(r3.sin()).div(gammaComplex(_t));
          }
          n3 = new Complex3(n3.re - 1, n3.im);
          var x4 = new Complex3(gammaP[0], 0);
          for (var i5 = 1; i5 < gammaP.length; ++i5) {
            var gammaPval = new Complex3(gammaP[i5], 0);
            x4 = x4.add(gammaPval.div(n3.add(i5)));
          }
          var t3 = new Complex3(n3.re + gammaG + 0.5, n3.im);
          var twoPiSqrt = Math.sqrt(2 * Math.PI);
          var tpow = t3.pow(n3.add(0.5));
          var expt = t3.neg().exp();
          return x4.mul(twoPiSqrt).mul(tpow).mul(expt);
        }
        return typed3(name262, {
          number: gammaNumber,
          Complex: gammaComplex,
          BigNumber: function BigNumber2(n3) {
            if (n3.isInteger()) {
              return n3.isNegative() || n3.isZero() ? new _BigNumber(Infinity) : bigFactorial(n3.minus(1));
            }
            if (!n3.isFinite()) {
              return new _BigNumber(n3.isNegative() ? NaN : Infinity);
            }
            throw new Error("Integer BigNumber expected");
          }
        });
        function bigFactorial(n3) {
          if (n3 < 8) {
            return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n3]);
          }
          var precision = config4.precision + (Math.log(n3.toNumber()) | 0);
          var Big = _BigNumber.clone({
            precision
          });
          if (n3 % 2 === 1) {
            return n3.times(bigFactorial(new _BigNumber(n3 - 1)));
          }
          var p3 = n3;
          var prod2 = new Big(n3);
          var sum3 = n3.toNumber();
          while (p3 > 2) {
            p3 -= 2;
            sum3 += p3;
            prod2 = prod2.times(sum3);
          }
          return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/lgamma.js
  var name263, dependencies263, createLgamma;
  var init_lgamma2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/lgamma.js"() {
      init_number2();
      init_factory();
      init_number();
      name263 = "lgamma";
      dependencies263 = ["Complex", "typed"];
      createLgamma = /* @__PURE__ */ factory(name263, dependencies263, (_ref) => {
        var {
          Complex: Complex3,
          typed: typed3
        } = _ref;
        var SMALL_RE = 7;
        var SMALL_IM = 7;
        var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
        return typed3(name263, {
          number: lgammaNumber,
          Complex: lgammaComplex,
          BigNumber: function BigNumber2() {
            throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
          }
        });
        function lgammaComplex(n3) {
          var TWOPI = 6.283185307179586;
          var LOGPI = 1.1447298858494002;
          var REFLECTION = 0.1;
          if (n3.isNaN()) {
            return new Complex3(NaN, NaN);
          } else if (n3.im === 0) {
            return new Complex3(lgammaNumber(n3.re), 0);
          } else if (n3.re >= SMALL_RE || Math.abs(n3.im) >= SMALL_IM) {
            return lgammaStirling(n3);
          } else if (n3.re <= REFLECTION) {
            var tmp = copysign(TWOPI, n3.im) * Math.floor(0.5 * n3.re + 0.25);
            var a3 = n3.mul(Math.PI).sin().log();
            var b3 = lgammaComplex(new Complex3(1 - n3.re, -n3.im));
            return new Complex3(LOGPI, tmp).sub(a3).sub(b3);
          } else if (n3.im >= 0) {
            return lgammaRecurrence(n3);
          } else {
            return lgammaRecurrence(n3.conjugate()).conjugate();
          }
        }
        function lgammaStirling(z5) {
          var leftPart = z5.sub(0.5).mul(z5.log()).sub(z5).add(lnSqrt2PI);
          var rz = new Complex3(1, 0).div(z5);
          var rzz = rz.div(z5);
          var a3 = coeffs[0];
          var b3 = coeffs[1];
          var r3 = 2 * rzz.re;
          var s3 = rzz.re * rzz.re + rzz.im * rzz.im;
          for (var i5 = 2; i5 < 8; i5++) {
            var tmp = b3;
            b3 = -s3 * a3 + coeffs[i5];
            a3 = r3 * a3 + tmp;
          }
          var rightPart = rz.mul(rzz.mul(a3).add(b3));
          return leftPart.add(rightPart);
        }
        function lgammaRecurrence(z5) {
          var signflips = 0;
          var sb = 0;
          var shiftprod = z5;
          z5 = z5.add(1);
          while (z5.re <= SMALL_RE) {
            shiftprod = shiftprod.mul(z5);
            var nsb = shiftprod.im < 0 ? 1 : 0;
            if (nsb !== 0 && sb === 0)
              signflips++;
            sb = nsb;
            z5 = z5.add(1);
          }
          return lgammaStirling(z5).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/factorial.js
  var name264, dependencies264, createFactorial;
  var init_factorial2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/factorial.js"() {
      init_collection();
      init_factory();
      name264 = "factorial";
      dependencies264 = ["typed", "gamma"];
      createFactorial = /* @__PURE__ */ factory(name264, dependencies264, (_ref) => {
        var {
          typed: typed3,
          gamma: gamma2
        } = _ref;
        return typed3(name264, {
          number: function number2(n3) {
            if (n3 < 0) {
              throw new Error("Value must be non-negative");
            }
            return gamma2(n3 + 1);
          },
          BigNumber: function BigNumber2(n3) {
            if (n3.isNegative()) {
              throw new Error("Value must be non-negative");
            }
            return gamma2(n3.plus(1));
          },
          "Array | Matrix": typed3.referToSelf((self2) => (n3) => deepMap(n3, self2))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/kldivergence.js
  var name265, dependencies265, createKldivergence;
  var init_kldivergence2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/kldivergence.js"() {
      init_factory();
      name265 = "kldivergence";
      dependencies265 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
      createKldivergence = /* @__PURE__ */ factory(name265, dependencies265, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          divide: divide3,
          sum: sum3,
          multiply: multiply2,
          map: map3,
          dotDivide: dotDivide2,
          log: log4,
          isNumeric: isNumeric2
        } = _ref;
        return typed3(name265, {
          "Array, Array": function ArrayArray(q4, p3) {
            return _kldiv(matrix2(q4), matrix2(p3));
          },
          "Matrix, Array": function MatrixArray(q4, p3) {
            return _kldiv(q4, matrix2(p3));
          },
          "Array, Matrix": function ArrayMatrix(q4, p3) {
            return _kldiv(matrix2(q4), p3);
          },
          "Matrix, Matrix": function MatrixMatrix(q4, p3) {
            return _kldiv(q4, p3);
          }
        });
        function _kldiv(q4, p3) {
          var plength = p3.size().length;
          var qlength = q4.size().length;
          if (plength > 1) {
            throw new Error("first object must be one dimensional");
          }
          if (qlength > 1) {
            throw new Error("second object must be one dimensional");
          }
          if (plength !== qlength) {
            throw new Error("Length of two vectors must be equal");
          }
          var sumq = sum3(q4);
          if (sumq === 0) {
            throw new Error("Sum of elements in first object must be non zero");
          }
          var sump = sum3(p3);
          if (sump === 0) {
            throw new Error("Sum of elements in second object must be non zero");
          }
          var qnorm = divide3(q4, sum3(q4));
          var pnorm = divide3(p3, sum3(p3));
          var result = sum3(multiply2(qnorm, map3(dotDivide2(qnorm, pnorm), (x4) => log4(x4))));
          if (isNumeric2(result)) {
            return result;
          } else {
            return Number.NaN;
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/multinomial.js
  var name266, dependencies266, createMultinomial;
  var init_multinomial2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/multinomial.js"() {
      init_collection();
      init_factory();
      name266 = "multinomial";
      dependencies266 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
      createMultinomial = /* @__PURE__ */ factory(name266, dependencies266, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          divide: divide3,
          multiply: multiply2,
          factorial: factorial2,
          isInteger: isInteger3,
          isPositive: isPositive2
        } = _ref;
        return typed3(name266, {
          "Array | Matrix": function ArrayMatrix(a3) {
            var sum3 = 0;
            var denom = 1;
            deepForEach(a3, function(ai) {
              if (!isInteger3(ai) || !isPositive2(ai)) {
                throw new TypeError("Positive integer value expected in function multinomial");
              }
              sum3 = add3(sum3, ai);
              denom = multiply2(denom, factorial2(ai));
            });
            return divide3(factorial2(sum3), denom);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/permutations.js
  function isPositiveInteger3(n3) {
    return n3.isInteger() && n3.gte(0);
  }
  var name267, dependencies267, createPermutations;
  var init_permutations2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/permutations.js"() {
      init_number();
      init_product();
      init_factory();
      name267 = "permutations";
      dependencies267 = ["typed", "factorial"];
      createPermutations = /* @__PURE__ */ factory(name267, dependencies267, (_ref) => {
        var {
          typed: typed3,
          factorial: factorial2
        } = _ref;
        return typed3(name267, {
          "number | BigNumber": factorial2,
          "number, number": function numberNumber(n3, k4) {
            if (!isInteger(n3) || n3 < 0) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (!isInteger(k4) || k4 < 0) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (k4 > n3) {
              throw new TypeError("second argument k must be less than or equal to first argument n");
            }
            return product2(n3 - k4 + 1, n3);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(n3, k4) {
            var result, i5;
            if (!isPositiveInteger3(n3) || !isPositiveInteger3(k4)) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (k4.gt(n3)) {
              throw new TypeError("second argument k must be less than or equal to first argument n");
            }
            var one = n3.mul(0).add(1);
            result = one;
            for (i5 = n3.minus(k4).plus(1); i5.lte(n3); i5 = i5.plus(1)) {
              result = result.times(i5);
            }
            return result;
          }
          // TODO: implement support for collection in permutations
        });
      });
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t3 = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t3 - (me.c = t3 | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy(f3, t3) {
          t3.c = f3.c;
          t3.s0 = f3.s0;
          t3.s1 = f3.s1;
          t3.s2 = f3.s2;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n3 = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i5 = 0; i5 < data.length; i5++) {
              n3 += data.charCodeAt(i5);
              var h3 = 0.02519603282416938 * n3;
              n3 = h3 >>> 0;
              h3 -= n3;
              h3 *= n3;
              n3 = h3 >>> 0;
              h3 -= n3;
              n3 += h3 * 4294967296;
            }
            return (n3 >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t3 = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t3 ^ t3 >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 64; k4++) {
            me.x ^= strseed.charCodeAt(k4) | 0;
            me.next();
          }
        }
        function copy(f3, t3) {
          t3.x = f3.x;
          t3.y = f3.y;
          t3.z = f3.z;
          t3.w = f3.w;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t3 = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t3 ^ t3 << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 64; k4++) {
            me.x ^= strseed.charCodeAt(k4) | 0;
            if (k4 == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy(f3, t3) {
          t3.x = f3.x;
          t3.y = f3.y;
          t3.z = f3.z;
          t3.w = f3.w;
          t3.v = f3.v;
          t3.d = f3.d;
          return t3;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X2 = me.x, i5 = me.i, t3, v3, w4;
            t3 = X2[i5];
            t3 ^= t3 >>> 7;
            v3 = t3 ^ t3 << 24;
            t3 = X2[i5 + 1 & 7];
            v3 ^= t3 ^ t3 >>> 10;
            t3 = X2[i5 + 3 & 7];
            v3 ^= t3 ^ t3 >>> 3;
            t3 = X2[i5 + 4 & 7];
            v3 ^= t3 ^ t3 << 7;
            t3 = X2[i5 + 7 & 7];
            t3 = t3 ^ t3 << 13;
            v3 ^= t3 ^ t3 << 9;
            X2[i5] = v3;
            me.i = i5 + 1 & 7;
            return v3;
          };
          function init(me2, seed2) {
            var j4, w4, X2 = [];
            if (seed2 === (seed2 | 0)) {
              w4 = X2[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j4 = 0; j4 < seed2.length; ++j4) {
                X2[j4 & 7] = X2[j4 & 7] << 15 ^ seed2.charCodeAt(j4) + X2[j4 + 1 & 7] << 13;
              }
            }
            while (X2.length < 8)
              X2.push(0);
            for (j4 = 0; j4 < 8 && X2[j4] === 0; ++j4)
              ;
            if (j4 == 8)
              w4 = X2[7] = -1;
            else
              w4 = X2[j4];
            me2.x = X2;
            me2.i = 0;
            for (j4 = 256; j4 > 0; --j4) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy(f3, t3) {
          t3.x = f3.x.slice();
          t3.i = f3.i;
          return t3;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w4 = me.w, X2 = me.X, i5 = me.i, t3, v3;
            me.w = w4 = w4 + 1640531527 | 0;
            v3 = X2[i5 + 34 & 127];
            t3 = X2[i5 = i5 + 1 & 127];
            v3 ^= v3 << 13;
            t3 ^= t3 << 17;
            v3 ^= v3 >>> 15;
            t3 ^= t3 >>> 12;
            v3 = X2[i5] = v3 ^ t3;
            me.i = i5;
            return v3 + (w4 ^ w4 >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t3, v3, i5, j4, w4, X2 = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v3 = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v3 = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i5 = 0, j4 = -32; j4 < limit; ++j4) {
              if (seed2)
                v3 ^= seed2.charCodeAt((j4 + 32) % seed2.length);
              if (j4 === 0)
                w4 = v3;
              v3 ^= v3 << 10;
              v3 ^= v3 >>> 15;
              v3 ^= v3 << 4;
              v3 ^= v3 >>> 13;
              if (j4 >= 0) {
                w4 = w4 + 1640531527 | 0;
                t3 = X2[j4 & 127] ^= v3 + w4;
                i5 = 0 == t3 ? i5 + 1 : 0;
              }
            }
            if (i5 >= 128) {
              X2[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i5 = 127;
            for (j4 = 4 * 128; j4 > 0; --j4) {
              v3 = X2[i5 + 34 & 127];
              t3 = X2[i5 = i5 + 1 & 127];
              v3 ^= v3 << 13;
              t3 ^= t3 << 17;
              v3 ^= v3 >>> 15;
              t3 ^= t3 >>> 12;
              X2[i5] = v3 ^ t3;
            }
            me2.w = w4;
            me2.X = X2;
            me2.i = i5;
          }
          init(me, seed);
        }
        function copy(f3, t3) {
          t3.i = f3.i;
          t3.w = f3.w;
          t3.X = f3.X.slice();
          return t3;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        // window object or global
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b3 = me.b, c3 = me.c, d3 = me.d, a3 = me.a;
            b3 = b3 << 25 ^ b3 >>> 7 ^ c3;
            c3 = c3 - d3 | 0;
            d3 = d3 << 24 ^ d3 >>> 8 ^ a3;
            a3 = a3 - b3 | 0;
            me.b = b3 = b3 << 20 ^ b3 >>> 12 ^ c3;
            me.c = c3 = c3 - d3 | 0;
            me.d = d3 << 16 ^ c3 >>> 16 ^ a3;
            return me.a = a3 - b3 | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k4 = 0; k4 < strseed.length + 20; k4++) {
            me.b ^= strseed.charCodeAt(k4) | 0;
            me.next();
          }
        }
        function copy(f3, t3) {
          t3.a = f3.a;
          t3.b = f3.b;
          t3.c = f3.c;
          t3.d = f3.d;
          return t3;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global, pool, math2) {
        var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten3(
            options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n3 = arc4.g(chunks), d3 = startdenom, x4 = 0;
            while (n3 < significance) {
              n3 = (n3 + x4) * width;
              d3 *= width;
              x4 = arc4.g(1);
            }
            while (n3 >= overflow) {
              n3 /= 2;
              d3 /= 2;
              x4 >>>= 1;
            }
            return (n3 + x4) / d3;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math2[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math2,
            options.state
          );
        }
        function ARC4(key) {
          var t3, keylen = key.length, me = this, i5 = 0, j4 = me.i = me.j = 0, s3 = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i5 < width) {
            s3[i5] = i5++;
          }
          for (i5 = 0; i5 < width; i5++) {
            s3[i5] = s3[j4 = mask & j4 + key[i5 % keylen] + (t3 = s3[i5])];
            s3[j4] = t3;
          }
          (me.g = function(count2) {
            var t4, r3 = 0, i6 = me.i, j5 = me.j, s4 = me.S;
            while (count2--) {
              t4 = s4[i6 = mask & i6 + 1];
              r3 = r3 * width + s4[mask & (s4[i6] = s4[j5 = mask & j5 + t4]) + (s4[j5] = t4)];
            }
            me.i = i6;
            me.j = j5;
            return r3;
          })(width);
        }
        function copy(f3, t3) {
          t3.i = f3.i;
          t3.j = f3.j;
          t3.S = f3.S.slice();
          return t3;
        }
        ;
        function flatten3(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten3(obj[prop], depth - 1));
              } catch (e6) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j4 = 0;
          while (j4 < stringseed.length) {
            key[mask & j4] = mask & (smear ^= key[mask & j4] * 19) + stringseed.charCodeAt(j4++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e6) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
          }
        }
        function tostring(a3) {
          return String.fromCharCode.apply(0, a3);
        }
        mixkey(math2.random(), pool);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom2;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom2;
          });
        } else {
          math2["seed" + rngname] = seedrandom2;
        }
      })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        typeof self !== "undefined" ? self : exports,
        [],
        // pool: entropy pool starts empty
        Math
        // math: package containing random, pow, and seedrandom
      );
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
  function createRng(randomSeed) {
    var random3;
    function setSeed(seed) {
      random3 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
    }
    setSeed(randomSeed);
    function rng2() {
      return random3();
    }
    return rng2;
  }
  var import_seedrandom, singletonRandom;
  var init_seededRNG = __esm({
    "node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js"() {
      import_seedrandom = __toESM(require_seedrandom2(), 1);
      singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/pickRandom.js
  var name268, dependencies268, createPickRandom;
  var init_pickRandom2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/pickRandom.js"() {
      init_array();
      init_factory();
      init_is();
      init_seededRNG();
      name268 = "pickRandom";
      dependencies268 = ["typed", "config", "?on"];
      createPickRandom = /* @__PURE__ */ factory(name268, dependencies268, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          on: on2
        } = _ref;
        var rng2 = createRng(config4.randomSeed);
        if (on2) {
          on2("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng2 = createRng(curr.randomSeed);
            }
          });
        }
        return typed3(name268, {
          "Array | Matrix": function ArrayMatrix(possibles) {
            return _pickRandom(possibles, {});
          },
          "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
            return _pickRandom(possibles, options);
          },
          "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
            return _pickRandom(possibles, {
              number: number2
            });
          },
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
            return _pickRandom(possibles, {
              weights
            });
          },
          "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
            return _pickRandom(possibles, {
              number: number2,
              weights
            });
          },
          "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
            return _pickRandom(possibles, {
              number: number2,
              weights
            });
          }
        });
        function _pickRandom(possibles, _ref2) {
          var {
            number: number2,
            weights,
            elementWise = true
          } = _ref2;
          var single = typeof number2 === "undefined";
          if (single) {
            number2 = 1;
          }
          var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
          possibles = possibles.valueOf();
          if (weights) {
            weights = weights.valueOf();
          }
          if (elementWise === true) {
            possibles = flatten(possibles);
            weights = flatten(weights);
          }
          var totalWeights = 0;
          if (typeof weights !== "undefined") {
            if (weights.length !== possibles.length) {
              throw new Error("Weights must have the same length as possibles");
            }
            for (var i5 = 0, len = weights.length; i5 < len; i5++) {
              if (!isNumber(weights[i5]) || weights[i5] < 0) {
                throw new Error("Weights must be an array of positive numbers");
              }
              totalWeights += weights[i5];
            }
          }
          var length = possibles.length;
          var result = [];
          var pick;
          while (result.length < number2) {
            if (typeof weights === "undefined") {
              pick = possibles[Math.floor(rng2() * length)];
            } else {
              var randKey = rng2() * totalWeights;
              for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
                randKey -= weights[_i];
                if (randKey < 0) {
                  pick = possibles[_i];
                  break;
                }
              }
            }
            result.push(pick);
          }
          return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
  function randomMatrix(size2, random3) {
    var data = [];
    size2 = size2.slice(0);
    if (size2.length > 1) {
      for (var i5 = 0, length = size2.shift(); i5 < length; i5++) {
        data.push(randomMatrix(size2, random3));
      }
    } else {
      for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
        data.push(random3());
      }
    }
    return data;
  }
  var init_randomMatrix = __esm({
    "node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/random.js
  var name269, dependencies269, createRandom;
  var init_random2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/random.js"() {
      init_factory();
      init_is();
      init_seededRNG();
      init_randomMatrix();
      name269 = "random";
      dependencies269 = ["typed", "config", "?on"];
      createRandom = /* @__PURE__ */ factory(name269, dependencies269, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          on: on2
        } = _ref;
        var rng2 = createRng(config4.randomSeed);
        if (on2) {
          on2("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng2 = createRng(curr.randomSeed);
            }
          });
        }
        return typed3(name269, {
          "": () => _random(0, 1),
          number: (max3) => _random(0, max3),
          "number, number": (min3, max3) => _random(min3, max3),
          "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
          "Array | Matrix, number": (size2, max3) => _randomMatrix(size2, 0, max3),
          "Array | Matrix, number, number": (size2, min3, max3) => _randomMatrix(size2, min3, max3)
        });
        function _randomMatrix(size2, min3, max3) {
          var res = randomMatrix(size2.valueOf(), () => _random(min3, max3));
          return isMatrix(size2) ? size2.create(res) : res;
        }
        function _random(min3, max3) {
          return min3 + rng2() * (max3 - min3);
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/randomInt.js
  var name270, dependencies270, createRandomInt;
  var init_randomInt2 = __esm({
    "node_modules/mathjs/lib/esm/function/probability/randomInt.js"() {
      init_factory();
      init_randomMatrix();
      init_seededRNG();
      init_is();
      name270 = "randomInt";
      dependencies270 = ["typed", "config", "?on"];
      createRandomInt = /* @__PURE__ */ factory(name270, dependencies270, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          on: on2
        } = _ref;
        var rng2 = createRng(config4.randomSeed);
        if (on2) {
          on2("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng2 = createRng(curr.randomSeed);
            }
          });
        }
        return typed3(name270, {
          "": () => _randomInt(0, 1),
          number: (max3) => _randomInt(0, max3),
          "number, number": (min3, max3) => _randomInt(min3, max3),
          "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
          "Array | Matrix, number": (size2, max3) => _randomIntMatrix(size2, 0, max3),
          "Array | Matrix, number, number": (size2, min3, max3) => _randomIntMatrix(size2, min3, max3)
        });
        function _randomIntMatrix(size2, min3, max3) {
          var res = randomMatrix(size2.valueOf(), () => _randomInt(min3, max3));
          return isMatrix(size2) ? size2.create(res) : res;
        }
        function _randomInt(min3, max3) {
          return Math.floor(min3 + rng2() * (max3 - min3));
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
  var name271, dependencies271, createStirlingS2;
  var init_stirlingS22 = __esm({
    "node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js"() {
      init_factory();
      init_is();
      name271 = "stirlingS2";
      dependencies271 = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
      createStirlingS2 = /* @__PURE__ */ factory(name271, dependencies271, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          subtract: subtract2,
          multiplyScalar: multiplyScalar2,
          divideScalar: divideScalar2,
          pow: pow3,
          factorial: factorial2,
          combinations: combinations2,
          isNegative: isNegative2,
          isInteger: isInteger3,
          number: number2,
          bignumber: bignumber2,
          larger: larger2
        } = _ref;
        var smallCache = [];
        var bigCache = [];
        return typed3(name271, {
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n3, k4) {
            if (!isInteger3(n3) || isNegative2(n3) || !isInteger3(k4) || isNegative2(k4)) {
              throw new TypeError("Non-negative integer value expected in function stirlingS2");
            } else if (larger2(k4, n3)) {
              throw new TypeError("k must be less than or equal to n in function stirlingS2");
            }
            var big = !(isNumber(n3) && isNumber(k4));
            var cache = big ? bigCache : smallCache;
            var make = big ? bignumber2 : number2;
            var nn2 = number2(n3);
            var nk = number2(k4);
            if (cache[nn2] && cache[nn2].length > nk) {
              return cache[nn2][nk];
            }
            for (var m3 = 0; m3 <= nn2; ++m3) {
              if (!cache[m3]) {
                cache[m3] = [m3 === 0 ? make(1) : make(0)];
              }
              if (m3 === 0)
                continue;
              var row2 = cache[m3];
              var prev = cache[m3 - 1];
              for (var i5 = row2.length; i5 <= m3 && i5 <= nk; ++i5) {
                if (i5 === m3) {
                  row2[i5] = 1;
                } else {
                  row2[i5] = addScalar2(multiplyScalar2(make(i5), prev[i5]), prev[i5 - 1]);
                }
              }
            }
            return cache[nn2][nk];
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
  var name272, dependencies272, createBellNumbers;
  var init_bellNumbers2 = __esm({
    "node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js"() {
      init_factory();
      name272 = "bellNumbers";
      dependencies272 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
      createBellNumbers = /* @__PURE__ */ factory(name272, dependencies272, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          isNegative: isNegative2,
          isInteger: isInteger3,
          stirlingS2: stirlingS22
        } = _ref;
        return typed3(name272, {
          "number | BigNumber": function numberBigNumber(n3) {
            if (!isInteger3(n3) || isNegative2(n3)) {
              throw new TypeError("Non-negative integer value expected in function bellNumbers");
            }
            var result = 0;
            for (var i5 = 0; i5 <= n3; i5++) {
              result = addScalar2(result, stirlingS22(n3, i5));
            }
            return result;
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
  var name273, dependencies273, createCatalan;
  var init_catalan2 = __esm({
    "node_modules/mathjs/lib/esm/function/combinatorics/catalan.js"() {
      init_factory();
      name273 = "catalan";
      dependencies273 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
      createCatalan = /* @__PURE__ */ factory(name273, dependencies273, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          divideScalar: divideScalar2,
          multiplyScalar: multiplyScalar2,
          combinations: combinations2,
          isNegative: isNegative2,
          isInteger: isInteger3
        } = _ref;
        return typed3(name273, {
          "number | BigNumber": function numberBigNumber(n3) {
            if (!isInteger3(n3) || isNegative2(n3)) {
              throw new TypeError("Non-negative integer value expected in function catalan");
            }
            return divideScalar2(combinations2(multiplyScalar2(n3, 2), n3), addScalar2(n3, 1));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/composition.js
  var name274, dependencies274, createComposition;
  var init_composition2 = __esm({
    "node_modules/mathjs/lib/esm/function/combinatorics/composition.js"() {
      init_factory();
      name274 = "composition";
      dependencies274 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
      createComposition = /* @__PURE__ */ factory(name274, dependencies274, (_ref) => {
        var {
          typed: typed3,
          addScalar: addScalar2,
          combinations: combinations2,
          isPositive: isPositive2,
          isNegative: isNegative2,
          isInteger: isInteger3,
          larger: larger2
        } = _ref;
        return typed3(name274, {
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n3, k4) {
            if (!isInteger3(n3) || !isPositive2(n3) || !isInteger3(k4) || !isPositive2(k4)) {
              throw new TypeError("Positive integer value expected in function composition");
            } else if (larger2(k4, n3)) {
              throw new TypeError("k must be less than or equal to n in function composition");
            }
            return combinations2(addScalar2(n3, -1), addScalar2(k4, -1));
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/leafCount.js
  var name275, dependencies275, createLeafCount;
  var init_leafCount2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/leafCount.js"() {
      init_factory();
      name275 = "leafCount";
      dependencies275 = ["parse", "typed"];
      createLeafCount = /* @__PURE__ */ factory(name275, dependencies275, (_ref) => {
        var {
          parse: parse2,
          typed: typed3
        } = _ref;
        function countLeaves(node) {
          var count2 = 0;
          node.forEach((n3) => {
            count2 += countLeaves(n3);
          });
          return count2 || 1;
        }
        return typed3(name275, {
          Node: function Node2(expr) {
            return countLeaves(expr);
          }
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
  function isNumericNode(x4) {
    return isConstantNode(x4) || isOperatorNode(x4) && x4.isUnary() && isConstantNode(x4.args[0]);
  }
  function isConstantExpression(x4) {
    if (isConstantNode(x4)) {
      return true;
    }
    if ((isFunctionNode(x4) || isOperatorNode(x4)) && x4.args.every(isConstantExpression)) {
      return true;
    }
    if (isParenthesisNode(x4) && isConstantExpression(x4.content)) {
      return true;
    }
    return false;
  }
  var init_wildcards = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js"() {
      init_is();
      init_is();
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread3(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = null != arguments[i5] ? arguments[i5] : {};
      i5 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var name276, dependencies276, createUtil;
  var init_util = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"() {
      init_defineProperty();
      init_is();
      init_factory();
      init_object();
      name276 = "simplifyUtil";
      dependencies276 = ["FunctionNode", "OperatorNode", "SymbolNode"];
      createUtil = /* @__PURE__ */ factory(name276, dependencies276, (_ref) => {
        var {
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        var T4 = true;
        var F4 = false;
        var defaultName = "defaultF";
        var defaultContext = {
          /*      */
          add: {
            trivial: T4,
            total: T4,
            commutative: T4,
            associative: T4
          },
          /**/
          unaryPlus: {
            trivial: T4,
            total: T4,
            commutative: T4,
            associative: T4
          },
          /* */
          subtract: {
            trivial: F4,
            total: T4,
            commutative: F4,
            associative: F4
          },
          /* */
          multiply: {
            trivial: T4,
            total: T4,
            commutative: T4,
            associative: T4
          },
          /*   */
          divide: {
            trivial: F4,
            total: T4,
            commutative: F4,
            associative: F4
          },
          /*    */
          paren: {
            trivial: T4,
            total: T4,
            commutative: T4,
            associative: F4
          },
          /* */
          defaultF: {
            trivial: F4,
            total: T4,
            commutative: F4,
            associative: F4
          }
        };
        var realContext = {
          divide: {
            total: F4
          },
          log: {
            total: F4
          }
        };
        var positiveContext = {
          subtract: {
            total: F4
          },
          abs: {
            trivial: T4
          },
          log: {
            total: T4
          }
        };
        function hasProperty(nodeOrName, property) {
          var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
          var name307 = defaultName;
          if (typeof nodeOrName === "string") {
            name307 = nodeOrName;
          } else if (isOperatorNode(nodeOrName)) {
            name307 = nodeOrName.fn.toString();
          } else if (isFunctionNode(nodeOrName)) {
            name307 = nodeOrName.name;
          } else if (isParenthesisNode(nodeOrName)) {
            name307 = "paren";
          }
          if (hasOwnProperty2(context, name307)) {
            var properties2 = context[name307];
            if (hasOwnProperty2(properties2, property)) {
              return properties2[property];
            }
            if (hasOwnProperty2(defaultContext, name307)) {
              return defaultContext[name307][property];
            }
          }
          if (hasOwnProperty2(context, defaultName)) {
            var _properties = context[defaultName];
            if (hasOwnProperty2(_properties, property)) {
              return _properties[property];
            }
            return defaultContext[defaultName][property];
          }
          if (hasOwnProperty2(defaultContext, name307)) {
            var _properties2 = defaultContext[name307];
            if (hasOwnProperty2(_properties2, property)) {
              return _properties2[property];
            }
          }
          return defaultContext[defaultName][property];
        }
        function isCommutative(node) {
          var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
          return hasProperty(node, "commutative", context);
        }
        function isAssociative(node) {
          var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
          return hasProperty(node, "associative", context);
        }
        function mergeContext(primary, secondary) {
          var merged = _objectSpread3({}, primary);
          for (var prop in secondary) {
            if (hasOwnProperty2(primary, prop)) {
              merged[prop] = _objectSpread3(_objectSpread3({}, secondary[prop]), primary[prop]);
            } else {
              merged[prop] = secondary[prop];
            }
          }
          return merged;
        }
        function flatten3(node, context) {
          if (!node.args || node.args.length === 0) {
            return node;
          }
          node.args = allChildren(node, context);
          for (var i5 = 0; i5 < node.args.length; i5++) {
            flatten3(node.args[i5], context);
          }
        }
        function allChildren(node, context) {
          var op;
          var children = [];
          var findChildren = function findChildren2(node2) {
            for (var i5 = 0; i5 < node2.args.length; i5++) {
              var child = node2.args[i5];
              if (isOperatorNode(child) && op === child.op) {
                findChildren2(child);
              } else {
                children.push(child);
              }
            }
          };
          if (isAssociative(node, context)) {
            op = node.op;
            findChildren(node);
            return children;
          } else {
            return node.args;
          }
        }
        function unflattenr(node, context) {
          if (!node.args || node.args.length === 0) {
            return;
          }
          var makeNode = createMakeNodeFunction(node);
          var l3 = node.args.length;
          for (var i5 = 0; i5 < l3; i5++) {
            unflattenr(node.args[i5], context);
          }
          if (l3 > 2 && isAssociative(node, context)) {
            var curnode = node.args.pop();
            while (node.args.length > 0) {
              curnode = makeNode([node.args.pop(), curnode]);
            }
            node.args = curnode.args;
          }
        }
        function unflattenl(node, context) {
          if (!node.args || node.args.length === 0) {
            return;
          }
          var makeNode = createMakeNodeFunction(node);
          var l3 = node.args.length;
          for (var i5 = 0; i5 < l3; i5++) {
            unflattenl(node.args[i5], context);
          }
          if (l3 > 2 && isAssociative(node, context)) {
            var curnode = node.args.shift();
            while (node.args.length > 0) {
              curnode = makeNode([curnode, node.args.shift()]);
            }
            node.args = curnode.args;
          }
        }
        function createMakeNodeFunction(node) {
          if (isOperatorNode(node)) {
            return function(args) {
              try {
                return new OperatorNode2(node.op, node.fn, args, node.implicit);
              } catch (err) {
                console.error(err);
                return [];
              }
            };
          } else {
            return function(args) {
              return new FunctionNode2(new SymbolNode2(node.name), args);
            };
          }
        }
        return {
          createMakeNodeFunction,
          hasProperty,
          isCommutative,
          isAssociative,
          mergeContext,
          flatten: flatten3,
          allChildren,
          unflattenr,
          unflattenl,
          defaultContext,
          realContext,
          positiveContext
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify.js
  var name277, dependencies277, createSimplify;
  var init_simplify2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/simplify.js"() {
      init_is();
      init_wildcards();
      init_factory();
      init_util();
      init_object();
      init_map();
      name277 = "simplify";
      dependencies277 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      createSimplify = /* @__PURE__ */ factory(name277, dependencies277, (_ref) => {
        var {
          config: config4,
          typed: typed3,
          parse: parse2,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          pow: pow3,
          isZero: isZero2,
          equal: equal2,
          resolve: resolve2,
          simplifyConstant: simplifyConstant2,
          simplifyCore: simplifyCore2,
          fraction: fraction2,
          bignumber: bignumber2,
          mathWithTransform: mathWithTransform2,
          matrix: matrix2,
          AccessorNode: AccessorNode2,
          ArrayNode: ArrayNode2,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          IndexNode: IndexNode2,
          ObjectNode: ObjectNode2,
          OperatorNode: OperatorNode2,
          ParenthesisNode: ParenthesisNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        var {
          hasProperty,
          isCommutative,
          isAssociative,
          mergeContext,
          flatten: flatten3,
          unflattenr,
          unflattenl,
          createMakeNodeFunction,
          defaultContext,
          realContext,
          positiveContext
        } = createUtil({
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2
        });
        typed3.addConversion({
          from: "Object",
          to: "Map",
          convert: createMap
        });
        var simplify2 = typed3("simplify", {
          Node: _simplify,
          "Node, Map": (expr, scope) => _simplify(expr, false, scope),
          "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
          "Node, Array": _simplify,
          "Node, Array, Map": _simplify,
          "Node, Array, Map, Object": _simplify
        });
        typed3.removeConversion({
          from: "Object",
          to: "Map",
          convert: createMap
        });
        simplify2.defaultContext = defaultContext;
        simplify2.realContext = realContext;
        simplify2.positiveContext = positiveContext;
        function removeParens(node) {
          return node.transform(function(node2, path, parent) {
            return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
          });
        }
        var SUPPORTED_CONSTANTS = {
          true: true,
          false: true,
          e: true,
          i: true,
          Infinity: true,
          LN2: true,
          LN10: true,
          LOG2E: true,
          LOG10E: true,
          NaN: true,
          phi: true,
          pi: true,
          SQRT1_2: true,
          SQRT2: true,
          tau: true
          // null: false,
          // undefined: false,
          // version: false,
        };
        simplify2.rules = [
          simplifyCore2,
          // { l: 'n+0', r: 'n' },     // simplifyCore
          // { l: 'n^0', r: '1' },     // simplifyCore
          // { l: '0*n', r: '0' },     // simplifyCore
          // { l: 'n/n', r: '1'},      // simplifyCore
          // { l: 'n^1', r: 'n' },     // simplifyCore
          // { l: '+n1', r:'n1' },     // simplifyCore
          // { l: 'n--n1', r:'n+n1' }, // simplifyCore
          {
            l: "log(e)",
            r: "1"
          },
          // temporary rules
          // Note initially we tend constants to the right because like-term
          // collection prefers the left, and we would rather collect nonconstants
          {
            s: "n-n1 -> n+-n1",
            // temporarily replace 'subtract' so we can further flatten the 'add' operator
            assuming: {
              subtract: {
                total: true
              }
            }
          },
          {
            s: "n-n -> 0",
            // partial alternative when we can't always subtract
            assuming: {
              subtract: {
                total: false
              }
            }
          },
          {
            s: "-(cl*v) -> v * (-cl)",
            // make non-constant terms positive
            assuming: {
              multiply: {
                commutative: true
              },
              subtract: {
                total: true
              }
            }
          },
          {
            s: "-(cl*v) -> (-cl) * v",
            // non-commutative version, part 1
            assuming: {
              multiply: {
                commutative: false
              },
              subtract: {
                total: true
              }
            }
          },
          {
            s: "-(v*cl) -> v * (-cl)",
            // non-commutative version, part 2
            assuming: {
              multiply: {
                commutative: false
              },
              subtract: {
                total: true
              }
            }
          },
          {
            l: "-(n1/n2)",
            r: "-n1/n2"
          },
          {
            l: "-v",
            r: "v * (-1)"
          },
          // finish making non-constant terms positive
          {
            l: "(n1 + n2)*(-1)",
            r: "n1*(-1) + n2*(-1)",
            repeat: true
          },
          // expand negations to achieve as much sign cancellation as possible
          {
            l: "n/n1^n2",
            r: "n*n1^-n2"
          },
          // temporarily replace 'divide' so we can further flatten the 'multiply' operator
          {
            l: "n/n1",
            r: "n*n1^-1"
          },
          {
            s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
            assuming: {
              multiply: {
                commutative: true
              }
            }
          },
          {
            s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          // expand nested exponentiation
          {
            s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
            assuming: {
              divide: {
                total: true
              }
            }
            // 1/(1/n) = n needs 1/n to exist
          },
          // collect like factors; into a sum, only do this for nonconstants
          {
            l: " vd   * ( vd   * n1 + n2)",
            r: "vd^2       * n1 +  vd   * n2"
          },
          {
            s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
            assuming: {
              divide: {
                total: true
              }
            }
            // v*1/v = v^(1+-1) needs 1/v
          },
          {
            s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
            assuming: {
              divide: {
                total: true
              }
            }
          },
          {
            s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
            assuming: {
              divide: {
                total: true
              }
            }
          },
          {
            l: "n*n",
            r: "n^2"
          },
          {
            s: "n * n^n1 -> n^(n1+1)",
            assuming: {
              divide: {
                total: true
              }
            }
            // n*1/n = n^(-1+1) needs 1/n
          },
          {
            s: "n^n1 * n^n2 -> n^(n1+n2)",
            assuming: {
              divide: {
                total: true
              }
            }
            // ditto for n^2*1/n^2
          },
          // Unfortunately, to deal with more complicated cancellations, it
          // becomes necessary to simplify constants twice per pass. It's not
          // terribly expensive compared to matching rules, so this should not
          // pose a performance problem.
          simplifyConstant2,
          // First: before collecting like terms
          // collect like terms
          {
            s: "n+n -> 2*n",
            assuming: {
              add: {
                total: true
              }
            }
            // 2 = 1 + 1 needs to exist
          },
          {
            l: "n+-n",
            r: "0"
          },
          {
            l: "vd*n + vd",
            r: "vd*(n+1)"
          },
          // NOTE: leftmost position is special:
          {
            l: "n3*n1 + n3*n2",
            r: "n3*(n1+n2)"
          },
          // All sub-monomials tried there.
          {
            l: "n3^(-n4)*n1 +   n3  * n2",
            r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
          },
          {
            l: "n3^(-n4)*n1 + n3^n5 * n2",
            r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
          },
          // noncommutative additional cases (term collection & factoring)
          {
            s: "n*vd + vd -> (n+1)*vd",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "vd + n*vd -> (1+n)*vd",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n^n1 * n -> n^(n1+1)",
            assuming: {
              divide: {
                total: true
              },
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            l: "n*cd + cd",
            r: "(n+1)*cd"
          },
          {
            s: "cd*n + cd -> cd*(n+1)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "cd + cd*n -> cd*(1+n)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          simplifyConstant2,
          // Second: before returning expressions to "standard form"
          // make factors positive (and undo 'make non-constant terms positive')
          {
            s: "(-n)*n1 -> -(n*n1)",
            assuming: {
              subtract: {
                total: true
              }
            }
          },
          {
            s: "n1*(-n) -> -(n1*n)",
            // in case * non-commutative
            assuming: {
              subtract: {
                total: true
              },
              multiply: {
                commutative: false
              }
            }
          },
          // final ordering of constants
          {
            s: "ce+ve -> ve+ce",
            assuming: {
              add: {
                commutative: true
              }
            },
            imposeContext: {
              add: {
                commutative: false
              }
            }
          },
          {
            s: "vd*cd -> cd*vd",
            assuming: {
              multiply: {
                commutative: true
              }
            },
            imposeContext: {
              multiply: {
                commutative: false
              }
            }
          },
          // undo temporary rules
          // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
          {
            l: "n+-n1",
            r: "n-n1"
          },
          // undo replace 'subtract'
          {
            l: "n+-(n1)",
            r: "n-(n1)"
          },
          {
            s: "n*(n1^-1) -> n/n1",
            // undo replace 'divide'; for * commutative
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            s: "n*n1^-n2 -> n/n1^n2",
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            s: "n^-1 -> 1/n",
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            l: "n^1",
            r: "n"
          },
          // can be produced by power cancellation
          {
            s: "n*(n1/n2) -> (n*n1)/n2",
            // '*' before '/'
            assuming: {
              multiply: {
                associative: true
              }
            }
          },
          {
            s: "n-(n1+n2) -> n-n1-n2",
            // '-' before '+'
            assuming: {
              addition: {
                associative: true,
                commutative: true
              }
            }
          },
          // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
          // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
          // simplifyConstant can leave an extra factor of 1, which can always
          // be eliminated, since the identity always commutes
          {
            l: "1*n",
            r: "n",
            imposeContext: {
              multiply: {
                commutative: true
              }
            }
          },
          {
            s: "n1/(n2/n3) -> (n1*n3)/n2",
            assuming: {
              multiply: {
                associative: true
              }
            }
          },
          {
            l: "n1/(-n2)",
            r: "-n1/n2"
          }
        ];
        function _canonicalizeRule(ruleObject, context) {
          var newRule = {};
          if (ruleObject.s) {
            var lr = ruleObject.s.split("->");
            if (lr.length === 2) {
              newRule.l = lr[0];
              newRule.r = lr[1];
            } else {
              throw SyntaxError("Could not parse rule: " + ruleObject.s);
            }
          } else {
            newRule.l = ruleObject.l;
            newRule.r = ruleObject.r;
          }
          newRule.l = removeParens(parse2(newRule.l));
          newRule.r = removeParens(parse2(newRule.r));
          for (var prop of ["imposeContext", "repeat", "assuming"]) {
            if (prop in ruleObject) {
              newRule[prop] = ruleObject[prop];
            }
          }
          if (ruleObject.evaluate) {
            newRule.evaluate = parse2(ruleObject.evaluate);
          }
          if (isAssociative(newRule.l, context)) {
            var nonCommutative = !isCommutative(newRule.l, context);
            var leftExpandsym;
            if (nonCommutative)
              leftExpandsym = _getExpandPlaceholderSymbol();
            var makeNode = createMakeNodeFunction(newRule.l);
            var expandsym = _getExpandPlaceholderSymbol();
            newRule.expanded = {};
            newRule.expanded.l = makeNode([newRule.l, expandsym]);
            flatten3(newRule.expanded.l, context);
            unflattenr(newRule.expanded.l, context);
            newRule.expanded.r = makeNode([newRule.r, expandsym]);
            if (nonCommutative) {
              newRule.expandedNC1 = {};
              newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
              newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
              newRule.expandedNC2 = {};
              newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
              newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
            }
          }
          return newRule;
        }
        function _buildRules(rules, context) {
          var ruleSet = [];
          for (var i5 = 0; i5 < rules.length; i5++) {
            var rule = rules[i5];
            var newRule = void 0;
            var ruleType = typeof rule;
            switch (ruleType) {
              case "string":
                rule = {
                  s: rule
                };
              case "object":
                newRule = _canonicalizeRule(rule, context);
                break;
              case "function":
                newRule = rule;
                break;
              default:
                throw TypeError("Unsupported type of rule: " + ruleType);
            }
            ruleSet.push(newRule);
          }
          return ruleSet;
        }
        var _lastsym = 0;
        function _getExpandPlaceholderSymbol() {
          return new SymbolNode2("_p" + _lastsym++);
        }
        function _simplify(expr, rules) {
          var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var debug = options.consoleDebug;
          rules = _buildRules(rules || simplify2.rules, options.context);
          var res = resolve2(expr, scope);
          res = removeParens(res);
          var visited = {};
          var str = res.toString({
            parenthesis: "all"
          });
          while (!visited[str]) {
            visited[str] = true;
            _lastsym = 0;
            var laststr = str;
            if (debug)
              console.log("Working on: ", str);
            for (var i5 = 0; i5 < rules.length; i5++) {
              var rulestr = "";
              if (typeof rules[i5] === "function") {
                res = rules[i5](res, options);
                if (debug)
                  rulestr = rules[i5].name;
              } else {
                flatten3(res, options.context);
                res = applyRule(res, rules[i5], options.context);
                if (debug) {
                  rulestr = "".concat(rules[i5].l.toString(), " -> ").concat(rules[i5].r.toString());
                }
              }
              if (debug) {
                var newstr = res.toString({
                  parenthesis: "all"
                });
                if (newstr !== laststr) {
                  console.log("Applying", rulestr, "produced", newstr);
                  laststr = newstr;
                }
              }
              unflattenl(res, options.context);
            }
            str = res.toString({
              parenthesis: "all"
            });
          }
          return res;
        }
        function mapRule(nodes, rule, context) {
          var resNodes = nodes;
          if (nodes) {
            for (var i5 = 0; i5 < nodes.length; ++i5) {
              var newNode = applyRule(nodes[i5], rule, context);
              if (newNode !== nodes[i5]) {
                if (resNodes === nodes) {
                  resNodes = nodes.slice();
                }
                resNodes[i5] = newNode;
              }
            }
          }
          return resNodes;
        }
        function applyRule(node, rule, context) {
          if (rule.assuming) {
            for (var symbol in rule.assuming) {
              for (var property in rule.assuming[symbol]) {
                if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
                  return node;
                }
              }
            }
          }
          var mergedContext = mergeContext(rule.imposeContext, context);
          var res = node;
          if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
            var newArgs = mapRule(res.args, rule, context);
            if (newArgs !== res.args) {
              res = res.clone();
              res.args = newArgs;
            }
          } else if (res instanceof ParenthesisNode2) {
            if (res.content) {
              var newContent = applyRule(res.content, rule, context);
              if (newContent !== res.content) {
                res = new ParenthesisNode2(newContent);
              }
            }
          } else if (res instanceof ArrayNode2) {
            var newItems = mapRule(res.items, rule, context);
            if (newItems !== res.items) {
              res = new ArrayNode2(newItems);
            }
          } else if (res instanceof AccessorNode2) {
            var newObj = res.object;
            if (res.object) {
              newObj = applyRule(res.object, rule, context);
            }
            var newIndex = res.index;
            if (res.index) {
              newIndex = applyRule(res.index, rule, context);
            }
            if (newObj !== res.object || newIndex !== res.index) {
              res = new AccessorNode2(newObj, newIndex);
            }
          } else if (res instanceof IndexNode2) {
            var newDims = mapRule(res.dimensions, rule, context);
            if (newDims !== res.dimensions) {
              res = new IndexNode2(newDims);
            }
          } else if (res instanceof ObjectNode2) {
            var changed = false;
            var newProps = {};
            for (var prop in res.properties) {
              newProps[prop] = applyRule(res.properties[prop], rule, context);
              if (newProps[prop] !== res.properties[prop]) {
                changed = true;
              }
            }
            if (changed) {
              res = new ObjectNode2(newProps);
            }
          }
          var repl = rule.r;
          var matches = _ruleMatch(rule.l, res, mergedContext)[0];
          if (!matches && rule.expanded) {
            repl = rule.expanded.r;
            matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
          }
          if (!matches && rule.expandedNC1) {
            repl = rule.expandedNC1.r;
            matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
            if (!matches) {
              repl = rule.expandedNC2.r;
              matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
            }
          }
          if (matches) {
            var implicit = res.implicit;
            res = repl.clone();
            if (implicit && "implicit" in repl) {
              res.implicit = true;
            }
            res = res.transform(function(node2) {
              if (node2.isSymbolNode && hasOwnProperty2(matches.placeholders, node2.name)) {
                return matches.placeholders[node2.name].clone();
              } else {
                return node2;
              }
            });
          }
          if (rule.repeat && res !== node) {
            res = applyRule(res, rule, context);
          }
          return res;
        }
        function getSplits(node, context) {
          var res = [];
          var right, rightArgs;
          var makeNode = createMakeNodeFunction(node);
          if (isCommutative(node, context)) {
            for (var i5 = 0; i5 < node.args.length; i5++) {
              rightArgs = node.args.slice(0);
              rightArgs.splice(i5, 1);
              right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
              res.push(makeNode([node.args[i5], right]));
            }
          } else {
            for (var _i = 1; _i < node.args.length; _i++) {
              var left = node.args[0];
              if (_i > 1) {
                left = makeNode(node.args.slice(0, _i));
              }
              rightArgs = node.args.slice(_i);
              right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
              res.push(makeNode([left, right]));
            }
          }
          return res;
        }
        function mergeMatch(match1, match2) {
          var res = {
            placeholders: {}
          };
          if (!match1.placeholders && !match2.placeholders) {
            return res;
          } else if (!match1.placeholders) {
            return match2;
          } else if (!match2.placeholders) {
            return match1;
          }
          for (var key in match1.placeholders) {
            if (hasOwnProperty2(match1.placeholders, key)) {
              res.placeholders[key] = match1.placeholders[key];
              if (hasOwnProperty2(match2.placeholders, key)) {
                if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
                  return null;
                }
              }
            }
          }
          for (var _key in match2.placeholders) {
            if (hasOwnProperty2(match2.placeholders, _key)) {
              res.placeholders[_key] = match2.placeholders[_key];
            }
          }
          return res;
        }
        function combineChildMatches(list1, list2) {
          var res = [];
          if (list1.length === 0 || list2.length === 0) {
            return res;
          }
          var merged;
          for (var i1 = 0; i1 < list1.length; i1++) {
            for (var i22 = 0; i22 < list2.length; i22++) {
              merged = mergeMatch(list1[i1], list2[i22]);
              if (merged) {
                res.push(merged);
              }
            }
          }
          return res;
        }
        function mergeChildMatches(childMatches) {
          if (childMatches.length === 0) {
            return childMatches;
          }
          var sets = childMatches.reduce(combineChildMatches);
          var uniqueSets = [];
          var unique = {};
          for (var i5 = 0; i5 < sets.length; i5++) {
            var s3 = JSON.stringify(sets[i5]);
            if (!unique[s3]) {
              unique[s3] = true;
              uniqueSets.push(sets[i5]);
            }
          }
          return uniqueSets;
        }
        function _ruleMatch(rule, node, context, isSplit) {
          var res = [{
            placeholders: {}
          }];
          if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
            if (rule instanceof OperatorNode2) {
              if (rule.op !== node.op || rule.fn !== node.fn) {
                return [];
              }
            } else if (rule instanceof FunctionNode2) {
              if (rule.name !== node.name) {
                return [];
              }
            }
            if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
              var childMatches = [];
              for (var i5 = 0; i5 < rule.args.length; i5++) {
                var childMatch = _ruleMatch(rule.args[i5], node.args[i5], context);
                if (childMatch.length === 0) {
                  break;
                }
                childMatches.push(childMatch);
              }
              if (childMatches.length !== rule.args.length) {
                if (!isCommutative(node, context) || // exact match in order needed
                rule.args.length === 1) {
                  return [];
                }
                if (rule.args.length > 2) {
                  throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
                }
                var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
                if (leftMatch.length === 0) {
                  return [];
                }
                var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
                if (rightMatch.length === 0) {
                  return [];
                }
                childMatches = [leftMatch, rightMatch];
              }
              res = mergeChildMatches(childMatches);
            } else if (node.args.length >= 2 && rule.args.length === 2) {
              var splits = getSplits(node, context);
              var splitMatches = [];
              for (var _i2 = 0; _i2 < splits.length; _i2++) {
                var matchSet = _ruleMatch(rule, splits[_i2], context, true);
                splitMatches = splitMatches.concat(matchSet);
              }
              return splitMatches;
            } else if (rule.args.length > 2) {
              throw Error("Unexpected non-binary associative function: " + rule.toString());
            } else {
              return [];
            }
          } else if (rule instanceof SymbolNode2) {
            if (rule.name.length === 0) {
              throw new Error("Symbol in rule has 0 length...!?");
            }
            if (SUPPORTED_CONSTANTS[rule.name]) {
              if (rule.name !== node.name) {
                return [];
              }
            } else {
              switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
                case "n":
                case "_p":
                  res[0].placeholders[rule.name] = node;
                  break;
                case "c":
                case "cl":
                  if (isConstantNode(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "v":
                  if (!isConstantNode(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "vl":
                  if (isSymbolNode(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "cd":
                  if (isNumericNode(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "vd":
                  if (!isNumericNode(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "ce":
                  if (isConstantExpression(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "ve":
                  if (!isConstantExpression(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                default:
                  throw new Error("Invalid symbol in rule: " + rule.name);
              }
            }
          } else if (rule instanceof ConstantNode2) {
            if (!equal2(rule.value, node.value)) {
              return [];
            }
          } else {
            return [];
          }
          return res;
        }
        function _exactMatch(p3, q4) {
          if (p3 instanceof ConstantNode2 && q4 instanceof ConstantNode2) {
            if (!equal2(p3.value, q4.value)) {
              return false;
            }
          } else if (p3 instanceof SymbolNode2 && q4 instanceof SymbolNode2) {
            if (p3.name !== q4.name) {
              return false;
            }
          } else if (p3 instanceof OperatorNode2 && q4 instanceof OperatorNode2 || p3 instanceof FunctionNode2 && q4 instanceof FunctionNode2) {
            if (p3 instanceof OperatorNode2) {
              if (p3.op !== q4.op || p3.fn !== q4.fn) {
                return false;
              }
            } else if (p3 instanceof FunctionNode2) {
              if (p3.name !== q4.name) {
                return false;
              }
            }
            if (p3.args.length !== q4.args.length) {
              return false;
            }
            for (var i5 = 0; i5 < p3.args.length; i5++) {
              if (!_exactMatch(p3.args[i5], q4.args[i5])) {
                return false;
              }
            }
          } else {
            return false;
          }
          return true;
        }
        return simplify2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
  var name278, dependencies278, createSimplifyConstant;
  var init_simplifyConstant2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js"() {
      init_is();
      init_factory();
      init_util();
      init_noop();
      name278 = "simplifyConstant";
      dependencies278 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
      createSimplifyConstant = /* @__PURE__ */ factory(name278, dependencies278, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          mathWithTransform: mathWithTransform2,
          matrix: matrix2,
          fraction: fraction2,
          bignumber: bignumber2,
          AccessorNode: AccessorNode2,
          ArrayNode: ArrayNode2,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          IndexNode: IndexNode2,
          ObjectNode: ObjectNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        var {
          isCommutative,
          isAssociative,
          allChildren,
          createMakeNodeFunction
        } = createUtil({
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2
        });
        var simplifyConstant2 = typed3("simplifyConstant", {
          Node: (node) => _ensureNode(foldFraction(node, {})),
          "Node, Object": function NodeObject(expr, options) {
            return _ensureNode(foldFraction(expr, options));
          }
        });
        function _removeFractions(thing) {
          if (isFraction(thing)) {
            return thing.valueOf();
          }
          if (thing instanceof Array) {
            return thing.map(_removeFractions);
          }
          if (isMatrix(thing)) {
            return matrix2(_removeFractions(thing.valueOf()));
          }
          return thing;
        }
        function _eval(fnname, args, options) {
          try {
            return mathWithTransform2[fnname].apply(null, args);
          } catch (ignore) {
            args = args.map(_removeFractions);
            return _toNumber(mathWithTransform2[fnname].apply(null, args), options);
          }
        }
        var _toNode = typed3({
          Fraction: _fractionToNode,
          number: function number2(n3) {
            if (n3 < 0) {
              return unaryMinusNode(new ConstantNode2(-n3));
            }
            return new ConstantNode2(n3);
          },
          BigNumber: function BigNumber2(n3) {
            if (n3 < 0) {
              return unaryMinusNode(new ConstantNode2(-n3));
            }
            return new ConstantNode2(n3);
          },
          Complex: function Complex3(s3) {
            throw new Error("Cannot convert Complex number to Node");
          },
          string: function string2(s3) {
            return new ConstantNode2(s3);
          },
          Matrix: function Matrix2(m3) {
            return new ArrayNode2(m3.valueOf().map((e6) => _toNode(e6)));
          }
        });
        function _ensureNode(thing) {
          if (isNode(thing)) {
            return thing;
          }
          return _toNode(thing);
        }
        function _exactFraction(n3, options) {
          var exactFractions = options && options.exactFractions !== false;
          if (exactFractions && isFinite(n3) && fraction2) {
            var f3 = fraction2(n3);
            var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
            if (f3.valueOf() === n3 && f3.n < fractionsLimit && f3.d < fractionsLimit) {
              return f3;
            }
          }
          return n3;
        }
        var _toNumber = typed3({
          "string, Object": function stringObject(s3, options) {
            if (config4.number === "BigNumber") {
              if (bignumber2 === void 0) {
                noBignumber();
              }
              return bignumber2(s3);
            } else if (config4.number === "Fraction") {
              if (fraction2 === void 0) {
                noFraction();
              }
              return fraction2(s3);
            } else {
              var n3 = parseFloat(s3);
              return _exactFraction(n3, options);
            }
          },
          "Fraction, Object": function FractionObject(s3, options) {
            return s3;
          },
          // we don't need options here
          "BigNumber, Object": function BigNumberObject(s3, options) {
            return s3;
          },
          // we don't need options here
          "number, Object": function numberObject(s3, options) {
            return _exactFraction(s3, options);
          },
          "Complex, Object": function ComplexObject(s3, options) {
            if (s3.im !== 0) {
              return s3;
            }
            return _exactFraction(s3.re, options);
          },
          "Matrix, Object": function MatrixObject(s3, options) {
            return matrix2(_exactFraction(s3.valueOf()));
          },
          "Array, Object": function ArrayObject(s3, options) {
            return s3.map(_exactFraction);
          }
        });
        function unaryMinusNode(n3) {
          return new OperatorNode2("-", "unaryMinus", [n3]);
        }
        function _fractionToNode(f3) {
          var n3;
          var vn2 = f3.s * f3.n;
          if (vn2 < 0) {
            n3 = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn2)]);
          } else {
            n3 = new ConstantNode2(vn2);
          }
          if (f3.d === 1) {
            return n3;
          }
          return new OperatorNode2("/", "divide", [n3, new ConstantNode2(f3.d)]);
        }
        function _foldAccessor(obj, index2, options) {
          if (!isIndexNode(index2)) {
            return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
          }
          if (isArrayNode(obj) || isMatrix(obj)) {
            var remainingDims = Array.from(index2.dimensions);
            while (remainingDims.length > 0) {
              if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
                var first = _toNumber(remainingDims.shift().value, options);
                if (isArrayNode(obj)) {
                  obj = obj.items[first - 1];
                } else {
                  obj = obj.valueOf()[first - 1];
                  if (obj instanceof Array) {
                    obj = matrix2(obj);
                  }
                }
              } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
                var second = _toNumber(remainingDims[1].value, options);
                var tryItems = [];
                var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
                for (var item of fromItems) {
                  if (isArrayNode(item)) {
                    tryItems.push(item.items[second - 1]);
                  } else if (isMatrix(obj)) {
                    tryItems.push(item[second - 1]);
                  } else {
                    break;
                  }
                }
                if (tryItems.length === fromItems.length) {
                  if (isArrayNode(obj)) {
                    obj = new ArrayNode2(tryItems);
                  } else {
                    obj = matrix2(tryItems);
                  }
                  remainingDims.splice(1, 1);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            if (remainingDims.length === index2.dimensions.length) {
              return new AccessorNode2(_ensureNode(obj), index2);
            }
            if (remainingDims.length > 0) {
              index2 = new IndexNode2(remainingDims);
              return new AccessorNode2(_ensureNode(obj), index2);
            }
            return obj;
          }
          if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
            var key = index2.dimensions[0].value;
            if (key in obj.properties) {
              return obj.properties[key];
            }
            return new ConstantNode2();
          }
          return new AccessorNode2(_ensureNode(obj), index2);
        }
        function foldOp(fn2, args, makeNode, options) {
          var first = args.shift();
          var reduction = args.reduce((sofar, next) => {
            if (!isNode(next)) {
              var last = sofar.pop();
              if (isNode(last)) {
                return [last, next];
              }
              try {
                sofar.push(_eval(fn2, [last, next], options));
                return sofar;
              } catch (ignoreandcontinue) {
                sofar.push(last);
              }
            }
            sofar.push(_ensureNode(sofar.pop()));
            var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
            return [makeNode([newtree, _ensureNode(next)])];
          }, [first]);
          if (reduction.length === 1) {
            return reduction[0];
          }
          return makeNode([reduction[0], _toNode(reduction[1])]);
        }
        function foldFraction(node, options) {
          switch (node.type) {
            case "SymbolNode":
              return node;
            case "ConstantNode":
              switch (typeof node.value) {
                case "number":
                  return _toNumber(node.value, options);
                case "string":
                  return node.value;
                default:
                  if (!isNaN(node.value))
                    return _toNumber(node.value, options);
              }
              return node;
            case "FunctionNode":
              if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
                return node;
              }
              {
                var operatorFunctions = ["add", "multiply"];
                if (operatorFunctions.indexOf(node.name) === -1) {
                  var args = node.args.map((arg2) => foldFraction(arg2, options));
                  if (!args.some(isNode)) {
                    try {
                      return _eval(node.name, args, options);
                    } catch (ignoreandcontinue) {
                    }
                  }
                  if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
                    var sz = [];
                    var section = args[0];
                    while (isArrayNode(section)) {
                      sz.push(section.items.length);
                      section = section.items[0];
                    }
                    return matrix2(sz);
                  }
                  return new FunctionNode2(node.name, args.map(_ensureNode));
                } else {
                }
              }
            case "OperatorNode": {
              var fn2 = node.fn.toString();
              var _args;
              var res;
              var makeNode = createMakeNodeFunction(node);
              if (isOperatorNode(node) && node.isUnary()) {
                _args = [foldFraction(node.args[0], options)];
                if (!isNode(_args[0])) {
                  res = _eval(fn2, _args, options);
                } else {
                  res = makeNode(_args);
                }
              } else if (isAssociative(node, options.context)) {
                _args = allChildren(node, options.context);
                _args = _args.map((arg2) => foldFraction(arg2, options));
                if (isCommutative(fn2, options.context)) {
                  var consts = [];
                  var vars = [];
                  for (var i5 = 0; i5 < _args.length; i5++) {
                    if (!isNode(_args[i5])) {
                      consts.push(_args[i5]);
                    } else {
                      vars.push(_args[i5]);
                    }
                  }
                  if (consts.length > 1) {
                    res = foldOp(fn2, consts, makeNode, options);
                    vars.unshift(res);
                    res = foldOp(fn2, vars, makeNode, options);
                  } else {
                    res = foldOp(fn2, _args, makeNode, options);
                  }
                } else {
                  res = foldOp(fn2, _args, makeNode, options);
                }
              } else {
                _args = node.args.map((arg2) => foldFraction(arg2, options));
                res = foldOp(fn2, _args, makeNode, options);
              }
              return res;
            }
            case "ParenthesisNode":
              return foldFraction(node.content, options);
            case "AccessorNode":
              return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
            case "ArrayNode": {
              var foldItems = node.items.map((item) => foldFraction(item, options));
              if (foldItems.some(isNode)) {
                return new ArrayNode2(foldItems.map(_ensureNode));
              }
              return matrix2(foldItems);
            }
            case "IndexNode": {
              return new IndexNode2(node.dimensions.map((n3) => simplifyConstant2(n3, options)));
            }
            case "ObjectNode": {
              var foldProps = {};
              for (var prop in node.properties) {
                foldProps[prop] = simplifyConstant2(node.properties[prop], options);
              }
              return new ObjectNode2(foldProps);
            }
            case "AssignmentNode":
            case "BlockNode":
            case "FunctionAssignmentNode":
            case "RangeNode":
            case "ConditionalNode":
            default:
              throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
          }
        }
        return simplifyConstant2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
  var name279, dependencies279, createSimplifyCore;
  var init_simplifyCore2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"() {
      init_is();
      init_operators();
      init_util();
      init_factory();
      name279 = "simplifyCore";
      dependencies279 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      createSimplifyCore = /* @__PURE__ */ factory(name279, dependencies279, (_ref) => {
        var {
          typed: typed3,
          parse: parse2,
          equal: equal2,
          isZero: isZero2,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          pow: pow3,
          AccessorNode: AccessorNode2,
          ArrayNode: ArrayNode2,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          IndexNode: IndexNode2,
          ObjectNode: ObjectNode2,
          OperatorNode: OperatorNode2,
          ParenthesisNode: ParenthesisNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        var node0 = new ConstantNode2(0);
        var node1 = new ConstantNode2(1);
        var nodeT = new ConstantNode2(true);
        var nodeF = new ConstantNode2(false);
        function isAlwaysBoolean(node) {
          return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
        }
        var {
          hasProperty,
          isCommutative
        } = createUtil({
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2
        });
        function _simplifyCore(nodeToSimplify) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = options ? options.context : void 0;
          if (hasProperty(nodeToSimplify, "trivial", context)) {
            if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
              return _simplifyCore(nodeToSimplify.args[0], options);
            }
            var simpChild = false;
            var childCount = 0;
            nodeToSimplify.forEach((c3) => {
              ++childCount;
              if (childCount === 1) {
                simpChild = _simplifyCore(c3, options);
              }
            });
            if (childCount === 1) {
              return simpChild;
            }
          }
          var node = nodeToSimplify;
          if (isFunctionNode(node)) {
            var op = getOperator(node.name);
            if (op) {
              if (node.args.length > 2 && hasProperty(node, "associative", context)) {
                while (node.args.length > 2) {
                  var last = node.args.pop();
                  var seclast = node.args.pop();
                  node.args.push(new OperatorNode2(op, node.name, [last, seclast]));
                }
              }
              node = new OperatorNode2(op, node.name, node.args);
            } else {
              return new FunctionNode2(_simplifyCore(node.fn), node.args.map((n3) => _simplifyCore(n3, options)));
            }
          }
          if (isOperatorNode(node) && node.isUnary()) {
            var a0 = _simplifyCore(node.args[0], options);
            if (node.op === "~") {
              if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
                return a0.args[0];
              }
            }
            if (node.op === "not") {
              if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
                if (isAlwaysBoolean(a0.args[0])) {
                  return a0.args[0];
                }
              }
            }
            var finish = true;
            if (node.op === "-") {
              if (isOperatorNode(a0)) {
                if (a0.isBinary() && a0.fn === "subtract") {
                  node = new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
                  finish = false;
                }
                if (a0.isUnary() && a0.op === "-") {
                  return a0.args[0];
                }
              }
            }
            if (finish)
              return new OperatorNode2(node.op, node.fn, [a0]);
          }
          if (isOperatorNode(node) && node.isBinary()) {
            var _a = _simplifyCore(node.args[0], options);
            var a1 = _simplifyCore(node.args[1], options);
            if (node.op === "+") {
              if (isConstantNode(_a) && isZero2(_a.value)) {
                return a1;
              }
              if (isConstantNode(a1) && isZero2(a1.value)) {
                return _a;
              }
              if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
                a1 = a1.args[0];
                node = new OperatorNode2("-", "subtract", [_a, a1]);
              }
            }
            if (node.op === "-") {
              if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
                return _simplifyCore(new OperatorNode2("+", "add", [_a, a1.args[0]]), options);
              }
              if (isConstantNode(_a) && isZero2(_a.value)) {
                return _simplifyCore(new OperatorNode2("-", "unaryMinus", [a1]));
              }
              if (isConstantNode(a1) && isZero2(a1.value)) {
                return _a;
              }
              return new OperatorNode2(node.op, node.fn, [_a, a1]);
            }
            if (node.op === "*") {
              if (isConstantNode(_a)) {
                if (isZero2(_a.value)) {
                  return node0;
                } else if (equal2(_a.value, 1)) {
                  return a1;
                }
              }
              if (isConstantNode(a1)) {
                if (isZero2(a1.value)) {
                  return node0;
                } else if (equal2(a1.value, 1)) {
                  return _a;
                }
                if (isCommutative(node, context)) {
                  return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
                }
              }
              return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
            }
            if (node.op === "/") {
              if (isConstantNode(_a) && isZero2(_a.value)) {
                return node0;
              }
              if (isConstantNode(a1) && equal2(a1.value, 1)) {
                return _a;
              }
              return new OperatorNode2(node.op, node.fn, [_a, a1]);
            }
            if (node.op === "^") {
              if (isConstantNode(a1)) {
                if (isZero2(a1.value)) {
                  return node1;
                } else if (equal2(a1.value, 1)) {
                  return _a;
                }
              }
            }
            if (node.op === "and") {
              if (isConstantNode(_a)) {
                if (_a.value) {
                  if (isAlwaysBoolean(a1))
                    return a1;
                } else {
                  return nodeF;
                }
              }
              if (isConstantNode(a1)) {
                if (a1.value) {
                  if (isAlwaysBoolean(_a))
                    return _a;
                } else {
                  return nodeF;
                }
              }
            }
            if (node.op === "or") {
              if (isConstantNode(_a)) {
                if (_a.value) {
                  return nodeT;
                } else {
                  if (isAlwaysBoolean(a1))
                    return a1;
                }
              }
              if (isConstantNode(a1)) {
                if (a1.value) {
                  return nodeT;
                } else {
                  if (isAlwaysBoolean(_a))
                    return _a;
                }
              }
            }
            return new OperatorNode2(node.op, node.fn, [_a, a1]);
          }
          if (isOperatorNode(node)) {
            return new OperatorNode2(node.op, node.fn, node.args.map((a3) => _simplifyCore(a3, options)));
          }
          if (isArrayNode(node)) {
            return new ArrayNode2(node.items.map((n3) => _simplifyCore(n3, options)));
          }
          if (isAccessorNode(node)) {
            return new AccessorNode2(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
          }
          if (isIndexNode(node)) {
            return new IndexNode2(node.dimensions.map((n3) => _simplifyCore(n3, options)));
          }
          if (isObjectNode(node)) {
            var newProps = {};
            for (var prop in node.properties) {
              newProps[prop] = _simplifyCore(node.properties[prop], options);
            }
            return new ObjectNode2(newProps);
          }
          return node;
        }
        return typed3(name279, {
          Node: _simplifyCore,
          "Node,Object": _simplifyCore
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/resolve.js
  var name280, dependencies280, createResolve;
  var init_resolve2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/resolve.js"() {
      init_map();
      init_is();
      init_factory();
      name280 = "resolve";
      dependencies280 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
      createResolve = /* @__PURE__ */ factory(name280, dependencies280, (_ref) => {
        var {
          typed: typed3,
          parse: parse2,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          ParenthesisNode: ParenthesisNode2
        } = _ref;
        function _resolve(node, scope) {
          var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
          if (!scope) {
            return node;
          }
          if (isSymbolNode(node)) {
            if (within.has(node.name)) {
              var variables = Array.from(within).join(", ");
              throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
            }
            var value = scope.get(node.name);
            if (isNode(value)) {
              var nextWithin = new Set(within);
              nextWithin.add(node.name);
              return _resolve(value, scope, nextWithin);
            } else if (typeof value === "number") {
              return parse2(String(value));
            } else if (value !== void 0) {
              return new ConstantNode2(value);
            } else {
              return node;
            }
          } else if (isOperatorNode(node)) {
            var args = node.args.map(function(arg2) {
              return _resolve(arg2, scope, within);
            });
            return new OperatorNode2(node.op, node.fn, args, node.implicit);
          } else if (isParenthesisNode(node)) {
            return new ParenthesisNode2(_resolve(node.content, scope, within));
          } else if (isFunctionNode(node)) {
            var _args = node.args.map(function(arg2) {
              return _resolve(arg2, scope, within);
            });
            return new FunctionNode2(node.name, _args);
          }
          return node.map((child) => _resolve(child, scope, within));
        }
        return typed3("resolve", {
          Node: _resolve,
          "Node, Map | null | undefined": _resolve,
          "Node, Object": (n3, scope) => _resolve(n3, createMap(scope)),
          // For arrays and matrices, we map `self` rather than `_resolve`
          // because resolve is fairly expensive anyway, and this way
          // we get nice error messages if one entry in the array has wrong type.
          "Array | Matrix": typed3.referToSelf((self2) => (A4) => A4.map((n3) => self2(n3))),
          "Array | Matrix, null | undefined": typed3.referToSelf((self2) => (A4) => A4.map((n3) => self2(n3))),
          "Array, Object": typed3.referTo("Array,Map", (selfAM) => (A4, scope) => selfAM(A4, createMap(scope))),
          "Matrix, Object": typed3.referTo("Matrix,Map", (selfMM) => (A4, scope) => selfMM(A4, createMap(scope))),
          "Array | Matrix, Map": typed3.referToSelf((self2) => (A4, scope) => A4.map((n3) => self2(n3, scope)))
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
  var name281, dependencies281, createSymbolicEqual;
  var init_symbolicEqual2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js"() {
      init_is();
      init_factory();
      name281 = "symbolicEqual";
      dependencies281 = ["parse", "simplify", "typed", "OperatorNode"];
      createSymbolicEqual = /* @__PURE__ */ factory(name281, dependencies281, (_ref) => {
        var {
          parse: parse2,
          simplify: simplify2,
          typed: typed3,
          OperatorNode: OperatorNode2
        } = _ref;
        function _symbolicEqual(e1, e22) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var diff2 = new OperatorNode2("-", "subtract", [e1, e22]);
          var simplified = simplify2(diff2, {}, options);
          return isConstantNode(simplified) && !simplified.value;
        }
        return typed3(name281, {
          "Node, Node": _symbolicEqual,
          "Node, Node, Object": _symbolicEqual
        });
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/derivative.js
  var name282, dependencies282, createDerivative;
  var init_derivative2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/derivative.js"() {
      init_is();
      init_factory();
      name282 = "derivative";
      dependencies282 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      createDerivative = /* @__PURE__ */ factory(name282, dependencies282, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          parse: parse2,
          simplify: simplify2,
          equal: equal2,
          isZero: isZero2,
          numeric: numeric3,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          OperatorNode: OperatorNode2,
          ParenthesisNode: ParenthesisNode2,
          SymbolNode: SymbolNode2
        } = _ref;
        function plainDerivative(expr, variable) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            simplify: true
          };
          var constNodes = {};
          constTag(constNodes, expr, variable.name);
          var res = _derivative(expr, constNodes);
          return options.simplify ? simplify2(res) : res;
        }
        typed3.addConversion({
          from: "identifier",
          to: "SymbolNode",
          convert: parse2
        });
        var derivative2 = typed3(name282, {
          "Node, SymbolNode": plainDerivative,
          "Node, SymbolNode, Object": plainDerivative
          /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
          'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
            let res = expr
            for (let i = 0; i < order; i++) {
              let constNodes = {}
              constTag(constNodes, expr, variable.name)
              res = _derivative(res, constNodes)
            }
            return res
          }
          */
        });
        typed3.removeConversion({
          from: "identifier",
          to: "SymbolNode",
          convert: parse2
        });
        derivative2._simplify = true;
        derivative2.toTex = function(deriv) {
          return _derivTex.apply(null, deriv.args);
        };
        var _derivTex = typed3("_derivTex", {
          "Node, SymbolNode": function NodeSymbolNode(expr, x4) {
            if (isConstantNode(expr) && typeOf(expr.value) === "string") {
              return _derivTex(parse2(expr.value).toString(), x4.toString(), 1);
            } else {
              return _derivTex(expr.toTex(), x4.toString(), 1);
            }
          },
          "Node, ConstantNode": function NodeConstantNode(expr, x4) {
            if (typeOf(x4.value) === "string") {
              return _derivTex(expr, parse2(x4.value));
            } else {
              throw new Error("The second parameter to 'derivative' is a non-string constant");
            }
          },
          "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x4, order) {
            return _derivTex(expr.toString(), x4.name, order.value);
          },
          "string, string, number": function stringStringNumber(expr, x4, order) {
            var d3;
            if (order === 1) {
              d3 = "{d\\over d" + x4 + "}";
            } else {
              d3 = "{d^{" + order + "}\\over d" + x4 + "^{" + order + "}}";
            }
            return d3 + "\\left[".concat(expr, "\\right]");
          }
        });
        var constTag = typed3("constTag", {
          "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
            constNodes[node] = true;
            return true;
          },
          "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
            if (node.name !== varName) {
              constNodes[node] = true;
              return true;
            }
            return false;
          },
          "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
            return constTag(constNodes, node.content, varName);
          },
          "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
            if (node.params.indexOf(varName) === -1) {
              constNodes[node] = true;
              return true;
            }
            return constTag(constNodes, node.expr, varName);
          },
          "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
            if (node.args.length > 0) {
              var isConst = constTag(constNodes, node.args[0], varName);
              for (var i5 = 1; i5 < node.args.length; ++i5) {
                isConst = constTag(constNodes, node.args[i5], varName) && isConst;
              }
              if (isConst) {
                constNodes[node] = true;
                return true;
              }
            }
            return false;
          }
        });
        var _derivative = typed3("_derivative", {
          "ConstantNode, Object": function ConstantNodeObject(node) {
            return createConstantNode2(0);
          },
          "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode2(0);
            }
            return createConstantNode2(1);
          },
          "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
            return new ParenthesisNode2(_derivative(node.content, constNodes));
          },
          "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode2(0);
            }
            return _derivative(node.expr, constNodes);
          },
          "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
            if (node.args.length !== 1) {
              funcArgsCheck(node);
            }
            if (constNodes[node] !== void 0) {
              return createConstantNode2(0);
            }
            var arg0 = node.args[0];
            var arg1;
            var div2 = false;
            var negative = false;
            var funcDerivative;
            switch (node.name) {
              case "cbrt":
                div2 = true;
                funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
                break;
              case "sqrt":
              case "nthRoot":
                if (node.args.length === 1) {
                  div2 = true;
                  funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
                } else if (node.args.length === 2) {
                  arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
                  constNodes[arg1] = constNodes[node.args[1]];
                  return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
                }
                break;
              case "log10":
                arg1 = createConstantNode2(10);
              case "log":
                if (!arg1 && node.args.length === 1) {
                  funcDerivative = arg0.clone();
                  div2 = true;
                } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
                  funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
                  div2 = true;
                } else if (node.args.length === 2) {
                  return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
                }
                break;
              case "pow":
                constNodes[arg1] = constNodes[node.args[1]];
                return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
              case "exp":
                funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
                break;
              case "sin":
                funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
                break;
              case "cos":
                funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
                break;
              case "tan":
                funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
                break;
              case "sec":
                funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
                break;
              case "csc":
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
                break;
              case "cot":
                negative = true;
                funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
                break;
              case "asin":
                div2 = true;
                funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
                break;
              case "acos":
                div2 = true;
                negative = true;
                funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
                break;
              case "atan":
                div2 = true;
                funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
                break;
              case "asec":
                div2 = true;
                funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
                break;
              case "acsc":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
                break;
              case "acot":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
                break;
              case "sinh":
                funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
                break;
              case "cosh":
                funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
                break;
              case "tanh":
                funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
                break;
              case "sech":
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
                break;
              case "csch":
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
                break;
              case "coth":
                negative = true;
                funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
                break;
              case "asinh":
                div2 = true;
                funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
                break;
              case "acosh":
                div2 = true;
                funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
                break;
              case "atanh":
                div2 = true;
                funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
                break;
              case "asech":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
                break;
              case "acsch":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
                break;
              case "acoth":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
                break;
              case "abs":
                funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
                break;
              case "gamma":
              default:
                throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
            }
            var op, func;
            if (div2) {
              op = "/";
              func = "divide";
            } else {
              op = "*";
              func = "multiply";
            }
            var chainDerivative = _derivative(arg0, constNodes);
            if (negative) {
              chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
            }
            return new OperatorNode2(op, func, [chainDerivative, funcDerivative]);
          },
          "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode2(0);
            }
            if (node.op === "+") {
              return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
                return _derivative(arg2, constNodes);
              }));
            }
            if (node.op === "-") {
              if (node.isUnary()) {
                return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
              }
              if (node.isBinary()) {
                return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
              }
            }
            if (node.op === "*") {
              var constantTerms = node.args.filter(function(arg2) {
                return constNodes[arg2] !== void 0;
              });
              if (constantTerms.length > 0) {
                var nonConstantTerms = node.args.filter(function(arg2) {
                  return constNodes[arg2] === void 0;
                });
                var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
                var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
                return new OperatorNode2("*", "multiply", newArgs);
              }
              return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
                return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
                  return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
                }));
              }));
            }
            if (node.op === "/" && node.isBinary()) {
              var arg0 = node.args[0];
              var arg1 = node.args[1];
              if (constNodes[arg1] !== void 0) {
                return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
              }
              if (constNodes[arg0] !== void 0) {
                return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
              }
              return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
            }
            if (node.op === "^" && node.isBinary()) {
              var _arg = node.args[0];
              var _arg2 = node.args[1];
              if (constNodes[_arg] !== void 0) {
                if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
                  return createConstantNode2(0);
                }
                return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
              }
              if (constNodes[_arg2] !== void 0) {
                if (isConstantNode(_arg2)) {
                  if (isZero2(_arg2.value)) {
                    return createConstantNode2(0);
                  }
                  if (equal2(_arg2.value, 1)) {
                    return _derivative(_arg, constNodes);
                  }
                }
                var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
                return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
              }
              return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
            }
            throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
          }
        });
        function funcArgsCheck(node) {
          if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
            return;
          }
          for (var i5 = 0; i5 < node.args.length; ++i5) {
            node.args[i5] = createConstantNode2(0);
          }
          node.compile().evaluate();
          throw new Error("Expected TypeError, but none found");
        }
        function createConstantNode2(value, valueType) {
          return new ConstantNode2(numeric3(value, valueType || config4.number));
        }
        return derivative2;
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/rationalize.js
  var name283, dependencies283, createRationalize;
  var init_rationalize2 = __esm({
    "node_modules/mathjs/lib/esm/function/algebra/rationalize.js"() {
      init_number();
      init_factory();
      name283 = "rationalize";
      dependencies283 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
      createRationalize = /* @__PURE__ */ factory(name283, dependencies283, (_ref) => {
        var {
          config: config4,
          typed: typed3,
          equal: equal2,
          isZero: isZero2,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          pow: pow3,
          parse: parse2,
          simplifyConstant: simplifyConstant2,
          simplifyCore: simplifyCore2,
          simplify: simplify2,
          fraction: fraction2,
          bignumber: bignumber2,
          mathWithTransform: mathWithTransform2,
          matrix: matrix2,
          AccessorNode: AccessorNode2,
          ArrayNode: ArrayNode2,
          ConstantNode: ConstantNode2,
          FunctionNode: FunctionNode2,
          IndexNode: IndexNode2,
          ObjectNode: ObjectNode2,
          OperatorNode: OperatorNode2,
          SymbolNode: SymbolNode2,
          ParenthesisNode: ParenthesisNode2
        } = _ref;
        function _rationalize(expr) {
          var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var setRules = rulesRationalize();
          var polyRet = polynomial(expr, scope, true, setRules.firstRules);
          var nVars = polyRet.variables.length;
          var noExactFractions = {
            exactFractions: false
          };
          var withExactFractions = {
            exactFractions: true
          };
          expr = polyRet.expression;
          if (nVars >= 1) {
            expr = expandPower(expr);
            var sBefore;
            var rules;
            var eDistrDiv = true;
            var redoInic = false;
            expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
            var s3;
            while (true) {
              rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
              expr = simplify2(expr, rules, {}, withExactFractions);
              eDistrDiv = !eDistrDiv;
              s3 = expr.toString();
              if (s3 === sBefore) {
                break;
              }
              redoInic = true;
              sBefore = s3;
            }
            if (redoInic) {
              expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
            }
            expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
          }
          var coefficients = [];
          var retRationalize = {};
          if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
            if (nVars === 1) {
              expr.args[0] = polyToCanonical(expr.args[0], coefficients);
              expr.args[1] = polyToCanonical(expr.args[1]);
            }
            if (detailed) {
              retRationalize.numerator = expr.args[0];
              retRationalize.denominator = expr.args[1];
            }
          } else {
            if (nVars === 1) {
              expr = polyToCanonical(expr, coefficients);
            }
            if (detailed) {
              retRationalize.numerator = expr;
              retRationalize.denominator = null;
            }
          }
          if (!detailed)
            return expr;
          retRationalize.coefficients = coefficients;
          retRationalize.variables = polyRet.variables;
          retRationalize.expression = expr;
          return retRationalize;
        }
        return typed3(name283, {
          Node: _rationalize,
          "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
          "Node, Object": _rationalize,
          "Node, Object, boolean": _rationalize
        });
        function polynomial(expr, scope, extended, rules) {
          var variables = [];
          var node = simplify2(expr, rules, scope, {
            exactFractions: false
          });
          extended = !!extended;
          var oper = "+-*" + (extended ? "/" : "");
          recPoly(node);
          var retFunc = {};
          retFunc.expression = node;
          retFunc.variables = variables;
          return retFunc;
          function recPoly(node2) {
            var tp = node2.type;
            if (tp === "FunctionNode") {
              throw new Error("There is an unsolved function call");
            } else if (tp === "OperatorNode") {
              if (node2.op === "^") {
                if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
                  throw new Error("There is a non-integer exponent");
                } else {
                  recPoly(node2.args[0]);
                }
              } else {
                if (oper.indexOf(node2.op) === -1) {
                  throw new Error("Operator " + node2.op + " invalid in polynomial expression");
                }
                for (var i5 = 0; i5 < node2.args.length; i5++) {
                  recPoly(node2.args[i5]);
                }
              }
            } else if (tp === "SymbolNode") {
              var _name = node2.name;
              var pos = variables.indexOf(_name);
              if (pos === -1) {
                variables.push(_name);
              }
            } else if (tp === "ParenthesisNode") {
              recPoly(node2.content);
            } else if (tp !== "ConstantNode") {
              throw new Error("type " + tp + " is not allowed in polynomial expression");
            }
          }
        }
        function rulesRationalize() {
          var oldRules = [
            simplifyCore2,
            // sCore
            {
              l: "n+n",
              r: "2*n"
            },
            {
              l: "n+-n",
              r: "0"
            },
            simplifyConstant2,
            // sConstant
            {
              l: "n*(n1^-1)",
              r: "n/n1"
            },
            {
              l: "n*n1^-n2",
              r: "n/n1^n2"
            },
            {
              l: "n1^-1",
              r: "1/n1"
            },
            {
              l: "n*(n1/n2)",
              r: "(n*n1)/n2"
            },
            {
              l: "1*n",
              r: "n"
            }
          ];
          var rulesFirst = [
            {
              l: "(-n1)/(-n2)",
              r: "n1/n2"
            },
            // Unary division
            {
              l: "(-n1)*(-n2)",
              r: "n1*n2"
            },
            // Unary multiplication
            {
              l: "n1--n2",
              r: "n1+n2"
            },
            // '--' elimination
            {
              l: "n1-n2",
              r: "n1+(-n2)"
            },
            // Subtraction turn into add with unry minus
            {
              l: "(n1+n2)*n3",
              r: "(n1*n3 + n2*n3)"
            },
            // Distributive 1
            {
              l: "n1*(n2+n3)",
              r: "(n1*n2+n1*n3)"
            },
            // Distributive 2
            {
              l: "c1*n + c2*n",
              r: "(c1+c2)*n"
            },
            // Joining constants
            {
              l: "c1*n + n",
              r: "(c1+1)*n"
            },
            // Joining constants
            {
              l: "c1*n - c2*n",
              r: "(c1-c2)*n"
            },
            // Joining constants
            {
              l: "c1*n - n",
              r: "(c1-1)*n"
            },
            // Joining constants
            {
              l: "v/c",
              r: "(1/c)*v"
            },
            // variable/constant (new!)
            {
              l: "v/-c",
              r: "-(1/c)*v"
            },
            // variable/constant (new!)
            {
              l: "-v*-c",
              r: "c*v"
            },
            // Inversion constant and variable 1
            {
              l: "-v*c",
              r: "-c*v"
            },
            // Inversion constant and variable 2
            {
              l: "v*-c",
              r: "-c*v"
            },
            // Inversion constant and variable 3
            {
              l: "v*c",
              r: "c*v"
            },
            // Inversion constant and variable 4
            {
              l: "-(-n1*n2)",
              r: "(n1*n2)"
            },
            // Unary propagation
            {
              l: "-(n1*n2)",
              r: "(-n1*n2)"
            },
            // Unary propagation
            {
              l: "-(-n1+n2)",
              r: "(n1-n2)"
            },
            // Unary propagation
            {
              l: "-(n1+n2)",
              r: "(-n1-n2)"
            },
            // Unary propagation
            {
              l: "(n1^n2)^n3",
              r: "(n1^(n2*n3))"
            },
            // Power to Power
            {
              l: "-(-n1/n2)",
              r: "(n1/n2)"
            },
            // Division and Unary
            {
              l: "-(n1/n2)",
              r: "(-n1/n2)"
            }
          ];
          var rulesDistrDiv = [
            {
              l: "(n1/n2 + n3/n4)",
              r: "((n1*n4 + n3*n2)/(n2*n4))"
            },
            // Sum of fractions
            {
              l: "(n1/n2 + n3)",
              r: "((n1 + n3*n2)/n2)"
            },
            // Sum fraction with number 1
            {
              l: "(n1 + n2/n3)",
              r: "((n1*n3 + n2)/n3)"
            }
          ];
          var rulesSucDiv = [
            {
              l: "(n1/(n2/n3))",
              r: "((n1*n3)/n2)"
            },
            // Division simplification
            {
              l: "(n1/n2/n3)",
              r: "(n1/(n2*n3))"
            }
          ];
          var setRules = {};
          setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
          setRules.distrDivRules = rulesDistrDiv;
          setRules.sucDivRules = rulesSucDiv;
          setRules.firstRulesAgain = oldRules.concat(rulesFirst);
          setRules.finalRules = [
            simplifyCore2,
            // simplify.rules[0]
            {
              l: "n*-n",
              r: "-n^2"
            },
            // Joining multiply with power 1
            {
              l: "n*n",
              r: "n^2"
            },
            // Joining multiply with power 2
            simplifyConstant2,
            // simplify.rules[14] old 3rd index in oldRules
            {
              l: "n*-n^n1",
              r: "-n^(n1+1)"
            },
            // Joining multiply with power 3
            {
              l: "n*n^n1",
              r: "n^(n1+1)"
            },
            // Joining multiply with power 4
            {
              l: "n^n1*-n^n2",
              r: "-n^(n1+n2)"
            },
            // Joining multiply with power 5
            {
              l: "n^n1*n^n2",
              r: "n^(n1+n2)"
            },
            // Joining multiply with power 6
            {
              l: "n^n1*-n",
              r: "-n^(n1+1)"
            },
            // Joining multiply with power 7
            {
              l: "n^n1*n",
              r: "n^(n1+1)"
            },
            // Joining multiply with power 8
            {
              l: "n^n1/-n",
              r: "-n^(n1-1)"
            },
            // Joining multiply with power 8
            {
              l: "n^n1/n",
              r: "n^(n1-1)"
            },
            // Joining division with power 1
            {
              l: "n/-n^n1",
              r: "-n^(1-n1)"
            },
            // Joining division with power 2
            {
              l: "n/n^n1",
              r: "n^(1-n1)"
            },
            // Joining division with power 3
            {
              l: "n^n1/-n^n2",
              r: "n^(n1-n2)"
            },
            // Joining division with power 4
            {
              l: "n^n1/n^n2",
              r: "n^(n1-n2)"
            },
            // Joining division with power 5
            {
              l: "n1+(-n2*n3)",
              r: "n1-n2*n3"
            },
            // Solving useless parenthesis 1
            {
              l: "v*(-c)",
              r: "-c*v"
            },
            // Solving useless unary 2
            {
              l: "n1+-n2",
              r: "n1-n2"
            },
            // Solving +- together (new!)
            {
              l: "v*c",
              r: "c*v"
            },
            // inversion constant with variable
            {
              l: "(n1^n2)^n3",
              r: "(n1^(n2*n3))"
            }
            // Power to Power
          ];
          return setRules;
        }
        function expandPower(node, parent, indParent) {
          var tp = node.type;
          var internal = arguments.length > 1;
          if (tp === "OperatorNode" && node.isBinary()) {
            var does = false;
            var val;
            if (node.op === "^") {
              if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
                val = parseFloat(node.args[1].value);
                does = val >= 2 && isInteger(val);
              }
            }
            if (does) {
              if (val > 2) {
                var nEsqTopo = node.args[0];
                var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
                node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
              } else {
                node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
              }
              if (internal) {
                if (indParent === "content") {
                  parent.content = node;
                } else {
                  parent.args[indParent] = node;
                }
              }
            }
          }
          if (tp === "ParenthesisNode") {
            expandPower(node.content, node, "content");
          } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
            for (var i5 = 0; i5 < node.args.length; i5++) {
              expandPower(node.args[i5], node, i5);
            }
          }
          if (!internal) {
            return node;
          }
        }
        function polyToCanonical(node, coefficients) {
          if (coefficients === void 0) {
            coefficients = [];
          }
          coefficients[0] = 0;
          var o3 = {};
          o3.cte = 1;
          o3.oper = "+";
          o3.fire = "";
          var maxExpo = 0;
          var varname = "";
          recurPol(node, null, o3);
          maxExpo = coefficients.length - 1;
          var first = true;
          var no;
          for (var i5 = maxExpo; i5 >= 0; i5--) {
            if (coefficients[i5] === 0)
              continue;
            var n16 = new ConstantNode2(first ? coefficients[i5] : Math.abs(coefficients[i5]));
            var op = coefficients[i5] < 0 ? "-" : "+";
            if (i5 > 0) {
              var n25 = new SymbolNode2(varname);
              if (i5 > 1) {
                var n3 = new ConstantNode2(i5);
                n25 = new OperatorNode2("^", "pow", [n25, n3]);
              }
              if (coefficients[i5] === -1 && first) {
                n16 = new OperatorNode2("-", "unaryMinus", [n25]);
              } else if (Math.abs(coefficients[i5]) === 1) {
                n16 = n25;
              } else {
                n16 = new OperatorNode2("*", "multiply", [n16, n25]);
              }
            }
            if (first) {
              no = n16;
            } else if (op === "+") {
              no = new OperatorNode2("+", "add", [no, n16]);
            } else {
              no = new OperatorNode2("-", "subtract", [no, n16]);
            }
            first = false;
          }
          if (first) {
            return new ConstantNode2(0);
          } else {
            return no;
          }
          function recurPol(node2, noPai, o4) {
            var tp = node2.type;
            if (tp === "FunctionNode") {
              throw new Error("There is an unsolved function call");
            } else if (tp === "OperatorNode") {
              if ("+-*^".indexOf(node2.op) === -1)
                throw new Error("Operator " + node2.op + " invalid");
              if (noPai !== null) {
                if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
                  throw new Error("Invalid " + node2.op + " placing");
                }
                if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
                  throw new Error("Invalid " + node2.op + " placing");
                }
                if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o4.noFil !== 0) {
                  throw new Error("Invalid " + node2.op + " placing");
                }
              }
              if (node2.op === "^" || node2.op === "*") {
                o4.fire = node2.op;
              }
              for (var _i = 0; _i < node2.args.length; _i++) {
                if (node2.fn === "unaryMinus")
                  o4.oper = "-";
                if (node2.op === "+" || node2.fn === "subtract") {
                  o4.fire = "";
                  o4.cte = 1;
                  o4.oper = _i === 0 ? "+" : node2.op;
                }
                o4.noFil = _i;
                recurPol(node2.args[_i], node2, o4);
              }
            } else if (tp === "SymbolNode") {
              if (node2.name !== varname && varname !== "") {
                throw new Error("There is more than one variable");
              }
              varname = node2.name;
              if (noPai === null) {
                coefficients[1] = 1;
                return;
              }
              if (noPai.op === "^" && o4.noFil !== 0) {
                throw new Error("In power the variable should be the first parameter");
              }
              if (noPai.op === "*" && o4.noFil !== 1) {
                throw new Error("In multiply the variable should be the second parameter");
              }
              if (o4.fire === "" || o4.fire === "*") {
                if (maxExpo < 1)
                  coefficients[1] = 0;
                coefficients[1] += o4.cte * (o4.oper === "+" ? 1 : -1);
                maxExpo = Math.max(1, maxExpo);
              }
            } else if (tp === "ConstantNode") {
              var valor = parseFloat(node2.value);
              if (noPai === null) {
                coefficients[0] = valor;
                return;
              }
              if (noPai.op === "^") {
                if (o4.noFil !== 1)
                  throw new Error("Constant cannot be powered");
                if (!isInteger(valor) || valor <= 0) {
                  throw new Error("Non-integer exponent is not allowed");
                }
                for (var _i2 = maxExpo + 1; _i2 < valor; _i2++)
                  coefficients[_i2] = 0;
                if (valor > maxExpo)
                  coefficients[valor] = 0;
                coefficients[valor] += o4.cte * (o4.oper === "+" ? 1 : -1);
                maxExpo = Math.max(valor, maxExpo);
                return;
              }
              o4.cte = valor;
              if (o4.fire === "") {
                coefficients[0] += o4.cte * (o4.oper === "+" ? 1 : -1);
              }
            } else {
              throw new Error("Type " + tp + " is not allowed");
            }
          }
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
  var name284, dependencies284, createZpk2tf;
  var init_zpk2tf2 = __esm({
    "node_modules/mathjs/lib/esm/function/signal/zpk2tf.js"() {
      init_factory();
      name284 = "zpk2tf";
      dependencies284 = ["typed", "add", "multiply", "Complex", "number"];
      createZpk2tf = /* @__PURE__ */ factory(name284, dependencies284, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          multiply: multiply2,
          Complex: Complex3,
          number: number2
        } = _ref;
        return typed3(name284, {
          "Array,Array,number": function ArrayArrayNumber(z5, p3, k4) {
            return _zpk2tf(z5, p3, k4);
          },
          "Array,Array": function ArrayArray(z5, p3) {
            return _zpk2tf(z5, p3, 1);
          },
          "Matrix,Matrix,number": function MatrixMatrixNumber(z5, p3, k4) {
            return _zpk2tf(z5.valueOf(), p3.valueOf(), k4);
          },
          "Matrix,Matrix": function MatrixMatrix(z5, p3) {
            return _zpk2tf(z5.valueOf(), p3.valueOf(), 1);
          }
        });
        function _zpk2tf(z5, p3, k4) {
          if (z5.some((el) => el.type === "BigNumber")) {
            z5 = z5.map((el) => number2(el));
          }
          if (p3.some((el) => el.type === "BigNumber")) {
            p3 = p3.map((el) => number2(el));
          }
          var num = [Complex3(1, 0)];
          var den = [Complex3(1, 0)];
          for (var i5 = 0; i5 < z5.length; i5++) {
            var zero = z5[i5];
            if (typeof zero === "number")
              zero = Complex3(zero, 0);
            num = _multiply(num, [Complex3(1, 0), Complex3(-zero.re, -zero.im)]);
          }
          for (var _i = 0; _i < p3.length; _i++) {
            var pole = p3[_i];
            if (typeof pole === "number")
              pole = Complex3(pole, 0);
            den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
          }
          for (var _i2 = 0; _i2 < num.length; _i2++) {
            num[_i2] = multiply2(num[_i2], k4);
          }
          return [num, den];
        }
        function _multiply(a3, b3) {
          var c3 = [];
          for (var i5 = 0; i5 < a3.length + b3.length - 1; i5++) {
            c3[i5] = Complex3(0, 0);
            for (var j4 = 0; j4 < a3.length; j4++) {
              if (i5 - j4 >= 0 && i5 - j4 < b3.length) {
                c3[i5] = add3(c3[i5], multiply2(a3[j4], b3[i5 - j4]));
              }
            }
          }
          return c3;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/signal/freqz.js
  var name285, dependencies285, createFreqz;
  var init_freqz2 = __esm({
    "node_modules/mathjs/lib/esm/function/signal/freqz.js"() {
      init_factory();
      name285 = "freqz";
      dependencies285 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
      createFreqz = /* @__PURE__ */ factory(name285, dependencies285, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          multiply: multiply2,
          Complex: Complex3,
          divide: divide3,
          matrix: matrix2
        } = _ref;
        return typed3(name285, {
          "Array, Array": function ArrayArray(b3, a3) {
            var w4 = createBins(512);
            return _freqz(b3, a3, w4);
          },
          "Array, Array, Array": function ArrayArrayArray(b3, a3, w4) {
            return _freqz(b3, a3, w4);
          },
          "Array, Array, number": function ArrayArrayNumber(b3, a3, w4) {
            if (w4 < 0) {
              throw new Error("w must be a positive number");
            }
            var w22 = createBins(w4);
            return _freqz(b3, a3, w22);
          },
          "Matrix, Matrix": function MatrixMatrix(b3, a3) {
            var _w = createBins(512);
            var {
              w: w4,
              h: h3
            } = _freqz(b3.valueOf(), a3.valueOf(), _w);
            return {
              w: matrix2(w4),
              h: matrix2(h3)
            };
          },
          "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b3, a3, w4) {
            var {
              h: h3
            } = _freqz(b3.valueOf(), a3.valueOf(), w4.valueOf());
            return {
              h: matrix2(h3),
              w: matrix2(w4)
            };
          },
          "Matrix, Matrix, number": function MatrixMatrixNumber(b3, a3, w4) {
            if (w4 < 0) {
              throw new Error("w must be a positive number");
            }
            var _w = createBins(w4);
            var {
              h: h3
            } = _freqz(b3.valueOf(), a3.valueOf(), _w);
            return {
              h: matrix2(h3),
              w: matrix2(_w)
            };
          }
        });
        function _freqz(b3, a3, w4) {
          var num = [];
          var den = [];
          for (var i5 = 0; i5 < w4.length; i5++) {
            var sumNum = Complex3(0, 0);
            var sumDen = Complex3(0, 0);
            for (var j4 = 0; j4 < b3.length; j4++) {
              sumNum = add3(sumNum, multiply2(b3[j4], Complex3(Math.cos(-j4 * w4[i5]), Math.sin(-j4 * w4[i5]))));
            }
            for (var _j = 0; _j < a3.length; _j++) {
              sumDen = add3(sumDen, multiply2(a3[_j], Complex3(Math.cos(-_j * w4[i5]), Math.sin(-_j * w4[i5]))));
            }
            num.push(sumNum);
            den.push(sumDen);
          }
          var h3 = [];
          for (var _i = 0; _i < num.length; _i++) {
            h3.push(divide3(num[_i], den[_i]));
          }
          return {
            h: h3,
            w: w4
          };
        }
        function createBins(n3) {
          var bins = [];
          for (var i5 = 0; i5 < n3; i5++) {
            bins.push(i5 / n3 * Math.PI);
          }
          return bins;
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/json/reviver.js
  var name286, dependencies286, createReviver;
  var init_reviver = __esm({
    "node_modules/mathjs/lib/esm/json/reviver.js"() {
      init_factory();
      name286 = "reviver";
      dependencies286 = ["classes"];
      createReviver = /* @__PURE__ */ factory(name286, dependencies286, (_ref) => {
        var {
          classes: classes2
        } = _ref;
        return function reviver2(key, value) {
          var constructor = classes2[value && value.mathjs];
          if (constructor && typeof constructor.fromJSON === "function") {
            return constructor.fromJSON(value);
          }
          return value;
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/json/replacer.js
  var name287, dependencies287, createReplacer;
  var init_replacer = __esm({
    "node_modules/mathjs/lib/esm/json/replacer.js"() {
      init_factory();
      name287 = "replacer";
      dependencies287 = [];
      createReplacer = /* @__PURE__ */ factory(name287, dependencies287, () => {
        return function replacer2(key, value) {
          if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
            return {
              mathjs: "number",
              value: String(value)
            };
          }
          return value;
        };
      });
    }
  });

  // node_modules/mathjs/lib/esm/version.js
  var version;
  var init_version2 = __esm({
    "node_modules/mathjs/lib/esm/version.js"() {
      version = "11.10.0";
    }
  });

  // node_modules/mathjs/lib/esm/constants.js
  function recreateFactory(name307, dependencies307, create2) {
    return factory(name307, dependencies307, create2, {
      recreateOnConfigChange: true
    });
  }
  var createTrue, createFalse, createNull, createInfinity, createNaN, createPi, createTau, createE, createPhi, createLN2, createLN10, createLOG2E, createLOG10E, createSQRT1_2, createSQRT2, createI, createVersion;
  var init_constants3 = __esm({
    "node_modules/mathjs/lib/esm/constants.js"() {
      init_factory();
      init_version2();
      init_constants2();
      init_number2();
      createTrue = /* @__PURE__ */ factory("true", [], () => true);
      createFalse = /* @__PURE__ */ factory("false", [], () => false);
      createNull = /* @__PURE__ */ factory("null", [], () => null);
      createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref;
        return config4.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
      });
      createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref2;
        return config4.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
      });
      createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref3;
        return config4.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi;
      });
      createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref4;
        return config4.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau;
      });
      createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref5;
        return config4.number === "BigNumber" ? createBigNumberE(BigNumber2) : e3;
      });
      createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref6;
        return config4.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi;
      });
      createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref7;
        return config4.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
      });
      createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref8;
        return config4.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
      });
      createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref9;
        return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
      });
      createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref10;
        return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
      });
      createSQRT1_2 = /* @__PURE__ */ recreateFactory(
        // eslint-disable-line camelcase
        "SQRT1_2",
        ["config", "?BigNumber"],
        (_ref11) => {
          var {
            config: config4,
            BigNumber: BigNumber2
          } = _ref11;
          return config4.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
        }
      );
      createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
        var {
          config: config4,
          BigNumber: BigNumber2
        } = _ref12;
        return config4.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
      });
      createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
        var {
          Complex: Complex3
        } = _ref13;
        return Complex3.I;
      });
      createVersion = /* @__PURE__ */ factory("version", [], () => version);
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
  function unitFactory(name307, valueStr, unitStr) {
    var dependencies307 = ["config", "Unit", "BigNumber"];
    return factory(name307, dependencies307, (_ref) => {
      var {
        config: config4,
        Unit: Unit2,
        BigNumber: BigNumber2
      } = _ref;
      var value = config4.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
      var unit2 = new Unit2(value, unitStr);
      unit2.fixPrefix = true;
      return unit2;
    });
  }
  function numberFactory(name307, value) {
    var dependencies307 = ["config", "BigNumber"];
    return factory(name307, dependencies307, (_ref2) => {
      var {
        config: config4,
        BigNumber: BigNumber2
      } = _ref2;
      return config4.number === "BigNumber" ? new BigNumber2(value) : value;
    });
  }
  var createSpeedOfLight, createGravitationConstant, createPlanckConstant, createReducedPlanckConstant, createMagneticConstant, createElectricConstant, createVacuumImpedance, createCoulomb, createElementaryCharge, createBohrMagneton, createConductanceQuantum, createInverseConductanceQuantum, createMagneticFluxQuantum, createNuclearMagneton, createKlitzing, createBohrRadius, createClassicalElectronRadius, createElectronMass, createFermiCoupling, createFineStructure, createHartreeEnergy, createProtonMass, createDeuteronMass, createNeutronMass, createQuantumOfCirculation, createRydberg, createThomsonCrossSection, createWeakMixingAngle, createEfimovFactor, createAtomicMass, createAvogadro, createBoltzmann, createFaraday, createFirstRadiation, createLoschmidt, createGasConstant, createMolarPlanckConstant, createMolarVolume, createSackurTetrode, createSecondRadiation, createStefanBoltzmann, createWienDisplacement, createMolarMass, createMolarMassC12, createGravity, createPlanckLength, createPlanckMass, createPlanckTime, createPlanckCharge, createPlanckTemperature;
  var init_physicalConstants = __esm({
    "node_modules/mathjs/lib/esm/type/unit/physicalConstants.js"() {
      init_factory();
      createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
      createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
      createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
      createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
      createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
      createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
      createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
      createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
      createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
      createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
      createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
      createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
      createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
      createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
      createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
      createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
      createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
      createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
      createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
      createFineStructure = numberFactory("fineStructure", 0.0072973525693);
      createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
      createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
      createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
      createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
      createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
      createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
      createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
      createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
      createEfimovFactor = numberFactory("efimovFactor", 22.7);
      createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
      createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
      createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
      createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
      createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
      createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
      createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
      createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
      createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
      createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
      createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
      createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
      createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
      createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
      createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
      createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
      createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
      createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
      createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
      createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
      createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
  var name288, dependencies288, createApplyTransform;
  var init_apply_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/apply.transform.js"() {
      init_errorTransform();
      init_factory();
      init_apply();
      init_is();
      name288 = "apply";
      dependencies288 = ["typed", "isInteger"];
      createApplyTransform = /* @__PURE__ */ factory(name288, dependencies288, (_ref) => {
        var {
          typed: typed3,
          isInteger: isInteger3
        } = _ref;
        var apply2 = createApply({
          typed: typed3,
          isInteger: isInteger3
        });
        return typed3("apply", {
          "...any": function any(args) {
            var dim = args[1];
            if (isNumber(dim)) {
              args[1] = dim - 1;
            } else if (isBigNumber(dim)) {
              args[1] = dim.minus(1);
            }
            try {
              return apply2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/column.transform.js
  var name289, dependencies289, createColumnTransform;
  var init_column_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/column.transform.js"() {
      init_errorTransform();
      init_factory();
      init_column();
      init_is();
      name289 = "column";
      dependencies289 = ["typed", "Index", "matrix", "range"];
      createColumnTransform = /* @__PURE__ */ factory(name289, dependencies289, (_ref) => {
        var {
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        } = _ref;
        var column2 = createColumn({
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        });
        return typed3("column", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if (isNumber(last)) {
              args[lastIndex] = last - 1;
            }
            try {
              return column2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
  function compileInlineExpression(expression, math2, scope) {
    var symbol = expression.filter(function(node) {
      return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
    })[0];
    if (!symbol) {
      throw new Error('No undefined variable found in inline expression "' + expression + '"');
    }
    var name307 = symbol.name;
    var subScope = createSubScope(scope);
    var eq = expression.compile();
    return function inlineExpression(x4) {
      subScope.set(name307, x4);
      return eq.evaluate(subScope);
    };
  }
  var init_compileInlineExpression = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js"() {
      init_is();
      init_scope();
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
  function _filter(x4, callback) {
    return filter(x4, function(value, index2, array) {
      return applyCallback(callback, value, [index2 + 1], array, "filter");
    });
  }
  var name290, dependencies290, createFilterTransform;
  var init_filter_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/filter.transform.js"() {
      init_applyCallback();
      init_array();
      init_factory();
      init_is();
      init_compileInlineExpression();
      name290 = "filter";
      dependencies290 = ["typed"];
      createFilterTransform = /* @__PURE__ */ factory(name290, dependencies290, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        function filterTransform(args, math2, scope) {
          var x4, callback;
          if (args[0]) {
            x4 = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = compileInlineExpression(args[1], math2, scope);
            }
          }
          return filter3(x4, callback);
        }
        filterTransform.rawArgs = true;
        var filter3 = typed3("filter", {
          "Array, function": _filter,
          "Matrix, function": function MatrixFunction(x4, test) {
            return x4.create(_filter(x4.toArray(), test));
          },
          "Array, RegExp": filterRegExp,
          "Matrix, RegExp": function MatrixRegExp(x4, test) {
            return x4.create(filterRegExp(x4.toArray(), test));
          }
        });
        return filterTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
  var name291, dependencies291, createForEachTransform;
  var init_forEach_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js"() {
      init_applyCallback();
      init_array();
      init_factory();
      init_is();
      init_compileInlineExpression();
      name291 = "forEach";
      dependencies291 = ["typed"];
      createForEachTransform = /* @__PURE__ */ factory(name291, dependencies291, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        function forEachTransform(args, math2, scope) {
          var x4, callback;
          if (args[0]) {
            x4 = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = compileInlineExpression(args[1], math2, scope);
            }
          }
          return _forEach2(x4, callback);
        }
        forEachTransform.rawArgs = true;
        var _forEach2 = typed3("forEach", {
          "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
            var recurse = function recurse2(value, index2) {
              if (Array.isArray(value)) {
                forEach(value, function(child, i5) {
                  recurse2(child, index2.concat(i5 + 1));
                });
              } else {
                return applyCallback(callback, value, index2, array, "forEach");
              }
            };
            recurse(array.valueOf(), []);
          }
        });
        return forEachTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/index.transform.js
  var name292, dependencies292, createIndexTransform;
  var init_index_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/index.transform.js"() {
      init_is();
      init_factory();
      name292 = "index";
      dependencies292 = ["Index", "getMatrixDataType"];
      createIndexTransform = /* @__PURE__ */ factory(name292, dependencies292, (_ref) => {
        var {
          Index: Index2,
          getMatrixDataType: getMatrixDataType2
        } = _ref;
        return function indexTransform() {
          var args = [];
          for (var i5 = 0, ii = arguments.length; i5 < ii; i5++) {
            var arg2 = arguments[i5];
            if (isRange(arg2)) {
              arg2.start--;
              arg2.end -= arg2.step > 0 ? 0 : 2;
            } else if (arg2 && arg2.isSet === true) {
              arg2 = arg2.map(function(v3) {
                return v3 - 1;
              });
            } else if (isArray(arg2) || isMatrix(arg2)) {
              if (getMatrixDataType2(arg2) !== "boolean") {
                arg2 = arg2.map(function(v3) {
                  return v3 - 1;
                });
              }
            } else if (isNumber(arg2)) {
              arg2--;
            } else if (isBigNumber(arg2)) {
              arg2 = arg2.toNumber() - 1;
            } else if (typeof arg2 === "string") {
            } else {
              throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
            }
            args[i5] = arg2;
          }
          var res = new Index2();
          Index2.apply(res, args);
          return res;
        };
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/map.transform.js
  function _map2(array, callback, orig) {
    function recurse(value, index2) {
      if (Array.isArray(value)) {
        return map(value, function(child, i5) {
          return recurse(child, index2.concat(i5 + 1));
        });
      } else {
        return applyCallback(callback, value, index2, orig, "map");
      }
    }
    return recurse(array, []);
  }
  var name293, dependencies293, createMapTransform;
  var init_map_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/map.transform.js"() {
      init_applyCallback();
      init_array();
      init_factory();
      init_is();
      init_compileInlineExpression();
      name293 = "map";
      dependencies293 = ["typed"];
      createMapTransform = /* @__PURE__ */ factory(name293, dependencies293, (_ref) => {
        var {
          typed: typed3
        } = _ref;
        function mapTransform(args, math2, scope) {
          var x4, callback;
          if (args[0]) {
            x4 = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = compileInlineExpression(args[1], math2, scope);
            }
          }
          return map3(x4, callback);
        }
        mapTransform.rawArgs = true;
        var map3 = typed3("map", {
          "Array, function": function ArrayFunction(x4, callback) {
            return _map2(x4, callback, x4);
          },
          "Matrix, function": function MatrixFunction(x4, callback) {
            return x4.create(_map2(x4.valueOf(), callback, x4));
          }
        });
        return mapTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
  function lastDimToZeroBase(args) {
    if (args.length === 2 && isCollection(args[0])) {
      args = args.slice();
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
    }
    return args;
  }
  var init_lastDimToZeroBase = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js"() {
      init_is();
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/max.transform.js
  var name294, dependencies294, createMaxTransform;
  var init_max_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/max.transform.js"() {
      init_factory();
      init_errorTransform();
      init_max();
      init_lastDimToZeroBase();
      name294 = "max";
      dependencies294 = ["typed", "config", "numeric", "larger"];
      createMaxTransform = /* @__PURE__ */ factory(name294, dependencies294, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          numeric: numeric3,
          larger: larger2
        } = _ref;
        var max3 = createMax({
          typed: typed3,
          config: config4,
          numeric: numeric3,
          larger: larger2
        });
        return typed3("max", {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return max3.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
  var name295, dependencies295, createMeanTransform;
  var init_mean_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/mean.transform.js"() {
      init_factory();
      init_errorTransform();
      init_mean2();
      init_lastDimToZeroBase();
      name295 = "mean";
      dependencies295 = ["typed", "add", "divide"];
      createMeanTransform = /* @__PURE__ */ factory(name295, dependencies295, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          divide: divide3
        } = _ref;
        var mean2 = createMean({
          typed: typed3,
          add: add3,
          divide: divide3
        });
        return typed3("mean", {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return mean2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/min.transform.js
  var name296, dependencies296, createMinTransform;
  var init_min_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/min.transform.js"() {
      init_factory();
      init_errorTransform();
      init_min();
      init_lastDimToZeroBase();
      name296 = "min";
      dependencies296 = ["typed", "config", "numeric", "smaller"];
      createMinTransform = /* @__PURE__ */ factory(name296, dependencies296, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          numeric: numeric3,
          smaller: smaller2
        } = _ref;
        var min3 = createMin({
          typed: typed3,
          config: config4,
          numeric: numeric3,
          smaller: smaller2
        });
        return typed3("min", {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return min3.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/range.transform.js
  var name297, dependencies297, createRangeTransform;
  var init_range_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/range.transform.js"() {
      init_factory();
      init_range();
      name297 = "range";
      dependencies297 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
      createRangeTransform = /* @__PURE__ */ factory(name297, dependencies297, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          matrix: matrix2,
          bignumber: bignumber2,
          smaller: smaller2,
          smallerEq: smallerEq2,
          larger: larger2,
          largerEq: largerEq2,
          add: add3,
          isPositive: isPositive2
        } = _ref;
        var range2 = createRange({
          typed: typed3,
          config: config4,
          matrix: matrix2,
          bignumber: bignumber2,
          smaller: smaller2,
          smallerEq: smallerEq2,
          larger: larger2,
          largerEq: largerEq2,
          add: add3,
          isPositive: isPositive2
        });
        return typed3("range", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if (typeof last !== "boolean") {
              args.push(true);
            }
            return range2.apply(null, args);
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/row.transform.js
  var name298, dependencies298, createRowTransform;
  var init_row_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/row.transform.js"() {
      init_factory();
      init_row();
      init_errorTransform();
      init_is();
      name298 = "row";
      dependencies298 = ["typed", "Index", "matrix", "range"];
      createRowTransform = /* @__PURE__ */ factory(name298, dependencies298, (_ref) => {
        var {
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        } = _ref;
        var row2 = createRow({
          typed: typed3,
          Index: Index2,
          matrix: matrix2,
          range: range2
        });
        return typed3("row", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if (isNumber(last)) {
              args[lastIndex] = last - 1;
            }
            try {
              return row2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
  var name299, dependencies299, createSubsetTransform;
  var init_subset_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/subset.transform.js"() {
      init_factory();
      init_errorTransform();
      init_subset();
      name299 = "subset";
      dependencies299 = ["typed", "matrix", "zeros", "add"];
      createSubsetTransform = /* @__PURE__ */ factory(name299, dependencies299, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          zeros: zeros3,
          add: add3
        } = _ref;
        var subset2 = createSubset({
          typed: typed3,
          matrix: matrix2,
          zeros: zeros3,
          add: add3
        });
        return typed3("subset", {
          "...any": function any(args) {
            try {
              return subset2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
  var name300, dependencies300, createConcatTransform;
  var init_concat_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/concat.transform.js"() {
      init_is();
      init_errorTransform();
      init_factory();
      init_concat();
      name300 = "concat";
      dependencies300 = ["typed", "matrix", "isInteger"];
      createConcatTransform = /* @__PURE__ */ factory(name300, dependencies300, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          isInteger: isInteger3
        } = _ref;
        var concat3 = createConcat({
          typed: typed3,
          matrix: matrix2,
          isInteger: isInteger3
        });
        return typed3("concat", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if (isNumber(last)) {
              args[lastIndex] = last - 1;
            } else if (isBigNumber(last)) {
              args[lastIndex] = last.minus(1);
            }
            try {
              return concat3.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
  var name301, dependencies301, createDiffTransform;
  var init_diff_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/diff.transform.js"() {
      init_factory();
      init_errorTransform();
      init_diff();
      init_lastDimToZeroBase();
      name301 = "diff";
      dependencies301 = ["typed", "matrix", "subtract", "number", "bignumber"];
      createDiffTransform = /* @__PURE__ */ factory(name301, dependencies301, (_ref) => {
        var {
          typed: typed3,
          matrix: matrix2,
          subtract: subtract2,
          number: number2,
          bignumber: bignumber2
        } = _ref;
        var diff2 = createDiff({
          typed: typed3,
          matrix: matrix2,
          subtract: subtract2,
          number: number2,
          bignumber: bignumber2
        });
        return typed3(name301, {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return diff2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/std.transform.js
  var name302, dependencies302, createStdTransform;
  var init_std_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/std.transform.js"() {
      init_factory();
      init_std2();
      init_errorTransform();
      init_lastDimToZeroBase();
      name302 = "std";
      dependencies302 = ["typed", "map", "sqrt", "variance"];
      createStdTransform = /* @__PURE__ */ factory(name302, dependencies302, (_ref) => {
        var {
          typed: typed3,
          map: map3,
          sqrt: sqrt3,
          variance: variance2
        } = _ref;
        var std2 = createStd({
          typed: typed3,
          map: map3,
          sqrt: sqrt3,
          variance: variance2
        });
        return typed3("std", {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return std2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
  var name303, dependencies303, createSumTransform;
  var init_sum_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/sum.transform.js"() {
      init_factory();
      init_errorTransform();
      init_sum2();
      init_lastDimToZeroBase();
      name303 = "sum";
      dependencies303 = ["typed", "config", "add", "numeric"];
      createSumTransform = /* @__PURE__ */ factory(name303, dependencies303, (_ref) => {
        var {
          typed: typed3,
          config: config4,
          add: add3,
          numeric: numeric3
        } = _ref;
        var sum3 = createSum({
          typed: typed3,
          config: config4,
          add: add3,
          numeric: numeric3
        });
        return typed3(name303, {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return sum3.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
  var name304, dependencies304, createQuantileSeqTransform;
  var init_quantileSeq_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js"() {
      init_factory();
      init_quantileSeq2();
      init_lastDimToZeroBase();
      name304 = "quantileSeq";
      dependencies304 = ["typed", "add", "multiply", "partitionSelect", "compare", "isInteger"];
      createQuantileSeqTransform = /* @__PURE__ */ factory(name304, dependencies304, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          multiply: multiply2,
          partitionSelect: partitionSelect2,
          compare: compare3,
          isInteger: isInteger3
        } = _ref;
        var quantileSeq2 = createQuantileSeq({
          typed: typed3,
          add: add3,
          multiply: multiply2,
          partitionSelect: partitionSelect2,
          compare: compare3,
          isInteger: isInteger3
        });
        return typed3("quantileSeq", {
          "Array|Matrix, number|BigNumber|Array, number": (arr, prob, dim) => quantileSeq2(arr, prob, dimToZeroBase(dim)),
          "Array|Matrix, number|BigNumber|Array, boolean, number": (arr, prob, sorted, dim) => quantileSeq2(arr, prob, sorted, dimToZeroBase(dim))
        });
        function dimToZeroBase(dim) {
          return lastDimToZeroBase([[], dim])[1];
        }
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
  var name305, dependencies305, createCumSumTransform;
  var init_cumsum_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js"() {
      init_is();
      init_factory();
      init_errorTransform();
      init_cumsum2();
      name305 = "cumsum";
      dependencies305 = ["typed", "add", "unaryPlus"];
      createCumSumTransform = /* @__PURE__ */ factory(name305, dependencies305, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          unaryPlus: unaryPlus2
        } = _ref;
        var cumsum2 = createCumSum({
          typed: typed3,
          add: add3,
          unaryPlus: unaryPlus2
        });
        return typed3(name305, {
          "...any": function any(args) {
            if (args.length === 2 && isCollection(args[0])) {
              var dim = args[1];
              if (isNumber(dim)) {
                args[1] = dim - 1;
              } else if (isBigNumber(dim)) {
                args[1] = dim.minus(1);
              }
            }
            try {
              return cumsum2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
  var name306, dependencies306, createVarianceTransform;
  var init_variance_transform = __esm({
    "node_modules/mathjs/lib/esm/expression/transform/variance.transform.js"() {
      init_factory();
      init_errorTransform();
      init_variance2();
      init_lastDimToZeroBase();
      name306 = "variance";
      dependencies306 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
      createVarianceTransform = /* @__PURE__ */ factory(name306, dependencies306, (_ref) => {
        var {
          typed: typed3,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          apply: apply2,
          isNaN: isNaN3
        } = _ref;
        var variance2 = createVariance({
          typed: typed3,
          add: add3,
          subtract: subtract2,
          multiply: multiply2,
          divide: divide3,
          apply: apply2,
          isNaN: isNaN3
        });
        return typed3(name306, {
          "...any": function any(args) {
            args = lastDimToZeroBase(args);
            try {
              return variance2.apply(null, args);
            } catch (err) {
              throw errorTransform(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/mathjs/lib/esm/factoriesAny.js
  var init_factoriesAny = __esm({
    "node_modules/mathjs/lib/esm/factoriesAny.js"() {
      init_typed();
      init_ResultSet();
      init_BigNumber();
      init_Complex();
      init_Fraction();
      init_Range();
      init_Matrix();
      init_DenseMatrix();
      init_clone();
      init_isInteger();
      init_isNegative();
      init_isNumeric();
      init_hasNumericValue();
      init_isPositive();
      init_isZero();
      init_isNaN();
      init_typeOf();
      init_equalScalar();
      init_SparseMatrix();
      init_number3();
      init_string2();
      init_boolean();
      init_bignumber();
      init_complex2();
      init_fraction();
      init_matrix();
      init_matrixFromFunction();
      init_matrixFromRows();
      init_matrixFromColumns();
      init_splitUnit();
      init_unaryMinus();
      init_unaryPlus();
      init_abs();
      init_apply();
      init_addScalar();
      init_cbrt();
      init_ceil();
      init_cube();
      init_exp();
      init_expm1();
      init_fix();
      init_floor();
      init_gcd();
      init_lcm();
      init_log10();
      init_log2();
      init_mod();
      init_multiplyScalar();
      init_multiply();
      init_nthRoot();
      init_sign();
      init_sqrt();
      init_square();
      init_subtract();
      init_xgcd();
      init_invmod();
      init_dotMultiply();
      init_bitAnd();
      init_bitNot();
      init_bitOr();
      init_bitXor();
      init_arg();
      init_conj();
      init_im();
      init_re();
      init_not();
      init_or();
      init_xor();
      init_concat();
      init_column();
      init_count();
      init_cross();
      init_diag();
      init_filter();
      init_flatten();
      init_forEach();
      init_getMatrixDataType();
      init_identity();
      init_kron();
      init_map2();
      init_diff();
      init_ones();
      init_range();
      init_reshape();
      init_resize();
      init_rotate();
      init_rotationMatrix();
      init_row();
      init_size();
      init_squeeze();
      init_subset();
      init_transpose();
      init_ctranspose();
      init_zeros();
      init_fft();
      init_ifft();
      init_solveODE();
      init_erf();
      init_zeta();
      init_mode();
      init_prod();
      init_format();
      init_bin();
      init_oct();
      init_hex();
      init_print();
      init_to();
      init_isPrime();
      init_numeric();
      init_divideScalar();
      init_pow();
      init_round();
      init_log();
      init_log1p();
      init_nthRoots();
      init_dotPow();
      init_dotDivide();
      init_lsolve();
      init_usolve();
      init_lsolveAll();
      init_usolveAll();
      init_leftShift();
      init_rightArithShift();
      init_rightLogShift();
      init_and();
      init_compare();
      init_compareNatural();
      init_compareText();
      init_equal();
      init_equalText();
      init_smaller();
      init_smallerEq();
      init_larger();
      init_largerEq();
      init_deepEqual();
      init_unequal();
      init_partitionSelect();
      init_sort();
      init_max();
      init_min();
      init_ImmutableDenseMatrix();
      init_MatrixIndex();
      init_FibonacciHeap();
      init_Spa();
      init_Unit();
      init_unit();
      init_sparse();
      init_createUnit();
      init_acos();
      init_acosh();
      init_acot();
      init_acoth();
      init_acsc();
      init_acsch();
      init_asec();
      init_asech();
      init_asin();
      init_asinh();
      init_atan();
      init_atan2();
      init_atanh();
      init_cos();
      init_cosh();
      init_cot();
      init_coth();
      init_csc();
      init_csch();
      init_sec();
      init_sech();
      init_sin();
      init_sinh();
      init_tan();
      init_tanh();
      init_setCartesian();
      init_setDifference();
      init_setDistinct();
      init_setIntersect();
      init_setIsSubset();
      init_setMultiplicity();
      init_setPowerset();
      init_setSize();
      init_setSymDifference();
      init_setUnion();
      init_add();
      init_hypot();
      init_norm();
      init_dot();
      init_trace();
      init_function2();
      init_Node();
      init_AccessorNode();
      init_ArrayNode();
      init_AssignmentNode();
      init_BlockNode();
      init_ConditionalNode();
      init_ConstantNode();
      init_FunctionAssignmentNode();
      init_IndexNode();
      init_ObjectNode();
      init_OperatorNode();
      init_ParenthesisNode();
      init_RangeNode();
      init_RelationalNode();
      init_SymbolNode();
      init_FunctionNode();
      init_parse();
      init_compile();
      init_evaluate();
      init_Parser();
      init_parser();
      init_lup();
      init_qr();
      init_slu();
      init_lusolve();
      init_polynomialRoot();
      init_Help();
      init_Chain();
      init_help2();
      init_chain();
      init_det2();
      init_inv2();
      init_pinv2();
      init_eigs2();
      init_expm2();
      init_sqrtm2();
      init_sylvester2();
      init_schur2();
      init_lyap2();
      init_divide2();
      init_distance2();
      init_intersect2();
      init_sum2();
      init_cumsum2();
      init_mean2();
      init_median2();
      init_mad2();
      init_variance2();
      init_quantileSeq2();
      init_std2();
      init_combinations3();
      init_combinationsWithRep2();
      init_gamma2();
      init_lgamma2();
      init_factorial2();
      init_kldivergence2();
      init_multinomial2();
      init_permutations2();
      init_pickRandom2();
      init_random2();
      init_randomInt2();
      init_stirlingS22();
      init_bellNumbers2();
      init_catalan2();
      init_composition2();
      init_leafCount2();
      init_simplify2();
      init_simplifyConstant2();
      init_simplifyCore2();
      init_resolve2();
      init_symbolicEqual2();
      init_derivative2();
      init_rationalize2();
      init_zpk2tf2();
      init_freqz2();
      init_reviver();
      init_replacer();
      init_constants3();
      init_physicalConstants();
      init_apply_transform();
      init_column_transform();
      init_filter_transform();
      init_forEach_transform();
      init_index_transform();
      init_map_transform();
      init_max_transform();
      init_mean_transform();
      init_min_transform();
      init_range_transform();
      init_row_transform();
      init_subset_transform();
      init_concat_transform();
      init_diff_transform();
      init_std_transform();
      init_sum_transform();
      init_quantileSeq_transform();
      init_cumsum_transform();
      init_variance_transform();
    }
  });

  // node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
  var BigNumber, Complex2, e4, _false, fineStructure, Fraction2, i3, _Infinity, LN102, LOG10E, Matrix, _NaN, _null, phi2, Range, ResultSet, SQRT1_2, sackurTetrode, tau2, _true, version2, DenseMatrix, efimovFactor, LN2, pi2, replacer, SQRT2, typed2, unaryPlus, weakMixingAngle, abs2, acos2, acot, acsc, addScalar, arg, asech, asinh3, atan3, atanh3, bignumber, bitNot, boolean, clone4, combinations, complex, conj, cosh3, coth, csc, cube, equalScalar, erf, exp2, expm13, filter2, forEach2, format4, getMatrixDataType, hex, im, isInteger2, isNegative, isPositive, isZero, LOG2E, lgamma, log104, log24, map2, multiplyScalar, not, number, oct, pickRandom, print, random2, re, sec, sign3, sin2, SparseMatrix, splitUnit, square, string, tan2, typeOf2, acosh3, acsch, apply, asec, bin, combinationsWithRep, cos2, csch, isNaN2, isPrime, randomInt, sech, sinh3, sparse, sqrt2, tanh3, unaryMinus, acoth, cot, fraction, isNumeric, matrix, matrixFromFunction, mode, numeric2, prod, reshape2, size, squeeze2, transpose, xgcd, zeros2, asin2, cbrt4, concat2, count, ctranspose, diag, divideScalar, dotDivide, equal, flatten2, gcd, hasNumericValue, identity, kron, largerEq, leftShift, matrixFromColumns, mod2, nthRoot, ones, resize2, rightArithShift, round2, smaller, subtract, to, unequal, usolve, xor, add2, atan22, bitAnd, bitXor2, catalan, compare2, compareText2, cumsum, deepEqual, diff, distance, dot, equalText, floor2, hypot2, ImmutableDenseMatrix, Index, invmod, larger, log3, lsolve, matrixFromRows, min2, multiply, nthRoots, or, partitionSelect, qr, rightLogShift, slu, subset, sum2, trace, usolveAll, zpk2tf, bitOr, ceil2, compareNatural, composition, cross, det, dotMultiply, FibonacciHeap, fix, index, intersect, lcm, log1p2, lsolveAll, max2, quantileSeq, setCartesian, setDistinct, setIsSubset, setPowerset, smallerEq, sort, and, range, row, setDifference, setMultiplicity, setSymDifference, Spa, column, inv, lup, pinv, pow2, setIntersect, setUnion, sqrtm, Unit, vacuumImpedance, wienDisplacement, atomicMass, bohrMagneton, boltzmann, conductanceQuantum, createUnit, deuteronMass, dotPow, electricConstant, elementaryCharge, expm, faraday, fft, gamma, gravitationConstant, hartreeEnergy, ifft, klitzing, loschmidt, magneticConstant, molarMass, molarPlanckConstant, neutronMass, nuclearMagneton, planckCharge, planckLength, planckTemperature, protonMass, reducedPlanckConstant, rydberg, secondRadiation, speedOfLight, stefanBoltzmann, thomsonCrossSection, avogadro, bohrRadius, coulomb, divide2, electronMass, factorial, firstRadiation, gravity, inverseConductanceQuantum, lusolve, magneticFluxQuantum, molarMassC12, multinomial, permutations, planckMass, polynomialRoot, setSize, solveODE, stirlingS2, unit, bellNumbers, eigs, fermiCoupling, gasConstant, mean, molarVolume, planckConstant, quantumOfCirculation, variance, classicalElectronRadius, median, kldivergence, mad, std, zeta, freqz, norm, rotationMatrix, planckTime, schur, rotate, sylvester, lyap;
  var init_pureFunctionsAny_generated = __esm({
    "node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"() {
      init_configReadonly();
      init_factoriesAny();
      BigNumber = /* @__PURE__ */ createBigNumberClass({
        config
      });
      Complex2 = /* @__PURE__ */ createComplexClass({});
      e4 = /* @__PURE__ */ createE({
        BigNumber,
        config
      });
      _false = /* @__PURE__ */ createFalse({});
      fineStructure = /* @__PURE__ */ createFineStructure({
        BigNumber,
        config
      });
      Fraction2 = /* @__PURE__ */ createFractionClass({});
      i3 = /* @__PURE__ */ createI({
        Complex: Complex2
      });
      _Infinity = /* @__PURE__ */ createInfinity({
        BigNumber,
        config
      });
      LN102 = /* @__PURE__ */ createLN10({
        BigNumber,
        config
      });
      LOG10E = /* @__PURE__ */ createLOG10E({
        BigNumber,
        config
      });
      Matrix = /* @__PURE__ */ createMatrixClass({});
      _NaN = /* @__PURE__ */ createNaN({
        BigNumber,
        config
      });
      _null = /* @__PURE__ */ createNull({});
      phi2 = /* @__PURE__ */ createPhi({
        BigNumber,
        config
      });
      Range = /* @__PURE__ */ createRangeClass({});
      ResultSet = /* @__PURE__ */ createResultSet({});
      SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
        BigNumber,
        config
      });
      sackurTetrode = /* @__PURE__ */ createSackurTetrode({
        BigNumber,
        config
      });
      tau2 = /* @__PURE__ */ createTau({
        BigNumber,
        config
      });
      _true = /* @__PURE__ */ createTrue({});
      version2 = /* @__PURE__ */ createVersion({});
      DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
        Matrix
      });
      efimovFactor = /* @__PURE__ */ createEfimovFactor({
        BigNumber,
        config
      });
      LN2 = /* @__PURE__ */ createLN2({
        BigNumber,
        config
      });
      pi2 = /* @__PURE__ */ createPi({
        BigNumber,
        config
      });
      replacer = /* @__PURE__ */ createReplacer({});
      SQRT2 = /* @__PURE__ */ createSQRT2({
        BigNumber,
        config
      });
      typed2 = /* @__PURE__ */ createTyped({
        BigNumber,
        Complex: Complex2,
        DenseMatrix,
        Fraction: Fraction2
      });
      unaryPlus = /* @__PURE__ */ createUnaryPlus({
        BigNumber,
        config,
        typed: typed2
      });
      weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
        BigNumber,
        config
      });
      abs2 = /* @__PURE__ */ createAbs({
        typed: typed2
      });
      acos2 = /* @__PURE__ */ createAcos({
        Complex: Complex2,
        config,
        typed: typed2
      });
      acot = /* @__PURE__ */ createAcot({
        BigNumber,
        typed: typed2
      });
      acsc = /* @__PURE__ */ createAcsc({
        BigNumber,
        Complex: Complex2,
        config,
        typed: typed2
      });
      addScalar = /* @__PURE__ */ createAddScalar({
        typed: typed2
      });
      arg = /* @__PURE__ */ createArg({
        typed: typed2
      });
      asech = /* @__PURE__ */ createAsech({
        BigNumber,
        Complex: Complex2,
        config,
        typed: typed2
      });
      asinh3 = /* @__PURE__ */ createAsinh({
        typed: typed2
      });
      atan3 = /* @__PURE__ */ createAtan({
        typed: typed2
      });
      atanh3 = /* @__PURE__ */ createAtanh({
        Complex: Complex2,
        config,
        typed: typed2
      });
      bignumber = /* @__PURE__ */ createBignumber({
        BigNumber,
        typed: typed2
      });
      bitNot = /* @__PURE__ */ createBitNot({
        typed: typed2
      });
      boolean = /* @__PURE__ */ createBoolean({
        typed: typed2
      });
      clone4 = /* @__PURE__ */ createClone({
        typed: typed2
      });
      combinations = /* @__PURE__ */ createCombinations({
        typed: typed2
      });
      complex = /* @__PURE__ */ createComplex({
        Complex: Complex2,
        typed: typed2
      });
      conj = /* @__PURE__ */ createConj({
        typed: typed2
      });
      cosh3 = /* @__PURE__ */ createCosh({
        typed: typed2
      });
      coth = /* @__PURE__ */ createCoth({
        BigNumber,
        typed: typed2
      });
      csc = /* @__PURE__ */ createCsc({
        BigNumber,
        typed: typed2
      });
      cube = /* @__PURE__ */ createCube({
        typed: typed2
      });
      equalScalar = /* @__PURE__ */ createEqualScalar({
        config,
        typed: typed2
      });
      erf = /* @__PURE__ */ createErf({
        typed: typed2
      });
      exp2 = /* @__PURE__ */ createExp({
        typed: typed2
      });
      expm13 = /* @__PURE__ */ createExpm1({
        Complex: Complex2,
        typed: typed2
      });
      filter2 = /* @__PURE__ */ createFilter({
        typed: typed2
      });
      forEach2 = /* @__PURE__ */ createForEach({
        typed: typed2
      });
      format4 = /* @__PURE__ */ createFormat({
        typed: typed2
      });
      getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
        typed: typed2
      });
      hex = /* @__PURE__ */ createHex({
        format: format4,
        typed: typed2
      });
      im = /* @__PURE__ */ createIm({
        typed: typed2
      });
      isInteger2 = /* @__PURE__ */ createIsInteger({
        typed: typed2
      });
      isNegative = /* @__PURE__ */ createIsNegative({
        typed: typed2
      });
      isPositive = /* @__PURE__ */ createIsPositive({
        typed: typed2
      });
      isZero = /* @__PURE__ */ createIsZero({
        typed: typed2
      });
      LOG2E = /* @__PURE__ */ createLOG2E({
        BigNumber,
        config
      });
      lgamma = /* @__PURE__ */ createLgamma({
        Complex: Complex2,
        typed: typed2
      });
      log104 = /* @__PURE__ */ createLog10({
        Complex: Complex2,
        config,
        typed: typed2
      });
      log24 = /* @__PURE__ */ createLog2({
        Complex: Complex2,
        config,
        typed: typed2
      });
      map2 = /* @__PURE__ */ createMap2({
        typed: typed2
      });
      multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
        typed: typed2
      });
      not = /* @__PURE__ */ createNot({
        typed: typed2
      });
      number = /* @__PURE__ */ createNumber({
        typed: typed2
      });
      oct = /* @__PURE__ */ createOct({
        format: format4,
        typed: typed2
      });
      pickRandom = /* @__PURE__ */ createPickRandom({
        config,
        typed: typed2
      });
      print = /* @__PURE__ */ createPrint({
        typed: typed2
      });
      random2 = /* @__PURE__ */ createRandom({
        config,
        typed: typed2
      });
      re = /* @__PURE__ */ createRe({
        typed: typed2
      });
      sec = /* @__PURE__ */ createSec({
        BigNumber,
        typed: typed2
      });
      sign3 = /* @__PURE__ */ createSign({
        BigNumber,
        Fraction: Fraction2,
        complex,
        typed: typed2
      });
      sin2 = /* @__PURE__ */ createSin({
        typed: typed2
      });
      SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
        Matrix,
        equalScalar,
        typed: typed2
      });
      splitUnit = /* @__PURE__ */ createSplitUnit({
        typed: typed2
      });
      square = /* @__PURE__ */ createSquare({
        typed: typed2
      });
      string = /* @__PURE__ */ createString({
        typed: typed2
      });
      tan2 = /* @__PURE__ */ createTan({
        typed: typed2
      });
      typeOf2 = /* @__PURE__ */ createTypeOf({
        typed: typed2
      });
      acosh3 = /* @__PURE__ */ createAcosh({
        Complex: Complex2,
        config,
        typed: typed2
      });
      acsch = /* @__PURE__ */ createAcsch({
        BigNumber,
        typed: typed2
      });
      apply = /* @__PURE__ */ createApply({
        isInteger: isInteger2,
        typed: typed2
      });
      asec = /* @__PURE__ */ createAsec({
        BigNumber,
        Complex: Complex2,
        config,
        typed: typed2
      });
      bin = /* @__PURE__ */ createBin({
        format: format4,
        typed: typed2
      });
      combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
        typed: typed2
      });
      cos2 = /* @__PURE__ */ createCos({
        typed: typed2
      });
      csch = /* @__PURE__ */ createCsch({
        BigNumber,
        typed: typed2
      });
      isNaN2 = /* @__PURE__ */ createIsNaN({
        typed: typed2
      });
      isPrime = /* @__PURE__ */ createIsPrime({
        typed: typed2
      });
      randomInt = /* @__PURE__ */ createRandomInt({
        config,
        typed: typed2
      });
      sech = /* @__PURE__ */ createSech({
        BigNumber,
        typed: typed2
      });
      sinh3 = /* @__PURE__ */ createSinh({
        typed: typed2
      });
      sparse = /* @__PURE__ */ createSparse({
        SparseMatrix,
        typed: typed2
      });
      sqrt2 = /* @__PURE__ */ createSqrt({
        Complex: Complex2,
        config,
        typed: typed2
      });
      tanh3 = /* @__PURE__ */ createTanh({
        typed: typed2
      });
      unaryMinus = /* @__PURE__ */ createUnaryMinus({
        typed: typed2
      });
      acoth = /* @__PURE__ */ createAcoth({
        BigNumber,
        Complex: Complex2,
        config,
        typed: typed2
      });
      cot = /* @__PURE__ */ createCot({
        BigNumber,
        typed: typed2
      });
      fraction = /* @__PURE__ */ createFraction({
        Fraction: Fraction2,
        typed: typed2
      });
      isNumeric = /* @__PURE__ */ createIsNumeric({
        typed: typed2
      });
      matrix = /* @__PURE__ */ createMatrix({
        DenseMatrix,
        Matrix,
        SparseMatrix,
        typed: typed2
      });
      matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
        isZero,
        matrix,
        typed: typed2
      });
      mode = /* @__PURE__ */ createMode({
        isNaN: isNaN2,
        isNumeric,
        typed: typed2
      });
      numeric2 = /* @__PURE__ */ createNumeric({
        bignumber,
        fraction,
        number
      });
      prod = /* @__PURE__ */ createProd({
        config,
        multiplyScalar,
        numeric: numeric2,
        typed: typed2
      });
      reshape2 = /* @__PURE__ */ createReshape({
        isInteger: isInteger2,
        matrix,
        typed: typed2
      });
      size = /* @__PURE__ */ createSize({
        matrix,
        config,
        typed: typed2
      });
      squeeze2 = /* @__PURE__ */ createSqueeze({
        matrix,
        typed: typed2
      });
      transpose = /* @__PURE__ */ createTranspose({
        matrix,
        typed: typed2
      });
      xgcd = /* @__PURE__ */ createXgcd({
        BigNumber,
        config,
        matrix,
        typed: typed2
      });
      zeros2 = /* @__PURE__ */ createZeros({
        BigNumber,
        config,
        matrix,
        typed: typed2
      });
      asin2 = /* @__PURE__ */ createAsin({
        Complex: Complex2,
        config,
        typed: typed2
      });
      cbrt4 = /* @__PURE__ */ createCbrt({
        BigNumber,
        Complex: Complex2,
        Fraction: Fraction2,
        config,
        isNegative,
        matrix,
        typed: typed2,
        unaryMinus
      });
      concat2 = /* @__PURE__ */ createConcat({
        isInteger: isInteger2,
        matrix,
        typed: typed2
      });
      count = /* @__PURE__ */ createCount({
        prod,
        size,
        typed: typed2
      });
      ctranspose = /* @__PURE__ */ createCtranspose({
        conj,
        transpose,
        typed: typed2
      });
      diag = /* @__PURE__ */ createDiag({
        DenseMatrix,
        SparseMatrix,
        matrix,
        typed: typed2
      });
      divideScalar = /* @__PURE__ */ createDivideScalar({
        numeric: numeric2,
        typed: typed2
      });
      dotDivide = /* @__PURE__ */ createDotDivide({
        DenseMatrix,
        concat: concat2,
        divideScalar,
        equalScalar,
        matrix,
        typed: typed2
      });
      equal = /* @__PURE__ */ createEqual({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      flatten2 = /* @__PURE__ */ createFlatten({
        matrix,
        typed: typed2
      });
      gcd = /* @__PURE__ */ createGcd({
        BigNumber,
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      hasNumericValue = /* @__PURE__ */ createHasNumericValue({
        isNumeric,
        typed: typed2
      });
      identity = /* @__PURE__ */ createIdentity({
        BigNumber,
        DenseMatrix,
        SparseMatrix,
        config,
        matrix,
        typed: typed2
      });
      kron = /* @__PURE__ */ createKron({
        matrix,
        multiplyScalar,
        typed: typed2
      });
      largerEq = /* @__PURE__ */ createLargerEq({
        DenseMatrix,
        concat: concat2,
        config,
        matrix,
        typed: typed2
      });
      leftShift = /* @__PURE__ */ createLeftShift({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
        flatten: flatten2,
        matrix,
        size,
        typed: typed2
      });
      mod2 = /* @__PURE__ */ createMod({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      nthRoot = /* @__PURE__ */ createNthRoot({
        BigNumber,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      ones = /* @__PURE__ */ createOnes({
        BigNumber,
        config,
        matrix,
        typed: typed2
      });
      resize2 = /* @__PURE__ */ createResize({
        config,
        matrix
      });
      rightArithShift = /* @__PURE__ */ createRightArithShift({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      round2 = /* @__PURE__ */ createRound({
        BigNumber,
        DenseMatrix,
        equalScalar,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      smaller = /* @__PURE__ */ createSmaller({
        DenseMatrix,
        concat: concat2,
        config,
        matrix,
        typed: typed2
      });
      subtract = /* @__PURE__ */ createSubtract({
        DenseMatrix,
        addScalar,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2,
        unaryMinus
      });
      to = /* @__PURE__ */ createTo({
        concat: concat2,
        matrix,
        typed: typed2
      });
      unequal = /* @__PURE__ */ createUnequal({
        DenseMatrix,
        concat: concat2,
        config,
        equalScalar,
        matrix,
        typed: typed2
      });
      usolve = /* @__PURE__ */ createUsolve({
        DenseMatrix,
        divideScalar,
        equalScalar,
        matrix,
        multiplyScalar,
        subtract,
        typed: typed2
      });
      xor = /* @__PURE__ */ createXor({
        DenseMatrix,
        concat: concat2,
        matrix,
        typed: typed2
      });
      add2 = /* @__PURE__ */ createAdd({
        DenseMatrix,
        SparseMatrix,
        addScalar,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      atan22 = /* @__PURE__ */ createAtan2({
        BigNumber,
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      bitAnd = /* @__PURE__ */ createBitAnd({
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      bitXor2 = /* @__PURE__ */ createBitXor({
        DenseMatrix,
        concat: concat2,
        matrix,
        typed: typed2
      });
      catalan = /* @__PURE__ */ createCatalan({
        addScalar,
        combinations,
        divideScalar,
        isInteger: isInteger2,
        isNegative,
        multiplyScalar,
        typed: typed2
      });
      compare2 = /* @__PURE__ */ createCompare({
        BigNumber,
        DenseMatrix,
        Fraction: Fraction2,
        concat: concat2,
        config,
        equalScalar,
        matrix,
        typed: typed2
      });
      compareText2 = /* @__PURE__ */ createCompareText({
        concat: concat2,
        matrix,
        typed: typed2
      });
      cumsum = /* @__PURE__ */ createCumSum({
        add: add2,
        typed: typed2,
        unaryPlus
      });
      deepEqual = /* @__PURE__ */ createDeepEqual({
        equal,
        typed: typed2
      });
      diff = /* @__PURE__ */ createDiff({
        matrix,
        number,
        subtract,
        typed: typed2
      });
      distance = /* @__PURE__ */ createDistance({
        abs: abs2,
        addScalar,
        deepEqual,
        divideScalar,
        multiplyScalar,
        sqrt: sqrt2,
        subtract,
        typed: typed2
      });
      dot = /* @__PURE__ */ createDot({
        addScalar,
        conj,
        multiplyScalar,
        size,
        typed: typed2
      });
      equalText = /* @__PURE__ */ createEqualText({
        compareText: compareText2,
        isZero,
        typed: typed2
      });
      floor2 = /* @__PURE__ */ createFloor({
        DenseMatrix,
        config,
        equalScalar,
        matrix,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      hypot2 = /* @__PURE__ */ createHypot({
        abs: abs2,
        addScalar,
        divideScalar,
        isPositive,
        multiplyScalar,
        smaller,
        sqrt: sqrt2,
        typed: typed2
      });
      ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
        DenseMatrix,
        smaller
      });
      Index = /* @__PURE__ */ createIndexClass({
        ImmutableDenseMatrix,
        getMatrixDataType
      });
      invmod = /* @__PURE__ */ createInvmod({
        BigNumber,
        add: add2,
        config,
        equal,
        isInteger: isInteger2,
        mod: mod2,
        smaller,
        typed: typed2,
        xgcd
      });
      larger = /* @__PURE__ */ createLarger({
        DenseMatrix,
        concat: concat2,
        config,
        matrix,
        typed: typed2
      });
      log3 = /* @__PURE__ */ createLog({
        Complex: Complex2,
        config,
        divideScalar,
        typed: typed2
      });
      lsolve = /* @__PURE__ */ createLsolve({
        DenseMatrix,
        divideScalar,
        equalScalar,
        matrix,
        multiplyScalar,
        subtract,
        typed: typed2
      });
      matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
        flatten: flatten2,
        matrix,
        size,
        typed: typed2
      });
      min2 = /* @__PURE__ */ createMin({
        config,
        numeric: numeric2,
        smaller,
        typed: typed2
      });
      multiply = /* @__PURE__ */ createMultiply({
        addScalar,
        dot,
        equalScalar,
        matrix,
        multiplyScalar,
        typed: typed2
      });
      nthRoots = /* @__PURE__ */ createNthRoots({
        Complex: Complex2,
        config,
        divideScalar,
        typed: typed2
      });
      or = /* @__PURE__ */ createOr({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      partitionSelect = /* @__PURE__ */ createPartitionSelect({
        compare: compare2,
        isNaN: isNaN2,
        isNumeric,
        typed: typed2
      });
      qr = /* @__PURE__ */ createQr({
        addScalar,
        complex,
        conj,
        divideScalar,
        equal,
        identity,
        isZero,
        matrix,
        multiplyScalar,
        sign: sign3,
        sqrt: sqrt2,
        subtract,
        typed: typed2,
        unaryMinus,
        zeros: zeros2
      });
      rightLogShift = /* @__PURE__ */ createRightLogShift({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      slu = /* @__PURE__ */ createSlu({
        SparseMatrix,
        abs: abs2,
        add: add2,
        divideScalar,
        larger,
        largerEq,
        multiply,
        subtract,
        transpose,
        typed: typed2
      });
      subset = /* @__PURE__ */ createSubset({
        add: add2,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      sum2 = /* @__PURE__ */ createSum({
        add: add2,
        config,
        numeric: numeric2,
        typed: typed2
      });
      trace = /* @__PURE__ */ createTrace({
        add: add2,
        matrix,
        typed: typed2
      });
      usolveAll = /* @__PURE__ */ createUsolveAll({
        DenseMatrix,
        divideScalar,
        equalScalar,
        matrix,
        multiplyScalar,
        subtract,
        typed: typed2
      });
      zpk2tf = /* @__PURE__ */ createZpk2tf({
        Complex: Complex2,
        add: add2,
        multiply,
        number,
        typed: typed2
      });
      bitOr = /* @__PURE__ */ createBitOr({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      ceil2 = /* @__PURE__ */ createCeil({
        DenseMatrix,
        config,
        equalScalar,
        matrix,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      compareNatural = /* @__PURE__ */ createCompareNatural({
        compare: compare2,
        typed: typed2
      });
      composition = /* @__PURE__ */ createComposition({
        addScalar,
        combinations,
        isInteger: isInteger2,
        isNegative,
        isPositive,
        larger,
        typed: typed2
      });
      cross = /* @__PURE__ */ createCross({
        matrix,
        multiply,
        subtract,
        typed: typed2
      });
      det = /* @__PURE__ */ createDet({
        divideScalar,
        isZero,
        matrix,
        multiply,
        subtract,
        typed: typed2,
        unaryMinus
      });
      dotMultiply = /* @__PURE__ */ createDotMultiply({
        concat: concat2,
        equalScalar,
        matrix,
        multiplyScalar,
        typed: typed2
      });
      FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
        larger,
        smaller
      });
      fix = /* @__PURE__ */ createFix({
        Complex: Complex2,
        DenseMatrix,
        ceil: ceil2,
        equalScalar,
        floor: floor2,
        matrix,
        typed: typed2,
        zeros: zeros2
      });
      index = /* @__PURE__ */ createIndex({
        Index,
        typed: typed2
      });
      intersect = /* @__PURE__ */ createIntersect({
        abs: abs2,
        add: add2,
        addScalar,
        config,
        divideScalar,
        equalScalar,
        flatten: flatten2,
        isNumeric,
        isZero,
        matrix,
        multiply,
        multiplyScalar,
        smaller,
        subtract,
        typed: typed2
      });
      lcm = /* @__PURE__ */ createLcm({
        concat: concat2,
        equalScalar,
        matrix,
        typed: typed2
      });
      log1p2 = /* @__PURE__ */ createLog1p({
        Complex: Complex2,
        config,
        divideScalar,
        log: log3,
        typed: typed2
      });
      lsolveAll = /* @__PURE__ */ createLsolveAll({
        DenseMatrix,
        divideScalar,
        equalScalar,
        matrix,
        multiplyScalar,
        subtract,
        typed: typed2
      });
      max2 = /* @__PURE__ */ createMax({
        config,
        larger,
        numeric: numeric2,
        typed: typed2
      });
      quantileSeq = /* @__PURE__ */ createQuantileSeq({
        add: add2,
        compare: compare2,
        isInteger: isInteger2,
        multiply,
        partitionSelect,
        typed: typed2
      });
      setCartesian = /* @__PURE__ */ createSetCartesian({
        DenseMatrix,
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setDistinct = /* @__PURE__ */ createSetDistinct({
        DenseMatrix,
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setIsSubset = /* @__PURE__ */ createSetIsSubset({
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setPowerset = /* @__PURE__ */ createSetPowerset({
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      smallerEq = /* @__PURE__ */ createSmallerEq({
        DenseMatrix,
        concat: concat2,
        config,
        matrix,
        typed: typed2
      });
      sort = /* @__PURE__ */ createSort({
        compare: compare2,
        compareNatural,
        matrix,
        typed: typed2
      });
      and = /* @__PURE__ */ createAnd({
        concat: concat2,
        equalScalar,
        matrix,
        not,
        typed: typed2,
        zeros: zeros2
      });
      range = /* @__PURE__ */ createRange({
        bignumber,
        matrix,
        add: add2,
        config,
        isPositive,
        larger,
        largerEq,
        smaller,
        smallerEq,
        typed: typed2
      });
      row = /* @__PURE__ */ createRow({
        Index,
        matrix,
        range,
        typed: typed2
      });
      setDifference = /* @__PURE__ */ createSetDifference({
        DenseMatrix,
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setSymDifference = /* @__PURE__ */ createSetSymDifference({
        Index,
        concat: concat2,
        setDifference,
        size,
        subset,
        typed: typed2
      });
      Spa = /* @__PURE__ */ createSpaClass({
        FibonacciHeap,
        addScalar,
        equalScalar
      });
      column = /* @__PURE__ */ createColumn({
        Index,
        matrix,
        range,
        typed: typed2
      });
      inv = /* @__PURE__ */ createInv({
        abs: abs2,
        addScalar,
        det,
        divideScalar,
        identity,
        matrix,
        multiply,
        typed: typed2,
        unaryMinus
      });
      lup = /* @__PURE__ */ createLup({
        DenseMatrix,
        Spa,
        SparseMatrix,
        abs: abs2,
        addScalar,
        divideScalar,
        equalScalar,
        larger,
        matrix,
        multiplyScalar,
        subtract,
        typed: typed2,
        unaryMinus
      });
      pinv = /* @__PURE__ */ createPinv({
        Complex: Complex2,
        add: add2,
        ctranspose,
        deepEqual,
        divideScalar,
        dot,
        dotDivide,
        equal,
        inv,
        matrix,
        multiply,
        typed: typed2
      });
      pow2 = /* @__PURE__ */ createPow({
        Complex: Complex2,
        config,
        fraction,
        identity,
        inv,
        matrix,
        multiply,
        number,
        typed: typed2
      });
      setIntersect = /* @__PURE__ */ createSetIntersect({
        DenseMatrix,
        Index,
        compareNatural,
        size,
        subset,
        typed: typed2
      });
      setUnion = /* @__PURE__ */ createSetUnion({
        Index,
        concat: concat2,
        setIntersect,
        setSymDifference,
        size,
        subset,
        typed: typed2
      });
      sqrtm = /* @__PURE__ */ createSqrtm({
        abs: abs2,
        add: add2,
        identity,
        inv,
        map: map2,
        max: max2,
        multiply,
        size,
        sqrt: sqrt2,
        subtract,
        typed: typed2
      });
      Unit = /* @__PURE__ */ createUnitClass({
        BigNumber,
        Complex: Complex2,
        Fraction: Fraction2,
        abs: abs2,
        addScalar,
        config,
        divideScalar,
        equal,
        fix,
        format: format4,
        isNumeric,
        multiplyScalar,
        number,
        pow: pow2,
        round: round2,
        subtract
      });
      vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
        BigNumber,
        Unit,
        config
      });
      wienDisplacement = /* @__PURE__ */ createWienDisplacement({
        BigNumber,
        Unit,
        config
      });
      atomicMass = /* @__PURE__ */ createAtomicMass({
        BigNumber,
        Unit,
        config
      });
      bohrMagneton = /* @__PURE__ */ createBohrMagneton({
        BigNumber,
        Unit,
        config
      });
      boltzmann = /* @__PURE__ */ createBoltzmann({
        BigNumber,
        Unit,
        config
      });
      conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
        BigNumber,
        Unit,
        config
      });
      createUnit = /* @__PURE__ */ createCreateUnit({
        Unit,
        typed: typed2
      });
      deuteronMass = /* @__PURE__ */ createDeuteronMass({
        BigNumber,
        Unit,
        config
      });
      dotPow = /* @__PURE__ */ createDotPow({
        DenseMatrix,
        concat: concat2,
        equalScalar,
        matrix,
        pow: pow2,
        typed: typed2
      });
      electricConstant = /* @__PURE__ */ createElectricConstant({
        BigNumber,
        Unit,
        config
      });
      elementaryCharge = /* @__PURE__ */ createElementaryCharge({
        BigNumber,
        Unit,
        config
      });
      expm = /* @__PURE__ */ createExpm({
        abs: abs2,
        add: add2,
        identity,
        inv,
        multiply,
        typed: typed2
      });
      faraday = /* @__PURE__ */ createFaraday({
        BigNumber,
        Unit,
        config
      });
      fft = /* @__PURE__ */ createFft({
        addScalar,
        ceil: ceil2,
        conj,
        divideScalar,
        dotDivide,
        exp: exp2,
        i: i3,
        log2: log24,
        matrix,
        multiplyScalar,
        pow: pow2,
        tau: tau2,
        typed: typed2
      });
      gamma = /* @__PURE__ */ createGamma({
        BigNumber,
        Complex: Complex2,
        config,
        multiplyScalar,
        pow: pow2,
        typed: typed2
      });
      gravitationConstant = /* @__PURE__ */ createGravitationConstant({
        BigNumber,
        Unit,
        config
      });
      hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
        BigNumber,
        Unit,
        config
      });
      ifft = /* @__PURE__ */ createIfft({
        conj,
        dotDivide,
        fft,
        typed: typed2
      });
      klitzing = /* @__PURE__ */ createKlitzing({
        BigNumber,
        Unit,
        config
      });
      loschmidt = /* @__PURE__ */ createLoschmidt({
        BigNumber,
        Unit,
        config
      });
      magneticConstant = /* @__PURE__ */ createMagneticConstant({
        BigNumber,
        Unit,
        config
      });
      molarMass = /* @__PURE__ */ createMolarMass({
        BigNumber,
        Unit,
        config
      });
      molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
        BigNumber,
        Unit,
        config
      });
      neutronMass = /* @__PURE__ */ createNeutronMass({
        BigNumber,
        Unit,
        config
      });
      nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
        BigNumber,
        Unit,
        config
      });
      planckCharge = /* @__PURE__ */ createPlanckCharge({
        BigNumber,
        Unit,
        config
      });
      planckLength = /* @__PURE__ */ createPlanckLength({
        BigNumber,
        Unit,
        config
      });
      planckTemperature = /* @__PURE__ */ createPlanckTemperature({
        BigNumber,
        Unit,
        config
      });
      protonMass = /* @__PURE__ */ createProtonMass({
        BigNumber,
        Unit,
        config
      });
      reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
        BigNumber,
        Unit,
        config
      });
      rydberg = /* @__PURE__ */ createRydberg({
        BigNumber,
        Unit,
        config
      });
      secondRadiation = /* @__PURE__ */ createSecondRadiation({
        BigNumber,
        Unit,
        config
      });
      speedOfLight = /* @__PURE__ */ createSpeedOfLight({
        BigNumber,
        Unit,
        config
      });
      stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
        BigNumber,
        Unit,
        config
      });
      thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
        BigNumber,
        Unit,
        config
      });
      avogadro = /* @__PURE__ */ createAvogadro({
        BigNumber,
        Unit,
        config
      });
      bohrRadius = /* @__PURE__ */ createBohrRadius({
        BigNumber,
        Unit,
        config
      });
      coulomb = /* @__PURE__ */ createCoulomb({
        BigNumber,
        Unit,
        config
      });
      divide2 = /* @__PURE__ */ createDivide({
        divideScalar,
        equalScalar,
        inv,
        matrix,
        multiply,
        typed: typed2
      });
      electronMass = /* @__PURE__ */ createElectronMass({
        BigNumber,
        Unit,
        config
      });
      factorial = /* @__PURE__ */ createFactorial({
        gamma,
        typed: typed2
      });
      firstRadiation = /* @__PURE__ */ createFirstRadiation({
        BigNumber,
        Unit,
        config
      });
      gravity = /* @__PURE__ */ createGravity({
        BigNumber,
        Unit,
        config
      });
      inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
        BigNumber,
        Unit,
        config
      });
      lusolve = /* @__PURE__ */ createLusolve({
        DenseMatrix,
        lsolve,
        lup,
        matrix,
        slu,
        typed: typed2,
        usolve
      });
      magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
        BigNumber,
        Unit,
        config
      });
      molarMassC12 = /* @__PURE__ */ createMolarMassC12({
        BigNumber,
        Unit,
        config
      });
      multinomial = /* @__PURE__ */ createMultinomial({
        add: add2,
        divide: divide2,
        factorial,
        isInteger: isInteger2,
        isPositive,
        multiply,
        typed: typed2
      });
      permutations = /* @__PURE__ */ createPermutations({
        factorial,
        typed: typed2
      });
      planckMass = /* @__PURE__ */ createPlanckMass({
        BigNumber,
        Unit,
        config
      });
      polynomialRoot = /* @__PURE__ */ createPolynomialRoot({
        add: add2,
        cbrt: cbrt4,
        divide: divide2,
        equalScalar,
        im,
        isZero,
        multiply,
        re,
        sqrt: sqrt2,
        subtract,
        typeOf: typeOf2,
        typed: typed2,
        unaryMinus
      });
      setSize = /* @__PURE__ */ createSetSize({
        compareNatural,
        typed: typed2
      });
      solveODE = /* @__PURE__ */ createSolveODE({
        abs: abs2,
        add: add2,
        bignumber,
        divide: divide2,
        isNegative,
        isPositive,
        larger,
        map: map2,
        matrix,
        max: max2,
        multiply,
        smaller,
        subtract,
        typed: typed2,
        unaryMinus
      });
      stirlingS2 = /* @__PURE__ */ createStirlingS2({
        bignumber,
        addScalar,
        combinations,
        divideScalar,
        factorial,
        isInteger: isInteger2,
        isNegative,
        larger,
        multiplyScalar,
        number,
        pow: pow2,
        subtract,
        typed: typed2
      });
      unit = /* @__PURE__ */ createUnitFunction({
        Unit,
        typed: typed2
      });
      bellNumbers = /* @__PURE__ */ createBellNumbers({
        addScalar,
        isInteger: isInteger2,
        isNegative,
        stirlingS2,
        typed: typed2
      });
      eigs = /* @__PURE__ */ createEigs({
        abs: abs2,
        add: add2,
        addScalar,
        atan: atan3,
        bignumber,
        column,
        complex,
        config,
        cos: cos2,
        diag,
        divideScalar,
        dot,
        equal,
        flatten: flatten2,
        im,
        inv,
        larger,
        matrix,
        matrixFromColumns,
        multiply,
        multiplyScalar,
        number,
        qr,
        re,
        sin: sin2,
        smaller,
        sqrt: sqrt2,
        subtract,
        typed: typed2,
        usolve,
        usolveAll
      });
      fermiCoupling = /* @__PURE__ */ createFermiCoupling({
        BigNumber,
        Unit,
        config
      });
      gasConstant = /* @__PURE__ */ createGasConstant({
        BigNumber,
        Unit,
        config
      });
      mean = /* @__PURE__ */ createMean({
        add: add2,
        divide: divide2,
        typed: typed2
      });
      molarVolume = /* @__PURE__ */ createMolarVolume({
        BigNumber,
        Unit,
        config
      });
      planckConstant = /* @__PURE__ */ createPlanckConstant({
        BigNumber,
        Unit,
        config
      });
      quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
        BigNumber,
        Unit,
        config
      });
      variance = /* @__PURE__ */ createVariance({
        add: add2,
        apply,
        divide: divide2,
        isNaN: isNaN2,
        multiply,
        subtract,
        typed: typed2
      });
      classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
        BigNumber,
        Unit,
        config
      });
      median = /* @__PURE__ */ createMedian({
        add: add2,
        compare: compare2,
        divide: divide2,
        partitionSelect,
        typed: typed2
      });
      kldivergence = /* @__PURE__ */ createKldivergence({
        divide: divide2,
        dotDivide,
        isNumeric,
        log: log3,
        map: map2,
        matrix,
        multiply,
        sum: sum2,
        typed: typed2
      });
      mad = /* @__PURE__ */ createMad({
        abs: abs2,
        map: map2,
        median,
        subtract,
        typed: typed2
      });
      std = /* @__PURE__ */ createStd({
        map: map2,
        sqrt: sqrt2,
        typed: typed2,
        variance
      });
      zeta = /* @__PURE__ */ createZeta({
        BigNumber,
        Complex: Complex2,
        add: add2,
        config,
        divide: divide2,
        equal,
        factorial,
        gamma,
        isNegative,
        multiply,
        pi: pi2,
        pow: pow2,
        sin: sin2,
        smallerEq,
        subtract,
        typed: typed2
      });
      freqz = /* @__PURE__ */ createFreqz({
        Complex: Complex2,
        add: add2,
        divide: divide2,
        matrix,
        multiply,
        typed: typed2
      });
      norm = /* @__PURE__ */ createNorm({
        abs: abs2,
        add: add2,
        conj,
        ctranspose,
        eigs,
        equalScalar,
        larger,
        matrix,
        multiply,
        pow: pow2,
        smaller,
        sqrt: sqrt2,
        typed: typed2
      });
      rotationMatrix = /* @__PURE__ */ createRotationMatrix({
        BigNumber,
        DenseMatrix,
        SparseMatrix,
        addScalar,
        config,
        cos: cos2,
        matrix,
        multiplyScalar,
        norm,
        sin: sin2,
        typed: typed2,
        unaryMinus
      });
      planckTime = /* @__PURE__ */ createPlanckTime({
        BigNumber,
        Unit,
        config
      });
      schur = /* @__PURE__ */ createSchur({
        identity,
        matrix,
        multiply,
        norm,
        qr,
        subtract,
        typed: typed2
      });
      rotate = /* @__PURE__ */ createRotate({
        multiply,
        rotationMatrix,
        typed: typed2
      });
      sylvester = /* @__PURE__ */ createSylvester({
        abs: abs2,
        add: add2,
        concat: concat2,
        identity,
        index,
        lusolve,
        matrix,
        matrixFromColumns,
        multiply,
        range,
        schur,
        subset,
        subtract,
        transpose,
        typed: typed2
      });
      lyap = /* @__PURE__ */ createLyap({
        matrix,
        multiply,
        sylvester,
        transpose,
        typed: typed2
      });
    }
  });

  // node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
  var math, mathWithTransform, classes, Node, ObjectNode, OperatorNode, ParenthesisNode, RelationalNode, ArrayNode, BlockNode, ConditionalNode, ConstantNode, RangeNode, reviver, Chain, FunctionAssignmentNode, chain, IndexNode, AccessorNode, AssignmentNode, SymbolNode, FunctionNode, parse, resolve, simplifyConstant, compile, Help, leafCount, simplifyCore, evaluate, help, Parser, simplify, symbolicEqual, derivative, parser, rationalize;
  var init_impureFunctionsAny_generated = __esm({
    "node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js"() {
      init_extends();
      init_configReadonly();
      init_factoriesAny();
      init_pureFunctionsAny_generated();
      math = {};
      mathWithTransform = {};
      classes = {};
      Node = createNode({
        mathWithTransform
      });
      ObjectNode = createObjectNode({
        Node
      });
      OperatorNode = createOperatorNode({
        Node
      });
      ParenthesisNode = createParenthesisNode({
        Node
      });
      RelationalNode = createRelationalNode({
        Node
      });
      ArrayNode = createArrayNode({
        Node
      });
      BlockNode = createBlockNode({
        Node,
        ResultSet
      });
      ConditionalNode = createConditionalNode({
        Node
      });
      ConstantNode = createConstantNode({
        Node
      });
      RangeNode = createRangeNode({
        Node
      });
      reviver = createReviver({
        classes
      });
      Chain = createChainClass({
        math,
        typed: typed2
      });
      FunctionAssignmentNode = createFunctionAssignmentNode({
        Node,
        typed: typed2
      });
      chain = createChain({
        Chain,
        typed: typed2
      });
      IndexNode = createIndexNode({
        Node,
        size
      });
      AccessorNode = createAccessorNode({
        Node,
        subset
      });
      AssignmentNode = createAssignmentNode({
        matrix,
        Node,
        subset
      });
      SymbolNode = createSymbolNode({
        Unit,
        Node,
        math
      });
      FunctionNode = createFunctionNode({
        Node,
        SymbolNode,
        math
      });
      parse = createParse({
        AccessorNode,
        ArrayNode,
        AssignmentNode,
        BlockNode,
        ConditionalNode,
        ConstantNode,
        FunctionAssignmentNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        RangeNode,
        RelationalNode,
        SymbolNode,
        config,
        numeric: numeric2,
        typed: typed2
      });
      resolve = createResolve({
        ConstantNode,
        FunctionNode,
        OperatorNode,
        ParenthesisNode,
        parse,
        typed: typed2
      });
      simplifyConstant = createSimplifyConstant({
        bignumber,
        fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        SymbolNode,
        config,
        mathWithTransform,
        matrix,
        typed: typed2
      });
      compile = createCompile({
        parse,
        typed: typed2
      });
      Help = createHelpClass({
        parse
      });
      leafCount = createLeafCount({
        parse,
        typed: typed2
      });
      simplifyCore = createSimplifyCore({
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: add2,
        divide: divide2,
        equal,
        isZero,
        multiply,
        parse,
        pow: pow2,
        subtract,
        typed: typed2
      });
      evaluate = createEvaluate({
        parse,
        typed: typed2
      });
      help = createHelp({
        Help,
        mathWithTransform,
        typed: typed2
      });
      Parser = createParserClass({
        evaluate
      });
      simplify = createSimplify({
        bignumber,
        fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: add2,
        config,
        divide: divide2,
        equal,
        isZero,
        mathWithTransform,
        matrix,
        multiply,
        parse,
        pow: pow2,
        resolve,
        simplifyConstant,
        simplifyCore,
        subtract,
        typed: typed2
      });
      symbolicEqual = createSymbolicEqual({
        OperatorNode,
        parse,
        simplify,
        typed: typed2
      });
      derivative = createDerivative({
        ConstantNode,
        FunctionNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        config,
        equal,
        isZero,
        numeric: numeric2,
        parse,
        simplify,
        typed: typed2
      });
      parser = createParser({
        Parser,
        typed: typed2
      });
      rationalize = createRationalize({
        bignumber,
        fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: add2,
        config,
        divide: divide2,
        equal,
        isZero,
        mathWithTransform,
        matrix,
        multiply,
        parse,
        pow: pow2,
        simplify,
        simplifyConstant,
        simplifyCore,
        subtract,
        typed: typed2
      });
      _extends(math, {
        e: e4,
        false: _false,
        fineStructure,
        i: i3,
        Infinity: _Infinity,
        LN10: LN102,
        LOG10E,
        NaN: _NaN,
        null: _null,
        phi: phi2,
        SQRT1_2,
        sackurTetrode,
        tau: tau2,
        true: _true,
        "E": e4,
        version: version2,
        efimovFactor,
        LN2,
        pi: pi2,
        replacer,
        reviver,
        SQRT2,
        typed: typed2,
        unaryPlus,
        "PI": pi2,
        weakMixingAngle,
        abs: abs2,
        acos: acos2,
        acot,
        acsc,
        addScalar,
        arg,
        asech,
        asinh: asinh3,
        atan: atan3,
        atanh: atanh3,
        bignumber,
        bitNot,
        boolean,
        clone: clone4,
        combinations,
        complex,
        conj,
        cosh: cosh3,
        coth,
        csc,
        cube,
        equalScalar,
        erf,
        exp: exp2,
        expm1: expm13,
        filter: filter2,
        forEach: forEach2,
        format: format4,
        getMatrixDataType,
        hex,
        im,
        isInteger: isInteger2,
        isNegative,
        isPositive,
        isZero,
        LOG2E,
        lgamma,
        log10: log104,
        log2: log24,
        map: map2,
        multiplyScalar,
        not,
        number,
        oct,
        pickRandom,
        print,
        random: random2,
        re,
        sec,
        sign: sign3,
        sin: sin2,
        splitUnit,
        square,
        string,
        tan: tan2,
        typeOf: typeOf2,
        acosh: acosh3,
        acsch,
        apply,
        asec,
        bin,
        chain,
        combinationsWithRep,
        cos: cos2,
        csch,
        isNaN: isNaN2,
        isPrime,
        randomInt,
        sech,
        sinh: sinh3,
        sparse,
        sqrt: sqrt2,
        tanh: tanh3,
        unaryMinus,
        acoth,
        cot,
        fraction,
        isNumeric,
        matrix,
        matrixFromFunction,
        mode,
        numeric: numeric2,
        prod,
        reshape: reshape2,
        size,
        squeeze: squeeze2,
        transpose,
        xgcd,
        zeros: zeros2,
        asin: asin2,
        cbrt: cbrt4,
        concat: concat2,
        count,
        ctranspose,
        diag,
        divideScalar,
        dotDivide,
        equal,
        flatten: flatten2,
        gcd,
        hasNumericValue,
        identity,
        kron,
        largerEq,
        leftShift,
        matrixFromColumns,
        mod: mod2,
        nthRoot,
        ones,
        resize: resize2,
        rightArithShift,
        round: round2,
        smaller,
        subtract,
        to,
        unequal,
        usolve,
        xor,
        add: add2,
        atan2: atan22,
        bitAnd,
        bitXor: bitXor2,
        catalan,
        compare: compare2,
        compareText: compareText2,
        cumsum,
        deepEqual,
        diff,
        distance,
        dot,
        equalText,
        floor: floor2,
        hypot: hypot2,
        invmod,
        larger,
        log: log3,
        lsolve,
        matrixFromRows,
        min: min2,
        multiply,
        nthRoots,
        or,
        partitionSelect,
        qr,
        rightLogShift,
        slu,
        subset,
        sum: sum2,
        trace,
        usolveAll,
        zpk2tf,
        bitOr,
        ceil: ceil2,
        compareNatural,
        composition,
        cross,
        det,
        dotMultiply,
        fix,
        index,
        intersect,
        lcm,
        log1p: log1p2,
        lsolveAll,
        max: max2,
        quantileSeq,
        setCartesian,
        setDistinct,
        setIsSubset,
        setPowerset,
        smallerEq,
        sort,
        and,
        range,
        row,
        setDifference,
        setMultiplicity,
        setSymDifference,
        column,
        inv,
        lup,
        pinv,
        pow: pow2,
        setIntersect,
        setUnion,
        sqrtm,
        vacuumImpedance,
        wienDisplacement,
        atomicMass,
        bohrMagneton,
        boltzmann,
        conductanceQuantum,
        createUnit,
        deuteronMass,
        dotPow,
        electricConstant,
        elementaryCharge,
        expm,
        faraday,
        fft,
        gamma,
        gravitationConstant,
        hartreeEnergy,
        ifft,
        klitzing,
        loschmidt,
        magneticConstant,
        molarMass,
        molarPlanckConstant,
        neutronMass,
        nuclearMagneton,
        planckCharge,
        planckLength,
        planckTemperature,
        protonMass,
        reducedPlanckConstant,
        rydberg,
        secondRadiation,
        speedOfLight,
        stefanBoltzmann,
        thomsonCrossSection,
        avogadro,
        bohrRadius,
        coulomb,
        divide: divide2,
        electronMass,
        factorial,
        firstRadiation,
        gravity,
        inverseConductanceQuantum,
        lusolve,
        magneticFluxQuantum,
        molarMassC12,
        multinomial,
        parse,
        permutations,
        planckMass,
        polynomialRoot,
        resolve,
        setSize,
        simplifyConstant,
        solveODE,
        stirlingS2,
        unit,
        bellNumbers,
        compile,
        eigs,
        fermiCoupling,
        gasConstant,
        leafCount,
        mean,
        molarVolume,
        planckConstant,
        quantumOfCirculation,
        simplifyCore,
        variance,
        classicalElectronRadius,
        evaluate,
        help,
        median,
        simplify,
        symbolicEqual,
        derivative,
        kldivergence,
        mad,
        parser,
        rationalize,
        std,
        zeta,
        freqz,
        norm,
        rotationMatrix,
        planckTime,
        schur,
        rotate,
        sylvester,
        lyap,
        config
      });
      _extends(mathWithTransform, math, {
        filter: createFilterTransform({
          typed: typed2
        }),
        forEach: createForEachTransform({
          typed: typed2
        }),
        map: createMapTransform({
          typed: typed2
        }),
        apply: createApplyTransform({
          isInteger: isInteger2,
          typed: typed2
        }),
        concat: createConcatTransform({
          isInteger: isInteger2,
          matrix,
          typed: typed2
        }),
        max: createMaxTransform({
          config,
          larger,
          numeric: numeric2,
          typed: typed2
        }),
        quantileSeq: createQuantileSeqTransform({
          add: add2,
          compare: compare2,
          isInteger: isInteger2,
          multiply,
          partitionSelect,
          typed: typed2
        }),
        diff: createDiffTransform({
          bignumber,
          matrix,
          number,
          subtract,
          typed: typed2
        }),
        min: createMinTransform({
          config,
          numeric: numeric2,
          smaller,
          typed: typed2
        }),
        subset: createSubsetTransform({
          add: add2,
          matrix,
          typed: typed2,
          zeros: zeros2
        }),
        cumsum: createCumSumTransform({
          add: add2,
          typed: typed2,
          unaryPlus
        }),
        index: createIndexTransform({
          Index,
          getMatrixDataType
        }),
        sum: createSumTransform({
          add: add2,
          config,
          numeric: numeric2,
          typed: typed2
        }),
        range: createRangeTransform({
          bignumber,
          matrix,
          add: add2,
          config,
          isPositive,
          larger,
          largerEq,
          smaller,
          smallerEq,
          typed: typed2
        }),
        row: createRowTransform({
          Index,
          matrix,
          range,
          typed: typed2
        }),
        column: createColumnTransform({
          Index,
          matrix,
          range,
          typed: typed2
        }),
        mean: createMeanTransform({
          add: add2,
          divide: divide2,
          typed: typed2
        }),
        variance: createVarianceTransform({
          add: add2,
          apply,
          divide: divide2,
          isNaN: isNaN2,
          multiply,
          subtract,
          typed: typed2
        }),
        std: createStdTransform({
          map: map2,
          sqrt: sqrt2,
          typed: typed2,
          variance
        })
      });
      _extends(classes, {
        BigNumber,
        Complex: Complex2,
        Fraction: Fraction2,
        Matrix,
        Node,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        Range,
        RelationalNode,
        ResultSet,
        ArrayNode,
        BlockNode,
        ConditionalNode,
        ConstantNode,
        DenseMatrix,
        RangeNode,
        Chain,
        FunctionAssignmentNode,
        SparseMatrix,
        IndexNode,
        ImmutableDenseMatrix,
        Index,
        AccessorNode,
        AssignmentNode,
        FibonacciHeap,
        Spa,
        Unit,
        SymbolNode,
        FunctionNode,
        Help,
        Parser
      });
      Chain.createProxy(math);
    }
  });

  // node_modules/mathjs/lib/esm/entry/typeChecks.js
  var init_typeChecks = __esm({
    "node_modules/mathjs/lib/esm/entry/typeChecks.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/entry/dependenciesAny.generated.js
  var init_dependenciesAny_generated = __esm({
    "node_modules/mathjs/lib/esm/entry/dependenciesAny.generated.js"() {
    }
  });

  // node_modules/mathjs/lib/esm/entry/mainAny.js
  var init_mainAny = __esm({
    "node_modules/mathjs/lib/esm/entry/mainAny.js"() {
      init_pureFunctionsAny_generated();
      init_impureFunctionsAny_generated();
      init_typeChecks();
      init_dependenciesAny_generated();
      init_factoriesAny();
    }
  });

  // node_modules/mathjs/lib/esm/index.js
  var init_esm2 = __esm({
    "node_modules/mathjs/lib/esm/index.js"() {
      init_mainAny();
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  var byteToHex;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      byteToHex = [];
      for (let i5 = 0; i5 < 256; ++i5) {
        byteToHex.push((i5 + 256).toString(16).slice(1));
      }
    }
  });

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID, native_default;
  var init_native = __esm({
    "node_modules/uuid/dist/esm-browser/native.js"() {
      randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      native_default = {
        randomUUID
      };
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i5 = 0; i5 < 16; ++i5) {
        buf[offset + i5] = rnds[i5];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_native();
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v4();
    }
  });

  // src/hooks/useThemeColor.ts
  var ThemeColorDataSchema, ThemeColorActionsSchema, ThemeColorSchema, color, themeColorStore, useThemeColorStore, useThemeColor, useThemeColor_default;
  var init_useThemeColor = __esm({
    "src/hooks/useThemeColor.ts"() {
      "use strict";
      init_useColor();
      init_useColor();
      init_ref();
      init_useAlias();
      init_esm2();
      init_hooks_module();
      init_esm_browser();
      init_lib3();
      init_esm();
      init_material_color_utilities();
      ThemeColorDataSchema = z3.object({
        id: z3.string().uuid(),
        name: z3.string(),
        sourceHex: z3.string(),
        sourceColor: ColorSchema,
        endColor: ColorSchema,
        tones: z3.array(z3.number()),
        hueCalc: z3.string(),
        chromaCalc: z3.string(),
        aliases: z3.array(AliasSchema)
      });
      ThemeColorActionsSchema = z3.object({
        setId: z3.function().args(z3.string(), z3.void()),
        setName: z3.function().args(z3.string(), z3.void()),
        setSourceHex: z3.function().args(z3.string(), z3.void()),
        setSourceColor: z3.function().args(ColorSchema, z3.void()),
        setEndColor: z3.function().args(ColorSchema, z3.void()),
        setTones: z3.function().args(z3.array(z3.number()), z3.void()),
        setHueCalc: z3.function().args(z3.string(), z3.void()),
        setChromaCalc: z3.function().args(z3.string(), z3.void()),
        setAliases: z3.function().args(z3.array(AliasSchema), z3.void()),
        addAlias: z3.function().args(AliasSchema, z3.void()),
        removeAlias: z3.function().args(AliasSchema, z3.void())
      });
      ThemeColorSchema = ThemeColorDataSchema.merge(
        ThemeColorActionsSchema
      );
      color = useColorStore.getState();
      themeColorStore = (set) => ({
        id: v4_default(),
        name: "color",
        sourceHex: color.sourceHex,
        sourceColor: color,
        endColor: color,
        tones: [
          0,
          10,
          20,
          30,
          40,
          50,
          60,
          70,
          80,
          90,
          95,
          99,
          100,
          4,
          5,
          6,
          12,
          17,
          22,
          24,
          25,
          35,
          87,
          92,
          94,
          96,
          98
        ],
        hueCalc: "",
        chromaCalc: "",
        aliases: [],
        setId: (id) => set(() => ({ id })),
        setName: (name307) => set(() => ({ name: name307 })),
        setSourceHex: (sourceHex) => set((state) => ({
          sourceHex,
          sourceColor: __spreadProps(__spreadValues({}, state.sourceColor), { sourceHex })
        })),
        setSourceColor: (sourceColor) => set(() => ({ sourceColor })),
        setEndColor: (endColor) => set(() => ({ endColor })),
        setTones: (tones) => set(() => ({ tones })),
        setHueCalc: (hueCalc) => set(() => ({ hueCalc })),
        setChromaCalc: (chromaCalc) => set(() => ({ chromaCalc })),
        setAliases: (aliases) => set(() => ({ aliases })),
        addAlias: (alias) => set((state) => {
          const newAliases = [...state.aliases];
          newAliases.push(alias);
          return { aliases: newAliases };
        }),
        removeAlias: (alias) => set((state) => {
          const newAliases = [...state.aliases];
          const index2 = newAliases.indexOf(alias);
          if (index2 > -1) {
            newAliases.splice(index2, 1);
          }
          return { aliases: newAliases };
        })
      });
      useThemeColorStore = create()((...a3) => __spreadValues({}, themeColorStore(...a3)));
      useThemeColor = (hexColor) => {
        const color2 = useColor(hexColor);
        const themeColorStore2 = useThemeColorStore;
        const themeColorState = themeColorStore2((state) => state);
        const id = themeColorState.id;
        const setId = (id2) => themeColorState.setId(id2);
        const name307 = themeColorState.name;
        const setName = (name308) => themeColorState.setName(name308);
        const sourceHex = themeColorState.sourceHex;
        const setSourceHex = (sourceHex2) => {
          const newColor = themeColorState.sourceColor;
          const newSourceColor = __spreadProps(__spreadValues({}, newColor), { sourceHex: sourceHex2 });
          themeColorState.setSourceColor(newSourceColor);
          themeColorState.setSourceHex(sourceHex2);
        };
        const sourceColor = themeColorState.sourceColor;
        const setSourceColor = (sourceColor2) => themeColorState.setSourceColor(sourceColor2);
        const endColor = themeColorState.endColor;
        const setEndColor = (endColor2) => themeColorState.setEndColor(endColor2);
        const tones = themeColorState.tones;
        const setTones = (tones2) => themeColorState.setTones(tones2);
        const hueCalc = themeColorState.hueCalc;
        const setHueCalc = (hueCalc2) => themeColorState.setHueCalc(hueCalc2);
        const chromaCalc = themeColorState.chromaCalc;
        const setChromaCalc = (chromaCalc2) => themeColorState.setChromaCalc(chromaCalc2);
        const aliases = themeColorState.aliases;
        const setAliases = (aliases2) => themeColorState.setAliases(aliases2);
        const calculateHue = (hueValue, hueCalcValue) => {
          const hueCalc2 = hueCalcValue || themeColorState.hueCalc;
          const sourceHue = hueValue || sourceColor.hct.hue;
          if (!hueCalc2.trim() || hueCalc2 === "") {
            return sourceHue;
          }
          try {
            const parsedHueCalc = hueCalc2.replace(/h/gi, sourceHue.toString());
            const hue = Math.abs(evaluate(parsedHueCalc) % 360);
            return hue;
          } catch (error) {
            console.error("Invalid expression:", error);
            let lastValidHue = NaN;
            for (let i5 = hueCalc2.length - 1; i5 >= 0; i5--) {
              const truncatedExpression = hueCalc2.substring(0, i5);
              try {
                lastValidHue = evaluate(
                  truncatedExpression.replace(/h/gi, sourceHue.toString())
                );
                break;
              } catch (e6) {
              }
            }
            const hue = !isNaN(lastValidHue) ? Math.abs(lastValidHue % 360) : sourceHue;
            return hue;
          }
        };
        const calculateChroma = (chromaValue, chromaCalcValue) => {
          let chroma = chromaValue || sourceColor.hct.chroma;
          const chromaCalc2 = chromaCalcValue || themeColorState.chromaCalc;
          if (chromaCalc2 !== "") {
            let sourceChroma = sourceColor.hct.chroma;
            let sourceHue = sourceColor.hct.hue;
            let maxChroma = maxChromaAtTonePerHue[round2(sourceHue)].chroma;
            console.log("maxChroma", maxChroma);
            let parsedChromaCalc = chromaCalc2.replace(/c/g, sourceChroma.toString());
            chroma = evaluate(parsedChromaCalc);
            if (chroma < 0) {
              chroma = 0;
            }
            if (chroma > maxChroma) {
              chroma = maxChroma;
            }
            chroma = Math.round(chroma);
          }
          console.log("chroma", chroma);
          return chroma;
        };
        const sourceHexRef = _2(sourceColor.sourceHex);
        const chromaCalcRef = _2(chromaCalc);
        const hueCalcRef = _2(hueCalc);
        p2(() => {
          themeColorStore2.subscribe((state) => {
            if (sourceHexRef.current !== state.sourceColor.sourceHex) {
              sourceHexRef.current = state.sourceColor.sourceHex;
              const newSourceHex = state.sourceColor.sourceHex;
              const newHct = HctFromHex(newSourceHex);
              const hueCalc2 = state.hueCalc;
              const chromaCalc2 = state.chromaCalc;
              const newSourceColor = __spreadProps(__spreadValues({}, color2), {
                sourceHex: newSourceHex,
                hct: newHct,
                rgba: rgbaFromHct(newHct),
                hex: hexFromHct(newHct),
                figmaSolidColor: SolidColorFromRgbColor(
                  rgbFromHex(hexFromHct(newHct))
                )
              });
              setSourceColor(newSourceColor);
              setSourceHex;
              const endHct = Hct.from(
                calculateHue(newSourceColor.hct.hue, hueCalc2),
                calculateChroma(newSourceColor.hct.chroma, chromaCalc2),
                newSourceColor.hct.tone
              );
              const newEndColor = __spreadProps(__spreadValues({}, newSourceColor), {
                hct: endHct,
                rgba: rgbaFromHct(endHct),
                hex: hexFromHct(endHct),
                figmaSolidColor: SolidColorFromRgbColor(
                  rgbFromHex(hexFromHct(endHct))
                )
              });
              setEndColor(newEndColor);
            }
            if (hueCalcRef.current !== state.hueCalc) {
              hueCalcRef.current = state.hueCalc;
              const hueCalc2 = state.hueCalc;
              const chromaCalc2 = state.chromaCalc;
              const newColor = state.sourceColor;
              const endHct = Hct.from(
                calculateHue(newColor.hct.hue, hueCalc2),
                calculateChroma(newColor.hct.chroma, chromaCalc2),
                newColor.hct.tone
              );
              const newEndColor = __spreadProps(__spreadValues({}, newColor), {
                hct: endHct,
                rgba: rgbaFromHct(endHct),
                hex: hexFromHct(endHct),
                figmaSolidColor: SolidColorFromRgbColor(
                  rgbFromHex(hexFromHct(endHct))
                )
              });
              setEndColor(newEndColor);
            }
            if (chromaCalcRef.current !== state.chromaCalc) {
              chromaCalcRef.current = state.chromaCalc;
              const newColor = state.sourceColor;
              const hueCalc2 = state.hueCalc;
              const chromaCalc2 = state.chromaCalc;
              const endHct = Hct.from(
                calculateHue(newColor.hct.hue, hueCalc2),
                calculateChroma(newColor.hct.chroma, chromaCalc2),
                newColor.hct.tone
              );
              const newEndColor = __spreadProps(__spreadValues({}, newColor), {
                hct: endHct,
                rgba: rgbaFromHct(endHct),
                hex: hexFromHct(endHct),
                figmaSolidColor: SolidColorFromRgbColor(
                  rgbFromHex(hexFromHct(endHct))
                )
              });
              setEndColor(newEndColor);
            }
          });
        }, []);
        const addAlias = (alias) => {
          const newAliases = [...aliases];
          newAliases.push(alias);
          setAliases(newAliases);
        };
        const setAlias = (alias) => {
          const newAliases = [...aliases];
          const name308 = (aliasName) => {
            const newAlias = __spreadProps(__spreadValues({}, alias), { name: aliasName });
          };
          const colorForMode = (mode2, tone) => {
            const newAlias = __spreadProps(__spreadValues({}, alias), { color: [{ mode: mode2, tone }] });
          };
          const index2 = newAliases.findIndex((newAlias) => newAlias.id === alias.id);
          if (index2 > -1) {
            newAliases[index2] = alias;
          }
          setAliases(newAliases);
          return { name: name308, colorForMode };
        };
        const removeAlias = (alias) => {
          const newAliases = [...aliases];
          const index2 = newAliases.indexOf(alias);
          if (index2 > -1) {
            newAliases.splice(index2, 1);
          }
          setAliases(newAliases);
        };
        p2(() => {
          if (sourceColor.sourceHex !== hexColor) {
            const newSourceColor = useColor(hexColor);
            setSourceColor(newSourceColor);
          }
        }, []);
        return {
          id,
          name: name307,
          sourceHex,
          sourceColor,
          endColor,
          tones,
          hueCalc,
          chromaCalc,
          aliases,
          setId,
          setName,
          setSourceHex,
          setSourceColor,
          setEndColor,
          setTones,
          setHueCalc,
          setChromaCalc,
          setAliases,
          addAlias,
          removeAlias
        };
      };
      useThemeColor_default = useThemeColor;
    }
  });

  // src/ui.tsx
  var ui_exports = {};
  __export(ui_exports, {
    Plugin: () => Plugin,
    default: () => ui_default
  });
  var Plugin, ui_default;
  var init_ui = __esm({
    "src/ui.tsx"() {
      "use strict";
      init_tailwind();
      init_lib2();
      init_preact_module();
      init_tabs2();
      init_useThemeColor();
      init_esm2();
      Plugin = () => {
        const newColor = useThemeColor_default("#808080");
        const blue = () => {
          newColor.setSourceHex("#2A59FF");
          newColor.setHueCalc("");
        };
        const red = () => {
          newColor.setSourceHex("#FF2A2A");
          newColor.setHueCalc("216");
        };
        return /* @__PURE__ */ y("div", { id: "container-wrap", className: "overflow-y-auto h-full bg-neutral-800" }, /* @__PURE__ */ y("div", { id: "grid-lines", className: "absolute inset-0" }, /* @__PURE__ */ y("div", { className: "absolute w-full h-px bg-neutral-700 top-10" }), /* @__PURE__ */ y("div", { className: "absolute h-full w-px bg-neutral-700 left-10" }), /* @__PURE__ */ y("div", { className: "absolute h-full w-px bg-neutral-700 right-32" }), /* @__PURE__ */ y("div", { className: "absolute w-full bg-neutral-900 top-20 left-10 p-4 pr-16 z-10" }, /* @__PURE__ */ y("p", { className: "text-lg" }, "ThemeColor"), /* @__PURE__ */ y("p", null, /* @__PURE__ */ y("span", { className: "font-bold" }, "Name:"), " ", newColor.name), /* @__PURE__ */ y("p", { className: "font-bold" }, "sourceColor"), /* @__PURE__ */ y("p", { className: "pl-4" }, "sourceHex: ", newColor.sourceColor.sourceHex), /* @__PURE__ */ y("p", { className: "pl-4" }, "hue: ", round2(newColor.sourceColor.hct.hue)), /* @__PURE__ */ y("p", { className: "pl-4" }, "chroma: ", round2(newColor.sourceColor.hct.chroma)), /* @__PURE__ */ y("p", { className: "pl-4" }, "tone: ", round2(newColor.sourceColor.hct.tone)), /* @__PURE__ */ y("p", { className: "pl-4" }, "hex: ", newColor.sourceColor.hex), /* @__PURE__ */ y("p", { className: "font-bold" }, "endColor"), /* @__PURE__ */ y("p", { className: "pl-4" }, "sourceHex: ", newColor.endColor.sourceHex), /* @__PURE__ */ y("p", { className: "pl-4" }, "hue: ", round2(newColor.endColor.hct.hue)), /* @__PURE__ */ y("p", { className: "pl-4" }, "chroma: ", round2(newColor.endColor.hct.chroma)), /* @__PURE__ */ y("p", { className: "pl-4" }, "tone: ", round2(newColor.endColor.hct.tone)), /* @__PURE__ */ y("p", { className: "pl-4" }, "hex: ", newColor.endColor.hex), /* @__PURE__ */ y("p", null, /* @__PURE__ */ y("span", { className: "font-bold" }, "Tones:"), " ", newColor.tones.map((tone) => tone).join(", ")), /* @__PURE__ */ y("p", null, /* @__PURE__ */ y("span", { className: "font-bold" }, "hueCalc:"), " ", newColor.hueCalc), /* @__PURE__ */ y("p", null, /* @__PURE__ */ y("span", { className: "font-bold" }, "chromaCalc:"), " ", newColor.chromaCalc), /* @__PURE__ */ y("p", null, /* @__PURE__ */ y("span", { className: "font-bold" }, "Aliases:"), " ", newColor.aliases.map((alias) => alias).join(", ")))), /* @__PURE__ */ y("div", { className: "h-10 w-full flex" }, /* @__PURE__ */ y("div", { className: "h-full w-10" }), /* @__PURE__ */ y("div", { className: "grow flex flex-row justify-between" }, /* @__PURE__ */ y(tabs_default, null), /* @__PURE__ */ y("div", { className: "h-full px-4 flex items-center justify-center" }, /* @__PURE__ */ y(Button, { onClick: blue }, "blue"), /* @__PURE__ */ y(Button, { danger: true, onClick: red }, "red"), /* @__PURE__ */ y("div", { className: "h-5 w-10 ml-3", style: `background: ${newColor};` }, newColor))), /* @__PURE__ */ y("div", { className: "h-full w-32 flex items-center justify-center" }, "Build")));
      };
      ui_default = render(Plugin);
    }
  });

  // <stdin>
  var rootNode = document.getElementById("create-figma-plugin");
  var modules = { "src/main.ts--default": (init_ui(), __toCommonJS(ui_exports))["default"] };
  var commandId = __FIGMA_COMMAND__ === "" ? "src/main.ts--default" : __FIGMA_COMMAND__;
  if (typeof modules[commandId] === "undefined") {
    throw new Error(
      "No UI defined for command `" + commandId + "`"
    );
  }
  modules[commandId](rootNode, __SHOW_UI_DATA__);
})();
/*! Bundled license information:

@material/material-color-utilities/utils/math_utils.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/utils/color_utils.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/hct/viewing_conditions.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/hct/cam16.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/hct/hct_solver.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/hct/hct.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/blend/blend.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/contrast/contrast.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/dislike/dislike_analyzer.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/dynamiccolor/dynamic_color.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/variant.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/dynamiccolor/contrast_curve.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/dynamiccolor/tone_delta_pair.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/dynamiccolor/material_dynamic_colors.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/palettes/tonal_palette.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/palettes/core_palette.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/quantize/lab_point_provider.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/quantize/quantizer_wsmeans.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/quantize/quantizer_map.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/quantize/quantizer_wu.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/quantize/quantizer_celebi.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/dynamic_scheme.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_android.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/temperature/temperature_cache.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_content.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_expressive.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_fidelity.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_monochrome.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_neutral.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_tonal_spot.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/scheme/scheme_vibrant.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/score/score.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/utils/string_utils.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/utils/image_utils.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/utils/theme_utils.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@material/material-color-utilities/index.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

complex.js/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.2.0 05/03/2022
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)
*/
